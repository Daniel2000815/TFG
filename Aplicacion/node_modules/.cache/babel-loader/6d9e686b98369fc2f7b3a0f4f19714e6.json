{"ast":null,"code":"export var operators=function operators(){return\"\\n    vec3 sdfTwist( in vec3 p, in float k )\\n    {\\n        float c = cos(k*p.y);\\n        float s = sin(k*p.y);\\n        mat2  m = mat2(c,-s,s,c);\\n        vec3  q = vec3(m*p.xz,p.y);\\n        return q;\\n    }\\n\\n    vec3 sdfBend(in vec3 p, in float k )\\n    {\\n        float c = cos(k*p.x);\\n        float s = sin(k*p.x);\\n        mat2  m = mat2(c,-s,s,c);\\n        vec3  q = vec3(m*p.xy,p.z);\\n        return q;\\n    }\\n    vec3 sdfRepeat( in vec3 p, in float s, in vec3 lim )\\n    {\\n        return p-s*clamp(floor(p/s+0.5),-lim,lim);\\n    }\\n\\n    float sdfUnion( float d1, float d2 ) {\\n        \\n        return min(d1,d2);\\n    }\\n\\n    float sdfSmoothUnion( float d1, float d2, float k ) {\\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\\n        return mix( d2, d1, h ) - k*h*(1.0-h); \\n    }\\n\\n    float sdfDifference( float d1, float d2 ) {\\n        \\n        return max(-d1,d2);\\n    }\\n\\n    float sdfSmoothDifference( float d1, float d2, float k ) {\\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\\n        return mix( d2, -d1, h ) + k*h*(1.0-h); \\n    }\\n\\n    float sdfIntersection( float d1, float d2 ) {\\n        \\n        return max(d1,d2);\\n    }\\n\\n    float sdfSmoothIntersection( float d1, float d2, float k ) {\\n        float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\\n        return mix( d2, d1, h ) + k*h*(1.0-h); \\n    }\\n\\n    // https://stackoverflow.com/questions/34050929/3d-point-rotation-algorithm\\n    vec3 sdfRotate(vec3 p, vec3 ang) {\\n        float pitch = ang.x;\\n        float roll = ang.y;\\n        float yaw = ang.z;\\n\\n        float cosa = cos(yaw);\\n        float sina = sin(yaw);\\n\\n        float cosb = cos(pitch);\\n        float sinb = sin(pitch);\\n\\n        float cosc = cos(roll);\\n        float sinc = sin(roll);\\n\\n        float Axx = cosa*cosb;\\n        float Axy = cosa*sinb*sinc - sina*cosc;\\n        float Axz = cosa*sinb*cosc + sina*sinc;\\n\\n        float Ayx = sina*cosb;\\n        float Ayy = sina*sinb*sinc + cosa*cosc;\\n        float Ayz = sina*sinb*cosc - cosa*sinc;\\n\\n        float Azx = -sinb;\\n        float Azy = cosb*sinc;\\n        float Azz = cosb*cosc;\\n\\n        float px = p.x;\\n        float py = p.y;\\n        float pz = p.z;\\n\\n        p.x = Axx*px + Axy*py + Axz*pz;\\n        p.y = Ayx*px + Ayy*py + Ayz*pz;\\n        p.z = Azx*px + Azy*py + Azz*pz;\\n        \\n        return p;\\n    }\\n\\n    vec3 sdfTranslate(vec3 p, vec3 t) {\\n        return p-t;\\n    }\\n\\n    vec3 sdfScale( vec3 p, vec3 s )\\n    {\\n        return (p/s)*s;\\n    }\\n\\n\";};","map":{"version":3,"names":["operators"],"sources":["G:/gitlab/TFG/Aplicacion/src/ShaderStuff/operators.js"],"sourcesContent":["export const operators = () => `\r\n    vec3 sdfTwist( in vec3 p, in float k )\r\n    {\r\n        float c = cos(k*p.y);\r\n        float s = sin(k*p.y);\r\n        mat2  m = mat2(c,-s,s,c);\r\n        vec3  q = vec3(m*p.xz,p.y);\r\n        return q;\r\n    }\r\n\r\n    vec3 sdfBend(in vec3 p, in float k )\r\n    {\r\n        float c = cos(k*p.x);\r\n        float s = sin(k*p.x);\r\n        mat2  m = mat2(c,-s,s,c);\r\n        vec3  q = vec3(m*p.xy,p.z);\r\n        return q;\r\n    }\r\n    vec3 sdfRepeat( in vec3 p, in float s, in vec3 lim )\r\n    {\r\n        return p-s*clamp(floor(p/s+0.5),-lim,lim);\r\n    }\r\n\r\n    float sdfUnion( float d1, float d2 ) {\r\n        \r\n        return min(d1,d2);\r\n    }\r\n\r\n    float sdfSmoothUnion( float d1, float d2, float k ) {\r\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\r\n        return mix( d2, d1, h ) - k*h*(1.0-h); \r\n    }\r\n\r\n    float sdfDifference( float d1, float d2 ) {\r\n        \r\n        return max(-d1,d2);\r\n    }\r\n\r\n    float sdfSmoothDifference( float d1, float d2, float k ) {\r\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\r\n        return mix( d2, -d1, h ) + k*h*(1.0-h); \r\n    }\r\n\r\n    float sdfIntersection( float d1, float d2 ) {\r\n        \r\n        return max(d1,d2);\r\n    }\r\n\r\n    float sdfSmoothIntersection( float d1, float d2, float k ) {\r\n        float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\r\n        return mix( d2, d1, h ) + k*h*(1.0-h); \r\n    }\r\n\r\n    // https://stackoverflow.com/questions/34050929/3d-point-rotation-algorithm\r\n    vec3 sdfRotate(vec3 p, vec3 ang) {\r\n        float pitch = ang.x;\r\n        float roll = ang.y;\r\n        float yaw = ang.z;\r\n\r\n        float cosa = cos(yaw);\r\n        float sina = sin(yaw);\r\n\r\n        float cosb = cos(pitch);\r\n        float sinb = sin(pitch);\r\n\r\n        float cosc = cos(roll);\r\n        float sinc = sin(roll);\r\n\r\n        float Axx = cosa*cosb;\r\n        float Axy = cosa*sinb*sinc - sina*cosc;\r\n        float Axz = cosa*sinb*cosc + sina*sinc;\r\n\r\n        float Ayx = sina*cosb;\r\n        float Ayy = sina*sinb*sinc + cosa*cosc;\r\n        float Ayz = sina*sinb*cosc - cosa*sinc;\r\n\r\n        float Azx = -sinb;\r\n        float Azy = cosb*sinc;\r\n        float Azz = cosb*cosc;\r\n\r\n        float px = p.x;\r\n        float py = p.y;\r\n        float pz = p.z;\r\n\r\n        p.x = Axx*px + Axy*py + Axz*pz;\r\n        p.y = Ayx*px + Ayy*py + Ayz*pz;\r\n        p.z = Azx*px + Azy*py + Azz*pz;\r\n        \r\n        return p;\r\n    }\r\n\r\n    vec3 sdfTranslate(vec3 p, vec3 t) {\r\n        return p-t;\r\n    }\r\n\r\n    vec3 sdfScale( vec3 p, vec3 s )\r\n    {\r\n        return (p/s)*s;\r\n    }\r\n\r\n`"],"mappings":"AAAA,MAAO,IAAMA,UAAS,CAAG,QAAZA,UAAY,q/EAAlB"},"metadata":{},"sourceType":"module"}