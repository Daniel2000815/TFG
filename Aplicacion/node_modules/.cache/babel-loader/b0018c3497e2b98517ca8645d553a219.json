{"ast":null,"code":"function _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nimport { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is.js';\nimport { isInteger } from '../../utils/number.js';\nimport { format } from '../../utils/string.js';\nimport { clone, deepStrictEqual } from '../../utils/object.js';\nimport { arraySize, getArrayDataType, processSizesWildcard, unsqueeze, validateIndex } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nimport { DimensionError } from '../../error/DimensionError.js';\nimport { maxArgumentCount } from '../../utils/function.js';\nvar name = 'SparseMatrix';\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\nexport var createSparseMatrixClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      equalScalar = _ref.equalScalar,\n      Matrix = _ref.Matrix;\n  /**\r\n   * Sparse Matrix implementation. This type implements\r\n   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))\r\n   * format for two-dimensional sparse matrices.\r\n   * @class SparseMatrix\r\n   */\n\n  function SparseMatrix(data, datatype) {\n    if (!(this instanceof SparseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (isMatrix(data)) {\n      // create from matrix\n      _createFromMatrix(this, data, datatype);\n    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {\n      // initialize fields\n      this._values = data.values;\n      this._index = data.index;\n      this._ptr = data.ptr;\n      this._size = data.size;\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // create from array\n      _createFromArray(this, data, datatype);\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._values = [];\n      this._index = [];\n      this._ptr = [0];\n      this._size = [0, 0];\n      this._datatype = datatype;\n    }\n  }\n\n  function _createFromMatrix(matrix, source, datatype) {\n    // check matrix type\n    if (source.type === 'SparseMatrix') {\n      // clone arrays\n      matrix._values = source._values ? clone(source._values) : undefined;\n      matrix._index = clone(source._index);\n      matrix._ptr = clone(source._ptr);\n      matrix._size = clone(source._size);\n      matrix._datatype = datatype || source._datatype;\n    } else {\n      // build from matrix data\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\n    }\n  }\n\n  function _createFromArray(matrix, data, datatype) {\n    // initialize fields\n    matrix._values = [];\n    matrix._index = [];\n    matrix._ptr = [];\n    matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice\n\n    var rows = data.length;\n    var columns = 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    } // check we have rows (empty array)\n\n\n    if (rows > 0) {\n      // column index\n      var j = 0;\n\n      do {\n        // store pointer to values index\n        matrix._ptr.push(matrix._index.length); // loop rows\n\n\n        for (var i = 0; i < rows; i++) {\n          // current row\n          var row = data[i]; // check row is an array\n\n          if (isArray(row)) {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < row.length) {\n              columns = row.length;\n            } // check row has column\n\n\n            if (j < row.length) {\n              // value\n              var v = row[j]; // check value != 0\n\n              if (!eq(v, zero)) {\n                // store value\n                matrix._values.push(v); // index\n\n\n                matrix._index.push(i);\n              }\n            }\n          } else {\n            // update columns if needed (only on first column)\n            if (j === 0 && columns < 1) {\n              columns = 1;\n            } // check value != 0 (row is a scalar)\n\n\n            if (!eq(row, zero)) {\n              // store value\n              matrix._values.push(row); // index\n\n\n              matrix._index.push(i);\n            }\n          }\n        } // increment index\n\n\n        j++;\n      } while (j < columns);\n    } // store number of values in ptr\n\n\n    matrix._ptr.push(matrix._index.length); // size\n\n\n    matrix._size = [rows, columns];\n  }\n\n  SparseMatrix.prototype = new Matrix();\n  /**\r\n   * Create a new SparseMatrix\r\n   */\n\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\r\n   * Attach type information\r\n   */\n\n\n  Object.defineProperty(SparseMatrix, 'name', {\n    value: 'SparseMatrix'\n  });\n  SparseMatrix.prototype.constructor = SparseMatrix;\n  SparseMatrix.prototype.type = 'SparseMatrix';\n  SparseMatrix.prototype.isSparseMatrix = true;\n  /**\r\n   * Get the matrix type\r\n   *\r\n   * Usage:\r\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\r\n   *\r\n   * @memberOf SparseMatrix\r\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\r\n   */\n\n  SparseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._values, typeOf);\n  };\n  /**\r\n   * Get the storage format used by the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.storage()   // retrieve storage format\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @return {string}           The storage format.\r\n   */\n\n\n  SparseMatrix.prototype.storage = function () {\n    return 'sparse';\n  };\n  /**\r\n   * Get the datatype of the data stored in the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.datatype()    // retrieve matrix datatype\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @return {string}           The datatype.\r\n   */\n\n\n  SparseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\r\n   * Create a new SparseMatrix\r\n   * @memberof SparseMatrix\r\n   * @param {Array} data\r\n   * @param {string} [datatype]\r\n   */\n\n\n  SparseMatrix.prototype.create = function (data, datatype) {\n    return new SparseMatrix(data, datatype);\n  };\n  /**\r\n   * Get the matrix density.\r\n   *\r\n   * Usage:\r\n   *     const density = matrix.density()                   // retrieve matrix density\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @return {number}           The matrix density.\r\n   */\n\n\n  SparseMatrix.prototype.density = function () {\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // calculate density\n\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\n  };\n  /**\r\n   * Get a subset of the matrix, or replace a subset of the matrix.\r\n   *\r\n   * Usage:\r\n   *     const subset = matrix.subset(index)               // retrieve subset\r\n   *     const value = matrix.subset(index, replacement)   // replace subset\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {Index} index\r\n   * @param {Array | Matrix | *} [replacement]\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be filled with zeros.\r\n   */\n\n\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\n    } // check arguments\n\n\n    switch (arguments.length) {\n      case 1:\n        return _getsubset(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _setsubset(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n\n  function _getsubset(matrix, idx) {\n    // check idx\n    if (!isIndex(idx)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = idx.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(idx.min());\n    } // validate dimensions\n\n\n    var size = idx.size();\n\n    if (size.length !== matrix._size.length) {\n      throw new DimensionError(size.length, matrix._size.length);\n    } // vars\n\n\n    var i, ii, k, kk; // validate if any of the ranges in the index is out of range\n\n    var min = idx.min();\n    var max = idx.max();\n\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\n      validateIndex(min[i], matrix._size[i]);\n      validateIndex(max[i], matrix._size[i]);\n    } // matrix arrays\n\n\n    var mvalues = matrix._values;\n    var mindex = matrix._index;\n    var mptr = matrix._ptr; // rows & columns dimensions for result matrix\n\n    var rows = idx.dimension(0);\n    var columns = idx.dimension(1); // workspace & permutation vector\n\n    var w = [];\n    var pv = []; // loop rows in resulting matrix\n\n    rows.forEach(function (i, r) {\n      // update permutation vector\n      pv[i] = r[0]; // mark i in workspace\n\n      w[i] = true;\n    }); // result matrix arrays\n\n    var values = mvalues ? [] : undefined;\n    var index = [];\n    var ptr = []; // loop columns in result matrix\n\n    columns.forEach(function (j) {\n      // update ptr\n      ptr.push(index.length); // loop values in column j\n\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\n        // row\n        i = mindex[k]; // check row is in result matrix\n\n        if (w[i] === true) {\n          // push index\n          index.push(pv[i]); // check we need to process values\n\n          if (values) {\n            values.push(mvalues[k]);\n          }\n        }\n      }\n    }); // update ptr\n\n    ptr.push(index.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: size,\n      datatype: matrix._datatype\n    });\n  }\n\n  function _setsubset(matrix, index, submatrix, defaultValue) {\n    // check index\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if (isMatrix(submatrix)) {\n      // submatrix size\n      sSize = submatrix.size(); // use array representation\n\n      submatrix = submatrix.toArray();\n    } else {\n      // get submatrix size (array, scalar)\n      sSize = arraySize(submatrix);\n    } // check index is a scalar\n\n\n    if (isScalar) {\n      // verify submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      } // set value\n\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // validate dimensions, index size must be one or two dimensions\n      if (iSize.length !== 1 && iSize.length !== 2) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      } // check submatrix and index have the same dimensions\n\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // insert the sub matrix\n\n\n      if (iSize.length === 1) {\n        // if the replacement index only has 1 dimension, go trough each one and set its value\n        var range = index.dimension(0);\n        range.forEach(function (dataIndex, subIndex) {\n          validateIndex(dataIndex);\n          matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);\n        });\n      } else {\n        // if the replacement index has 2 dimensions, go through each one and set the value in the correct index\n        var firstDimensionRange = index.dimension(0);\n        var secondDimensionRange = index.dimension(1);\n        firstDimensionRange.forEach(function (firstDataIndex, firstSubIndex) {\n          validateIndex(firstDataIndex);\n          secondDimensionRange.forEach(function (secondDataIndex, secondSubIndex) {\n            validateIndex(secondDataIndex);\n            matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);\n          });\n        });\n      }\n    }\n\n    return matrix;\n  }\n  /**\r\n   * Get a single element from the matrix.\r\n   * @memberof SparseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @return {*} value\r\n   */\n\n\n  SparseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke get on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // check i, j are valid\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[1]); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      return this._values[k];\n    }\n\n    return 0;\n  };\n  /**\r\n   * Replace a single element in the matrix.\r\n   * @memberof SparseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @param {*} v\r\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be set to zero.\r\n   * @return {SparseMatrix} self\r\n   */\n\n\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check it is a pattern matrix\n\n\n    if (!this._values) {\n      throw new Error('Cannot invoke set on a Pattern only matrix');\n    } // row and column\n\n\n    var i = index[0];\n    var j = index[1]; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(this._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, this._datatype);\n    } // check we need to resize matrix\n\n\n    if (i > rows - 1 || j > columns - 1) {\n      // resize matrix\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns\n\n\n      rows = this._size[0];\n      columns = this._size[1];\n    } // check i, j are valid\n\n\n    validateIndex(i, rows);\n    validateIndex(j, columns); // find value index\n\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\n\n\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\n      // check value != 0\n      if (!eq(v, zero)) {\n        // update value\n        this._values[k] = v;\n      } else {\n        // remove value from matrix\n        _remove(k, j, this._values, this._index, this._ptr);\n      }\n    } else {\n      // insert value @ (i, j)\n      _insert(k, i, j, v, this._values, this._index, this._ptr);\n    }\n\n    return this;\n  };\n\n  function _getValueIndex(i, top, bottom, index) {\n    // check row is on the bottom side\n    if (bottom - top === 0) {\n      return bottom;\n    } // loop rows [top, bottom[\n\n\n    for (var r = top; r < bottom; r++) {\n      // check we found value index\n      if (index[r] === i) {\n        return r;\n      }\n    } // we did not find row\n\n\n    return top;\n  }\n\n  function _remove(k, j, values, index, ptr) {\n    // remove value @ k\n    values.splice(k, 1);\n    index.splice(k, 1); // update pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]--;\n    }\n  }\n\n  function _insert(k, i, j, v, values, index, ptr) {\n    // insert value\n    values.splice(k, 0, v); // update row for k\n\n    index.splice(k, 0, i); // update column pointers\n\n    for (var x = j + 1; x < ptr.length; x++) {\n      ptr[x]++;\n    }\n  }\n  /**\r\n   * Resize the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (resize in place).\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {number[] | Matrix} size  The new size the matrix should have.\r\n   *                                  Since sparse matrices are always two-dimensional,\r\n   *                                  size must be two numbers in either an array or a matrix\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\r\n   *                                  If not provided, the matrix elements will\r\n   *                                  be filled with zeros.\r\n   * @param {boolean} [copy]          Return a resized copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The resized matrix\r\n   */\n\n\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isCollection(size)) {\n      throw new TypeError('Array or Matrix expected');\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n\n\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    });\n\n    if (sizeArray.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // check sizes\n\n\n    sizeArray.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value < 0) {\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(sizeArray) + ')');\n      }\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);\n  };\n\n  function _resize(matrix, rows, columns, defaultValue) {\n    // value to insert at the time of growing matrix\n    var value = defaultValue || 0; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype); // convert value to the same datatype\n\n      value = typed.convert(value, matrix._datatype);\n    } // should we insert the value?\n\n\n    var ins = !eq(value, zero); // old columns and rows\n\n    var r = matrix._size[0];\n    var c = matrix._size[1];\n    var i, j, k; // check we need to increase columns\n\n    if (columns > c) {\n      // loop new columns\n      for (j = c; j < columns; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values\n\n        if (ins) {\n          // loop rows\n          for (i = 0; i < r; i++) {\n            // add new matrix._values\n            matrix._values.push(value); // update matrix._index\n\n\n            matrix._index.push(i);\n          }\n        }\n      } // store number of matrix._values in matrix._ptr\n\n\n      matrix._ptr[columns] = matrix._values.length;\n    } else if (columns < c) {\n      // truncate matrix._ptr\n      matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index\n\n\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\n\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\n    } // update columns\n\n\n    c = columns; // check we need to increase rows\n\n    if (rows > r) {\n      // check we have to insert values\n      if (ins) {\n        // inserts\n        var n = 0; // loop columns\n\n        for (j = 0; j < c; j++) {\n          // update matrix._ptr for current column\n          matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values\n\n          k = matrix._ptr[j + 1] + n; // pointer\n\n          var p = 0; // loop new rows, initialize pointer\n\n          for (i = r; i < rows; i++, p++) {\n            // add value\n            matrix._values.splice(k + p, 0, value); // update matrix._index\n\n\n            matrix._index.splice(k + p, 0, i); // increment inserts\n\n\n            n++;\n          }\n        } // store number of matrix._values in matrix._ptr\n\n\n        matrix._ptr[c] = matrix._values.length;\n      }\n    } else if (rows < r) {\n      // deletes\n      var d = 0; // loop columns\n\n      for (j = 0; j < c; j++) {\n        // update matrix._ptr for current column\n        matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column\n\n        var k0 = matrix._ptr[j];\n        var k1 = matrix._ptr[j + 1] - d; // loop matrix._index\n\n        for (k = k0; k < k1; k++) {\n          // row\n          i = matrix._index[k]; // check we need to delete value and matrix._index\n\n          if (i > rows - 1) {\n            // remove value\n            matrix._values.splice(k, 1); // remove item from matrix._index\n\n\n            matrix._index.splice(k, 1); // increase deletes\n\n\n            d++;\n          }\n        }\n      } // update matrix._ptr for current column\n\n\n      matrix._ptr[j] = matrix._values.length;\n    } // update matrix._size\n\n\n    matrix._size[0] = rows;\n    matrix._size[1] = columns; // return matrix\n\n    return matrix;\n  }\n  /**\r\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\r\n   *\r\n   * NOTE: This might be better suited to copy by default, instead of modifying\r\n   *       in place. For now, it operates in place to remain consistent with\r\n   *       resize().\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {number[]} sizes          The new size the matrix should have.\r\n   *                                  Since sparse matrices are always two-dimensional,\r\n   *                                  size must be two numbers in either an array or a matrix\r\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The reshaped matrix\r\n   */\n\n\n  SparseMatrix.prototype.reshape = function (sizes, copy) {\n    // validate arguments\n    if (!isArray(sizes)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (sizes.length !== 2) {\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\n    } // check sizes\n\n\n    sizes.forEach(function (value) {\n      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {\n        throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + format(sizes) + ')');\n      }\n    });\n    var currentLength = this._size[0] * this._size[1];\n    sizes = processSizesWildcard(sizes, currentLength);\n    var newLength = sizes[0] * sizes[1]; // m * n must not change\n\n    if (currentLength !== newLength) {\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\n    } // matrix to reshape\n\n\n    var m = copy ? this.clone() : this; // return unchanged if the same shape\n\n    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {\n      return m;\n    } // Convert to COO format (generate a column index)\n\n\n    var colIndex = [];\n\n    for (var i = 0; i < m._ptr.length; i++) {\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\n        colIndex.push(i);\n      }\n    } // Clone the values array\n\n\n    var values = m._values.slice(); // Clone the row index array\n\n\n    var rowIndex = m._index.slice(); // Transform the (row, column) indices\n\n\n    for (var _i = 0; _i < m._index.length; _i++) {\n      var r1 = rowIndex[_i];\n      var c1 = colIndex[_i];\n      var flat = r1 * m._size[1] + c1;\n      colIndex[_i] = flat % sizes[1];\n      rowIndex[_i] = Math.floor(flat / sizes[1]);\n    } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\n    // sorting several arrays based on some other array.\n    // OR, we could easily just:\n    // 1. Remove all values from the matrix\n\n\n    m._values.length = 0;\n    m._index.length = 0;\n    m._ptr.length = sizes[1] + 1;\n    m._size = sizes.slice();\n\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\n      m._ptr[_i2] = 0;\n    } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\n    // This step is probably the most time-consuming\n\n\n    for (var h = 0; h < values.length; h++) {\n      var _i3 = rowIndex[h];\n      var _j = colIndex[h];\n      var v = values[h];\n\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\n\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\n    } // The value indices are inserted out of order, but apparently that's... still OK?\n\n\n    return m;\n  };\n  /**\r\n   * Create a clone of the matrix\r\n   * @memberof SparseMatrix\r\n   * @return {SparseMatrix} clone\r\n   */\n\n\n  SparseMatrix.prototype.clone = function () {\n    var m = new SparseMatrix({\n      values: this._values ? clone(this._values) : undefined,\n      index: clone(this._index),\n      ptr: clone(this._ptr),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\r\n   * Retrieve the size of the matrix.\r\n   * @memberof SparseMatrix\r\n   * @returns {number[]} size\r\n   */\n\n\n  SparseMatrix.prototype.size = function () {\n    return this._size.slice(0); // copy the Array\n  };\n  /**\r\n   * Create a new matrix with the results of the callback function executed on\r\n   * each entry of the matrix.\r\n   * @memberof SparseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\r\n   *\r\n   * @return {SparseMatrix} matrix\r\n   */\n\n\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke map on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // invoke callback\n\n    var args = maxArgumentCount(callback);\n\n    var invoke = function invoke(v, i, j) {\n      // invoke callback\n      if (args === 1) return callback(v);\n      if (args === 2) return callback(v, [i, j]);\n      return callback(v, [i, j], me);\n    }; // invoke _map\n\n\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\n  };\n  /**\r\n   * Create a new matrix with the results of the callback function executed on the interval\r\n   * [minRow..maxRow, minColumn..maxColumn].\r\n   */\n\n\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\n    // result arrays\n    var values = [];\n    var index = [];\n    var ptr = []; // equal signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(matrix._datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, matrix._datatype);\n    } // invoke callback\n\n\n    var invoke = function invoke(v, x, y) {\n      // invoke callback\n      v = callback(v, x, y); // check value != 0\n\n      if (!eq(v, zero)) {\n        // store value\n        values.push(v); // index\n\n        index.push(x);\n      }\n    }; // loop columns\n\n\n    for (var j = minColumn; j <= maxColumn; j++) {\n      // store pointer to values index\n      ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = matrix._ptr[j];\n      var k1 = matrix._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = matrix._index[k]; // check i is in range\n\n          if (i >= minRow && i <= maxRow) {\n            // value @ k\n            invoke(matrix._values[k], i - minRow, j - minColumn);\n          }\n        }\n      } else {\n        // create a cache holding all defined values\n        var _values = {};\n\n        for (var _k = k0; _k < k1; _k++) {\n          var _i4 = matrix._index[_k];\n          _values[_i4] = matrix._values[_k];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\n          var value = _i5 in _values ? _values[_i5] : 0;\n          invoke(value, _i5 - minRow, j - minColumn);\n        }\n      }\n    } // store number of values in ptr\n\n\n    ptr.push(values.length); // return sparse matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\n    });\n  }\n  /**\r\n   * Execute a callback function on each entry of the matrix.\r\n   * @memberof SparseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\r\n   *                              If false, the indices are guaranteed to be in order,\r\n   *                              if true, the indices can be unordered.\r\n   */\n\n\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\n    // check it is a pattern matrix\n    if (!this._values) {\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\n    } // matrix instance\n\n\n    var me = this; // rows and columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1];\n\n      if (skipZeros) {\n        // loop k within [k0, k1[\n        for (var k = k0; k < k1; k++) {\n          // row index\n          var i = this._index[k]; // value @ k\n\n          callback(this._values[k], [i, j], me);\n        }\n      } else {\n        // create a cache holding all defined values\n        var values = {};\n\n        for (var _k2 = k0; _k2 < k1; _k2++) {\n          var _i6 = this._index[_k2];\n          values[_i6] = this._values[_k2];\n        } // loop over all rows (indexes can be unordered so we can't use that),\n        // and either read the value or zero\n\n\n        for (var _i7 = 0; _i7 < rows; _i7++) {\n          var value = _i7 in values ? values[_i7] : 0;\n          callback(value, [_i7, j], me);\n        }\n      }\n    }\n  };\n  /**\r\n   * Iterate over the matrix elements, skipping zeros\r\n   * @return {Iterable<{ value, index: number[] }>}\r\n   */\n\n\n  SparseMatrix.prototype[Symbol.iterator] = /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var columns, j, k0, k1, k, i;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (this._values) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new Error('Cannot iterate a Pattern only matrix');\n\n          case 2:\n            columns = this._size[1];\n            j = 0;\n\n          case 4:\n            if (!(j < columns)) {\n              _context.next = 18;\n              break;\n            }\n\n            k0 = this._ptr[j];\n            k1 = this._ptr[j + 1];\n            k = k0;\n\n          case 8:\n            if (!(k < k1)) {\n              _context.next = 15;\n              break;\n            }\n\n            // row index\n            i = this._index[k];\n            _context.next = 12;\n            return {\n              value: this._values[k],\n              index: [i, j]\n            };\n\n          case 12:\n            k++;\n            _context.next = 8;\n            break;\n\n          case 15:\n            j++;\n            _context.next = 4;\n            break;\n\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  });\n  /**\r\n   * Create an Array with a copy of the data of the SparseMatrix\r\n   * @memberof SparseMatrix\r\n   * @returns {Array} array\r\n   */\n\n  SparseMatrix.prototype.toArray = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\n  };\n  /**\r\n   * Get the primitive value of the SparseMatrix: a two dimensions array\r\n   * @memberof SparseMatrix\r\n   * @returns {Array} array\r\n   */\n\n\n  SparseMatrix.prototype.valueOf = function () {\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\n  };\n\n  function _toArray(values, index, ptr, size, copy) {\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1]; // result\n\n    var a = []; // vars\n\n    var i, j; // initialize array\n\n    for (i = 0; i < rows; i++) {\n      a[i] = [];\n\n      for (j = 0; j < columns; j++) {\n        a[i][j] = 0;\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        i = index[k]; // set value (use one for pattern matrix)\n\n        a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;\n      }\n    }\n\n    return a;\n  }\n  /**\r\n   * Get a string representation of the matrix, with optional formatting options.\r\n   * @memberof SparseMatrix\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @returns {string} str\r\n   */\n\n\n  SparseMatrix.prototype.format = function (options) {\n    // rows and columns\n    var rows = this._size[0];\n    var columns = this._size[1]; // density\n\n    var density = this.density(); // rows & columns\n\n    var str = 'Sparse Matrix [' + format(rows, options) + ' x ' + format(columns, options) + '] density: ' + format(density, options) + '\\n'; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop k within [k0, k1[\n\n      for (var k = k0; k < k1; k++) {\n        // row index\n        var i = this._index[k]; // append value\n\n        str += '\\n    (' + format(i, options) + ', ' + format(j, options) + ') ==> ' + (this._values ? format(this._values[k], options) : 'X');\n      }\n    }\n\n    return str;\n  };\n  /**\r\n   * Get a string representation of the matrix\r\n   * @memberof SparseMatrix\r\n   * @returns {string} str\r\n   */\n\n\n  SparseMatrix.prototype.toString = function () {\n    return format(this.toArray());\n  };\n  /**\r\n   * Get a JSON representation of the matrix\r\n   * @memberof SparseMatrix\r\n   * @returns {Object}\r\n   */\n\n\n  SparseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'SparseMatrix',\n      values: this._values,\n      index: this._index,\n      ptr: this._ptr,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\r\n   * Get the kth Matrix diagonal.\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\r\n   *\r\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\r\n   */\n\n\n  SparseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays\n\n    var values = [];\n    var index = [];\n    var ptr = []; // initial ptr value\n\n    ptr[0] = 0; // loop columns\n\n    for (var j = kSuper; j < columns && values.length < n; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = this._ptr[j];\n      var k1 = this._ptr[j + 1]; // loop x within [k0, k1[\n\n      for (var x = k0; x < k1; x++) {\n        // row index\n        var i = this._index[x]; // check row\n\n        if (i === j - kSuper + kSub) {\n          // value on this column\n          values.push(this._values[x]); // store row\n\n          index[values.length - 1] = i - kSub; // exit loop\n\n          break;\n        }\n      }\n    } // close ptr\n\n\n    ptr.push(values.length); // return matrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [n, 1]\n    });\n  };\n  /**\r\n   * Generate a matrix from a JSON object\r\n   * @memberof SparseMatrix\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"SparseMatrix\", \"values\": [], \"index\": [], \"ptr\": [], \"size\": []}`,\r\n   *                       where mathjs is optional\r\n   * @returns {SparseMatrix}\r\n   */\n\n\n  SparseMatrix.fromJSON = function (json) {\n    return new SparseMatrix(json);\n  };\n  /**\r\n   * Create a diagonal matrix.\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {Array} size                       The matrix size.\r\n   * @param {number | Array | Matrix } value   The values for the diagonal.\r\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\r\n   * @param {number} [defaultValue]            The default value for non-diagonal\r\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\r\n   *\r\n   * @returns {SparseMatrix}\r\n   */\n\n\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    } // equal signature to use\n\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0;\n\n    if (isString(datatype)) {\n      // find signature that matches (datatype, datatype)\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\n\n      zero = typed.convert(0, datatype);\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // create arrays\n\n\n    var values = [];\n    var index = [];\n    var ptr = []; // loop items\n\n    for (var j = 0; j < columns; j++) {\n      // number of rows with value\n      ptr.push(values.length); // diagonal index\n\n      var i = j - kSuper; // check we need to set diagonal value\n\n      if (i >= 0 && i < n) {\n        // get value @ i\n        var v = _value(i); // check for zero\n\n\n        if (!eq(v, zero)) {\n          // column\n          index.push(i + kSub); // add value\n\n          values.push(v);\n        }\n      }\n    } // last value should be number of values\n\n\n    ptr.push(values.length); // create SparseMatrix\n\n    return new SparseMatrix({\n      values: values,\n      index: index,\n      ptr: ptr,\n      size: [rows, columns]\n    });\n  };\n  /**\r\n   * Swap rows i and j in Matrix.\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   *\r\n   * @return {Matrix}        The matrix reference\r\n   */\n\n\n  SparseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance\n\n\n    return this;\n  };\n  /**\r\n   * Loop rows with data in column j.\r\n   *\r\n   * @param {number} j            Column\r\n   * @param {Array} values        Matrix values\r\n   * @param {Array} index         Matrix row indeces\r\n   * @param {Array} ptr           Matrix column pointers\r\n   * @param {Function} callback   Callback function invoked for every row in column j\r\n   */\n\n\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\n    // indeces for column j\n    var k0 = ptr[j];\n    var k1 = ptr[j + 1]; // loop\n\n    for (var k = k0; k < k1; k++) {\n      // invoke callback\n      callback(index[k], values[k]);\n    }\n  };\n  /**\r\n   * Swap rows x and y in Sparse Matrix data structures.\r\n   *\r\n   * @param {number} x         Matrix row index 1\r\n   * @param {number} y         Matrix row index 2\r\n   * @param {number} columns   Number of columns in matrix\r\n   * @param {Array} values     Matrix values\r\n   * @param {Array} index      Matrix row indeces\r\n   * @param {Array} ptr        Matrix column pointers\r\n   */\n\n\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\n    // loop columns\n    for (var j = 0; j < columns; j++) {\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // find value index @ x\n\n      var kx = _getValueIndex(x, k0, k1, index); // find value index @ x\n\n\n      var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix\n\n\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\n        // swap values (check for pattern matrix)\n        if (values) {\n          var v = values[kx];\n          values[kx] = values[ky];\n          values[ky] = v;\n        } // next column\n\n\n        continue;\n      } // check x row exist & no y row\n\n\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\n        // value @ x (check for pattern matrix)\n        var vx = values ? values[kx] : undefined; // insert value @ y\n\n        index.splice(ky, 0, y);\n\n        if (values) {\n          values.splice(ky, 0, vx);\n        } // remove value @ x (adjust array index if needed)\n\n\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\n\n        if (values) {\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\n        } // next column\n\n\n        continue;\n      } // check y row exist & no x row\n\n\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\n        // value @ y (check for pattern matrix)\n        var vy = values ? values[ky] : undefined; // insert value @ x\n\n        index.splice(kx, 0, x);\n\n        if (values) {\n          values.splice(kx, 0, vy);\n        } // remove value @ y (adjust array index if needed)\n\n\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\n\n        if (values) {\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\n        }\n      }\n    }\n  };\n\n  return SparseMatrix;\n}, {\n  isClass: true\n});","map":{"version":3,"names":["isArray","isBigNumber","isCollection","isIndex","isMatrix","isNumber","isString","typeOf","isInteger","format","clone","deepStrictEqual","arraySize","getArrayDataType","processSizesWildcard","unsqueeze","validateIndex","factory","DimensionError","maxArgumentCount","name","dependencies","createSparseMatrixClass","_ref","typed","equalScalar","Matrix","SparseMatrix","data","datatype","SyntaxError","Error","_createFromMatrix","index","ptr","size","_values","values","_index","_ptr","_size","_datatype","_createFromArray","TypeError","matrix","source","type","undefined","valueOf","rows","length","columns","eq","zero","find","convert","j","push","i","row","v","prototype","createSparseMatrix","Object","defineProperty","value","constructor","isSparseMatrix","getDataType","storage","create","density","subset","replacement","defaultValue","arguments","_getsubset","_setsubset","idx","isScalar","get","min","ii","k","kk","max","mvalues","mindex","mptr","dimension","w","pv","forEach","r","submatrix","iSize","sSize","toArray","set","outer","range","dataIndex","subIndex","firstDimensionRange","secondDimensionRange","firstDataIndex","firstSubIndex","secondDataIndex","secondSubIndex","_getValueIndex","_resize","Math","_remove","_insert","top","bottom","splice","x","resize","copy","sizeArray","map","Array","m","ins","c","n","p","d","k0","k1","reshape","sizes","currentLength","newLength","colIndex","slice","rowIndex","_i","r1","c1","flat","floor","_i2","h","_i3","_j","callback","skipZeros","me","args","invoke","_map","minRow","maxRow","minColumn","maxColumn","y","_k","_i4","_i5","_k2","_i6","_i7","Symbol","iterator","_toArray","a","options","str","toString","toJSON","mathjs","diagonal","toNumber","kSuper","kSub","fromJSON","json","s","_value","ms","swapRows","_swapRows","_forEachRow","kx","ky","vx","vy","isClass"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js"],"sourcesContent":["import { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is.js';\r\nimport { isInteger } from '../../utils/number.js';\r\nimport { format } from '../../utils/string.js';\r\nimport { clone, deepStrictEqual } from '../../utils/object.js';\r\nimport { arraySize, getArrayDataType, processSizesWildcard, unsqueeze, validateIndex } from '../../utils/array.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { DimensionError } from '../../error/DimensionError.js';\r\nimport { maxArgumentCount } from '../../utils/function.js';\r\nvar name = 'SparseMatrix';\r\nvar dependencies = ['typed', 'equalScalar', 'Matrix'];\r\nexport var createSparseMatrixClass = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    equalScalar,\r\n    Matrix\r\n  } = _ref;\r\n\r\n  /**\r\n   * Sparse Matrix implementation. This type implements\r\n   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))\r\n   * format for two-dimensional sparse matrices.\r\n   * @class SparseMatrix\r\n   */\r\n  function SparseMatrix(data, datatype) {\r\n    if (!(this instanceof SparseMatrix)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n\r\n    if (datatype && !isString(datatype)) {\r\n      throw new Error('Invalid datatype: ' + datatype);\r\n    }\r\n\r\n    if (isMatrix(data)) {\r\n      // create from matrix\r\n      _createFromMatrix(this, data, datatype);\r\n    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {\r\n      // initialize fields\r\n      this._values = data.values;\r\n      this._index = data.index;\r\n      this._ptr = data.ptr;\r\n      this._size = data.size;\r\n      this._datatype = datatype || data.datatype;\r\n    } else if (isArray(data)) {\r\n      // create from array\r\n      _createFromArray(this, data, datatype);\r\n    } else if (data) {\r\n      // unsupported type\r\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\r\n    } else {\r\n      // nothing provided\r\n      this._values = [];\r\n      this._index = [];\r\n      this._ptr = [0];\r\n      this._size = [0, 0];\r\n      this._datatype = datatype;\r\n    }\r\n  }\r\n\r\n  function _createFromMatrix(matrix, source, datatype) {\r\n    // check matrix type\r\n    if (source.type === 'SparseMatrix') {\r\n      // clone arrays\r\n      matrix._values = source._values ? clone(source._values) : undefined;\r\n      matrix._index = clone(source._index);\r\n      matrix._ptr = clone(source._ptr);\r\n      matrix._size = clone(source._size);\r\n      matrix._datatype = datatype || source._datatype;\r\n    } else {\r\n      // build from matrix data\r\n      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);\r\n    }\r\n  }\r\n\r\n  function _createFromArray(matrix, data, datatype) {\r\n    // initialize fields\r\n    matrix._values = [];\r\n    matrix._index = [];\r\n    matrix._ptr = [];\r\n    matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice\r\n\r\n    var rows = data.length;\r\n    var columns = 0; // equal signature to use\r\n\r\n    var eq = equalScalar; // zero value\r\n\r\n    var zero = 0;\r\n\r\n    if (isString(datatype)) {\r\n      // find signature that matches (datatype, datatype)\r\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\r\n\r\n      zero = typed.convert(0, datatype);\r\n    } // check we have rows (empty array)\r\n\r\n\r\n    if (rows > 0) {\r\n      // column index\r\n      var j = 0;\r\n\r\n      do {\r\n        // store pointer to values index\r\n        matrix._ptr.push(matrix._index.length); // loop rows\r\n\r\n\r\n        for (var i = 0; i < rows; i++) {\r\n          // current row\r\n          var row = data[i]; // check row is an array\r\n\r\n          if (isArray(row)) {\r\n            // update columns if needed (only on first column)\r\n            if (j === 0 && columns < row.length) {\r\n              columns = row.length;\r\n            } // check row has column\r\n\r\n\r\n            if (j < row.length) {\r\n              // value\r\n              var v = row[j]; // check value != 0\r\n\r\n              if (!eq(v, zero)) {\r\n                // store value\r\n                matrix._values.push(v); // index\r\n\r\n\r\n                matrix._index.push(i);\r\n              }\r\n            }\r\n          } else {\r\n            // update columns if needed (only on first column)\r\n            if (j === 0 && columns < 1) {\r\n              columns = 1;\r\n            } // check value != 0 (row is a scalar)\r\n\r\n\r\n            if (!eq(row, zero)) {\r\n              // store value\r\n              matrix._values.push(row); // index\r\n\r\n\r\n              matrix._index.push(i);\r\n            }\r\n          }\r\n        } // increment index\r\n\r\n\r\n        j++;\r\n      } while (j < columns);\r\n    } // store number of values in ptr\r\n\r\n\r\n    matrix._ptr.push(matrix._index.length); // size\r\n\r\n\r\n    matrix._size = [rows, columns];\r\n  }\r\n\r\n  SparseMatrix.prototype = new Matrix();\r\n  /**\r\n   * Create a new SparseMatrix\r\n   */\r\n\r\n  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {\r\n    return new SparseMatrix(data, datatype);\r\n  };\r\n  /**\r\n   * Attach type information\r\n   */\r\n\r\n\r\n  Object.defineProperty(SparseMatrix, 'name', {\r\n    value: 'SparseMatrix'\r\n  });\r\n  SparseMatrix.prototype.constructor = SparseMatrix;\r\n  SparseMatrix.prototype.type = 'SparseMatrix';\r\n  SparseMatrix.prototype.isSparseMatrix = true;\r\n  /**\r\n   * Get the matrix type\r\n   *\r\n   * Usage:\r\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\r\n   *\r\n   * @memberOf SparseMatrix\r\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\r\n   */\r\n\r\n  SparseMatrix.prototype.getDataType = function () {\r\n    return getArrayDataType(this._values, typeOf);\r\n  };\r\n  /**\r\n   * Get the storage format used by the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.storage()   // retrieve storage format\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @return {string}           The storage format.\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.storage = function () {\r\n    return 'sparse';\r\n  };\r\n  /**\r\n   * Get the datatype of the data stored in the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.datatype()    // retrieve matrix datatype\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @return {string}           The datatype.\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.datatype = function () {\r\n    return this._datatype;\r\n  };\r\n  /**\r\n   * Create a new SparseMatrix\r\n   * @memberof SparseMatrix\r\n   * @param {Array} data\r\n   * @param {string} [datatype]\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.create = function (data, datatype) {\r\n    return new SparseMatrix(data, datatype);\r\n  };\r\n  /**\r\n   * Get the matrix density.\r\n   *\r\n   * Usage:\r\n   *     const density = matrix.density()                   // retrieve matrix density\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @return {number}           The matrix density.\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.density = function () {\r\n    // rows & columns\r\n    var rows = this._size[0];\r\n    var columns = this._size[1]; // calculate density\r\n\r\n    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;\r\n  };\r\n  /**\r\n   * Get a subset of the matrix, or replace a subset of the matrix.\r\n   *\r\n   * Usage:\r\n   *     const subset = matrix.subset(index)               // retrieve subset\r\n   *     const value = matrix.subset(index, replacement)   // replace subset\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {Index} index\r\n   * @param {Array | Matrix | *} [replacement]\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be filled with zeros.\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {\r\n    // check it is a pattern matrix\r\n    if (!this._values) {\r\n      throw new Error('Cannot invoke subset on a Pattern only matrix');\r\n    } // check arguments\r\n\r\n\r\n    switch (arguments.length) {\r\n      case 1:\r\n        return _getsubset(this, index);\r\n      // intentional fall through\r\n\r\n      case 2:\r\n      case 3:\r\n        return _setsubset(this, index, replacement, defaultValue);\r\n\r\n      default:\r\n        throw new SyntaxError('Wrong number of arguments');\r\n    }\r\n  };\r\n\r\n  function _getsubset(matrix, idx) {\r\n    // check idx\r\n    if (!isIndex(idx)) {\r\n      throw new TypeError('Invalid index');\r\n    }\r\n\r\n    var isScalar = idx.isScalar();\r\n\r\n    if (isScalar) {\r\n      // return a scalar\r\n      return matrix.get(idx.min());\r\n    } // validate dimensions\r\n\r\n\r\n    var size = idx.size();\r\n\r\n    if (size.length !== matrix._size.length) {\r\n      throw new DimensionError(size.length, matrix._size.length);\r\n    } // vars\r\n\r\n\r\n    var i, ii, k, kk; // validate if any of the ranges in the index is out of range\r\n\r\n    var min = idx.min();\r\n    var max = idx.max();\r\n\r\n    for (i = 0, ii = matrix._size.length; i < ii; i++) {\r\n      validateIndex(min[i], matrix._size[i]);\r\n      validateIndex(max[i], matrix._size[i]);\r\n    } // matrix arrays\r\n\r\n\r\n    var mvalues = matrix._values;\r\n    var mindex = matrix._index;\r\n    var mptr = matrix._ptr; // rows & columns dimensions for result matrix\r\n\r\n    var rows = idx.dimension(0);\r\n    var columns = idx.dimension(1); // workspace & permutation vector\r\n\r\n    var w = [];\r\n    var pv = []; // loop rows in resulting matrix\r\n\r\n    rows.forEach(function (i, r) {\r\n      // update permutation vector\r\n      pv[i] = r[0]; // mark i in workspace\r\n\r\n      w[i] = true;\r\n    }); // result matrix arrays\r\n\r\n    var values = mvalues ? [] : undefined;\r\n    var index = [];\r\n    var ptr = []; // loop columns in result matrix\r\n\r\n    columns.forEach(function (j) {\r\n      // update ptr\r\n      ptr.push(index.length); // loop values in column j\r\n\r\n      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {\r\n        // row\r\n        i = mindex[k]; // check row is in result matrix\r\n\r\n        if (w[i] === true) {\r\n          // push index\r\n          index.push(pv[i]); // check we need to process values\r\n\r\n          if (values) {\r\n            values.push(mvalues[k]);\r\n          }\r\n        }\r\n      }\r\n    }); // update ptr\r\n\r\n    ptr.push(index.length); // return matrix\r\n\r\n    return new SparseMatrix({\r\n      values,\r\n      index,\r\n      ptr,\r\n      size,\r\n      datatype: matrix._datatype\r\n    });\r\n  }\r\n\r\n  function _setsubset(matrix, index, submatrix, defaultValue) {\r\n    // check index\r\n    if (!index || index.isIndex !== true) {\r\n      throw new TypeError('Invalid index');\r\n    } // get index size and check whether the index contains a single value\r\n\r\n\r\n    var iSize = index.size();\r\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\r\n\r\n    var sSize;\r\n\r\n    if (isMatrix(submatrix)) {\r\n      // submatrix size\r\n      sSize = submatrix.size(); // use array representation\r\n\r\n      submatrix = submatrix.toArray();\r\n    } else {\r\n      // get submatrix size (array, scalar)\r\n      sSize = arraySize(submatrix);\r\n    } // check index is a scalar\r\n\r\n\r\n    if (isScalar) {\r\n      // verify submatrix is a scalar\r\n      if (sSize.length !== 0) {\r\n        throw new TypeError('Scalar expected');\r\n      } // set value\r\n\r\n\r\n      matrix.set(index.min(), submatrix, defaultValue);\r\n    } else {\r\n      // validate dimensions, index size must be one or two dimensions\r\n      if (iSize.length !== 1 && iSize.length !== 2) {\r\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\r\n      } // check submatrix and index have the same dimensions\r\n\r\n\r\n      if (sSize.length < iSize.length) {\r\n        // calculate number of missing outer dimensions\r\n        var i = 0;\r\n        var outer = 0;\r\n\r\n        while (iSize[i] === 1 && sSize[i] === 1) {\r\n          i++;\r\n        }\r\n\r\n        while (iSize[i] === 1) {\r\n          outer++;\r\n          i++;\r\n        } // unsqueeze both outer and inner dimensions\r\n\r\n\r\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\r\n      } // check whether the size of the submatrix matches the index size\r\n\r\n\r\n      if (!deepStrictEqual(iSize, sSize)) {\r\n        throw new DimensionError(iSize, sSize, '>');\r\n      } // insert the sub matrix\r\n\r\n\r\n      if (iSize.length === 1) {\r\n        // if the replacement index only has 1 dimension, go trough each one and set its value\r\n        var range = index.dimension(0);\r\n        range.forEach(function (dataIndex, subIndex) {\r\n          validateIndex(dataIndex);\r\n          matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);\r\n        });\r\n      } else {\r\n        // if the replacement index has 2 dimensions, go through each one and set the value in the correct index\r\n        var firstDimensionRange = index.dimension(0);\r\n        var secondDimensionRange = index.dimension(1);\r\n        firstDimensionRange.forEach(function (firstDataIndex, firstSubIndex) {\r\n          validateIndex(firstDataIndex);\r\n          secondDimensionRange.forEach(function (secondDataIndex, secondSubIndex) {\r\n            validateIndex(secondDataIndex);\r\n            matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);\r\n          });\r\n        });\r\n      }\r\n    }\r\n\r\n    return matrix;\r\n  }\r\n  /**\r\n   * Get a single element from the matrix.\r\n   * @memberof SparseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @return {*} value\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.get = function (index) {\r\n    if (!isArray(index)) {\r\n      throw new TypeError('Array expected');\r\n    }\r\n\r\n    if (index.length !== this._size.length) {\r\n      throw new DimensionError(index.length, this._size.length);\r\n    } // check it is a pattern matrix\r\n\r\n\r\n    if (!this._values) {\r\n      throw new Error('Cannot invoke get on a Pattern only matrix');\r\n    } // row and column\r\n\r\n\r\n    var i = index[0];\r\n    var j = index[1]; // check i, j are valid\r\n\r\n    validateIndex(i, this._size[0]);\r\n    validateIndex(j, this._size[1]); // find value index\r\n\r\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\r\n\r\n\r\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\r\n      return this._values[k];\r\n    }\r\n\r\n    return 0;\r\n  };\r\n  /**\r\n   * Replace a single element in the matrix.\r\n   * @memberof SparseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @param {*} v\r\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be set to zero.\r\n   * @return {SparseMatrix} self\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.set = function (index, v, defaultValue) {\r\n    if (!isArray(index)) {\r\n      throw new TypeError('Array expected');\r\n    }\r\n\r\n    if (index.length !== this._size.length) {\r\n      throw new DimensionError(index.length, this._size.length);\r\n    } // check it is a pattern matrix\r\n\r\n\r\n    if (!this._values) {\r\n      throw new Error('Cannot invoke set on a Pattern only matrix');\r\n    } // row and column\r\n\r\n\r\n    var i = index[0];\r\n    var j = index[1]; // rows & columns\r\n\r\n    var rows = this._size[0];\r\n    var columns = this._size[1]; // equal signature to use\r\n\r\n    var eq = equalScalar; // zero value\r\n\r\n    var zero = 0;\r\n\r\n    if (isString(this._datatype)) {\r\n      // find signature that matches (datatype, datatype)\r\n      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype\r\n\r\n      zero = typed.convert(0, this._datatype);\r\n    } // check we need to resize matrix\r\n\r\n\r\n    if (i > rows - 1 || j > columns - 1) {\r\n      // resize matrix\r\n      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns\r\n\r\n\r\n      rows = this._size[0];\r\n      columns = this._size[1];\r\n    } // check i, j are valid\r\n\r\n\r\n    validateIndex(i, rows);\r\n    validateIndex(j, columns); // find value index\r\n\r\n    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row\r\n\r\n\r\n    if (k < this._ptr[j + 1] && this._index[k] === i) {\r\n      // check value != 0\r\n      if (!eq(v, zero)) {\r\n        // update value\r\n        this._values[k] = v;\r\n      } else {\r\n        // remove value from matrix\r\n        _remove(k, j, this._values, this._index, this._ptr);\r\n      }\r\n    } else {\r\n      // insert value @ (i, j)\r\n      _insert(k, i, j, v, this._values, this._index, this._ptr);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  function _getValueIndex(i, top, bottom, index) {\r\n    // check row is on the bottom side\r\n    if (bottom - top === 0) {\r\n      return bottom;\r\n    } // loop rows [top, bottom[\r\n\r\n\r\n    for (var r = top; r < bottom; r++) {\r\n      // check we found value index\r\n      if (index[r] === i) {\r\n        return r;\r\n      }\r\n    } // we did not find row\r\n\r\n\r\n    return top;\r\n  }\r\n\r\n  function _remove(k, j, values, index, ptr) {\r\n    // remove value @ k\r\n    values.splice(k, 1);\r\n    index.splice(k, 1); // update pointers\r\n\r\n    for (var x = j + 1; x < ptr.length; x++) {\r\n      ptr[x]--;\r\n    }\r\n  }\r\n\r\n  function _insert(k, i, j, v, values, index, ptr) {\r\n    // insert value\r\n    values.splice(k, 0, v); // update row for k\r\n\r\n    index.splice(k, 0, i); // update column pointers\r\n\r\n    for (var x = j + 1; x < ptr.length; x++) {\r\n      ptr[x]++;\r\n    }\r\n  }\r\n  /**\r\n   * Resize the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (resize in place).\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {number[] | Matrix} size  The new size the matrix should have.\r\n   *                                  Since sparse matrices are always two-dimensional,\r\n   *                                  size must be two numbers in either an array or a matrix\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\r\n   *                                  If not provided, the matrix elements will\r\n   *                                  be filled with zeros.\r\n   * @param {boolean} [copy]          Return a resized copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The resized matrix\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {\r\n    // validate arguments\r\n    if (!isCollection(size)) {\r\n      throw new TypeError('Array or Matrix expected');\r\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\r\n\r\n\r\n    var sizeArray = size.valueOf().map(value => {\r\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\r\n    });\r\n\r\n    if (sizeArray.length !== 2) {\r\n      throw new Error('Only two dimensions matrix are supported');\r\n    } // check sizes\r\n\r\n\r\n    sizeArray.forEach(function (value) {\r\n      if (!isNumber(value) || !isInteger(value) || value < 0) {\r\n        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(sizeArray) + ')');\r\n      }\r\n    }); // matrix to resize\r\n\r\n    var m = copy ? this.clone() : this; // resize matrix\r\n\r\n    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);\r\n  };\r\n\r\n  function _resize(matrix, rows, columns, defaultValue) {\r\n    // value to insert at the time of growing matrix\r\n    var value = defaultValue || 0; // equal signature to use\r\n\r\n    var eq = equalScalar; // zero value\r\n\r\n    var zero = 0;\r\n\r\n    if (isString(matrix._datatype)) {\r\n      // find signature that matches (datatype, datatype)\r\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\r\n\r\n      zero = typed.convert(0, matrix._datatype); // convert value to the same datatype\r\n\r\n      value = typed.convert(value, matrix._datatype);\r\n    } // should we insert the value?\r\n\r\n\r\n    var ins = !eq(value, zero); // old columns and rows\r\n\r\n    var r = matrix._size[0];\r\n    var c = matrix._size[1];\r\n    var i, j, k; // check we need to increase columns\r\n\r\n    if (columns > c) {\r\n      // loop new columns\r\n      for (j = c; j < columns; j++) {\r\n        // update matrix._ptr for current column\r\n        matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values\r\n\r\n        if (ins) {\r\n          // loop rows\r\n          for (i = 0; i < r; i++) {\r\n            // add new matrix._values\r\n            matrix._values.push(value); // update matrix._index\r\n\r\n\r\n            matrix._index.push(i);\r\n          }\r\n        }\r\n      } // store number of matrix._values in matrix._ptr\r\n\r\n\r\n      matrix._ptr[columns] = matrix._values.length;\r\n    } else if (columns < c) {\r\n      // truncate matrix._ptr\r\n      matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index\r\n\r\n\r\n      matrix._values.splice(matrix._ptr[columns], matrix._values.length);\r\n\r\n      matrix._index.splice(matrix._ptr[columns], matrix._index.length);\r\n    } // update columns\r\n\r\n\r\n    c = columns; // check we need to increase rows\r\n\r\n    if (rows > r) {\r\n      // check we have to insert values\r\n      if (ins) {\r\n        // inserts\r\n        var n = 0; // loop columns\r\n\r\n        for (j = 0; j < c; j++) {\r\n          // update matrix._ptr for current column\r\n          matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values\r\n\r\n          k = matrix._ptr[j + 1] + n; // pointer\r\n\r\n          var p = 0; // loop new rows, initialize pointer\r\n\r\n          for (i = r; i < rows; i++, p++) {\r\n            // add value\r\n            matrix._values.splice(k + p, 0, value); // update matrix._index\r\n\r\n\r\n            matrix._index.splice(k + p, 0, i); // increment inserts\r\n\r\n\r\n            n++;\r\n          }\r\n        } // store number of matrix._values in matrix._ptr\r\n\r\n\r\n        matrix._ptr[c] = matrix._values.length;\r\n      }\r\n    } else if (rows < r) {\r\n      // deletes\r\n      var d = 0; // loop columns\r\n\r\n      for (j = 0; j < c; j++) {\r\n        // update matrix._ptr for current column\r\n        matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column\r\n\r\n        var k0 = matrix._ptr[j];\r\n        var k1 = matrix._ptr[j + 1] - d; // loop matrix._index\r\n\r\n        for (k = k0; k < k1; k++) {\r\n          // row\r\n          i = matrix._index[k]; // check we need to delete value and matrix._index\r\n\r\n          if (i > rows - 1) {\r\n            // remove value\r\n            matrix._values.splice(k, 1); // remove item from matrix._index\r\n\r\n\r\n            matrix._index.splice(k, 1); // increase deletes\r\n\r\n\r\n            d++;\r\n          }\r\n        }\r\n      } // update matrix._ptr for current column\r\n\r\n\r\n      matrix._ptr[j] = matrix._values.length;\r\n    } // update matrix._size\r\n\r\n\r\n    matrix._size[0] = rows;\r\n    matrix._size[1] = columns; // return matrix\r\n\r\n    return matrix;\r\n  }\r\n  /**\r\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\r\n   *\r\n   * NOTE: This might be better suited to copy by default, instead of modifying\r\n   *       in place. For now, it operates in place to remain consistent with\r\n   *       resize().\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {number[]} sizes          The new size the matrix should have.\r\n   *                                  Since sparse matrices are always two-dimensional,\r\n   *                                  size must be two numbers in either an array or a matrix\r\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The reshaped matrix\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.reshape = function (sizes, copy) {\r\n    // validate arguments\r\n    if (!isArray(sizes)) {\r\n      throw new TypeError('Array expected');\r\n    }\r\n\r\n    if (sizes.length !== 2) {\r\n      throw new Error('Sparse matrices can only be reshaped in two dimensions');\r\n    } // check sizes\r\n\r\n\r\n    sizes.forEach(function (value) {\r\n      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {\r\n        throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + format(sizes) + ')');\r\n      }\r\n    });\r\n    var currentLength = this._size[0] * this._size[1];\r\n    sizes = processSizesWildcard(sizes, currentLength);\r\n    var newLength = sizes[0] * sizes[1]; // m * n must not change\r\n\r\n    if (currentLength !== newLength) {\r\n      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');\r\n    } // matrix to reshape\r\n\r\n\r\n    var m = copy ? this.clone() : this; // return unchanged if the same shape\r\n\r\n    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {\r\n      return m;\r\n    } // Convert to COO format (generate a column index)\r\n\r\n\r\n    var colIndex = [];\r\n\r\n    for (var i = 0; i < m._ptr.length; i++) {\r\n      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {\r\n        colIndex.push(i);\r\n      }\r\n    } // Clone the values array\r\n\r\n\r\n    var values = m._values.slice(); // Clone the row index array\r\n\r\n\r\n    var rowIndex = m._index.slice(); // Transform the (row, column) indices\r\n\r\n\r\n    for (var _i = 0; _i < m._index.length; _i++) {\r\n      var r1 = rowIndex[_i];\r\n      var c1 = colIndex[_i];\r\n      var flat = r1 * m._size[1] + c1;\r\n      colIndex[_i] = flat % sizes[1];\r\n      rowIndex[_i] = Math.floor(flat / sizes[1]);\r\n    } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored\r\n    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,\r\n    // sorting several arrays based on some other array.\r\n    // OR, we could easily just:\r\n    // 1. Remove all values from the matrix\r\n\r\n\r\n    m._values.length = 0;\r\n    m._index.length = 0;\r\n    m._ptr.length = sizes[1] + 1;\r\n    m._size = sizes.slice();\r\n\r\n    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {\r\n      m._ptr[_i2] = 0;\r\n    } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)\r\n    // This step is probably the most time-consuming\r\n\r\n\r\n    for (var h = 0; h < values.length; h++) {\r\n      var _i3 = rowIndex[h];\r\n      var _j = colIndex[h];\r\n      var v = values[h];\r\n\r\n      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);\r\n\r\n      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);\r\n    } // The value indices are inserted out of order, but apparently that's... still OK?\r\n\r\n\r\n    return m;\r\n  };\r\n  /**\r\n   * Create a clone of the matrix\r\n   * @memberof SparseMatrix\r\n   * @return {SparseMatrix} clone\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.clone = function () {\r\n    var m = new SparseMatrix({\r\n      values: this._values ? clone(this._values) : undefined,\r\n      index: clone(this._index),\r\n      ptr: clone(this._ptr),\r\n      size: clone(this._size),\r\n      datatype: this._datatype\r\n    });\r\n    return m;\r\n  };\r\n  /**\r\n   * Retrieve the size of the matrix.\r\n   * @memberof SparseMatrix\r\n   * @returns {number[]} size\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.size = function () {\r\n    return this._size.slice(0); // copy the Array\r\n  };\r\n  /**\r\n   * Create a new matrix with the results of the callback function executed on\r\n   * each entry of the matrix.\r\n   * @memberof SparseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\r\n   *\r\n   * @return {SparseMatrix} matrix\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.map = function (callback, skipZeros) {\r\n    // check it is a pattern matrix\r\n    if (!this._values) {\r\n      throw new Error('Cannot invoke map on a Pattern only matrix');\r\n    } // matrix instance\r\n\r\n\r\n    var me = this; // rows and columns\r\n\r\n    var rows = this._size[0];\r\n    var columns = this._size[1]; // invoke callback\r\n\r\n    var args = maxArgumentCount(callback);\r\n\r\n    var invoke = function invoke(v, i, j) {\r\n      // invoke callback\r\n      if (args === 1) return callback(v);\r\n      if (args === 2) return callback(v, [i, j]);\r\n      return callback(v, [i, j], me);\r\n    }; // invoke _map\r\n\r\n\r\n    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);\r\n  };\r\n  /**\r\n   * Create a new matrix with the results of the callback function executed on the interval\r\n   * [minRow..maxRow, minColumn..maxColumn].\r\n   */\r\n\r\n\r\n  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {\r\n    // result arrays\r\n    var values = [];\r\n    var index = [];\r\n    var ptr = []; // equal signature to use\r\n\r\n    var eq = equalScalar; // zero value\r\n\r\n    var zero = 0;\r\n\r\n    if (isString(matrix._datatype)) {\r\n      // find signature that matches (datatype, datatype)\r\n      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype\r\n\r\n      zero = typed.convert(0, matrix._datatype);\r\n    } // invoke callback\r\n\r\n\r\n    var invoke = function invoke(v, x, y) {\r\n      // invoke callback\r\n      v = callback(v, x, y); // check value != 0\r\n\r\n      if (!eq(v, zero)) {\r\n        // store value\r\n        values.push(v); // index\r\n\r\n        index.push(x);\r\n      }\r\n    }; // loop columns\r\n\r\n\r\n    for (var j = minColumn; j <= maxColumn; j++) {\r\n      // store pointer to values index\r\n      ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\r\n\r\n      var k0 = matrix._ptr[j];\r\n      var k1 = matrix._ptr[j + 1];\r\n\r\n      if (skipZeros) {\r\n        // loop k within [k0, k1[\r\n        for (var k = k0; k < k1; k++) {\r\n          // row index\r\n          var i = matrix._index[k]; // check i is in range\r\n\r\n          if (i >= minRow && i <= maxRow) {\r\n            // value @ k\r\n            invoke(matrix._values[k], i - minRow, j - minColumn);\r\n          }\r\n        }\r\n      } else {\r\n        // create a cache holding all defined values\r\n        var _values = {};\r\n\r\n        for (var _k = k0; _k < k1; _k++) {\r\n          var _i4 = matrix._index[_k];\r\n          _values[_i4] = matrix._values[_k];\r\n        } // loop over all rows (indexes can be unordered so we can't use that),\r\n        // and either read the value or zero\r\n\r\n\r\n        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {\r\n          var value = _i5 in _values ? _values[_i5] : 0;\r\n          invoke(value, _i5 - minRow, j - minColumn);\r\n        }\r\n      }\r\n    } // store number of values in ptr\r\n\r\n\r\n    ptr.push(values.length); // return sparse matrix\r\n\r\n    return new SparseMatrix({\r\n      values,\r\n      index,\r\n      ptr,\r\n      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]\r\n    });\r\n  }\r\n  /**\r\n   * Execute a callback function on each entry of the matrix.\r\n   * @memberof SparseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\r\n   *                              If false, the indices are guaranteed to be in order,\r\n   *                              if true, the indices can be unordered.\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.forEach = function (callback, skipZeros) {\r\n    // check it is a pattern matrix\r\n    if (!this._values) {\r\n      throw new Error('Cannot invoke forEach on a Pattern only matrix');\r\n    } // matrix instance\r\n\r\n\r\n    var me = this; // rows and columns\r\n\r\n    var rows = this._size[0];\r\n    var columns = this._size[1]; // loop columns\r\n\r\n    for (var j = 0; j < columns; j++) {\r\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\r\n      var k0 = this._ptr[j];\r\n      var k1 = this._ptr[j + 1];\r\n\r\n      if (skipZeros) {\r\n        // loop k within [k0, k1[\r\n        for (var k = k0; k < k1; k++) {\r\n          // row index\r\n          var i = this._index[k]; // value @ k\r\n\r\n          callback(this._values[k], [i, j], me);\r\n        }\r\n      } else {\r\n        // create a cache holding all defined values\r\n        var values = {};\r\n\r\n        for (var _k2 = k0; _k2 < k1; _k2++) {\r\n          var _i6 = this._index[_k2];\r\n          values[_i6] = this._values[_k2];\r\n        } // loop over all rows (indexes can be unordered so we can't use that),\r\n        // and either read the value or zero\r\n\r\n\r\n        for (var _i7 = 0; _i7 < rows; _i7++) {\r\n          var value = _i7 in values ? values[_i7] : 0;\r\n          callback(value, [_i7, j], me);\r\n        }\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Iterate over the matrix elements, skipping zeros\r\n   * @return {Iterable<{ value, index: number[] }>}\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype[Symbol.iterator] = function* () {\r\n    if (!this._values) {\r\n      throw new Error('Cannot iterate a Pattern only matrix');\r\n    }\r\n\r\n    var columns = this._size[1];\r\n\r\n    for (var j = 0; j < columns; j++) {\r\n      var k0 = this._ptr[j];\r\n      var k1 = this._ptr[j + 1];\r\n\r\n      for (var k = k0; k < k1; k++) {\r\n        // row index\r\n        var i = this._index[k];\r\n        yield {\r\n          value: this._values[k],\r\n          index: [i, j]\r\n        };\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * Create an Array with a copy of the data of the SparseMatrix\r\n   * @memberof SparseMatrix\r\n   * @returns {Array} array\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.toArray = function () {\r\n    return _toArray(this._values, this._index, this._ptr, this._size, true);\r\n  };\r\n  /**\r\n   * Get the primitive value of the SparseMatrix: a two dimensions array\r\n   * @memberof SparseMatrix\r\n   * @returns {Array} array\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.valueOf = function () {\r\n    return _toArray(this._values, this._index, this._ptr, this._size, false);\r\n  };\r\n\r\n  function _toArray(values, index, ptr, size, copy) {\r\n    // rows and columns\r\n    var rows = size[0];\r\n    var columns = size[1]; // result\r\n\r\n    var a = []; // vars\r\n\r\n    var i, j; // initialize array\r\n\r\n    for (i = 0; i < rows; i++) {\r\n      a[i] = [];\r\n\r\n      for (j = 0; j < columns; j++) {\r\n        a[i][j] = 0;\r\n      }\r\n    } // loop columns\r\n\r\n\r\n    for (j = 0; j < columns; j++) {\r\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\r\n      var k0 = ptr[j];\r\n      var k1 = ptr[j + 1]; // loop k within [k0, k1[\r\n\r\n      for (var k = k0; k < k1; k++) {\r\n        // row index\r\n        i = index[k]; // set value (use one for pattern matrix)\r\n\r\n        a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;\r\n      }\r\n    }\r\n\r\n    return a;\r\n  }\r\n  /**\r\n   * Get a string representation of the matrix, with optional formatting options.\r\n   * @memberof SparseMatrix\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @returns {string} str\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.format = function (options) {\r\n    // rows and columns\r\n    var rows = this._size[0];\r\n    var columns = this._size[1]; // density\r\n\r\n    var density = this.density(); // rows & columns\r\n\r\n    var str = 'Sparse Matrix [' + format(rows, options) + ' x ' + format(columns, options) + '] density: ' + format(density, options) + '\\n'; // loop columns\r\n\r\n    for (var j = 0; j < columns; j++) {\r\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\r\n      var k0 = this._ptr[j];\r\n      var k1 = this._ptr[j + 1]; // loop k within [k0, k1[\r\n\r\n      for (var k = k0; k < k1; k++) {\r\n        // row index\r\n        var i = this._index[k]; // append value\r\n\r\n        str += '\\n    (' + format(i, options) + ', ' + format(j, options) + ') ==> ' + (this._values ? format(this._values[k], options) : 'X');\r\n      }\r\n    }\r\n\r\n    return str;\r\n  };\r\n  /**\r\n   * Get a string representation of the matrix\r\n   * @memberof SparseMatrix\r\n   * @returns {string} str\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.toString = function () {\r\n    return format(this.toArray());\r\n  };\r\n  /**\r\n   * Get a JSON representation of the matrix\r\n   * @memberof SparseMatrix\r\n   * @returns {Object}\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'SparseMatrix',\r\n      values: this._values,\r\n      index: this._index,\r\n      ptr: this._ptr,\r\n      size: this._size,\r\n      datatype: this._datatype\r\n    };\r\n  };\r\n  /**\r\n   * Get the kth Matrix diagonal.\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\r\n   *\r\n   * @returns {Matrix}                     The matrix vector with the diagonal values.\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.diagonal = function (k) {\r\n    // validate k if any\r\n    if (k) {\r\n      // convert BigNumber to a number\r\n      if (isBigNumber(k)) {\r\n        k = k.toNumber();\r\n      } // is must be an integer\r\n\r\n\r\n      if (!isNumber(k) || !isInteger(k)) {\r\n        throw new TypeError('The parameter k must be an integer number');\r\n      }\r\n    } else {\r\n      // default value\r\n      k = 0;\r\n    }\r\n\r\n    var kSuper = k > 0 ? k : 0;\r\n    var kSub = k < 0 ? -k : 0; // rows & columns\r\n\r\n    var rows = this._size[0];\r\n    var columns = this._size[1]; // number diagonal values\r\n\r\n    var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays\r\n\r\n    var values = [];\r\n    var index = [];\r\n    var ptr = []; // initial ptr value\r\n\r\n    ptr[0] = 0; // loop columns\r\n\r\n    for (var j = kSuper; j < columns && values.length < n; j++) {\r\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\r\n      var k0 = this._ptr[j];\r\n      var k1 = this._ptr[j + 1]; // loop x within [k0, k1[\r\n\r\n      for (var x = k0; x < k1; x++) {\r\n        // row index\r\n        var i = this._index[x]; // check row\r\n\r\n        if (i === j - kSuper + kSub) {\r\n          // value on this column\r\n          values.push(this._values[x]); // store row\r\n\r\n          index[values.length - 1] = i - kSub; // exit loop\r\n\r\n          break;\r\n        }\r\n      }\r\n    } // close ptr\r\n\r\n\r\n    ptr.push(values.length); // return matrix\r\n\r\n    return new SparseMatrix({\r\n      values,\r\n      index,\r\n      ptr,\r\n      size: [n, 1]\r\n    });\r\n  };\r\n  /**\r\n   * Generate a matrix from a JSON object\r\n   * @memberof SparseMatrix\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"SparseMatrix\", \"values\": [], \"index\": [], \"ptr\": [], \"size\": []}`,\r\n   *                       where mathjs is optional\r\n   * @returns {SparseMatrix}\r\n   */\r\n\r\n\r\n  SparseMatrix.fromJSON = function (json) {\r\n    return new SparseMatrix(json);\r\n  };\r\n  /**\r\n   * Create a diagonal matrix.\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {Array} size                       The matrix size.\r\n   * @param {number | Array | Matrix } value   The values for the diagonal.\r\n   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.\r\n   * @param {number} [defaultValue]            The default value for non-diagonal\r\n   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.\r\n   *\r\n   * @returns {SparseMatrix}\r\n   */\r\n\r\n\r\n  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {\r\n    if (!isArray(size)) {\r\n      throw new TypeError('Array expected, size parameter');\r\n    }\r\n\r\n    if (size.length !== 2) {\r\n      throw new Error('Only two dimensions matrix are supported');\r\n    } // map size & validate\r\n\r\n\r\n    size = size.map(function (s) {\r\n      // check it is a big number\r\n      if (isBigNumber(s)) {\r\n        // convert it\r\n        s = s.toNumber();\r\n      } // validate arguments\r\n\r\n\r\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\r\n        throw new Error('Size values must be positive integers');\r\n      }\r\n\r\n      return s;\r\n    }); // validate k if any\r\n\r\n    if (k) {\r\n      // convert BigNumber to a number\r\n      if (isBigNumber(k)) {\r\n        k = k.toNumber();\r\n      } // is must be an integer\r\n\r\n\r\n      if (!isNumber(k) || !isInteger(k)) {\r\n        throw new TypeError('The parameter k must be an integer number');\r\n      }\r\n    } else {\r\n      // default value\r\n      k = 0;\r\n    } // equal signature to use\r\n\r\n\r\n    var eq = equalScalar; // zero value\r\n\r\n    var zero = 0;\r\n\r\n    if (isString(datatype)) {\r\n      // find signature that matches (datatype, datatype)\r\n      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype\r\n\r\n      zero = typed.convert(0, datatype);\r\n    }\r\n\r\n    var kSuper = k > 0 ? k : 0;\r\n    var kSub = k < 0 ? -k : 0; // rows and columns\r\n\r\n    var rows = size[0];\r\n    var columns = size[1]; // number of non-zero items\r\n\r\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\r\n\r\n    var _value; // check value\r\n\r\n\r\n    if (isArray(value)) {\r\n      // validate array\r\n      if (value.length !== n) {\r\n        // number of values in array must be n\r\n        throw new Error('Invalid value array length');\r\n      } // define function\r\n\r\n\r\n      _value = function _value(i) {\r\n        // return value @ i\r\n        return value[i];\r\n      };\r\n    } else if (isMatrix(value)) {\r\n      // matrix size\r\n      var ms = value.size(); // validate matrix\r\n\r\n      if (ms.length !== 1 || ms[0] !== n) {\r\n        // number of values in array must be n\r\n        throw new Error('Invalid matrix length');\r\n      } // define function\r\n\r\n\r\n      _value = function _value(i) {\r\n        // return value @ i\r\n        return value.get([i]);\r\n      };\r\n    } else {\r\n      // define function\r\n      _value = function _value() {\r\n        // return value\r\n        return value;\r\n      };\r\n    } // create arrays\r\n\r\n\r\n    var values = [];\r\n    var index = [];\r\n    var ptr = []; // loop items\r\n\r\n    for (var j = 0; j < columns; j++) {\r\n      // number of rows with value\r\n      ptr.push(values.length); // diagonal index\r\n\r\n      var i = j - kSuper; // check we need to set diagonal value\r\n\r\n      if (i >= 0 && i < n) {\r\n        // get value @ i\r\n        var v = _value(i); // check for zero\r\n\r\n\r\n        if (!eq(v, zero)) {\r\n          // column\r\n          index.push(i + kSub); // add value\r\n\r\n          values.push(v);\r\n        }\r\n      }\r\n    } // last value should be number of values\r\n\r\n\r\n    ptr.push(values.length); // create SparseMatrix\r\n\r\n    return new SparseMatrix({\r\n      values,\r\n      index,\r\n      ptr,\r\n      size: [rows, columns]\r\n    });\r\n  };\r\n  /**\r\n   * Swap rows i and j in Matrix.\r\n   *\r\n   * @memberof SparseMatrix\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   *\r\n   * @return {Matrix}        The matrix reference\r\n   */\r\n\r\n\r\n  SparseMatrix.prototype.swapRows = function (i, j) {\r\n    // check index\r\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\r\n      throw new Error('Row index must be positive integers');\r\n    } // check dimensions\r\n\r\n\r\n    if (this._size.length !== 2) {\r\n      throw new Error('Only two dimensional matrix is supported');\r\n    } // validate index\r\n\r\n\r\n    validateIndex(i, this._size[0]);\r\n    validateIndex(j, this._size[0]); // swap rows\r\n\r\n    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance\r\n\r\n\r\n    return this;\r\n  };\r\n  /**\r\n   * Loop rows with data in column j.\r\n   *\r\n   * @param {number} j            Column\r\n   * @param {Array} values        Matrix values\r\n   * @param {Array} index         Matrix row indeces\r\n   * @param {Array} ptr           Matrix column pointers\r\n   * @param {Function} callback   Callback function invoked for every row in column j\r\n   */\r\n\r\n\r\n  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {\r\n    // indeces for column j\r\n    var k0 = ptr[j];\r\n    var k1 = ptr[j + 1]; // loop\r\n\r\n    for (var k = k0; k < k1; k++) {\r\n      // invoke callback\r\n      callback(index[k], values[k]);\r\n    }\r\n  };\r\n  /**\r\n   * Swap rows x and y in Sparse Matrix data structures.\r\n   *\r\n   * @param {number} x         Matrix row index 1\r\n   * @param {number} y         Matrix row index 2\r\n   * @param {number} columns   Number of columns in matrix\r\n   * @param {Array} values     Matrix values\r\n   * @param {Array} index      Matrix row indeces\r\n   * @param {Array} ptr        Matrix column pointers\r\n   */\r\n\r\n\r\n  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {\r\n    // loop columns\r\n    for (var j = 0; j < columns; j++) {\r\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\r\n      var k0 = ptr[j];\r\n      var k1 = ptr[j + 1]; // find value index @ x\r\n\r\n      var kx = _getValueIndex(x, k0, k1, index); // find value index @ x\r\n\r\n\r\n      var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix\r\n\r\n\r\n      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {\r\n        // swap values (check for pattern matrix)\r\n        if (values) {\r\n          var v = values[kx];\r\n          values[kx] = values[ky];\r\n          values[ky] = v;\r\n        } // next column\r\n\r\n\r\n        continue;\r\n      } // check x row exist & no y row\r\n\r\n\r\n      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {\r\n        // value @ x (check for pattern matrix)\r\n        var vx = values ? values[kx] : undefined; // insert value @ y\r\n\r\n        index.splice(ky, 0, y);\r\n\r\n        if (values) {\r\n          values.splice(ky, 0, vx);\r\n        } // remove value @ x (adjust array index if needed)\r\n\r\n\r\n        index.splice(ky <= kx ? kx + 1 : kx, 1);\r\n\r\n        if (values) {\r\n          values.splice(ky <= kx ? kx + 1 : kx, 1);\r\n        } // next column\r\n\r\n\r\n        continue;\r\n      } // check y row exist & no x row\r\n\r\n\r\n      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {\r\n        // value @ y (check for pattern matrix)\r\n        var vy = values ? values[ky] : undefined; // insert value @ x\r\n\r\n        index.splice(kx, 0, x);\r\n\r\n        if (values) {\r\n          values.splice(kx, 0, vy);\r\n        } // remove value @ y (adjust array index if needed)\r\n\r\n\r\n        index.splice(kx <= ky ? ky + 1 : ky, 1);\r\n\r\n        if (values) {\r\n          values.splice(kx <= ky ? ky + 1 : ky, 1);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return SparseMatrix;\r\n}, {\r\n  isClass: true\r\n});"],"mappings":"+CACA,oJ;;AADA,SAASA,OAAT,EAAkBC,WAAlB,EAA+BC,YAA/B,EAA6CC,OAA7C,EAAsDC,QAAtD,EAAgEC,QAAhE,EAA0EC,QAA1E,EAAoFC,MAApF,QAAkG,mBAAlG;AACA,SAASC,SAAT,QAA0B,uBAA1B;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,KAAT,EAAgBC,eAAhB,QAAuC,uBAAvC;AACA,SAASC,SAAT,EAAoBC,gBAApB,EAAsCC,oBAAtC,EAA4DC,SAA5D,EAAuEC,aAAvE,QAA4F,sBAA5F;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,cAAT,QAA+B,+BAA/B;AACA,SAASC,gBAAT,QAAiC,yBAAjC;AACA,IAAIC,IAAI,GAAG,cAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,aAAV,EAAyB,QAAzB,CAAnB;AACA,OAAO,IAAIC,uBAAuB,GAAG,eAAeL,OAAO,CAACG,IAAD,EAAOC,YAAP,EAAqB,UAAAE,IAAI,EAAI;EACtF,IACEC,KADF,GAIID,IAJJ,CACEC,KADF;EAAA,IAEEC,WAFF,GAIIF,IAJJ,CAEEE,WAFF;EAAA,IAGEC,MAHF,GAIIH,IAJJ,CAGEG,MAHF;EAMA;AACF;AACA;AACA;AACA;AACA;;EACE,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,QAA5B,EAAsC;IACpC,IAAI,EAAE,gBAAgBF,YAAlB,CAAJ,EAAqC;MACnC,MAAM,IAAIG,WAAJ,CAAgB,kDAAhB,CAAN;IACD;;IAED,IAAID,QAAQ,IAAI,CAACvB,QAAQ,CAACuB,QAAD,CAAzB,EAAqC;MACnC,MAAM,IAAIE,KAAJ,CAAU,uBAAuBF,QAAjC,CAAN;IACD;;IAED,IAAIzB,QAAQ,CAACwB,IAAD,CAAZ,EAAoB;MAClB;MACAI,iBAAiB,CAAC,IAAD,EAAOJ,IAAP,EAAaC,QAAb,CAAjB;IACD,CAHD,MAGO,IAAID,IAAI,IAAI5B,OAAO,CAAC4B,IAAI,CAACK,KAAN,CAAf,IAA+BjC,OAAO,CAAC4B,IAAI,CAACM,GAAN,CAAtC,IAAoDlC,OAAO,CAAC4B,IAAI,CAACO,IAAN,CAA/D,EAA4E;MACjF;MACA,KAAKC,OAAL,GAAeR,IAAI,CAACS,MAApB;MACA,KAAKC,MAAL,GAAcV,IAAI,CAACK,KAAnB;MACA,KAAKM,IAAL,GAAYX,IAAI,CAACM,GAAjB;MACA,KAAKM,KAAL,GAAaZ,IAAI,CAACO,IAAlB;MACA,KAAKM,SAAL,GAAiBZ,QAAQ,IAAID,IAAI,CAACC,QAAlC;IACD,CAPM,MAOA,IAAI7B,OAAO,CAAC4B,IAAD,CAAX,EAAmB;MACxB;MACAc,gBAAgB,CAAC,IAAD,EAAOd,IAAP,EAAaC,QAAb,CAAhB;IACD,CAHM,MAGA,IAAID,IAAJ,EAAU;MACf;MACA,MAAM,IAAIe,SAAJ,CAAc,+BAA+BpC,MAAM,CAACqB,IAAD,CAArC,GAA8C,GAA5D,CAAN;IACD,CAHM,MAGA;MACL;MACA,KAAKQ,OAAL,GAAe,EAAf;MACA,KAAKE,MAAL,GAAc,EAAd;MACA,KAAKC,IAAL,GAAY,CAAC,CAAD,CAAZ;MACA,KAAKC,KAAL,GAAa,CAAC,CAAD,EAAI,CAAJ,CAAb;MACA,KAAKC,SAAL,GAAiBZ,QAAjB;IACD;EACF;;EAED,SAASG,iBAAT,CAA2BY,MAA3B,EAAmCC,MAAnC,EAA2ChB,QAA3C,EAAqD;IACnD;IACA,IAAIgB,MAAM,CAACC,IAAP,KAAgB,cAApB,EAAoC;MAClC;MACAF,MAAM,CAACR,OAAP,GAAiBS,MAAM,CAACT,OAAP,GAAiB1B,KAAK,CAACmC,MAAM,CAACT,OAAR,CAAtB,GAAyCW,SAA1D;MACAH,MAAM,CAACN,MAAP,GAAgB5B,KAAK,CAACmC,MAAM,CAACP,MAAR,CAArB;MACAM,MAAM,CAACL,IAAP,GAAc7B,KAAK,CAACmC,MAAM,CAACN,IAAR,CAAnB;MACAK,MAAM,CAACJ,KAAP,GAAe9B,KAAK,CAACmC,MAAM,CAACL,KAAR,CAApB;MACAI,MAAM,CAACH,SAAP,GAAmBZ,QAAQ,IAAIgB,MAAM,CAACJ,SAAtC;IACD,CAPD,MAOO;MACL;MACAC,gBAAgB,CAACE,MAAD,EAASC,MAAM,CAACG,OAAP,EAAT,EAA2BnB,QAAQ,IAAIgB,MAAM,CAACJ,SAA9C,CAAhB;IACD;EACF;;EAED,SAASC,gBAAT,CAA0BE,MAA1B,EAAkChB,IAAlC,EAAwCC,QAAxC,EAAkD;IAChD;IACAe,MAAM,CAACR,OAAP,GAAiB,EAAjB;IACAQ,MAAM,CAACN,MAAP,GAAgB,EAAhB;IACAM,MAAM,CAACL,IAAP,GAAc,EAAd;IACAK,MAAM,CAACH,SAAP,GAAmBZ,QAAnB,CALgD,CAKnB;;IAE7B,IAAIoB,IAAI,GAAGrB,IAAI,CAACsB,MAAhB;IACA,IAAIC,OAAO,GAAG,CAAd,CARgD,CAQ/B;;IAEjB,IAAIC,EAAE,GAAG3B,WAAT,CAVgD,CAU1B;;IAEtB,IAAI4B,IAAI,GAAG,CAAX;;IAEA,IAAI/C,QAAQ,CAACuB,QAAD,CAAZ,EAAwB;MACtB;MACAuB,EAAE,GAAG5B,KAAK,CAAC8B,IAAN,CAAW7B,WAAX,EAAwB,CAACI,QAAD,EAAWA,QAAX,CAAxB,KAAiDJ,WAAtD,CAFsB,CAE6C;;MAEnE4B,IAAI,GAAG7B,KAAK,CAAC+B,OAAN,CAAc,CAAd,EAAiB1B,QAAjB,CAAP;IACD,CAnB+C,CAmB9C;;;IAGF,IAAIoB,IAAI,GAAG,CAAX,EAAc;MACZ;MACA,IAAIO,CAAC,GAAG,CAAR;;MAEA,GAAG;QACD;QACAZ,MAAM,CAACL,IAAP,CAAYkB,IAAZ,CAAiBb,MAAM,CAACN,MAAP,CAAcY,MAA/B,EAFC,CAEuC;;;QAGxC,KAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,IAApB,EAA0BS,CAAC,EAA3B,EAA+B;UAC7B;UACA,IAAIC,GAAG,GAAG/B,IAAI,CAAC8B,CAAD,CAAd,CAF6B,CAEV;;UAEnB,IAAI1D,OAAO,CAAC2D,GAAD,CAAX,EAAkB;YAChB;YACA,IAAIH,CAAC,KAAK,CAAN,IAAWL,OAAO,GAAGQ,GAAG,CAACT,MAA7B,EAAqC;cACnCC,OAAO,GAAGQ,GAAG,CAACT,MAAd;YACD,CAJe,CAId;;;YAGF,IAAIM,CAAC,GAAGG,GAAG,CAACT,MAAZ,EAAoB;cAClB;cACA,IAAIU,CAAC,GAAGD,GAAG,CAACH,CAAD,CAAX,CAFkB,CAEF;;cAEhB,IAAI,CAACJ,EAAE,CAACQ,CAAD,EAAIP,IAAJ,CAAP,EAAkB;gBAChB;gBACAT,MAAM,CAACR,OAAP,CAAeqB,IAAf,CAAoBG,CAApB,EAFgB,CAEQ;;;gBAGxBhB,MAAM,CAACN,MAAP,CAAcmB,IAAd,CAAmBC,CAAnB;cACD;YACF;UACF,CAnBD,MAmBO;YACL;YACA,IAAIF,CAAC,KAAK,CAAN,IAAWL,OAAO,GAAG,CAAzB,EAA4B;cAC1BA,OAAO,GAAG,CAAV;YACD,CAJI,CAIH;;;YAGF,IAAI,CAACC,EAAE,CAACO,GAAD,EAAMN,IAAN,CAAP,EAAoB;cAClB;cACAT,MAAM,CAACR,OAAP,CAAeqB,IAAf,CAAoBE,GAApB,EAFkB,CAEQ;;;cAG1Bf,MAAM,CAACN,MAAP,CAAcmB,IAAd,CAAmBC,CAAnB;YACD;UACF;QACF,CA3CA,CA2CC;;;QAGFF,CAAC;MACF,CA/CD,QA+CSA,CAAC,GAAGL,OA/Cb;IAgDD,CA1E+C,CA0E9C;;;IAGFP,MAAM,CAACL,IAAP,CAAYkB,IAAZ,CAAiBb,MAAM,CAACN,MAAP,CAAcY,MAA/B,EA7EgD,CA6ER;;;IAGxCN,MAAM,CAACJ,KAAP,GAAe,CAACS,IAAD,EAAOE,OAAP,CAAf;EACD;;EAEDxB,YAAY,CAACkC,SAAb,GAAyB,IAAInC,MAAJ,EAAzB;EACA;AACF;AACA;;EAEEC,YAAY,CAACkC,SAAb,CAAuBC,kBAAvB,GAA4C,UAAUlC,IAAV,EAAgBC,QAAhB,EAA0B;IACpE,OAAO,IAAIF,YAAJ,CAAiBC,IAAjB,EAAuBC,QAAvB,CAAP;EACD,CAFD;EAGA;AACF;AACA;;;EAGEkC,MAAM,CAACC,cAAP,CAAsBrC,YAAtB,EAAoC,MAApC,EAA4C;IAC1CsC,KAAK,EAAE;EADmC,CAA5C;EAGAtC,YAAY,CAACkC,SAAb,CAAuBK,WAAvB,GAAqCvC,YAArC;EACAA,YAAY,CAACkC,SAAb,CAAuBf,IAAvB,GAA8B,cAA9B;EACAnB,YAAY,CAACkC,SAAb,CAAuBM,cAAvB,GAAwC,IAAxC;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEExC,YAAY,CAACkC,SAAb,CAAuBO,WAAvB,GAAqC,YAAY;IAC/C,OAAOvD,gBAAgB,CAAC,KAAKuB,OAAN,EAAe7B,MAAf,CAAvB;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEoB,YAAY,CAACkC,SAAb,CAAuBQ,OAAvB,GAAiC,YAAY;IAC3C,OAAO,QAAP;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE1C,YAAY,CAACkC,SAAb,CAAuBhC,QAAvB,GAAkC,YAAY;IAC5C,OAAO,KAAKY,SAAZ;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;AACA;;;EAGEd,YAAY,CAACkC,SAAb,CAAuBS,MAAvB,GAAgC,UAAU1C,IAAV,EAAgBC,QAAhB,EAA0B;IACxD,OAAO,IAAIF,YAAJ,CAAiBC,IAAjB,EAAuBC,QAAvB,CAAP;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEF,YAAY,CAACkC,SAAb,CAAuBU,OAAvB,GAAiC,YAAY;IAC3C;IACA,IAAItB,IAAI,GAAG,KAAKT,KAAL,CAAW,CAAX,CAAX;IACA,IAAIW,OAAO,GAAG,KAAKX,KAAL,CAAW,CAAX,CAAd,CAH2C,CAGd;;IAE7B,OAAOS,IAAI,KAAK,CAAT,IAAcE,OAAO,KAAK,CAA1B,GAA8B,KAAKb,MAAL,CAAYY,MAAZ,IAAsBD,IAAI,GAAGE,OAA7B,CAA9B,GAAsE,CAA7E;EACD,CAND;EAOA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGExB,YAAY,CAACkC,SAAb,CAAuBW,MAAvB,GAAgC,UAAUvC,KAAV,EAAiBwC,WAAjB,EAA8BC,YAA9B,EAA4C;IAC1E;IACA,IAAI,CAAC,KAAKtC,OAAV,EAAmB;MACjB,MAAM,IAAIL,KAAJ,CAAU,+CAAV,CAAN;IACD,CAJyE,CAIxE;;;IAGF,QAAQ4C,SAAS,CAACzB,MAAlB;MACE,KAAK,CAAL;QACE,OAAO0B,UAAU,CAAC,IAAD,EAAO3C,KAAP,CAAjB;MACF;;MAEA,KAAK,CAAL;MACA,KAAK,CAAL;QACE,OAAO4C,UAAU,CAAC,IAAD,EAAO5C,KAAP,EAAcwC,WAAd,EAA2BC,YAA3B,CAAjB;;MAEF;QACE,MAAM,IAAI5C,WAAJ,CAAgB,2BAAhB,CAAN;IAVJ;EAYD,CAnBD;;EAqBA,SAAS8C,UAAT,CAAoBhC,MAApB,EAA4BkC,GAA5B,EAAiC;IAC/B;IACA,IAAI,CAAC3E,OAAO,CAAC2E,GAAD,CAAZ,EAAmB;MACjB,MAAM,IAAInC,SAAJ,CAAc,eAAd,CAAN;IACD;;IAED,IAAIoC,QAAQ,GAAGD,GAAG,CAACC,QAAJ,EAAf;;IAEA,IAAIA,QAAJ,EAAc;MACZ;MACA,OAAOnC,MAAM,CAACoC,GAAP,CAAWF,GAAG,CAACG,GAAJ,EAAX,CAAP;IACD,CAX8B,CAW7B;;;IAGF,IAAI9C,IAAI,GAAG2C,GAAG,CAAC3C,IAAJ,EAAX;;IAEA,IAAIA,IAAI,CAACe,MAAL,KAAgBN,MAAM,CAACJ,KAAP,CAAaU,MAAjC,EAAyC;MACvC,MAAM,IAAIhC,cAAJ,CAAmBiB,IAAI,CAACe,MAAxB,EAAgCN,MAAM,CAACJ,KAAP,CAAaU,MAA7C,CAAN;IACD,CAlB8B,CAkB7B;;;IAGF,IAAIQ,CAAJ,EAAOwB,EAAP,EAAWC,CAAX,EAAcC,EAAd,CArB+B,CAqBb;;IAElB,IAAIH,GAAG,GAAGH,GAAG,CAACG,GAAJ,EAAV;IACA,IAAII,GAAG,GAAGP,GAAG,CAACO,GAAJ,EAAV;;IAEA,KAAK3B,CAAC,GAAG,CAAJ,EAAOwB,EAAE,GAAGtC,MAAM,CAACJ,KAAP,CAAaU,MAA9B,EAAsCQ,CAAC,GAAGwB,EAA1C,EAA8CxB,CAAC,EAA/C,EAAmD;MACjD1C,aAAa,CAACiE,GAAG,CAACvB,CAAD,CAAJ,EAASd,MAAM,CAACJ,KAAP,CAAakB,CAAb,CAAT,CAAb;MACA1C,aAAa,CAACqE,GAAG,CAAC3B,CAAD,CAAJ,EAASd,MAAM,CAACJ,KAAP,CAAakB,CAAb,CAAT,CAAb;IACD,CA7B8B,CA6B7B;;;IAGF,IAAI4B,OAAO,GAAG1C,MAAM,CAACR,OAArB;IACA,IAAImD,MAAM,GAAG3C,MAAM,CAACN,MAApB;IACA,IAAIkD,IAAI,GAAG5C,MAAM,CAACL,IAAlB,CAlC+B,CAkCP;;IAExB,IAAIU,IAAI,GAAG6B,GAAG,CAACW,SAAJ,CAAc,CAAd,CAAX;IACA,IAAItC,OAAO,GAAG2B,GAAG,CAACW,SAAJ,CAAc,CAAd,CAAd,CArC+B,CAqCC;;IAEhC,IAAIC,CAAC,GAAG,EAAR;IACA,IAAIC,EAAE,GAAG,EAAT,CAxC+B,CAwClB;;IAEb1C,IAAI,CAAC2C,OAAL,CAAa,UAAUlC,CAAV,EAAamC,CAAb,EAAgB;MAC3B;MACAF,EAAE,CAACjC,CAAD,CAAF,GAAQmC,CAAC,CAAC,CAAD,CAAT,CAF2B,CAEb;;MAEdH,CAAC,CAAChC,CAAD,CAAD,GAAO,IAAP;IACD,CALD,EA1C+B,CA+C3B;;IAEJ,IAAIrB,MAAM,GAAGiD,OAAO,GAAG,EAAH,GAAQvC,SAA5B;IACA,IAAId,KAAK,GAAG,EAAZ;IACA,IAAIC,GAAG,GAAG,EAAV,CAnD+B,CAmDjB;;IAEdiB,OAAO,CAACyC,OAAR,CAAgB,UAAUpC,CAAV,EAAa;MAC3B;MACAtB,GAAG,CAACuB,IAAJ,CAASxB,KAAK,CAACiB,MAAf,EAF2B,CAEH;;MAExB,KAAKiC,CAAC,GAAGK,IAAI,CAAChC,CAAD,CAAR,EAAa4B,EAAE,GAAGI,IAAI,CAAChC,CAAC,GAAG,CAAL,CAA3B,EAAoC2B,CAAC,GAAGC,EAAxC,EAA4CD,CAAC,EAA7C,EAAiD;QAC/C;QACAzB,CAAC,GAAG6B,MAAM,CAACJ,CAAD,CAAV,CAF+C,CAEhC;;QAEf,IAAIO,CAAC,CAAChC,CAAD,CAAD,KAAS,IAAb,EAAmB;UACjB;UACAzB,KAAK,CAACwB,IAAN,CAAWkC,EAAE,CAACjC,CAAD,CAAb,EAFiB,CAEE;;UAEnB,IAAIrB,MAAJ,EAAY;YACVA,MAAM,CAACoB,IAAP,CAAY6B,OAAO,CAACH,CAAD,CAAnB;UACD;QACF;MACF;IACF,CAjBD,EArD+B,CAsE3B;;IAEJjD,GAAG,CAACuB,IAAJ,CAASxB,KAAK,CAACiB,MAAf,EAxE+B,CAwEP;;IAExB,OAAO,IAAIvB,YAAJ,CAAiB;MACtBU,MAAM,EAANA,MADsB;MAEtBJ,KAAK,EAALA,KAFsB;MAGtBC,GAAG,EAAHA,GAHsB;MAItBC,IAAI,EAAJA,IAJsB;MAKtBN,QAAQ,EAAEe,MAAM,CAACH;IALK,CAAjB,CAAP;EAOD;;EAED,SAASoC,UAAT,CAAoBjC,MAApB,EAA4BX,KAA5B,EAAmC6D,SAAnC,EAA8CpB,YAA9C,EAA4D;IAC1D;IACA,IAAI,CAACzC,KAAD,IAAUA,KAAK,CAAC9B,OAAN,KAAkB,IAAhC,EAAsC;MACpC,MAAM,IAAIwC,SAAJ,CAAc,eAAd,CAAN;IACD,CAJyD,CAIxD;;;IAGF,IAAIoD,KAAK,GAAG9D,KAAK,CAACE,IAAN,EAAZ;IACA,IAAI4C,QAAQ,GAAG9C,KAAK,CAAC8C,QAAN,EAAf,CAR0D,CAQzB;;IAEjC,IAAIiB,KAAJ;;IAEA,IAAI5F,QAAQ,CAAC0F,SAAD,CAAZ,EAAyB;MACvB;MACAE,KAAK,GAAGF,SAAS,CAAC3D,IAAV,EAAR,CAFuB,CAEG;;MAE1B2D,SAAS,GAAGA,SAAS,CAACG,OAAV,EAAZ;IACD,CALD,MAKO;MACL;MACAD,KAAK,GAAGpF,SAAS,CAACkF,SAAD,CAAjB;IACD,CApByD,CAoBxD;;;IAGF,IAAIf,QAAJ,EAAc;MACZ;MACA,IAAIiB,KAAK,CAAC9C,MAAN,KAAiB,CAArB,EAAwB;QACtB,MAAM,IAAIP,SAAJ,CAAc,iBAAd,CAAN;MACD,CAJW,CAIV;;;MAGFC,MAAM,CAACsD,GAAP,CAAWjE,KAAK,CAACgD,GAAN,EAAX,EAAwBa,SAAxB,EAAmCpB,YAAnC;IACD,CARD,MAQO;MACL;MACA,IAAIqB,KAAK,CAAC7C,MAAN,KAAiB,CAAjB,IAAsB6C,KAAK,CAAC7C,MAAN,KAAiB,CAA3C,EAA8C;QAC5C,MAAM,IAAIhC,cAAJ,CAAmB6E,KAAK,CAAC7C,MAAzB,EAAiCN,MAAM,CAACJ,KAAP,CAAaU,MAA9C,EAAsD,GAAtD,CAAN;MACD,CAJI,CAIH;;;MAGF,IAAI8C,KAAK,CAAC9C,MAAN,GAAe6C,KAAK,CAAC7C,MAAzB,EAAiC;QAC/B;QACA,IAAIQ,CAAC,GAAG,CAAR;QACA,IAAIyC,KAAK,GAAG,CAAZ;;QAEA,OAAOJ,KAAK,CAACrC,CAAD,CAAL,KAAa,CAAb,IAAkBsC,KAAK,CAACtC,CAAD,CAAL,KAAa,CAAtC,EAAyC;UACvCA,CAAC;QACF;;QAED,OAAOqC,KAAK,CAACrC,CAAD,CAAL,KAAa,CAApB,EAAuB;UACrByC,KAAK;UACLzC,CAAC;QACF,CAZ8B,CAY7B;;;QAGFoC,SAAS,GAAG/E,SAAS,CAAC+E,SAAD,EAAYC,KAAK,CAAC7C,MAAlB,EAA0BiD,KAA1B,EAAiCH,KAAjC,CAArB;MACD,CAvBI,CAuBH;;;MAGF,IAAI,CAACrF,eAAe,CAACoF,KAAD,EAAQC,KAAR,CAApB,EAAoC;QAClC,MAAM,IAAI9E,cAAJ,CAAmB6E,KAAnB,EAA0BC,KAA1B,EAAiC,GAAjC,CAAN;MACD,CA5BI,CA4BH;;;MAGF,IAAID,KAAK,CAAC7C,MAAN,KAAiB,CAArB,EAAwB;QACtB;QACA,IAAIkD,KAAK,GAAGnE,KAAK,CAACwD,SAAN,CAAgB,CAAhB,CAAZ;QACAW,KAAK,CAACR,OAAN,CAAc,UAAUS,SAAV,EAAqBC,QAArB,EAA+B;UAC3CtF,aAAa,CAACqF,SAAD,CAAb;UACAzD,MAAM,CAACsD,GAAP,CAAW,CAACG,SAAD,EAAY,CAAZ,CAAX,EAA2BP,SAAS,CAACQ,QAAQ,CAAC,CAAD,CAAT,CAApC,EAAmD5B,YAAnD;QACD,CAHD;MAID,CAPD,MAOO;QACL;QACA,IAAI6B,mBAAmB,GAAGtE,KAAK,CAACwD,SAAN,CAAgB,CAAhB,CAA1B;QACA,IAAIe,oBAAoB,GAAGvE,KAAK,CAACwD,SAAN,CAAgB,CAAhB,CAA3B;QACAc,mBAAmB,CAACX,OAApB,CAA4B,UAAUa,cAAV,EAA0BC,aAA1B,EAAyC;UACnE1F,aAAa,CAACyF,cAAD,CAAb;UACAD,oBAAoB,CAACZ,OAArB,CAA6B,UAAUe,eAAV,EAA2BC,cAA3B,EAA2C;YACtE5F,aAAa,CAAC2F,eAAD,CAAb;YACA/D,MAAM,CAACsD,GAAP,CAAW,CAACO,cAAD,EAAiBE,eAAjB,CAAX,EAA8Cb,SAAS,CAACY,aAAa,CAAC,CAAD,CAAd,CAAT,CAA4BE,cAAc,CAAC,CAAD,CAA1C,CAA9C,EAA8FlC,YAA9F;UACD,CAHD;QAID,CAND;MAOD;IACF;;IAED,OAAO9B,MAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;;;EAGEjB,YAAY,CAACkC,SAAb,CAAuBmB,GAAvB,GAA6B,UAAU/C,KAAV,EAAiB;IAC5C,IAAI,CAACjC,OAAO,CAACiC,KAAD,CAAZ,EAAqB;MACnB,MAAM,IAAIU,SAAJ,CAAc,gBAAd,CAAN;IACD;;IAED,IAAIV,KAAK,CAACiB,MAAN,KAAiB,KAAKV,KAAL,CAAWU,MAAhC,EAAwC;MACtC,MAAM,IAAIhC,cAAJ,CAAmBe,KAAK,CAACiB,MAAzB,EAAiC,KAAKV,KAAL,CAAWU,MAA5C,CAAN;IACD,CAP2C,CAO1C;;;IAGF,IAAI,CAAC,KAAKd,OAAV,EAAmB;MACjB,MAAM,IAAIL,KAAJ,CAAU,4CAAV,CAAN;IACD,CAZ2C,CAY1C;;;IAGF,IAAI2B,CAAC,GAAGzB,KAAK,CAAC,CAAD,CAAb;IACA,IAAIuB,CAAC,GAAGvB,KAAK,CAAC,CAAD,CAAb,CAhB4C,CAgB1B;;IAElBjB,aAAa,CAAC0C,CAAD,EAAI,KAAKlB,KAAL,CAAW,CAAX,CAAJ,CAAb;IACAxB,aAAa,CAACwC,CAAD,EAAI,KAAKhB,KAAL,CAAW,CAAX,CAAJ,CAAb,CAnB4C,CAmBX;;IAEjC,IAAI2C,CAAC,GAAG0B,cAAc,CAACnD,CAAD,EAAI,KAAKnB,IAAL,CAAUiB,CAAV,CAAJ,EAAkB,KAAKjB,IAAL,CAAUiB,CAAC,GAAG,CAAd,CAAlB,EAAoC,KAAKlB,MAAzC,CAAtB,CArB4C,CAqB4B;;;IAGxE,IAAI6C,CAAC,GAAG,KAAK5C,IAAL,CAAUiB,CAAC,GAAG,CAAd,CAAJ,IAAwB,KAAKlB,MAAL,CAAY6C,CAAZ,MAAmBzB,CAA/C,EAAkD;MAChD,OAAO,KAAKtB,OAAL,CAAa+C,CAAb,CAAP;IACD;;IAED,OAAO,CAAP;EACD,CA7BD;EA8BA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGExD,YAAY,CAACkC,SAAb,CAAuBqC,GAAvB,GAA6B,UAAUjE,KAAV,EAAiB2B,CAAjB,EAAoBc,YAApB,EAAkC;IAC7D,IAAI,CAAC1E,OAAO,CAACiC,KAAD,CAAZ,EAAqB;MACnB,MAAM,IAAIU,SAAJ,CAAc,gBAAd,CAAN;IACD;;IAED,IAAIV,KAAK,CAACiB,MAAN,KAAiB,KAAKV,KAAL,CAAWU,MAAhC,EAAwC;MACtC,MAAM,IAAIhC,cAAJ,CAAmBe,KAAK,CAACiB,MAAzB,EAAiC,KAAKV,KAAL,CAAWU,MAA5C,CAAN;IACD,CAP4D,CAO3D;;;IAGF,IAAI,CAAC,KAAKd,OAAV,EAAmB;MACjB,MAAM,IAAIL,KAAJ,CAAU,4CAAV,CAAN;IACD,CAZ4D,CAY3D;;;IAGF,IAAI2B,CAAC,GAAGzB,KAAK,CAAC,CAAD,CAAb;IACA,IAAIuB,CAAC,GAAGvB,KAAK,CAAC,CAAD,CAAb,CAhB6D,CAgB3C;;IAElB,IAAIgB,IAAI,GAAG,KAAKT,KAAL,CAAW,CAAX,CAAX;IACA,IAAIW,OAAO,GAAG,KAAKX,KAAL,CAAW,CAAX,CAAd,CAnB6D,CAmBhC;;IAE7B,IAAIY,EAAE,GAAG3B,WAAT,CArB6D,CAqBvC;;IAEtB,IAAI4B,IAAI,GAAG,CAAX;;IAEA,IAAI/C,QAAQ,CAAC,KAAKmC,SAAN,CAAZ,EAA8B;MAC5B;MACAW,EAAE,GAAG5B,KAAK,CAAC8B,IAAN,CAAW7B,WAAX,EAAwB,CAAC,KAAKgB,SAAN,EAAiB,KAAKA,SAAtB,CAAxB,KAA6DhB,WAAlE,CAF4B,CAEmD;;MAE/E4B,IAAI,GAAG7B,KAAK,CAAC+B,OAAN,CAAc,CAAd,EAAiB,KAAKd,SAAtB,CAAP;IACD,CA9B4D,CA8B3D;;;IAGF,IAAIiB,CAAC,GAAGT,IAAI,GAAG,CAAX,IAAgBO,CAAC,GAAGL,OAAO,GAAG,CAAlC,EAAqC;MACnC;MACA2D,OAAO,CAAC,IAAD,EAAOC,IAAI,CAAC1B,GAAL,CAAS3B,CAAC,GAAG,CAAb,EAAgBT,IAAhB,CAAP,EAA8B8D,IAAI,CAAC1B,GAAL,CAAS7B,CAAC,GAAG,CAAb,EAAgBL,OAAhB,CAA9B,EAAwDuB,YAAxD,CAAP,CAFmC,CAE2C;;;MAG9EzB,IAAI,GAAG,KAAKT,KAAL,CAAW,CAAX,CAAP;MACAW,OAAO,GAAG,KAAKX,KAAL,CAAW,CAAX,CAAV;IACD,CAxC4D,CAwC3D;;;IAGFxB,aAAa,CAAC0C,CAAD,EAAIT,IAAJ,CAAb;IACAjC,aAAa,CAACwC,CAAD,EAAIL,OAAJ,CAAb,CA5C6D,CA4ClC;;IAE3B,IAAIgC,CAAC,GAAG0B,cAAc,CAACnD,CAAD,EAAI,KAAKnB,IAAL,CAAUiB,CAAV,CAAJ,EAAkB,KAAKjB,IAAL,CAAUiB,CAAC,GAAG,CAAd,CAAlB,EAAoC,KAAKlB,MAAzC,CAAtB,CA9C6D,CA8CW;;;IAGxE,IAAI6C,CAAC,GAAG,KAAK5C,IAAL,CAAUiB,CAAC,GAAG,CAAd,CAAJ,IAAwB,KAAKlB,MAAL,CAAY6C,CAAZ,MAAmBzB,CAA/C,EAAkD;MAChD;MACA,IAAI,CAACN,EAAE,CAACQ,CAAD,EAAIP,IAAJ,CAAP,EAAkB;QAChB;QACA,KAAKjB,OAAL,CAAa+C,CAAb,IAAkBvB,CAAlB;MACD,CAHD,MAGO;QACL;QACAoD,OAAO,CAAC7B,CAAD,EAAI3B,CAAJ,EAAO,KAAKpB,OAAZ,EAAqB,KAAKE,MAA1B,EAAkC,KAAKC,IAAvC,CAAP;MACD;IACF,CATD,MASO;MACL;MACA0E,OAAO,CAAC9B,CAAD,EAAIzB,CAAJ,EAAOF,CAAP,EAAUI,CAAV,EAAa,KAAKxB,OAAlB,EAA2B,KAAKE,MAAhC,EAAwC,KAAKC,IAA7C,CAAP;IACD;;IAED,OAAO,IAAP;EACD,CAhED;;EAkEA,SAASsE,cAAT,CAAwBnD,CAAxB,EAA2BwD,GAA3B,EAAgCC,MAAhC,EAAwClF,KAAxC,EAA+C;IAC7C;IACA,IAAIkF,MAAM,GAAGD,GAAT,KAAiB,CAArB,EAAwB;MACtB,OAAOC,MAAP;IACD,CAJ4C,CAI3C;;;IAGF,KAAK,IAAItB,CAAC,GAAGqB,GAAb,EAAkBrB,CAAC,GAAGsB,MAAtB,EAA8BtB,CAAC,EAA/B,EAAmC;MACjC;MACA,IAAI5D,KAAK,CAAC4D,CAAD,CAAL,KAAanC,CAAjB,EAAoB;QAClB,OAAOmC,CAAP;MACD;IACF,CAZ4C,CAY3C;;;IAGF,OAAOqB,GAAP;EACD;;EAED,SAASF,OAAT,CAAiB7B,CAAjB,EAAoB3B,CAApB,EAAuBnB,MAAvB,EAA+BJ,KAA/B,EAAsCC,GAAtC,EAA2C;IACzC;IACAG,MAAM,CAAC+E,MAAP,CAAcjC,CAAd,EAAiB,CAAjB;IACAlD,KAAK,CAACmF,MAAN,CAAajC,CAAb,EAAgB,CAAhB,EAHyC,CAGrB;;IAEpB,KAAK,IAAIkC,CAAC,GAAG7D,CAAC,GAAG,CAAjB,EAAoB6D,CAAC,GAAGnF,GAAG,CAACgB,MAA5B,EAAoCmE,CAAC,EAArC,EAAyC;MACvCnF,GAAG,CAACmF,CAAD,CAAH;IACD;EACF;;EAED,SAASJ,OAAT,CAAiB9B,CAAjB,EAAoBzB,CAApB,EAAuBF,CAAvB,EAA0BI,CAA1B,EAA6BvB,MAA7B,EAAqCJ,KAArC,EAA4CC,GAA5C,EAAiD;IAC/C;IACAG,MAAM,CAAC+E,MAAP,CAAcjC,CAAd,EAAiB,CAAjB,EAAoBvB,CAApB,EAF+C,CAEvB;;IAExB3B,KAAK,CAACmF,MAAN,CAAajC,CAAb,EAAgB,CAAhB,EAAmBzB,CAAnB,EAJ+C,CAIxB;;IAEvB,KAAK,IAAI2D,CAAC,GAAG7D,CAAC,GAAG,CAAjB,EAAoB6D,CAAC,GAAGnF,GAAG,CAACgB,MAA5B,EAAoCmE,CAAC,EAArC,EAAyC;MACvCnF,GAAG,CAACmF,CAAD,CAAH;IACD;EACF;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE1F,YAAY,CAACkC,SAAb,CAAuByD,MAAvB,GAAgC,UAAUnF,IAAV,EAAgBuC,YAAhB,EAA8B6C,IAA9B,EAAoC;IAClE;IACA,IAAI,CAACrH,YAAY,CAACiC,IAAD,CAAjB,EAAyB;MACvB,MAAM,IAAIQ,SAAJ,CAAc,0BAAd,CAAN;IACD,CAJiE,CAIhE;;;IAGF,IAAI6E,SAAS,GAAGrF,IAAI,CAACa,OAAL,GAAeyE,GAAf,CAAmB,UAAAxD,KAAK,EAAI;MAC1C,OAAOyD,KAAK,CAAC1H,OAAN,CAAciE,KAAd,KAAwBA,KAAK,CAACf,MAAN,KAAiB,CAAzC,GAA6Ce,KAAK,CAAC,CAAD,CAAlD,GAAwDA,KAA/D;IACD,CAFe,CAAhB;;IAIA,IAAIuD,SAAS,CAACtE,MAAV,KAAqB,CAAzB,EAA4B;MAC1B,MAAM,IAAInB,KAAJ,CAAU,0CAAV,CAAN;IACD,CAbiE,CAahE;;;IAGFyF,SAAS,CAAC5B,OAAV,CAAkB,UAAU3B,KAAV,EAAiB;MACjC,IAAI,CAAC5D,QAAQ,CAAC4D,KAAD,CAAT,IAAoB,CAACzD,SAAS,CAACyD,KAAD,CAA9B,IAAyCA,KAAK,GAAG,CAArD,EAAwD;QACtD,MAAM,IAAItB,SAAJ,CAAc,kDAAkD,SAAlD,GAA8DlC,MAAM,CAAC+G,SAAD,CAApE,GAAkF,GAAhG,CAAN;MACD;IACF,CAJD,EAhBkE,CAoB9D;;IAEJ,IAAIG,CAAC,GAAGJ,IAAI,GAAG,KAAK7G,KAAL,EAAH,GAAkB,IAA9B,CAtBkE,CAsB9B;;IAEpC,OAAOoG,OAAO,CAACa,CAAD,EAAIH,SAAS,CAAC,CAAD,CAAb,EAAkBA,SAAS,CAAC,CAAD,CAA3B,EAAgC9C,YAAhC,CAAd;EACD,CAzBD;;EA2BA,SAASoC,OAAT,CAAiBlE,MAAjB,EAAyBK,IAAzB,EAA+BE,OAA/B,EAAwCuB,YAAxC,EAAsD;IACpD;IACA,IAAIT,KAAK,GAAGS,YAAY,IAAI,CAA5B,CAFoD,CAErB;;IAE/B,IAAItB,EAAE,GAAG3B,WAAT,CAJoD,CAI9B;;IAEtB,IAAI4B,IAAI,GAAG,CAAX;;IAEA,IAAI/C,QAAQ,CAACsC,MAAM,CAACH,SAAR,CAAZ,EAAgC;MAC9B;MACAW,EAAE,GAAG5B,KAAK,CAAC8B,IAAN,CAAW7B,WAAX,EAAwB,CAACmB,MAAM,CAACH,SAAR,EAAmBG,MAAM,CAACH,SAA1B,CAAxB,KAAiEhB,WAAtE,CAF8B,CAEqD;;MAEnF4B,IAAI,GAAG7B,KAAK,CAAC+B,OAAN,CAAc,CAAd,EAAiBX,MAAM,CAACH,SAAxB,CAAP,CAJ8B,CAIa;;MAE3CwB,KAAK,GAAGzC,KAAK,CAAC+B,OAAN,CAAcU,KAAd,EAAqBrB,MAAM,CAACH,SAA5B,CAAR;IACD,CAfmD,CAelD;;;IAGF,IAAImF,GAAG,GAAG,CAACxE,EAAE,CAACa,KAAD,EAAQZ,IAAR,CAAb,CAlBoD,CAkBxB;;IAE5B,IAAIwC,CAAC,GAAGjD,MAAM,CAACJ,KAAP,CAAa,CAAb,CAAR;IACA,IAAIqF,CAAC,GAAGjF,MAAM,CAACJ,KAAP,CAAa,CAAb,CAAR;IACA,IAAIkB,CAAJ,EAAOF,CAAP,EAAU2B,CAAV,CAtBoD,CAsBvC;;IAEb,IAAIhC,OAAO,GAAG0E,CAAd,EAAiB;MACf;MACA,KAAKrE,CAAC,GAAGqE,CAAT,EAAYrE,CAAC,GAAGL,OAAhB,EAAyBK,CAAC,EAA1B,EAA8B;QAC5B;QACAZ,MAAM,CAACL,IAAP,CAAYiB,CAAZ,IAAiBZ,MAAM,CAACR,OAAP,CAAec,MAAhC,CAF4B,CAEY;;QAExC,IAAI0E,GAAJ,EAAS;UACP;UACA,KAAKlE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGmC,CAAhB,EAAmBnC,CAAC,EAApB,EAAwB;YACtB;YACAd,MAAM,CAACR,OAAP,CAAeqB,IAAf,CAAoBQ,KAApB,EAFsB,CAEM;;;YAG5BrB,MAAM,CAACN,MAAP,CAAcmB,IAAd,CAAmBC,CAAnB;UACD;QACF;MACF,CAhBc,CAgBb;;;MAGFd,MAAM,CAACL,IAAP,CAAYY,OAAZ,IAAuBP,MAAM,CAACR,OAAP,CAAec,MAAtC;IACD,CApBD,MAoBO,IAAIC,OAAO,GAAG0E,CAAd,EAAiB;MACtB;MACAjF,MAAM,CAACL,IAAP,CAAY6E,MAAZ,CAAmBjE,OAAO,GAAG,CAA7B,EAAgC0E,CAAC,GAAG1E,OAApC,EAFsB,CAEwB;;;MAG9CP,MAAM,CAACR,OAAP,CAAegF,MAAf,CAAsBxE,MAAM,CAACL,IAAP,CAAYY,OAAZ,CAAtB,EAA4CP,MAAM,CAACR,OAAP,CAAec,MAA3D;;MAEAN,MAAM,CAACN,MAAP,CAAc8E,MAAd,CAAqBxE,MAAM,CAACL,IAAP,CAAYY,OAAZ,CAArB,EAA2CP,MAAM,CAACN,MAAP,CAAcY,MAAzD;IACD,CApDmD,CAoDlD;;;IAGF2E,CAAC,GAAG1E,OAAJ,CAvDoD,CAuDvC;;IAEb,IAAIF,IAAI,GAAG4C,CAAX,EAAc;MACZ;MACA,IAAI+B,GAAJ,EAAS;QACP;QACA,IAAIE,CAAC,GAAG,CAAR,CAFO,CAEI;;QAEX,KAAKtE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGqE,CAAhB,EAAmBrE,CAAC,EAApB,EAAwB;UACtB;UACAZ,MAAM,CAACL,IAAP,CAAYiB,CAAZ,IAAiBZ,MAAM,CAACL,IAAP,CAAYiB,CAAZ,IAAiBsE,CAAlC,CAFsB,CAEe;;UAErC3C,CAAC,GAAGvC,MAAM,CAACL,IAAP,CAAYiB,CAAC,GAAG,CAAhB,IAAqBsE,CAAzB,CAJsB,CAIM;;UAE5B,IAAIC,CAAC,GAAG,CAAR,CANsB,CAMX;;UAEX,KAAKrE,CAAC,GAAGmC,CAAT,EAAYnC,CAAC,GAAGT,IAAhB,EAAsBS,CAAC,IAAIqE,CAAC,EAA5B,EAAgC;YAC9B;YACAnF,MAAM,CAACR,OAAP,CAAegF,MAAf,CAAsBjC,CAAC,GAAG4C,CAA1B,EAA6B,CAA7B,EAAgC9D,KAAhC,EAF8B,CAEU;;;YAGxCrB,MAAM,CAACN,MAAP,CAAc8E,MAAd,CAAqBjC,CAAC,GAAG4C,CAAzB,EAA4B,CAA5B,EAA+BrE,CAA/B,EAL8B,CAKK;;;YAGnCoE,CAAC;UACF;QACF,CAtBM,CAsBL;;;QAGFlF,MAAM,CAACL,IAAP,CAAYsF,CAAZ,IAAiBjF,MAAM,CAACR,OAAP,CAAec,MAAhC;MACD;IACF,CA7BD,MA6BO,IAAID,IAAI,GAAG4C,CAAX,EAAc;MACnB;MACA,IAAImC,CAAC,GAAG,CAAR,CAFmB,CAER;;MAEX,KAAKxE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGqE,CAAhB,EAAmBrE,CAAC,EAApB,EAAwB;QACtB;QACAZ,MAAM,CAACL,IAAP,CAAYiB,CAAZ,IAAiBZ,MAAM,CAACL,IAAP,CAAYiB,CAAZ,IAAiBwE,CAAlC,CAFsB,CAEe;;QAErC,IAAIC,EAAE,GAAGrF,MAAM,CAACL,IAAP,CAAYiB,CAAZ,CAAT;QACA,IAAI0E,EAAE,GAAGtF,MAAM,CAACL,IAAP,CAAYiB,CAAC,GAAG,CAAhB,IAAqBwE,CAA9B,CALsB,CAKW;;QAEjC,KAAK7C,CAAC,GAAG8C,EAAT,EAAa9C,CAAC,GAAG+C,EAAjB,EAAqB/C,CAAC,EAAtB,EAA0B;UACxB;UACAzB,CAAC,GAAGd,MAAM,CAACN,MAAP,CAAc6C,CAAd,CAAJ,CAFwB,CAEF;;UAEtB,IAAIzB,CAAC,GAAGT,IAAI,GAAG,CAAf,EAAkB;YAChB;YACAL,MAAM,CAACR,OAAP,CAAegF,MAAf,CAAsBjC,CAAtB,EAAyB,CAAzB,EAFgB,CAEa;;;YAG7BvC,MAAM,CAACN,MAAP,CAAc8E,MAAd,CAAqBjC,CAArB,EAAwB,CAAxB,EALgB,CAKY;;;YAG5B6C,CAAC;UACF;QACF;MACF,CA1BkB,CA0BjB;;;MAGFpF,MAAM,CAACL,IAAP,CAAYiB,CAAZ,IAAiBZ,MAAM,CAACR,OAAP,CAAec,MAAhC;IACD,CApHmD,CAoHlD;;;IAGFN,MAAM,CAACJ,KAAP,CAAa,CAAb,IAAkBS,IAAlB;IACAL,MAAM,CAACJ,KAAP,CAAa,CAAb,IAAkBW,OAAlB,CAxHoD,CAwHzB;;IAE3B,OAAOP,MAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEjB,YAAY,CAACkC,SAAb,CAAuBsE,OAAvB,GAAiC,UAAUC,KAAV,EAAiBb,IAAjB,EAAuB;IACtD;IACA,IAAI,CAACvH,OAAO,CAACoI,KAAD,CAAZ,EAAqB;MACnB,MAAM,IAAIzF,SAAJ,CAAc,gBAAd,CAAN;IACD;;IAED,IAAIyF,KAAK,CAAClF,MAAN,KAAiB,CAArB,EAAwB;MACtB,MAAM,IAAInB,KAAJ,CAAU,wDAAV,CAAN;IACD,CARqD,CAQpD;;;IAGFqG,KAAK,CAACxC,OAAN,CAAc,UAAU3B,KAAV,EAAiB;MAC7B,IAAI,CAAC5D,QAAQ,CAAC4D,KAAD,CAAT,IAAoB,CAACzD,SAAS,CAACyD,KAAD,CAA9B,IAAyCA,KAAK,IAAI,CAAC,CAAnD,IAAwDA,KAAK,KAAK,CAAtE,EAAyE;QACvE,MAAM,IAAItB,SAAJ,CAAc,wDAAwD,SAAxD,GAAoElC,MAAM,CAAC2H,KAAD,CAA1E,GAAoF,GAAlG,CAAN;MACD;IACF,CAJD;IAKA,IAAIC,aAAa,GAAG,KAAK7F,KAAL,CAAW,CAAX,IAAgB,KAAKA,KAAL,CAAW,CAAX,CAApC;IACA4F,KAAK,GAAGtH,oBAAoB,CAACsH,KAAD,EAAQC,aAAR,CAA5B;IACA,IAAIC,SAAS,GAAGF,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAhC,CAlBsD,CAkBjB;;IAErC,IAAIC,aAAa,KAAKC,SAAtB,EAAiC;MAC/B,MAAM,IAAIvG,KAAJ,CAAU,qEAAV,CAAN;IACD,CAtBqD,CAsBpD;;;IAGF,IAAI4F,CAAC,GAAGJ,IAAI,GAAG,KAAK7G,KAAL,EAAH,GAAkB,IAA9B,CAzBsD,CAyBlB;;IAEpC,IAAI,KAAK8B,KAAL,CAAW,CAAX,MAAkB4F,KAAK,CAAC,CAAD,CAAvB,IAA8B,KAAK5F,KAAL,CAAW,CAAX,MAAkB4F,KAAK,CAAC,CAAD,CAAzD,EAA8D;MAC5D,OAAOT,CAAP;IACD,CA7BqD,CA6BpD;;;IAGF,IAAIY,QAAQ,GAAG,EAAf;;IAEA,KAAK,IAAI7E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiE,CAAC,CAACpF,IAAF,CAAOW,MAA3B,EAAmCQ,CAAC,EAApC,EAAwC;MACtC,KAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmE,CAAC,CAACpF,IAAF,CAAOmB,CAAC,GAAG,CAAX,IAAgBiE,CAAC,CAACpF,IAAF,CAAOmB,CAAP,CAApC,EAA+CF,CAAC,EAAhD,EAAoD;QAClD+E,QAAQ,CAAC9E,IAAT,CAAcC,CAAd;MACD;IACF,CAtCqD,CAsCpD;;;IAGF,IAAIrB,MAAM,GAAGsF,CAAC,CAACvF,OAAF,CAAUoG,KAAV,EAAb,CAzCsD,CAyCtB;;;IAGhC,IAAIC,QAAQ,GAAGd,CAAC,CAACrF,MAAF,CAASkG,KAAT,EAAf,CA5CsD,CA4CrB;;;IAGjC,KAAK,IAAIE,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGf,CAAC,CAACrF,MAAF,CAASY,MAA/B,EAAuCwF,EAAE,EAAzC,EAA6C;MAC3C,IAAIC,EAAE,GAAGF,QAAQ,CAACC,EAAD,CAAjB;MACA,IAAIE,EAAE,GAAGL,QAAQ,CAACG,EAAD,CAAjB;MACA,IAAIG,IAAI,GAAGF,EAAE,GAAGhB,CAAC,CAACnF,KAAF,CAAQ,CAAR,CAAL,GAAkBoG,EAA7B;MACAL,QAAQ,CAACG,EAAD,CAAR,GAAeG,IAAI,GAAGT,KAAK,CAAC,CAAD,CAA3B;MACAK,QAAQ,CAACC,EAAD,CAAR,GAAe3B,IAAI,CAAC+B,KAAL,CAAWD,IAAI,GAAGT,KAAK,CAAC,CAAD,CAAvB,CAAf;IACD,CArDqD,CAqDpD;IACF;IACA;IACA;IACA;;;IAGAT,CAAC,CAACvF,OAAF,CAAUc,MAAV,GAAmB,CAAnB;IACAyE,CAAC,CAACrF,MAAF,CAASY,MAAT,GAAkB,CAAlB;IACAyE,CAAC,CAACpF,IAAF,CAAOW,MAAP,GAAgBkF,KAAK,CAAC,CAAD,CAAL,GAAW,CAA3B;IACAT,CAAC,CAACnF,KAAF,GAAU4F,KAAK,CAACI,KAAN,EAAV;;IAEA,KAAK,IAAIO,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGpB,CAAC,CAACpF,IAAF,CAAOW,MAA/B,EAAuC6F,GAAG,EAA1C,EAA8C;MAC5CpB,CAAC,CAACpF,IAAF,CAAOwG,GAAP,IAAc,CAAd;IACD,CAnEqD,CAmEpD;IACF;;;IAGA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3G,MAAM,CAACa,MAA3B,EAAmC8F,CAAC,EAApC,EAAwC;MACtC,IAAIC,GAAG,GAAGR,QAAQ,CAACO,CAAD,CAAlB;MACA,IAAIE,EAAE,GAAGX,QAAQ,CAACS,CAAD,CAAjB;MACA,IAAIpF,CAAC,GAAGvB,MAAM,CAAC2G,CAAD,CAAd;;MAEA,IAAI7D,CAAC,GAAG0B,cAAc,CAACoC,GAAD,EAAMtB,CAAC,CAACpF,IAAF,CAAO2G,EAAP,CAAN,EAAkBvB,CAAC,CAACpF,IAAF,CAAO2G,EAAE,GAAG,CAAZ,CAAlB,EAAkCvB,CAAC,CAACrF,MAApC,CAAtB;;MAEA2E,OAAO,CAAC9B,CAAD,EAAI8D,GAAJ,EAASC,EAAT,EAAatF,CAAb,EAAgB+D,CAAC,CAACvF,OAAlB,EAA2BuF,CAAC,CAACrF,MAA7B,EAAqCqF,CAAC,CAACpF,IAAvC,CAAP;IACD,CA/EqD,CA+EpD;;;IAGF,OAAOoF,CAAP;EACD,CAnFD;EAoFA;AACF;AACA;AACA;AACA;;;EAGEhG,YAAY,CAACkC,SAAb,CAAuBnD,KAAvB,GAA+B,YAAY;IACzC,IAAIiH,CAAC,GAAG,IAAIhG,YAAJ,CAAiB;MACvBU,MAAM,EAAE,KAAKD,OAAL,GAAe1B,KAAK,CAAC,KAAK0B,OAAN,CAApB,GAAqCW,SADtB;MAEvBd,KAAK,EAAEvB,KAAK,CAAC,KAAK4B,MAAN,CAFW;MAGvBJ,GAAG,EAAExB,KAAK,CAAC,KAAK6B,IAAN,CAHa;MAIvBJ,IAAI,EAAEzB,KAAK,CAAC,KAAK8B,KAAN,CAJY;MAKvBX,QAAQ,EAAE,KAAKY;IALQ,CAAjB,CAAR;IAOA,OAAOkF,CAAP;EACD,CATD;EAUA;AACF;AACA;AACA;AACA;;;EAGEhG,YAAY,CAACkC,SAAb,CAAuB1B,IAAvB,GAA8B,YAAY;IACxC,OAAO,KAAKK,KAAL,CAAWgG,KAAX,CAAiB,CAAjB,CAAP,CADwC,CACZ;EAC7B,CAFD;EAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE7G,YAAY,CAACkC,SAAb,CAAuB4D,GAAvB,GAA6B,UAAU0B,QAAV,EAAoBC,SAApB,EAA+B;IAC1D;IACA,IAAI,CAAC,KAAKhH,OAAV,EAAmB;MACjB,MAAM,IAAIL,KAAJ,CAAU,4CAAV,CAAN;IACD,CAJyD,CAIxD;;;IAGF,IAAIsH,EAAE,GAAG,IAAT,CAP0D,CAO3C;;IAEf,IAAIpG,IAAI,GAAG,KAAKT,KAAL,CAAW,CAAX,CAAX;IACA,IAAIW,OAAO,GAAG,KAAKX,KAAL,CAAW,CAAX,CAAd,CAV0D,CAU7B;;IAE7B,IAAI8G,IAAI,GAAGnI,gBAAgB,CAACgI,QAAD,CAA3B;;IAEA,IAAII,MAAM,GAAG,SAASA,MAAT,CAAgB3F,CAAhB,EAAmBF,CAAnB,EAAsBF,CAAtB,EAAyB;MACpC;MACA,IAAI8F,IAAI,KAAK,CAAb,EAAgB,OAAOH,QAAQ,CAACvF,CAAD,CAAf;MAChB,IAAI0F,IAAI,KAAK,CAAb,EAAgB,OAAOH,QAAQ,CAACvF,CAAD,EAAI,CAACF,CAAD,EAAIF,CAAJ,CAAJ,CAAf;MAChB,OAAO2F,QAAQ,CAACvF,CAAD,EAAI,CAACF,CAAD,EAAIF,CAAJ,CAAJ,EAAY6F,EAAZ,CAAf;IACD,CALD,CAd0D,CAmBvD;;;IAGH,OAAOG,IAAI,CAAC,IAAD,EAAO,CAAP,EAAUvG,IAAI,GAAG,CAAjB,EAAoB,CAApB,EAAuBE,OAAO,GAAG,CAAjC,EAAoCoG,MAApC,EAA4CH,SAA5C,CAAX;EACD,CAvBD;EAwBA;AACF;AACA;AACA;;;EAGE,SAASI,IAAT,CAAc5G,MAAd,EAAsB6G,MAAtB,EAA8BC,MAA9B,EAAsCC,SAAtC,EAAiDC,SAAjD,EAA4DT,QAA5D,EAAsEC,SAAtE,EAAiF;IAC/E;IACA,IAAI/G,MAAM,GAAG,EAAb;IACA,IAAIJ,KAAK,GAAG,EAAZ;IACA,IAAIC,GAAG,GAAG,EAAV,CAJ+E,CAIjE;;IAEd,IAAIkB,EAAE,GAAG3B,WAAT,CAN+E,CAMzD;;IAEtB,IAAI4B,IAAI,GAAG,CAAX;;IAEA,IAAI/C,QAAQ,CAACsC,MAAM,CAACH,SAAR,CAAZ,EAAgC;MAC9B;MACAW,EAAE,GAAG5B,KAAK,CAAC8B,IAAN,CAAW7B,WAAX,EAAwB,CAACmB,MAAM,CAACH,SAAR,EAAmBG,MAAM,CAACH,SAA1B,CAAxB,KAAiEhB,WAAtE,CAF8B,CAEqD;;MAEnF4B,IAAI,GAAG7B,KAAK,CAAC+B,OAAN,CAAc,CAAd,EAAiBX,MAAM,CAACH,SAAxB,CAAP;IACD,CAf8E,CAe7E;;;IAGF,IAAI8G,MAAM,GAAG,SAASA,MAAT,CAAgB3F,CAAhB,EAAmByD,CAAnB,EAAsBwC,CAAtB,EAAyB;MACpC;MACAjG,CAAC,GAAGuF,QAAQ,CAACvF,CAAD,EAAIyD,CAAJ,EAAOwC,CAAP,CAAZ,CAFoC,CAEb;;MAEvB,IAAI,CAACzG,EAAE,CAACQ,CAAD,EAAIP,IAAJ,CAAP,EAAkB;QAChB;QACAhB,MAAM,CAACoB,IAAP,CAAYG,CAAZ,EAFgB,CAEA;;QAEhB3B,KAAK,CAACwB,IAAN,CAAW4D,CAAX;MACD;IACF,CAVD,CAlB+E,CA4B5E;;;IAGH,KAAK,IAAI7D,CAAC,GAAGmG,SAAb,EAAwBnG,CAAC,IAAIoG,SAA7B,EAAwCpG,CAAC,EAAzC,EAA6C;MAC3C;MACAtB,GAAG,CAACuB,IAAJ,CAASpB,MAAM,CAACa,MAAhB,EAF2C,CAElB;;MAEzB,IAAI+E,EAAE,GAAGrF,MAAM,CAACL,IAAP,CAAYiB,CAAZ,CAAT;MACA,IAAI0E,EAAE,GAAGtF,MAAM,CAACL,IAAP,CAAYiB,CAAC,GAAG,CAAhB,CAAT;;MAEA,IAAI4F,SAAJ,EAAe;QACb;QACA,KAAK,IAAIjE,CAAC,GAAG8C,EAAb,EAAiB9C,CAAC,GAAG+C,EAArB,EAAyB/C,CAAC,EAA1B,EAA8B;UAC5B;UACA,IAAIzB,CAAC,GAAGd,MAAM,CAACN,MAAP,CAAc6C,CAAd,CAAR,CAF4B,CAEF;;UAE1B,IAAIzB,CAAC,IAAI+F,MAAL,IAAe/F,CAAC,IAAIgG,MAAxB,EAAgC;YAC9B;YACAH,MAAM,CAAC3G,MAAM,CAACR,OAAP,CAAe+C,CAAf,CAAD,EAAoBzB,CAAC,GAAG+F,MAAxB,EAAgCjG,CAAC,GAAGmG,SAApC,CAAN;UACD;QACF;MACF,CAXD,MAWO;QACL;QACA,IAAIvH,OAAO,GAAG,EAAd;;QAEA,KAAK,IAAI0H,EAAE,GAAG7B,EAAd,EAAkB6B,EAAE,GAAG5B,EAAvB,EAA2B4B,EAAE,EAA7B,EAAiC;UAC/B,IAAIC,GAAG,GAAGnH,MAAM,CAACN,MAAP,CAAcwH,EAAd,CAAV;UACA1H,OAAO,CAAC2H,GAAD,CAAP,GAAenH,MAAM,CAACR,OAAP,CAAe0H,EAAf,CAAf;QACD,CAPI,CAOH;QACF;;;QAGA,KAAK,IAAIE,GAAG,GAAGP,MAAf,EAAuBO,GAAG,IAAIN,MAA9B,EAAsCM,GAAG,EAAzC,EAA6C;UAC3C,IAAI/F,KAAK,GAAG+F,GAAG,IAAI5H,OAAP,GAAiBA,OAAO,CAAC4H,GAAD,CAAxB,GAAgC,CAA5C;UACAT,MAAM,CAACtF,KAAD,EAAQ+F,GAAG,GAAGP,MAAd,EAAsBjG,CAAC,GAAGmG,SAA1B,CAAN;QACD;MACF;IACF,CAjE8E,CAiE7E;;;IAGFzH,GAAG,CAACuB,IAAJ,CAASpB,MAAM,CAACa,MAAhB,EApE+E,CAoEtD;;IAEzB,OAAO,IAAIvB,YAAJ,CAAiB;MACtBU,MAAM,EAANA,MADsB;MAEtBJ,KAAK,EAALA,KAFsB;MAGtBC,GAAG,EAAHA,GAHsB;MAItBC,IAAI,EAAE,CAACuH,MAAM,GAAGD,MAAT,GAAkB,CAAnB,EAAsBG,SAAS,GAAGD,SAAZ,GAAwB,CAA9C;IAJgB,CAAjB,CAAP;EAMD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEhI,YAAY,CAACkC,SAAb,CAAuB+B,OAAvB,GAAiC,UAAUuD,QAAV,EAAoBC,SAApB,EAA+B;IAC9D;IACA,IAAI,CAAC,KAAKhH,OAAV,EAAmB;MACjB,MAAM,IAAIL,KAAJ,CAAU,gDAAV,CAAN;IACD,CAJ6D,CAI5D;;;IAGF,IAAIsH,EAAE,GAAG,IAAT,CAP8D,CAO/C;;IAEf,IAAIpG,IAAI,GAAG,KAAKT,KAAL,CAAW,CAAX,CAAX;IACA,IAAIW,OAAO,GAAG,KAAKX,KAAL,CAAW,CAAX,CAAd,CAV8D,CAUjC;;IAE7B,KAAK,IAAIgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAApB,EAA6BK,CAAC,EAA9B,EAAkC;MAChC;MACA,IAAIyE,EAAE,GAAG,KAAK1F,IAAL,CAAUiB,CAAV,CAAT;MACA,IAAI0E,EAAE,GAAG,KAAK3F,IAAL,CAAUiB,CAAC,GAAG,CAAd,CAAT;;MAEA,IAAI4F,SAAJ,EAAe;QACb;QACA,KAAK,IAAIjE,CAAC,GAAG8C,EAAb,EAAiB9C,CAAC,GAAG+C,EAArB,EAAyB/C,CAAC,EAA1B,EAA8B;UAC5B;UACA,IAAIzB,CAAC,GAAG,KAAKpB,MAAL,CAAY6C,CAAZ,CAAR,CAF4B,CAEJ;;UAExBgE,QAAQ,CAAC,KAAK/G,OAAL,CAAa+C,CAAb,CAAD,EAAkB,CAACzB,CAAD,EAAIF,CAAJ,CAAlB,EAA0B6F,EAA1B,CAAR;QACD;MACF,CARD,MAQO;QACL;QACA,IAAIhH,MAAM,GAAG,EAAb;;QAEA,KAAK,IAAI4H,GAAG,GAAGhC,EAAf,EAAmBgC,GAAG,GAAG/B,EAAzB,EAA6B+B,GAAG,EAAhC,EAAoC;UAClC,IAAIC,GAAG,GAAG,KAAK5H,MAAL,CAAY2H,GAAZ,CAAV;UACA5H,MAAM,CAAC6H,GAAD,CAAN,GAAc,KAAK9H,OAAL,CAAa6H,GAAb,CAAd;QACD,CAPI,CAOH;QACF;;;QAGA,KAAK,IAAIE,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGlH,IAAxB,EAA8BkH,GAAG,EAAjC,EAAqC;UACnC,IAAIlG,KAAK,GAAGkG,GAAG,IAAI9H,MAAP,GAAgBA,MAAM,CAAC8H,GAAD,CAAtB,GAA8B,CAA1C;UACAhB,QAAQ,CAAClF,KAAD,EAAQ,CAACkG,GAAD,EAAM3G,CAAN,CAAR,EAAkB6F,EAAlB,CAAR;QACD;MACF;IACF;EACF,CA1CD;EA2CA;AACF;AACA;AACA;;;EAGE1H,YAAY,CAACkC,SAAb,CAAuBuG,MAAM,CAACC,QAA9B,4CAA0C;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,IACnC,KAAKjI,OAD8B;cAAA;cAAA;YAAA;;YAAA,MAEhC,IAAIL,KAAJ,CAAU,sCAAV,CAFgC;;UAAA;YAKpCoB,OALoC,GAK1B,KAAKX,KAAL,CAAW,CAAX,CAL0B;YAO/BgB,CAP+B,GAO3B,CAP2B;;UAAA;YAAA,MAOxBA,CAAC,GAAGL,OAPoB;cAAA;cAAA;YAAA;;YAQlC8E,EARkC,GAQ7B,KAAK1F,IAAL,CAAUiB,CAAV,CAR6B;YASlC0E,EATkC,GAS7B,KAAK3F,IAAL,CAAUiB,CAAC,GAAG,CAAd,CAT6B;YAW7B2B,CAX6B,GAWzB8C,EAXyB;;UAAA;YAAA,MAWrB9C,CAAC,GAAG+C,EAXiB;cAAA;cAAA;YAAA;;YAYpC;YACIxE,CAbgC,GAa5B,KAAKpB,MAAL,CAAY6C,CAAZ,CAb4B;YAAA;YAcpC,OAAM;cACJlB,KAAK,EAAE,KAAK7B,OAAL,CAAa+C,CAAb,CADH;cAEJlD,KAAK,EAAE,CAACyB,CAAD,EAAIF,CAAJ;YAFH,CAAN;;UAdoC;YAWb2B,CAAC,EAXY;YAAA;YAAA;;UAAA;YAOX3B,CAAC,EAPU;YAAA;YAAA;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAA1C;EAqBA;AACF;AACA;AACA;AACA;;EAGE7B,YAAY,CAACkC,SAAb,CAAuBoC,OAAvB,GAAiC,YAAY;IAC3C,OAAOqE,QAAQ,CAAC,KAAKlI,OAAN,EAAe,KAAKE,MAApB,EAA4B,KAAKC,IAAjC,EAAuC,KAAKC,KAA5C,EAAmD,IAAnD,CAAf;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;;;EAGEb,YAAY,CAACkC,SAAb,CAAuBb,OAAvB,GAAiC,YAAY;IAC3C,OAAOsH,QAAQ,CAAC,KAAKlI,OAAN,EAAe,KAAKE,MAApB,EAA4B,KAAKC,IAAjC,EAAuC,KAAKC,KAA5C,EAAmD,KAAnD,CAAf;EACD,CAFD;;EAIA,SAAS8H,QAAT,CAAkBjI,MAAlB,EAA0BJ,KAA1B,EAAiCC,GAAjC,EAAsCC,IAAtC,EAA4CoF,IAA5C,EAAkD;IAChD;IACA,IAAItE,IAAI,GAAGd,IAAI,CAAC,CAAD,CAAf;IACA,IAAIgB,OAAO,GAAGhB,IAAI,CAAC,CAAD,CAAlB,CAHgD,CAGzB;;IAEvB,IAAIoI,CAAC,GAAG,EAAR,CALgD,CAKpC;;IAEZ,IAAI7G,CAAJ,EAAOF,CAAP,CAPgD,CAOtC;;IAEV,KAAKE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGT,IAAhB,EAAsBS,CAAC,EAAvB,EAA2B;MACzB6G,CAAC,CAAC7G,CAAD,CAAD,GAAO,EAAP;;MAEA,KAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGL,OAAhB,EAAyBK,CAAC,EAA1B,EAA8B;QAC5B+G,CAAC,CAAC7G,CAAD,CAAD,CAAKF,CAAL,IAAU,CAAV;MACD;IACF,CAf+C,CAe9C;;;IAGF,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGL,OAAhB,EAAyBK,CAAC,EAA1B,EAA8B;MAC5B;MACA,IAAIyE,EAAE,GAAG/F,GAAG,CAACsB,CAAD,CAAZ;MACA,IAAI0E,EAAE,GAAGhG,GAAG,CAACsB,CAAC,GAAG,CAAL,CAAZ,CAH4B,CAGP;;MAErB,KAAK,IAAI2B,CAAC,GAAG8C,EAAb,EAAiB9C,CAAC,GAAG+C,EAArB,EAAyB/C,CAAC,EAA1B,EAA8B;QAC5B;QACAzB,CAAC,GAAGzB,KAAK,CAACkD,CAAD,CAAT,CAF4B,CAEd;;QAEdoF,CAAC,CAAC7G,CAAD,CAAD,CAAKF,CAAL,IAAUnB,MAAM,GAAGkF,IAAI,GAAG7G,KAAK,CAAC2B,MAAM,CAAC8C,CAAD,CAAP,CAAR,GAAsB9C,MAAM,CAAC8C,CAAD,CAAnC,GAAyC,CAAzD;MACD;IACF;;IAED,OAAOoF,CAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE5I,YAAY,CAACkC,SAAb,CAAuBpD,MAAvB,GAAgC,UAAU+J,OAAV,EAAmB;IACjD;IACA,IAAIvH,IAAI,GAAG,KAAKT,KAAL,CAAW,CAAX,CAAX;IACA,IAAIW,OAAO,GAAG,KAAKX,KAAL,CAAW,CAAX,CAAd,CAHiD,CAGpB;;IAE7B,IAAI+B,OAAO,GAAG,KAAKA,OAAL,EAAd,CALiD,CAKnB;;IAE9B,IAAIkG,GAAG,GAAG,oBAAoBhK,MAAM,CAACwC,IAAD,EAAOuH,OAAP,CAA1B,GAA4C,KAA5C,GAAoD/J,MAAM,CAAC0C,OAAD,EAAUqH,OAAV,CAA1D,GAA+E,aAA/E,GAA+F/J,MAAM,CAAC8D,OAAD,EAAUiG,OAAV,CAArG,GAA0H,IAApI,CAPiD,CAOyF;;IAE1I,KAAK,IAAIhH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAApB,EAA6BK,CAAC,EAA9B,EAAkC;MAChC;MACA,IAAIyE,EAAE,GAAG,KAAK1F,IAAL,CAAUiB,CAAV,CAAT;MACA,IAAI0E,EAAE,GAAG,KAAK3F,IAAL,CAAUiB,CAAC,GAAG,CAAd,CAAT,CAHgC,CAGL;;MAE3B,KAAK,IAAI2B,CAAC,GAAG8C,EAAb,EAAiB9C,CAAC,GAAG+C,EAArB,EAAyB/C,CAAC,EAA1B,EAA8B;QAC5B;QACA,IAAIzB,CAAC,GAAG,KAAKpB,MAAL,CAAY6C,CAAZ,CAAR,CAF4B,CAEJ;;QAExBsF,GAAG,IAAI,YAAYhK,MAAM,CAACiD,CAAD,EAAI8G,OAAJ,CAAlB,GAAiC,IAAjC,GAAwC/J,MAAM,CAAC+C,CAAD,EAAIgH,OAAJ,CAA9C,GAA6D,QAA7D,IAAyE,KAAKpI,OAAL,GAAe3B,MAAM,CAAC,KAAK2B,OAAL,CAAa+C,CAAb,CAAD,EAAkBqF,OAAlB,CAArB,GAAkD,GAA3H,CAAP;MACD;IACF;;IAED,OAAOC,GAAP;EACD,CAvBD;EAwBA;AACF;AACA;AACA;AACA;;;EAGE9I,YAAY,CAACkC,SAAb,CAAuB6G,QAAvB,GAAkC,YAAY;IAC5C,OAAOjK,MAAM,CAAC,KAAKwF,OAAL,EAAD,CAAb;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;;;EAGEtE,YAAY,CAACkC,SAAb,CAAuB8G,MAAvB,GAAgC,YAAY;IAC1C,OAAO;MACLC,MAAM,EAAE,cADH;MAELvI,MAAM,EAAE,KAAKD,OAFR;MAGLH,KAAK,EAAE,KAAKK,MAHP;MAILJ,GAAG,EAAE,KAAKK,IAJL;MAKLJ,IAAI,EAAE,KAAKK,KALN;MAMLX,QAAQ,EAAE,KAAKY;IANV,CAAP;EAQD,CATD;EAUA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEd,YAAY,CAACkC,SAAb,CAAuBgH,QAAvB,GAAkC,UAAU1F,CAAV,EAAa;IAC7C;IACA,IAAIA,CAAJ,EAAO;MACL;MACA,IAAIlF,WAAW,CAACkF,CAAD,CAAf,EAAoB;QAClBA,CAAC,GAAGA,CAAC,CAAC2F,QAAF,EAAJ;MACD,CAJI,CAIH;;;MAGF,IAAI,CAACzK,QAAQ,CAAC8E,CAAD,CAAT,IAAgB,CAAC3E,SAAS,CAAC2E,CAAD,CAA9B,EAAmC;QACjC,MAAM,IAAIxC,SAAJ,CAAc,2CAAd,CAAN;MACD;IACF,CAVD,MAUO;MACL;MACAwC,CAAC,GAAG,CAAJ;IACD;;IAED,IAAI4F,MAAM,GAAG5F,CAAC,GAAG,CAAJ,GAAQA,CAAR,GAAY,CAAzB;IACA,IAAI6F,IAAI,GAAG7F,CAAC,GAAG,CAAJ,GAAQ,CAACA,CAAT,GAAa,CAAxB,CAlB6C,CAkBlB;;IAE3B,IAAIlC,IAAI,GAAG,KAAKT,KAAL,CAAW,CAAX,CAAX;IACA,IAAIW,OAAO,GAAG,KAAKX,KAAL,CAAW,CAAX,CAAd,CArB6C,CAqBhB;;IAE7B,IAAIsF,CAAC,GAAGf,IAAI,CAAC9B,GAAL,CAAShC,IAAI,GAAG+H,IAAhB,EAAsB7H,OAAO,GAAG4H,MAAhC,CAAR,CAvB6C,CAuBI;;IAEjD,IAAI1I,MAAM,GAAG,EAAb;IACA,IAAIJ,KAAK,GAAG,EAAZ;IACA,IAAIC,GAAG,GAAG,EAAV,CA3B6C,CA2B/B;;IAEdA,GAAG,CAAC,CAAD,CAAH,GAAS,CAAT,CA7B6C,CA6BjC;;IAEZ,KAAK,IAAIsB,CAAC,GAAGuH,MAAb,EAAqBvH,CAAC,GAAGL,OAAJ,IAAed,MAAM,CAACa,MAAP,GAAgB4E,CAApD,EAAuDtE,CAAC,EAAxD,EAA4D;MAC1D;MACA,IAAIyE,EAAE,GAAG,KAAK1F,IAAL,CAAUiB,CAAV,CAAT;MACA,IAAI0E,EAAE,GAAG,KAAK3F,IAAL,CAAUiB,CAAC,GAAG,CAAd,CAAT,CAH0D,CAG/B;;MAE3B,KAAK,IAAI6D,CAAC,GAAGY,EAAb,EAAiBZ,CAAC,GAAGa,EAArB,EAAyBb,CAAC,EAA1B,EAA8B;QAC5B;QACA,IAAI3D,CAAC,GAAG,KAAKpB,MAAL,CAAY+E,CAAZ,CAAR,CAF4B,CAEJ;;QAExB,IAAI3D,CAAC,KAAKF,CAAC,GAAGuH,MAAJ,GAAaC,IAAvB,EAA6B;UAC3B;UACA3I,MAAM,CAACoB,IAAP,CAAY,KAAKrB,OAAL,CAAaiF,CAAb,CAAZ,EAF2B,CAEG;;UAE9BpF,KAAK,CAACI,MAAM,CAACa,MAAP,GAAgB,CAAjB,CAAL,GAA2BQ,CAAC,GAAGsH,IAA/B,CAJ2B,CAIU;;UAErC;QACD;MACF;IACF,CAjD4C,CAiD3C;;;IAGF9I,GAAG,CAACuB,IAAJ,CAASpB,MAAM,CAACa,MAAhB,EApD6C,CAoDpB;;IAEzB,OAAO,IAAIvB,YAAJ,CAAiB;MACtBU,MAAM,EAANA,MADsB;MAEtBJ,KAAK,EAALA,KAFsB;MAGtBC,GAAG,EAAHA,GAHsB;MAItBC,IAAI,EAAE,CAAC2F,CAAD,EAAI,CAAJ;IAJgB,CAAjB,CAAP;EAMD,CA5DD;EA6DA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEnG,YAAY,CAACsJ,QAAb,GAAwB,UAAUC,IAAV,EAAgB;IACtC,OAAO,IAAIvJ,YAAJ,CAAiBuJ,IAAjB,CAAP;EACD,CAFD;EAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEvJ,YAAY,CAACkJ,QAAb,GAAwB,UAAU1I,IAAV,EAAgB8B,KAAhB,EAAuBkB,CAAvB,EAA0BT,YAA1B,EAAwC7C,QAAxC,EAAkD;IACxE,IAAI,CAAC7B,OAAO,CAACmC,IAAD,CAAZ,EAAoB;MAClB,MAAM,IAAIQ,SAAJ,CAAc,gCAAd,CAAN;IACD;;IAED,IAAIR,IAAI,CAACe,MAAL,KAAgB,CAApB,EAAuB;MACrB,MAAM,IAAInB,KAAJ,CAAU,0CAAV,CAAN;IACD,CAPuE,CAOtE;;;IAGFI,IAAI,GAAGA,IAAI,CAACsF,GAAL,CAAS,UAAU0D,CAAV,EAAa;MAC3B;MACA,IAAIlL,WAAW,CAACkL,CAAD,CAAf,EAAoB;QAClB;QACAA,CAAC,GAAGA,CAAC,CAACL,QAAF,EAAJ;MACD,CAL0B,CAKzB;;;MAGF,IAAI,CAACzK,QAAQ,CAAC8K,CAAD,CAAT,IAAgB,CAAC3K,SAAS,CAAC2K,CAAD,CAA1B,IAAiCA,CAAC,GAAG,CAAzC,EAA4C;QAC1C,MAAM,IAAIpJ,KAAJ,CAAU,uCAAV,CAAN;MACD;;MAED,OAAOoJ,CAAP;IACD,CAbM,CAAP,CAVwE,CAuBpE;;IAEJ,IAAIhG,CAAJ,EAAO;MACL;MACA,IAAIlF,WAAW,CAACkF,CAAD,CAAf,EAAoB;QAClBA,CAAC,GAAGA,CAAC,CAAC2F,QAAF,EAAJ;MACD,CAJI,CAIH;;;MAGF,IAAI,CAACzK,QAAQ,CAAC8E,CAAD,CAAT,IAAgB,CAAC3E,SAAS,CAAC2E,CAAD,CAA9B,EAAmC;QACjC,MAAM,IAAIxC,SAAJ,CAAc,2CAAd,CAAN;MACD;IACF,CAVD,MAUO;MACL;MACAwC,CAAC,GAAG,CAAJ;IACD,CAtCuE,CAsCtE;;;IAGF,IAAI/B,EAAE,GAAG3B,WAAT,CAzCwE,CAyClD;;IAEtB,IAAI4B,IAAI,GAAG,CAAX;;IAEA,IAAI/C,QAAQ,CAACuB,QAAD,CAAZ,EAAwB;MACtB;MACAuB,EAAE,GAAG5B,KAAK,CAAC8B,IAAN,CAAW7B,WAAX,EAAwB,CAACI,QAAD,EAAWA,QAAX,CAAxB,KAAiDJ,WAAtD,CAFsB,CAE6C;;MAEnE4B,IAAI,GAAG7B,KAAK,CAAC+B,OAAN,CAAc,CAAd,EAAiB1B,QAAjB,CAAP;IACD;;IAED,IAAIkJ,MAAM,GAAG5F,CAAC,GAAG,CAAJ,GAAQA,CAAR,GAAY,CAAzB;IACA,IAAI6F,IAAI,GAAG7F,CAAC,GAAG,CAAJ,GAAQ,CAACA,CAAT,GAAa,CAAxB,CArDwE,CAqD7C;;IAE3B,IAAIlC,IAAI,GAAGd,IAAI,CAAC,CAAD,CAAf;IACA,IAAIgB,OAAO,GAAGhB,IAAI,CAAC,CAAD,CAAlB,CAxDwE,CAwDjD;;IAEvB,IAAI2F,CAAC,GAAGf,IAAI,CAAC9B,GAAL,CAAShC,IAAI,GAAG+H,IAAhB,EAAsB7H,OAAO,GAAG4H,MAAhC,CAAR,CA1DwE,CA0DvB;;IAEjD,IAAIK,MAAJ,CA5DwE,CA4D5D;;;IAGZ,IAAIpL,OAAO,CAACiE,KAAD,CAAX,EAAoB;MAClB;MACA,IAAIA,KAAK,CAACf,MAAN,KAAiB4E,CAArB,EAAwB;QACtB;QACA,MAAM,IAAI/F,KAAJ,CAAU,4BAAV,CAAN;MACD,CALiB,CAKhB;;;MAGFqJ,MAAM,GAAG,SAASA,MAAT,CAAgB1H,CAAhB,EAAmB;QAC1B;QACA,OAAOO,KAAK,CAACP,CAAD,CAAZ;MACD,CAHD;IAID,CAZD,MAYO,IAAItD,QAAQ,CAAC6D,KAAD,CAAZ,EAAqB;MAC1B;MACA,IAAIoH,EAAE,GAAGpH,KAAK,CAAC9B,IAAN,EAAT,CAF0B,CAEH;;MAEvB,IAAIkJ,EAAE,CAACnI,MAAH,KAAc,CAAd,IAAmBmI,EAAE,CAAC,CAAD,CAAF,KAAUvD,CAAjC,EAAoC;QAClC;QACA,MAAM,IAAI/F,KAAJ,CAAU,uBAAV,CAAN;MACD,CAPyB,CAOxB;;;MAGFqJ,MAAM,GAAG,SAASA,MAAT,CAAgB1H,CAAhB,EAAmB;QAC1B;QACA,OAAOO,KAAK,CAACe,GAAN,CAAU,CAACtB,CAAD,CAAV,CAAP;MACD,CAHD;IAID,CAdM,MAcA;MACL;MACA0H,MAAM,GAAG,SAASA,MAAT,GAAkB;QACzB;QACA,OAAOnH,KAAP;MACD,CAHD;IAID,CA/FuE,CA+FtE;;;IAGF,IAAI5B,MAAM,GAAG,EAAb;IACA,IAAIJ,KAAK,GAAG,EAAZ;IACA,IAAIC,GAAG,GAAG,EAAV,CApGwE,CAoG1D;;IAEd,KAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAApB,EAA6BK,CAAC,EAA9B,EAAkC;MAChC;MACAtB,GAAG,CAACuB,IAAJ,CAASpB,MAAM,CAACa,MAAhB,EAFgC,CAEP;;MAEzB,IAAIQ,CAAC,GAAGF,CAAC,GAAGuH,MAAZ,CAJgC,CAIZ;;MAEpB,IAAIrH,CAAC,IAAI,CAAL,IAAUA,CAAC,GAAGoE,CAAlB,EAAqB;QACnB;QACA,IAAIlE,CAAC,GAAGwH,MAAM,CAAC1H,CAAD,CAAd,CAFmB,CAEA;;;QAGnB,IAAI,CAACN,EAAE,CAACQ,CAAD,EAAIP,IAAJ,CAAP,EAAkB;UAChB;UACApB,KAAK,CAACwB,IAAN,CAAWC,CAAC,GAAGsH,IAAf,EAFgB,CAEM;;UAEtB3I,MAAM,CAACoB,IAAP,CAAYG,CAAZ;QACD;MACF;IACF,CAxHuE,CAwHtE;;;IAGF1B,GAAG,CAACuB,IAAJ,CAASpB,MAAM,CAACa,MAAhB,EA3HwE,CA2H/C;;IAEzB,OAAO,IAAIvB,YAAJ,CAAiB;MACtBU,MAAM,EAANA,MADsB;MAEtBJ,KAAK,EAALA,KAFsB;MAGtBC,GAAG,EAAHA,GAHsB;MAItBC,IAAI,EAAE,CAACc,IAAD,EAAOE,OAAP;IAJgB,CAAjB,CAAP;EAMD,CAnID;EAoIA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGExB,YAAY,CAACkC,SAAb,CAAuByH,QAAvB,GAAkC,UAAU5H,CAAV,EAAaF,CAAb,EAAgB;IAChD;IACA,IAAI,CAACnD,QAAQ,CAACqD,CAAD,CAAT,IAAgB,CAAClD,SAAS,CAACkD,CAAD,CAA1B,IAAiC,CAACrD,QAAQ,CAACmD,CAAD,CAA1C,IAAiD,CAAChD,SAAS,CAACgD,CAAD,CAA/D,EAAoE;MAClE,MAAM,IAAIzB,KAAJ,CAAU,qCAAV,CAAN;IACD,CAJ+C,CAI9C;;;IAGF,IAAI,KAAKS,KAAL,CAAWU,MAAX,KAAsB,CAA1B,EAA6B;MAC3B,MAAM,IAAInB,KAAJ,CAAU,0CAAV,CAAN;IACD,CAT+C,CAS9C;;;IAGFf,aAAa,CAAC0C,CAAD,EAAI,KAAKlB,KAAL,CAAW,CAAX,CAAJ,CAAb;IACAxB,aAAa,CAACwC,CAAD,EAAI,KAAKhB,KAAL,CAAW,CAAX,CAAJ,CAAb,CAbgD,CAaf;;IAEjCb,YAAY,CAAC4J,SAAb,CAAuB7H,CAAvB,EAA0BF,CAA1B,EAA6B,KAAKhB,KAAL,CAAW,CAAX,CAA7B,EAA4C,KAAKJ,OAAjD,EAA0D,KAAKE,MAA/D,EAAuE,KAAKC,IAA5E,EAfgD,CAemC;;;IAGnF,OAAO,IAAP;EACD,CAnBD;EAoBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGEZ,YAAY,CAAC6J,WAAb,GAA2B,UAAUhI,CAAV,EAAanB,MAAb,EAAqBJ,KAArB,EAA4BC,GAA5B,EAAiCiH,QAAjC,EAA2C;IACpE;IACA,IAAIlB,EAAE,GAAG/F,GAAG,CAACsB,CAAD,CAAZ;IACA,IAAI0E,EAAE,GAAGhG,GAAG,CAACsB,CAAC,GAAG,CAAL,CAAZ,CAHoE,CAG/C;;IAErB,KAAK,IAAI2B,CAAC,GAAG8C,EAAb,EAAiB9C,CAAC,GAAG+C,EAArB,EAAyB/C,CAAC,EAA1B,EAA8B;MAC5B;MACAgE,QAAQ,CAAClH,KAAK,CAACkD,CAAD,CAAN,EAAW9C,MAAM,CAAC8C,CAAD,CAAjB,CAAR;IACD;EACF,CATD;EAUA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGExD,YAAY,CAAC4J,SAAb,GAAyB,UAAUlE,CAAV,EAAawC,CAAb,EAAgB1G,OAAhB,EAAyBd,MAAzB,EAAiCJ,KAAjC,EAAwCC,GAAxC,EAA6C;IACpE;IACA,KAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAApB,EAA6BK,CAAC,EAA9B,EAAkC;MAChC;MACA,IAAIyE,EAAE,GAAG/F,GAAG,CAACsB,CAAD,CAAZ;MACA,IAAI0E,EAAE,GAAGhG,GAAG,CAACsB,CAAC,GAAG,CAAL,CAAZ,CAHgC,CAGX;;MAErB,IAAIiI,EAAE,GAAG5E,cAAc,CAACQ,CAAD,EAAIY,EAAJ,EAAQC,EAAR,EAAYjG,KAAZ,CAAvB,CALgC,CAKW;;;MAG3C,IAAIyJ,EAAE,GAAG7E,cAAc,CAACgD,CAAD,EAAI5B,EAAJ,EAAQC,EAAR,EAAYjG,KAAZ,CAAvB,CARgC,CAQW;;;MAG3C,IAAIwJ,EAAE,GAAGvD,EAAL,IAAWwD,EAAE,GAAGxD,EAAhB,IAAsBjG,KAAK,CAACwJ,EAAD,CAAL,KAAcpE,CAApC,IAAyCpF,KAAK,CAACyJ,EAAD,CAAL,KAAc7B,CAA3D,EAA8D;QAC5D;QACA,IAAIxH,MAAJ,EAAY;UACV,IAAIuB,CAAC,GAAGvB,MAAM,CAACoJ,EAAD,CAAd;UACApJ,MAAM,CAACoJ,EAAD,CAAN,GAAapJ,MAAM,CAACqJ,EAAD,CAAnB;UACArJ,MAAM,CAACqJ,EAAD,CAAN,GAAa9H,CAAb;QACD,CAN2D,CAM1D;;;QAGF;MACD,CArB+B,CAqB9B;;;MAGF,IAAI6H,EAAE,GAAGvD,EAAL,IAAWjG,KAAK,CAACwJ,EAAD,CAAL,KAAcpE,CAAzB,KAA+BqE,EAAE,IAAIxD,EAAN,IAAYjG,KAAK,CAACyJ,EAAD,CAAL,KAAc7B,CAAzD,CAAJ,EAAiE;QAC/D;QACA,IAAI8B,EAAE,GAAGtJ,MAAM,GAAGA,MAAM,CAACoJ,EAAD,CAAT,GAAgB1I,SAA/B,CAF+D,CAErB;;QAE1Cd,KAAK,CAACmF,MAAN,CAAasE,EAAb,EAAiB,CAAjB,EAAoB7B,CAApB;;QAEA,IAAIxH,MAAJ,EAAY;UACVA,MAAM,CAAC+E,MAAP,CAAcsE,EAAd,EAAkB,CAAlB,EAAqBC,EAArB;QACD,CAR8D,CAQ7D;;;QAGF1J,KAAK,CAACmF,MAAN,CAAasE,EAAE,IAAID,EAAN,GAAWA,EAAE,GAAG,CAAhB,GAAoBA,EAAjC,EAAqC,CAArC;;QAEA,IAAIpJ,MAAJ,EAAY;UACVA,MAAM,CAAC+E,MAAP,CAAcsE,EAAE,IAAID,EAAN,GAAWA,EAAE,GAAG,CAAhB,GAAoBA,EAAlC,EAAsC,CAAtC;QACD,CAf8D,CAe7D;;;QAGF;MACD,CA3C+B,CA2C9B;;;MAGF,IAAIC,EAAE,GAAGxD,EAAL,IAAWjG,KAAK,CAACyJ,EAAD,CAAL,KAAc7B,CAAzB,KAA+B4B,EAAE,IAAIvD,EAAN,IAAYjG,KAAK,CAACwJ,EAAD,CAAL,KAAcpE,CAAzD,CAAJ,EAAiE;QAC/D;QACA,IAAIuE,EAAE,GAAGvJ,MAAM,GAAGA,MAAM,CAACqJ,EAAD,CAAT,GAAgB3I,SAA/B,CAF+D,CAErB;;QAE1Cd,KAAK,CAACmF,MAAN,CAAaqE,EAAb,EAAiB,CAAjB,EAAoBpE,CAApB;;QAEA,IAAIhF,MAAJ,EAAY;UACVA,MAAM,CAAC+E,MAAP,CAAcqE,EAAd,EAAkB,CAAlB,EAAqBG,EAArB;QACD,CAR8D,CAQ7D;;;QAGF3J,KAAK,CAACmF,MAAN,CAAaqE,EAAE,IAAIC,EAAN,GAAWA,EAAE,GAAG,CAAhB,GAAoBA,EAAjC,EAAqC,CAArC;;QAEA,IAAIrJ,MAAJ,EAAY;UACVA,MAAM,CAAC+E,MAAP,CAAcqE,EAAE,IAAIC,EAAN,GAAWA,EAAE,GAAG,CAAhB,GAAoBA,EAAlC,EAAsC,CAAtC;QACD;MACF;IACF;EACF,CAlED;;EAoEA,OAAO/J,YAAP;AACD,CApiD0D,EAoiDxD;EACDkK,OAAO,EAAE;AADR,CApiDwD,CAApD"},"metadata":{},"sourceType":"module"}