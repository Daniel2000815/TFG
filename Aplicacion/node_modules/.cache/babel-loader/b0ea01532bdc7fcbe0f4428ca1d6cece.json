{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.default = lexer;\n\nvar _Token = require(\"./Token\");\n\nvar _Token2 = _interopRequireDefault(_Token);\n\nvar _arities = require(\"./util/arities\");\n\nvar _arities2 = _interopRequireDefault(_arities);\n\nvar _localFunctions = require(\"./util/localFunctions\");\n\nvar _localFunctions2 = _interopRequireDefault(_localFunctions);\n\nvar _replaceToken = require(\"./util/replaceToken\");\n\nvar _replaceToken2 = _interopRequireDefault(_replaceToken);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Single-arg tokens are those that, when in LaTeX mode, read only one character as their argument OR a block delimited by { }. For example, `x ^ 24` would be read as `SYMBOL(x) POWER NUMBER(2) NUMBER(4).\n\n\nvar CHAR_ARG_TOKENS = [_Token2.default.TYPE_POWER, _Token2.default.TYPE_COMMAND];\nvar DEFAULT_OPTS = {\n  latex: false\n};\n/**\n * The lexer reads a math expression and breaks it down into easily-digestible Tokens.\n * A list of valid tokens can be found lower in this file.\n * @param equation (String) The equation to lex.\n * @param constants (Object) An object of functions and variables.\n * @param opts Options.\n * @returns {Array} An array of Tokens.\n */\n\nfunction lexer(equation) {\n  var constants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTS;\n  var l = new Lexer(equation, constants, opts);\n  l.lex(); // toString() each token and concatenate into a big string. Useful for debugging.\n\n  l.tokens.toString = function () {\n    return l.tokens.map(function (token) {\n      return token.toString();\n    }).join(\" \");\n  };\n\n  return l.tokens;\n}\n\nvar Lexer = function () {\n  function Lexer(buffer, constants, opts) {\n    _classCallCheck(this, Lexer);\n\n    this.buffer = buffer;\n    this.constants = Object.assign({}, constants, _localFunctions2.default);\n    this.opts = opts;\n    this.tokens = [];\n  }\n\n  _createClass(Lexer, [{\n    key: \"lex\",\n    value: function lex() {\n      this.lexExpression();\n      this.replaceConstants();\n      this.replaceCommands();\n    }\n    /**\n     * Lexes an expression or sub-expression.\n     */\n\n  }, {\n    key: \"lexExpression\",\n    value: function lexExpression() {\n      var charMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      while (this.hasNext()) {\n        var token = charMode ? this.nextCharToken() : this.next();\n        this.tokens.push((0, _replaceToken2.default)(token));\n\n        if (this.opts.latex && isCharArgToken(token)) {\n          var arity = 1;\n\n          if (token.type === _Token2.default.TYPE_COMMAND) {\n            arity = _arities2.default[token.value.substr(1).toLowerCase()];\n          }\n\n          for (var i = 0; i < arity; i++) {\n            this.lexExpression(true);\n          }\n        } else if (isStartGroupToken(token)) {\n          this.lexExpression(false);\n        }\n\n        if (charMode || isEndGroupToken(token)) {\n          return;\n        }\n      }\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext() {\n      return this.buffer.length > 0;\n    }\n    /**\n     * Retrieves the next non-whitespace token from the buffer.\n     * @param len\n     * @returns {Token}\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      var len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      this.skipWhitespace();\n\n      if (!this.hasNext()) {\n        throw \"Lexer error: reached end of stream\";\n      } // Try to match each pattern in tokenPatterns to the remaining buffer\n\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _Token2.default.patterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          var type = _ref2[0];\n          var regex = _ref2[1]; // Force the regex to match only at the beginning of the string\n\n          var regexFromStart = new RegExp(/^/.source + regex.source); // When `len` is undefined, substr reads to the end\n\n          var match = regexFromStart.exec(this.buffer.substr(0, len));\n\n          if (match) {\n            this.buffer = this.buffer.substr(match[0].length);\n            return new _Token2.default(type, match[0]);\n          }\n        } // TODO: Meaningful error\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      throw \"Lexer error: can't match any token\";\n    }\n    /**\n     * Tokenizes the next single character of the buffer, unless the following token is a LaTeX command, in which case the entire command is tokenized.\n     */\n\n  }, {\n    key: \"nextCharToken\",\n    value: function nextCharToken() {\n      this.skipWhitespace();\n\n      if (this.buffer.charAt(0) === \"\\\\\") {\n        return this.next();\n      }\n\n      return this.next(1);\n    }\n  }, {\n    key: \"replaceCommands\",\n    value: function replaceCommands() {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.tokens[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var token = _step2.value;\n\n          if (token.type === _Token2.default.TYPE_COMMAND) {\n            token.value = token.value.substr(1).toLowerCase();\n            token.name = token.value; // Save name of function for debugging later\n\n            token.value = this.constants[token.name];\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"replaceConstants\",\n    value: function replaceConstants() {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.tokens[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var token = _step3.value;\n\n          if (token.type === _Token2.default.TYPE_SYMBOL) {\n            // Symbols will need to be looked up during the evaluation phase.\n            // If the symbol refers to things defined in either Math or\n            // the locals, compile them, to prevent slow lookups later.\n            if (typeof this.constants[token.value] === \"function\") {\n              token.type = _Token2.default.TYPE_FUNCTION;\n              token.name = token.value; // Save name of function for debugging later\n\n              token.value = this.constants[token.value];\n            } else if (typeof this.constants[token.value] === \"number\") {\n              token.type = _Token2.default.TYPE_NUMBER;\n              token.value = token.fn = this.constants[token.value];\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n    /**\n     * Removes whitespace from the beginning of the buffer.\n     */\n\n  }, {\n    key: \"skipWhitespace\",\n    value: function skipWhitespace() {\n      var regex = new RegExp(/^/.source + _Token2.default.patterns.get(_Token2.default.TYPE_WHITESPACE).source);\n      this.buffer = this.buffer.replace(regex, \"\");\n    }\n  }]);\n\n  return Lexer;\n}();\n\nfunction isCharArgToken(token) {\n  return CHAR_ARG_TOKENS.indexOf(token.type) !== -1;\n}\n\nfunction isStartGroupToken(token) {\n  return token.type === _Token2.default.TYPE_LPAREN && token.value === \"{\";\n}\n\nfunction isEndGroupToken(token) {\n  return token.type === _Token2.default.TYPE_RPAREN && token.value === \"}\";\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","default","lexer","_Token","require","_Token2","_interopRequireDefault","_arities","_arities2","_localFunctions","_localFunctions2","_replaceToken","_replaceToken2","obj","__esModule","_classCallCheck","instance","CHAR_ARG_TOKENS","TYPE_POWER","TYPE_COMMAND","DEFAULT_OPTS","latex","equation","constants","arguments","opts","l","Lexer","lex","tokens","toString","map","token","join","buffer","assign","lexExpression","replaceConstants","replaceCommands","charMode","hasNext","nextCharToken","isCharArgToken","arity","type","substr","toLowerCase","isStartGroupToken","isEndGroupToken","len","skipWhitespace","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","patterns","_step","_ref","_ref2","regex","regexFromStart","RegExp","source","match","exec","return","charAt","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","name","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","TYPE_SYMBOL","TYPE_FUNCTION","TYPE_NUMBER","fn","get","TYPE_WHITESPACE","replace","indexOf","TYPE_LPAREN","TYPE_RPAREN"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/evaluatex/dist/lexer.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.default = lexer;\n\nvar _Token = require(\"./Token\");\n\nvar _Token2 = _interopRequireDefault(_Token);\n\nvar _arities = require(\"./util/arities\");\n\nvar _arities2 = _interopRequireDefault(_arities);\n\nvar _localFunctions = require(\"./util/localFunctions\");\n\nvar _localFunctions2 = _interopRequireDefault(_localFunctions);\n\nvar _replaceToken = require(\"./util/replaceToken\");\n\nvar _replaceToken2 = _interopRequireDefault(_replaceToken);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Single-arg tokens are those that, when in LaTeX mode, read only one character as their argument OR a block delimited by { }. For example, `x ^ 24` would be read as `SYMBOL(x) POWER NUMBER(2) NUMBER(4).\nvar CHAR_ARG_TOKENS = [_Token2.default.TYPE_POWER, _Token2.default.TYPE_COMMAND];\n\nvar DEFAULT_OPTS = {\n    latex: false\n};\n\n/**\n * The lexer reads a math expression and breaks it down into easily-digestible Tokens.\n * A list of valid tokens can be found lower in this file.\n * @param equation (String) The equation to lex.\n * @param constants (Object) An object of functions and variables.\n * @param opts Options.\n * @returns {Array} An array of Tokens.\n */\nfunction lexer(equation) {\n    var constants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTS;\n\n    var l = new Lexer(equation, constants, opts);\n    l.lex();\n\n    // toString() each token and concatenate into a big string. Useful for debugging.\n    l.tokens.toString = function () {\n        return l.tokens.map(function (token) {\n            return token.toString();\n        }).join(\" \");\n    };\n\n    return l.tokens;\n}\n\nvar Lexer = function () {\n    function Lexer(buffer, constants, opts) {\n        _classCallCheck(this, Lexer);\n\n        this.buffer = buffer;\n        this.constants = Object.assign({}, constants, _localFunctions2.default);\n        this.opts = opts;\n        this.tokens = [];\n    }\n\n    _createClass(Lexer, [{\n        key: \"lex\",\n        value: function lex() {\n            this.lexExpression();\n            this.replaceConstants();\n            this.replaceCommands();\n        }\n\n        /**\n         * Lexes an expression or sub-expression.\n         */\n\n    }, {\n        key: \"lexExpression\",\n        value: function lexExpression() {\n            var charMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            while (this.hasNext()) {\n                var token = charMode ? this.nextCharToken() : this.next();\n                this.tokens.push((0, _replaceToken2.default)(token));\n\n                if (this.opts.latex && isCharArgToken(token)) {\n                    var arity = 1;\n                    if (token.type === _Token2.default.TYPE_COMMAND) {\n                        arity = _arities2.default[token.value.substr(1).toLowerCase()];\n                    }\n                    for (var i = 0; i < arity; i++) {\n                        this.lexExpression(true);\n                    }\n                } else if (isStartGroupToken(token)) {\n                    this.lexExpression(false);\n                }\n\n                if (charMode || isEndGroupToken(token)) {\n                    return;\n                }\n            }\n        }\n    }, {\n        key: \"hasNext\",\n        value: function hasNext() {\n            return this.buffer.length > 0;\n        }\n\n        /**\n         * Retrieves the next non-whitespace token from the buffer.\n         * @param len\n         * @returns {Token}\n         */\n\n    }, {\n        key: \"next\",\n        value: function next() {\n            var len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n            this.skipWhitespace();\n\n            if (!this.hasNext()) {\n                throw \"Lexer error: reached end of stream\";\n            }\n\n            // Try to match each pattern in tokenPatterns to the remaining buffer\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = _Token2.default.patterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var _ref = _step.value;\n\n                    var _ref2 = _slicedToArray(_ref, 2);\n\n                    var type = _ref2[0];\n                    var regex = _ref2[1];\n\n                    // Force the regex to match only at the beginning of the string\n                    var regexFromStart = new RegExp(/^/.source + regex.source);\n\n                    // When `len` is undefined, substr reads to the end\n                    var match = regexFromStart.exec(this.buffer.substr(0, len));\n                    if (match) {\n                        this.buffer = this.buffer.substr(match[0].length);\n                        return new _Token2.default(type, match[0]);\n                    }\n                }\n\n                // TODO: Meaningful error\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            throw \"Lexer error: can't match any token\";\n        }\n\n        /**\n         * Tokenizes the next single character of the buffer, unless the following token is a LaTeX command, in which case the entire command is tokenized.\n         */\n\n    }, {\n        key: \"nextCharToken\",\n        value: function nextCharToken() {\n            this.skipWhitespace();\n            if (this.buffer.charAt(0) === \"\\\\\") {\n                return this.next();\n            }\n            return this.next(1);\n        }\n    }, {\n        key: \"replaceCommands\",\n        value: function replaceCommands() {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.tokens[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var token = _step2.value;\n\n                    if (token.type === _Token2.default.TYPE_COMMAND) {\n                        token.value = token.value.substr(1).toLowerCase();\n                        token.name = token.value; // Save name of function for debugging later\n                        token.value = this.constants[token.name];\n                    }\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"replaceConstants\",\n        value: function replaceConstants() {\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = this.tokens[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var token = _step3.value;\n\n                    if (token.type === _Token2.default.TYPE_SYMBOL) {\n                        // Symbols will need to be looked up during the evaluation phase.\n                        // If the symbol refers to things defined in either Math or\n                        // the locals, compile them, to prevent slow lookups later.\n                        if (typeof this.constants[token.value] === \"function\") {\n                            token.type = _Token2.default.TYPE_FUNCTION;\n                            token.name = token.value; // Save name of function for debugging later\n                            token.value = this.constants[token.value];\n                        } else if (typeof this.constants[token.value] === \"number\") {\n                            token.type = _Token2.default.TYPE_NUMBER;\n                            token.value = token.fn = this.constants[token.value];\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Removes whitespace from the beginning of the buffer.\n         */\n\n    }, {\n        key: \"skipWhitespace\",\n        value: function skipWhitespace() {\n            var regex = new RegExp(/^/.source + _Token2.default.patterns.get(_Token2.default.TYPE_WHITESPACE).source);\n            this.buffer = this.buffer.replace(regex, \"\");\n        }\n    }]);\n\n    return Lexer;\n}();\n\nfunction isCharArgToken(token) {\n    return CHAR_ARG_TOKENS.indexOf(token.type) !== -1;\n}\n\nfunction isStartGroupToken(token) {\n    return token.type === _Token2.default.TYPE_LPAREN && token.value === \"{\";\n}\n\nfunction isEndGroupToken(token) {\n    return token.type === _Token2.default.TYPE_RPAREN && token.value === \"}\";\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}