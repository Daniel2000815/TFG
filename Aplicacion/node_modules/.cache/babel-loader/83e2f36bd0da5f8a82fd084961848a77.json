{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Expression = void 0;\n\nvar Settings_1 = require(\"../Settings\");\n\nvar Build_1 = require(\"./Build\");\n\nvar Text_1 = require(\"../Core/Text\");\n\nvar LaTeX_1 = require(\"../LaTeX/LaTeX\");\n\nvar Utils_1 = require(\"../Core/Utils\");\n\nvar Core_1 = require(\"../Functions/Core\");\n\nvar expand_1 = require(\"../Functions/Core/math/expand\");\n\nvar Parser_1 = require(\"./Parser\");\n/**\n * This is what nerdamer returns. It's sort of a wrapper around the symbol class and\n * provides the user with some useful functions. If you want to provide the user with extra\n * library functions then add them to this class's prototype.\n * @param {Symbol} symbol\n */\n\n\nvar Expression = /*#__PURE__*/function () {\n  function Expression(symbol) {\n    _classCallCheck(this, Expression);\n\n    //we don't want arrays wrapped\n    this.symbol = symbol;\n  }\n  /**\n   * Returns stored expression at index. For first index use 1 not 0.\n   * @param {number | string} expression_number\n   * @param {boolean} asType\n   */\n\n\n  _createClass(Expression, [{\n    key: \"text\",\n    value:\n    /**\n     * Returns the text representation of the expression\n     * @param {String} opt - option of formatting numbers\n     * @param {Number} n The number of significant figures\n     * @returns {String}\n     */\n    function text() {\n      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'decimals';\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      n = n || 19;\n      opt = opt || 'decimals';\n      if (this.symbol.text_) return this.symbol.text_(opt);\n      return (0, Text_1.text)(this.symbol, opt, undefined, n);\n    }\n    /**\n     * Returns the latex representation of the expression\n     * @param {String} option - option for formatting numbers\n     * @returns {String}\n     */\n\n  }, {\n    key: \"latex\",\n    value: function latex(option) {\n      if (this.symbol.latex) return this.symbol.latex(option);\n      return LaTeX_1.LaTeX.latex(this.symbol, option);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.symbol.valueOf();\n    }\n    /**\n     * Evaluates the expression and tries to reduce it to a number if possible.\n     * If an argument is given in the form of %{integer} it will evaluate that expression.\n     * Other than that it will just use it's own text and reparse\n     * @returns {Expression}\n     */\n\n  }, {\n    key: \"evaluate\",\n    value: function evaluate() {\n      // Don't evaluate an empty vector\n      if ((0, Utils_1.isVector)(this.symbol) && this.symbol.dimensions() === 0) {\n        return this;\n      }\n\n      var first_arg = arguments[0],\n          expression,\n          idx = 1; //Enable getting of expressions using the % so for example %1 should get the first expression\n\n      if (typeof first_arg === 'string') {\n        expression = first_arg.charAt(0) === '%' ? Expression.getExpression(first_arg.substr(1)).text() : first_arg;\n      } else if (first_arg instanceof Expression || (0, Utils_1.isSymbol)(first_arg)) {\n        expression = first_arg.text();\n      } else {\n        expression = this.symbol.text();\n        idx--;\n      }\n\n      var subs = arguments[idx] || {};\n      return new Expression((0, Utils_1.block)('PARSE2NUMBER', function () {\n        return (0, Parser_1.parse)(expression, subs);\n      }, true, this));\n    }\n    /**\n     * Converts a symbol to a JS function. Pass in an array of variables to use that order instead of\n     * the default alphabetical order\n     * @param vars {Array}\n     */\n\n  }, {\n    key: \"buildFunction\",\n    value: function buildFunction(vars) {\n      return Build_1.Build.build(this.symbol, vars);\n    }\n    /**\n     * Checks to see if the expression is just a plain old number\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isNumber\",\n    value: function isNumber() {\n      return (0, Utils_1.isNumericSymbol)(this.symbol);\n    }\n    /**\n     * Checks to see if the expression is infinity\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isInfinity\",\n    value: function isInfinity() {\n      return Math.abs(this.symbol.multiplier) === Infinity;\n    }\n    /**\n     * Checks to see if the expression contains imaginary numbers\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isImaginary\",\n    value: function isImaginary() {\n      return (0, Parser_1.evaluate)((0, Parser_1.parse)(this.symbol)).isImaginary();\n    }\n    /**\n     * Returns all the variables in the expression\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"variables\",\n    value: function variables() {\n      if (!(0, Utils_1.isSymbol)(this.symbol)) {\n        return [];\n      }\n\n      return this.symbol.variables();\n    }\n    /**\n     *\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      try {\n        if (Array.isArray(this.symbol)) return '[' + this.symbol.toString() + ']';\n        return this.symbol.toString();\n      } catch (e) {\n        return '';\n      }\n    } //forces the symbol to be returned as a decimal\n\n  }, {\n    key: \"toDecimal\",\n    value: function toDecimal(prec) {\n      Settings_1.Settings.precision = prec;\n      var dec = (0, Text_1.text)(this.symbol, 'decimals');\n      Settings_1.Settings.precision = undefined;\n      return dec;\n    } //checks to see if the expression is a fraction\n\n  }, {\n    key: \"isFraction\",\n    value: function isFraction() {\n      return (0, Utils_1.isFraction)(this.symbol);\n    } //checks to see if the symbol is a multivariate polynomial\n\n  }, {\n    key: \"isPolynomial\",\n    value: function isPolynomial() {\n      return this.symbol.isPoly();\n    } //performs a substitution\n\n  }, {\n    key: \"sub\",\n    value: function sub(symbol, for_symbol) {\n      return new Expression(this.symbol.sub((0, Parser_1.parse)(symbol), (0, Parser_1.parse)(for_symbol)));\n    }\n  }, {\n    key: \"operation\",\n    value: function operation(otype, symbol) {\n      if (isExpression(symbol)) {\n        symbol = symbol.symbol;\n      } else if (!(0, Utils_1.isSymbol)(symbol)) {\n        symbol = (0, Parser_1.parse)(symbol);\n      }\n\n      return new Expression(Parser_1.ParseDeps.parser.getAction(otype)(this.symbol.clone(), symbol.clone()));\n    }\n  }, {\n    key: \"add\",\n    value: function add(symbol) {\n      return this.operation('add', symbol);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(symbol) {\n      return this.operation('subtract', symbol);\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(symbol) {\n      return this.operation('multiply', symbol);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(symbol) {\n      return this.operation('divide', symbol);\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(symbol) {\n      return this.operation('pow', symbol);\n    }\n  }, {\n    key: \"expand\",\n    value: function expand() {\n      return new Expression((0, expand_1.expand)(this.symbol));\n    }\n  }, {\n    key: \"each\",\n    value: function each(callback, i) {\n      if (this.symbol.each) this.symbol.each(callback, i);else if (Array.isArray(this.symbol)) {\n        for (var _i = 0; _i < this.symbol.length; _i++) {\n          callback.call(this.symbol, this.symbol[_i], _i);\n        }\n      } else callback.call(this.symbol);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(value) {\n      if (!(0, Utils_1.isSymbol)(value)) value = (0, Parser_1.parse)(value);\n\n      try {\n        var d = (0, Core_1.subtract)(this.symbol.clone(), value);\n        return d.equals(0);\n      } catch (e) {\n        return false;\n      }\n    }\n  }, {\n    key: \"lt\",\n    value: function lt(value) {\n      if (!(0, Utils_1.isSymbol)(value)) value = (0, Parser_1.parse)(value);\n\n      try {\n        var d = (0, Parser_1.evaluate)((0, Core_1.subtract)(this.symbol.clone(), value));\n        return d.lessThan(0);\n      } catch (e) {\n        return false;\n      }\n    }\n  }, {\n    key: \"gt\",\n    value: function gt(value) {\n      if (!(0, Utils_1.isSymbol)(value)) value = (0, Parser_1.parse)(value);\n\n      try {\n        var d = (0, Parser_1.evaluate)((0, Core_1.subtract)(this.symbol.clone(), value));\n        return d.greaterThan(0);\n      } catch (e) {\n        return false;\n      }\n    }\n  }, {\n    key: \"gte\",\n    value: function gte(value) {\n      return this.gt(value) || this.eq(value);\n    }\n  }, {\n    key: \"lte\",\n    value: function lte(value) {\n      return this.lt(value) || this.eq(value);\n    }\n  }, {\n    key: \"numerator\",\n    value: function numerator() {\n      return new Expression(this.symbol.getNum());\n    }\n  }, {\n    key: \"denominator\",\n    value: function denominator() {\n      return new Expression(this.symbol.getDenom());\n    }\n  }, {\n    key: \"hasFunction\",\n    value: function hasFunction(f) {\n      return this.symbol.containsFunction(f);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(variable) {\n      return this.symbol.contains(variable);\n    }\n  }, {\n    key: \"toTeX\",\n    value: function toTeX(option) {\n      return this.latex(option);\n    }\n  }], [{\n    key: \"getExpression\",\n    value: function getExpression(expression_number) {\n      var asType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (expression_number === 'last' || !expression_number) expression_number = Expression.$EXPRESSIONS.length;\n      if (expression_number === 'first') expression_number = 1;\n      var index = expression_number - 1,\n          expression = Expression.$EXPRESSIONS[index];\n      return expression ? new Expression(expression) : expression;\n    }\n  }]);\n\n  return Expression;\n}();\n\nexports.Expression = Expression;","map":{"version":3,"mappings":"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","names":["Expression","symbol","opt","n","text_","undefined","option","latex","LaTeX_1","valueOf","dimensions","first_arg","arguments","expression","idx","charAt","getExpression","substr","text","subs","vars","Build_1","build","Math","abs","multiplier","Infinity","isImaginary","variables","Array","isArray","toString","e","prec","Settings_1","precision","dec","isPoly","for_symbol","sub","otype","isExpression","Parser_1","parser","getAction","clone","operation","callback","i","each","length","call","value","d","equals","lessThan","greaterThan","gt","eq","lt","getNum","getDenom","f","containsFunction","variable","contains","expression_number","asType","$EXPRESSIONS","index","exports"],"sourceRoot":"","sources":["../../src/Parser/Expression.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}