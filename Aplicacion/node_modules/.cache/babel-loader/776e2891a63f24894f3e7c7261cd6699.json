{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RPN = void 0;\nvar Token_1 = require(\"./Token\");\nvar Settings_1 = require(\"../Settings\");\nvar Symbol_1 = require(\"../Types/Symbol\");\nvar Collection_1 = require(\"./Collection\");\nvar Slice_1 = require(\"./Slice\");\nvar Vector_1 = require(\"../Types/Vector\");\nvar Set_1 = require(\"../Types/Set\");\nvar Errors_1 = require(\"../Core/Errors\");\nvar Utils_1 = require(\"../Core/Utils\");\nvar Parser_1 = require(\"./Parser\");\nvar RPN = /*#__PURE__*/function () {\n  function RPN(deps, variables, peekers) {\n    _classCallCheck(this, RPN);\n    this.deps = deps;\n    this.peekers = peekers;\n    this.variables = variables;\n  }\n  /**\n   * Puts token array in Reverse Polish Notation\n   * @param {Token[] | Token} tokens\n   * @returns {Token[]}\n   */\n  _createClass(RPN, [{\n    key: \"parseRPN\",\n    value:\n    /*\n    * Parses the tokens\n    * @param {Tokens[]} rpn\n    * @param {object} substitutions\n    * @returns {Symbol}\n    */\n    function parseRPN(rpn) {\n      var substitutions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var deps = this.deps;\n      // try {\n      //prepare the substitutions.\n      substitutions = substitutions || {};\n      //we first parse them out as-is\n      for (var x in substitutions) {\n        substitutions[x] = (0, Parser_1.parse)(substitutions[x], {});\n      }\n      //Although technically constants,\n      //pi and e are only available when evaluating the expression so add to the subs.\n      //Doing this avoids rounding errors\n      //link e and pi\n      if (Settings_1.Settings.PARSE2NUMBER) {\n        //use the value provided if the individual for some strange reason prefers this.\n        //one reason could be to sub e but not pi or vice versa\n        if (!('e' in substitutions)) substitutions.e = new Symbol_1.Symbol(Settings_1.Settings.E);\n        if (!('pi' in substitutions)) substitutions.pi = new Symbol_1.Symbol(Settings_1.Settings.PI);\n      }\n      var Q = [];\n      for (var i = 0, l = rpn.length; i < l; i++) {\n        var e = rpn[i];\n        //Arrays indicate a new scope so parse that out\n        if (Array.isArray(e)) {\n          e = this.parseRPN(e, substitutions);\n        }\n        if (e) {\n          if (e.type === Token_1.Token.OPERATOR) {\n            if (e.is_prefix || e.postfix) {\n              //resolve the operation assocated with the prefix\n              Q.push(e.operation(Q.pop()));\n            } else {\n              var b = Q.pop();\n              var a = Q.pop();\n              //Throw an error if the RH value is empty. This cannot be a postfix since we already checked\n              if (typeof a === 'undefined') throw new Errors_1.OperatorError(e + ' is not a valid postfix operator at ' + e.column);\n              var is_comma = e.action === 'comma';\n              //convert Sets to Vectors on all operations at this point. Sets are only recognized functions or individually\n              if (a instanceof Set_1.Set && !is_comma) a = Vector_1.Vector.fromSet(a);\n              if (b instanceof Set_1.Set && !is_comma) b = Vector_1.Vector.fromSet(b);\n              //call all the pre-operators\n              this.callPeekers('pre_operator', a, b, e);\n              var action = deps.getAction(e.action);\n              var ans = action(a, b);\n              //call all the pre-operators\n              this.callPeekers('post_operator', ans, a, b, e);\n              Q.push(ans);\n            }\n          } else if (e.type === Token_1.Token.FUNCTION) {\n            var args = Q.pop();\n            var parent = args.parent; //make a note of the parent\n            if (!(args instanceof Collection_1.Collection)) args = Collection_1.Collection.create(args);\n            //the return value may be a vector. If it is then we check\n            //Q to see if there's another vector on the stack. If it is then\n            //we check if has elements. If it does then we know that we're dealing\n            //with an \"getter\" object and return the requested values\n            //call the function. This is the _.callfunction method in nerdamer\n            //call the function. This is the _.callfunction method in nerdamer\n            var fn_name = e.value;\n            var fn_args = args.getItems();\n            //call the pre-function peekers\n            this.callPeekers('pre_function', fn_name, fn_args);\n            var ret = deps.callfunction(fn_name, fn_args);\n            //call the post-function peekers\n            this.callPeekers('post_function', ret, fn_name, fn_args);\n            var last = Q[Q.length - 1];\n            var next = rpn[i + 1];\n            var next_is_comma = next && next.type === Token_1.Token.OPERATOR && next.value === ',';\n            if (!next_is_comma && ret instanceof Vector_1.Vector && last && last.elements && !(last instanceof Collection_1.Collection)) {\n              //remove the item from the queue\n              var item = Q.pop();\n              var getter = ret.elements[0];\n              //check if it's symbolic. If so put it back and add the item to the stack\n              if (!getter.isConstant()) {\n                item.getter = getter;\n                Q.push(item);\n                Q.push(ret);\n              } else if (getter instanceof Slice_1.Slice) {\n                //if it's a Slice return the slice\n                Q.push(Vector_1.Vector.fromArray(item.elements.slice(getter.start, getter.end)));\n              } else {\n                var index = Number(getter);\n                var il = item.elements.length;\n                //support for negative indices\n                if (index < 0) index = il + index;\n                //it it's still out of bounds\n                if (index < 0 || index >= il)\n                  //index should no longer be negative since it's been reset above\n                  //range error\n                  throw new Errors_1.OutOfRangeError('Index out of range ' + (e.column + 1));\n                var element = item.elements[index];\n                //cyclic but we need to mark this for future reference\n                item.getter = index;\n                element.parent = item;\n                Q.push(element);\n              }\n            } else {\n              //extend the parent reference\n              if (parent) ret.parent = parent;\n              Q.push(ret);\n            }\n          } else {\n            var subbed = void 0;\n            var v = e.value;\n            if (v in Settings_1.Settings.ALIASES) e = (0, Parser_1.parse)(Settings_1.Settings.ALIASES[e]);\n            //wrap it in a symbol if need be\n            else if (e.type === Token_1.Token.VARIABLE_OR_LITERAL) e = new Symbol_1.Symbol(v);else if (e.type === Token_1.Token.UNIT) {\n              e = new Symbol_1.Symbol(v);\n              e.isUnit = true;\n            }\n            //make substitutions\n            //Always constants first. This avoids the being overridden\n            if (this.variables.isConstant(v)) {\n              subbed = e;\n              e = new Symbol_1.Symbol(this.variables.getConstant(v));\n            }\n            //next substitutions. This allows declared variable to be overridden\n            //check if the values match to avoid erasing the multiplier.\n            //Example:/e = 3*a. substutiting a for a will wipe out the multiplier.\n            else if (v in substitutions && v !== substitutions[v].toString()) {\n              subbed = e;\n              e = substitutions[v].clone();\n            }\n            //next declare variables\n            else if (this.variables.isVar(v)) {\n              subbed = e;\n              e = this.variables.getVar(v).clone();\n            }\n            //make notation of what it was before\n            if (subbed) e.subbed = subbed;\n            Q.push(e);\n          }\n        }\n      }\n      var retval = Q[0];\n      if (['undefined', 'string', 'number'].indexOf(typeof retval) !== -1) {\n        throw new Errors_1.UnexpectedTokenError(\"Unexpected token: \".concat(typeof retval, \", \").concat(retval));\n      }\n      return retval;\n      // }\n      // catch(error) {\n      //     throw error;\n      //     // let rethrowErrors = [OutOfFunctionDomainError];\n      //     // // Rethrow certain errors in the same class to preserve them\n      //     // rethrowErrors.forEach(function (E) {\n      //     //     if (error instanceof E) {\n      //     //         throw new E(error.message + ': ' + e.column);\n      //     //     }\n      //     // });\n      //     //\n      //     // throw new ParseError(error.message + ': ' + e.column);\n      // }\n    }\n  }, {\n    key: \"callPeekers\",\n    value: function callPeekers(name) {\n      if (Settings_1.Settings.callPeekers) {\n        var peekers = this.peekers[name];\n        //remove the first items and stringify\n        var args = (0, Utils_1.arguments2Array)(arguments).slice(1).map(function (o) {\n          return o ? String(o) : o;\n        });\n        //call each one of the peekers\n        for (var i = 0; i < peekers.length; i++) {\n          peekers[i].apply(null, args);\n        }\n      }\n    }\n  }], [{\n    key: \"TokensToRPN\",\n    value: function TokensToRPN(tokens) {\n      var fn = tokens.type;\n      var l = tokens.length;\n      var output = [];\n      var stack = [];\n      var prefixes = [];\n      var collapse = function collapse(target, destination) {\n        while (target.length) {\n          destination.push(target.pop());\n        }\n      };\n      var i;\n      //mark all the prefixes and add them to the stack\n      for (i = 0; i < l; i++) {\n        var token = tokens[i];\n        if (token.type !== Token_1.Token.OPERATOR) break;\n        if (!token.prefix) throw new Errors_1.OperatorError('Not a prefix operator');\n        token.is_prefix = true;\n        stack.push(token);\n      }\n      //begin with remaining tokens\n      for (; i < l; i++) {\n        var e = tokens[i];\n        if (e.type === Token_1.Token.OPERATOR) {\n          var operator = e;\n          //create the option for the operator being overloaded\n          if (operator.overloaded) {\n            var next = tokens[i + 1];\n            //if it's followed by a number or variable then we assume it's not a postfix operator\n            if (next && next.type === Token_1.Token.VARIABLE_OR_LITERAL) {\n              operator.postfix = false;\n              //override the original function with the overload function\n              operator.action = operator.overloadAction;\n              operator.leftAssoc = operator.overloadLeftAssoc;\n            }\n          }\n          //if the stack is not empty\n          while (stack.length) {\n            var last = stack[stack.length - 1];\n            //if (there is an operator at the top of the operator stack with greater precedence)\n            //or (the operator at the top of the operator stack has equal precedence and is left associative)) ~ wikipedia\n            //the !prefixes.length makes sure that the operator on stack isn't prematurely taken from the stack.\n            if (!(last.precedence > operator.precedence || !operator.leftAssoc && last.precedence === operator.precedence)) break;\n            output.push(stack.pop());\n          }\n          //change the behavior of the operator if it's a vector and we've been asked to do so\n          if ((fn === 'vector' || fn === 'set') && 'vectorFn' in operator) operator.action = operator.vectorFn;\n          //if the operator is a postfix operator then we're ready to go since it belongs\n          //to the preceding token. However the output cannot be empty. It must have either\n          //an operator or a variable/literal\n          if (operator.postfix) {\n            var previous = tokens[i - 1];\n            if (!previous) throw new Errors_1.OperatorError(\"Unexpected prefix operator '\" + e.value + \"'! at \" + e.column);else if (previous.type === Token_1.Token.OPERATOR) {\n              //a postfix can only be followed by a postfix\n              if (!previous.postfix) throw new Errors_1.OperatorError(\"Unexpected prefix operator '\" + previous.value + \"'! at \" + previous.column);\n            }\n          } else {\n            var next_is_operator = void 0;\n            //we must be at an infix so point the operator this\n            do {\n              //the first one is an infix operator all others have to be prefix operators so jump to the end\n              var _next = tokens[i + 1]; //take a look ahead\n              next_is_operator = _next ? _next.type === Token_1.Token.OPERATOR : false; //check if it's an operator\n              if (next_is_operator) {\n                //if it's not a prefix operator then it not in the right place\n                if (!_next.prefix) {\n                  throw new Errors_1.OperatorError('A prefix operator was expected at ' + _next.column);\n                }\n                //mark it as a confirmed prefix\n                _next.is_prefix = true;\n                //add it to the prefixes\n                prefixes.push(_next);\n                i++;\n              }\n            } while (next_is_operator);\n          }\n          //if it's a prefix it should be on a special stack called prefixes\n          //we do this to hold on to prefixes because of left associative operators.\n          //they belong to the variable/literal but if placed on either the stack\n          //or output there's no way of knowing this. I might be wrong so I welcome\n          //any discussion about this.\n          if (operator.is_prefix)\n            //ADD ALL EXCEPTIONS FOR ADDING TO PREFIX STACK HERE. !!!\n            prefixes.push(operator);else stack.push(operator);\n          //move the prefixes to the stack\n          while (prefixes.length) {\n            if (operator.leftAssoc || !operator.leftAssoc && prefixes[prefixes.length - 1].precedence >= operator.precedence)\n              //revisit for commas\n              stack.push(prefixes.pop());else break;\n          }\n        } else if (e.type === Token_1.Token.VARIABLE_OR_LITERAL) {\n          //move prefixes to stack at beginning of scope\n          if (output.length === 0) collapse(prefixes, stack);\n          //done with token\n          output.push(e);\n          var last_on_stack = stack[stack.length - 1];\n          //then move all the prefixes to the output\n          if (!last_on_stack || !last_on_stack.leftAssoc) collapse(prefixes, output);\n        } else if (e.type === Token_1.Token.FUNCTION) {\n          stack.push(e);\n        } else if (e.type === Token_1.Token.UNIT) {\n          //if it's a unit it belongs on the stack since it's tied to the previous token\n          output.push(e);\n        }\n        //if it's an additional scope then put that into RPN form\n        if (Array.isArray(e)) {\n          output.push(RPN.TokensToRPN(e));\n          if (e.type) output.push(new Token_1.Token(e.type, Token_1.Token.FUNCTION, e.column)); //since it's hidden it needs no column\n        }\n      }\n      //collapse the remainder of the stack and prefixes to output\n      collapse(stack, output);\n      collapse(prefixes, output);\n      return output;\n    }\n  }]);\n  return RPN;\n}();\nexports.RPN = RPN;","map":{"version":3,"mappings":"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","names":["RPN","deps","variables","peekers","rpn","substitutions","x","Settings_1","PARSE2NUMBER","e","Symbol_1","E","pi","PI","Q","i","l","length","Array","isArray","parseRPN","type","Token_1","OPERATOR","is_prefix","postfix","push","operation","pop","b","a","Errors_1","column","is_comma","action","Set_1","Vector_1","fromSet","callPeekers","getAction","ans","FUNCTION","args","parent","Collection_1","create","fn_name","value","fn_args","getItems","ret","callfunction","last","next","next_is_comma","elements","item","getter","isConstant","Slice_1","fromArray","slice","start","end","index","Number","il","element","subbed","v","ALIASES","VARIABLE_OR_LITERAL","UNIT","isUnit","getConstant","toString","clone","isVar","getVar","retval","indexOf","name","arguments","map","o","String","apply","tokens","fn","output","stack","prefixes","collapse","target","destination","token","prefix","operator","overloaded","overloadAction","leftAssoc","overloadLeftAssoc","precedence","vectorFn","previous","next_is_operator","last_on_stack","TokensToRPN","exports"],"sourceRoot":"","sources":["../../src/Parser/RPN.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}