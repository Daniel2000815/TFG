{"ast":null,"code":"export var defaultShader = function defaultShader() {\n  return \"\\n// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\\n// I am the sole copyright owner of this Work.\\n// You cannot host, display, distribute or share this Work in any form,\\n// including physical and digital. You cannot use this Work in any\\n// commercial or non-commercial product, website or project. You cannot\\n// sell this Work and you cannot mint an NFTs of it.\\n// I share this Work for educational purposes, and you can link to it,\\n// through an URL, proper attribution and unmodified screenshot, as part\\n// of your educational material. If these conditions are too restrictive\\n// please contact me and we'll definitely work it out.\\n\\n// A list of useful distance function to simple primitives. All\\n// these functions (except for ellipsoid) return an exact\\n// euclidean distance, meaning they produce a better SDF than\\n// what you'd get if you were constructing them from boolean\\n// operations (such as cutting an infinite cylinder with two planes).\\n\\n// List of other 3D SDFs:\\n//    https://www.shadertoy.com/playlist/43cXRl\\n// and\\n//    https://iquilezles.org/articles/distfunctions\\n\\n#if HW_PERFORMANCE==0\\n#define AA 1\\n#else\\n#define AA 2   // make this 2 or 3 for antialiasing\\n#endif\\n\\n//------------------------------------------------------------------\\nfloat dot2( in vec2 v ) { return dot(v,v); }\\nfloat dot2( in vec3 v ) { return dot(v,v); }\\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\\n\\nfloat sdPlane( vec3 p )\\n{\\n\\treturn p.y;\\n}\\n\\nfloat sdSphere( vec3 p, float s )\\n{\\n    return length(p)-s;\\n}\\n\\n\\nfloat sdU( in vec3 p, in float r, in float le, vec2 w )\\n{\\n    p.x = (p.y>0.0) ? abs(p.x) : length(p.xy);\\n    p.x = abs(p.x-r);\\n    p.y = p.y - le;\\n    float k = max(p.x,p.y);\\n    vec2 q = vec2( (k<0.0) ? -k : length(max(p.xy,0.0)), abs(p.z) ) - w;\\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\\n}\\n\\n//------------------------------------------------------------------\\n\\nvec2 opU( vec2 d1, vec2 d2 )\\n{\\n\\treturn (d1.x<d2.x) ? d1 : d2;\\n}\\n\\n//------------------------------------------------------------------\\n\\n#define ZERO (min(iFrame,0))\\n\\n//------------------------------------------------------------------\\n\\nvec2 map( in vec3 pos )\\n{\\n    vec2 res = vec2( 1e10, 0.0 );\\n\\n    {\\n      res = opU( res, vec2( sdSphere(pos-vec3(0.0,0.25, 0.0), 0.25 ), 26.9 ) );\\n    }\\n    \\n    return res;\\n}\\n\\n// https://iquilezles.org/articles/boxfunctions\\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \\n{\\n    vec3 m = 1.0/rd;\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*rad;\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\\n\\t             min( min( t2.x, t2.y ), t2.z ) );\\n}\\n\\nvec2 raycast( in vec3 ro, in vec3 rd )\\n{\\n    vec2 res = vec2(-1.0,-1.0);\\n\\n    float tmin = 1.0;\\n    float tmax = 20.0;\\n\\n    // raytrace floor plane\\n    float tp1 = (0.0-ro.y)/rd.y;\\n    if( tp1>0.0 )\\n    {\\n        tmax = min( tmax, tp1 );\\n        res = vec2( tp1, 1.0 );\\n    }\\n    //else return res;\\n    \\n    // raymarch primitives   \\n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\\n    {\\n        //return vec2(tb.x,2.0);\\n        tmin = max(tb.x,tmin);\\n        tmax = min(tb.y,tmax);\\n\\n        float t = tmin;\\n        for( int i=0; i<70 && t<tmax; i++ )\\n        {\\n            vec2 h = map( ro+rd*t );\\n            if( abs(h.x)<(0.0001*t) )\\n            { \\n                res = vec2(t,h.y); \\n                break;\\n            }\\n            t += h.x;\\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n// https://iquilezles.org/articles/rmshadows\\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\\n{\\n    // bounding volume\\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\\n\\n    float res = 1.0;\\n    float t = mint;\\n    for( int i=ZERO; i<24; i++ )\\n    {\\n\\t\\tfloat h = map( ro + rd*t ).x;\\n        float s = clamp(8.0*h/t,0.0,1.0);\\n        res = min( res, s*s*(3.0-2.0*s) );\\n        t += clamp( h, 0.02, 0.2 );\\n        if( res<0.004 || t>tmax ) break;\\n    }\\n    return clamp( res, 0.0, 1.0 );\\n}\\n\\n// https://iquilezles.org/articles/normalsSDF\\nvec3 calcNormal( in vec3 pos )\\n{\\n#if 0\\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\\n    return normalize( e.xyy*map( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map( pos + e.xxx ).x );\\n#else\\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\\n    vec3 n = vec3(0.0);\\n    for( int i=ZERO; i<4; i++ )\\n    {\\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\\n        n += e*map(pos+0.0005*e).x;\\n      //if( n.x+n.y+n.z>100.0 ) break;\\n    }\\n    return normalize(n);\\n#endif    \\n}\\n\\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\\nfloat calcAO( in vec3 pos, in vec3 nor )\\n{\\n\\tfloat occ = 0.0;\\n    float sca = 1.0;\\n    for( int i=ZERO; i<5; i++ )\\n    {\\n        float h = 0.01 + 0.12*float(i)/4.0;\\n        float d = map( pos + h*nor ).x;\\n        occ += (h-d)*sca;\\n        sca *= 0.95;\\n        if( occ>0.35 ) break;\\n    }\\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\\n}\\n\\n// https://iquilezles.org/articles/checkerfiltering\\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\\n{\\n    // filter kernel\\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\\n    // analytical integral (box filter)\\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\\n    // xor pattern\\n    return 0.5 - 0.5*i.x*i.y;                  \\n}\\n\\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\\n{ \\n    // background\\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\\n    \\n    // raycast scene\\n    vec2 res = raycast(ro,rd);\\n    float t = res.x;\\n\\tfloat m = res.y;\\n    if( m>-0.5 )\\n    {\\n        vec3 pos = ro + t*rd;\\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\\n        vec3 ref = reflect( rd, nor );\\n        \\n        // material        \\n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\\n        float ks = 1.0;\\n        \\n        if( m<1.5 )\\n        {\\n            // project pixel footprint into the plane\\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\\n\\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\\n            col = 0.15 + f*vec3(0.05);\\n            ks = 0.4;\\n        }\\n\\n        // lighting\\n        float occ = calcAO( pos, nor );\\n        \\n\\t\\tvec3 lin = vec3(0.0);\\n\\n        // sun\\n        {\\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\\n            vec3  hal = normalize( lig-rd );\\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\\n          //if( dif>0.0001 )\\n        \\t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\\n\\t\\t\\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\\n                  spe *= dif;\\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\\n        }\\n        // sky\\n        {\\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\\n                  dif *= occ;\\n            float spe = smoothstep( -0.2, 0.2, ref.y );\\n                  spe *= dif;\\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\\n          //if( spe>0.001 )\\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\\n        }\\n        // back\\n        {\\n        \\tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\\n                  dif *= occ;\\n        \\tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\\n        }\\n        // sss\\n        {\\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\\n                  dif *= occ;\\n        \\tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\\n        }\\n        \\n\\t\\tcol = lin;\\n\\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\\n    }\\n\\n\\treturn vec3( clamp(col,0.0,1.0) );\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\\n{\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv =          ( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    vec2 mo = iMouse.xy/iResolution.xy;\\n\\tfloat time = 32.0 + iTime*1.5;\\n\\n    // camera\\t\\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\\n    // camera-to-world transformation\\n    mat3 ca = setCamera( ro, ta, 0.0 );\\n\\n    vec3 tot = vec3(0.0);\\n#if AA>1\\n    for( int m=ZERO; m<AA; m++ )\\n    for( int n=ZERO; n<AA; n++ )\\n    {\\n        // pixel coordinates\\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\\n#else    \\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\\n#endif\\n\\n        // focal length\\n        const float fl = 2.5;\\n        \\n        // ray direction\\n        vec3 rd = ca * normalize( vec3(p,fl) );\\n\\n         // ray differentials\\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\\n        vec3 rdx = ca * normalize( vec3(px,fl) );\\n        vec3 rdy = ca * normalize( vec3(py,fl) );\\n        \\n        // render\\t\\n        vec3 col = render( ro, rd, rdx, rdy );\\n\\n        // gain\\n        // col = col*3.0/(2.5+col);\\n        \\n\\t\\t// gamma\\n        col = pow( col, vec3(0.4545) );\\n\\n        tot += col;\\n#if AA>1\\n    }\\n    tot /= float(AA*AA);\\n#endif\\n    \\n    fragColor = vec4( tot, 1.0 );\\n}\\n\";\n};","map":{"version":3,"names":["defaultShader"],"sources":["C:/Users/daniz/TFG/Aplicacion/src/defaultShader.js"],"sourcesContent":["export const defaultShader = () => `\r\n// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\r\n// I am the sole copyright owner of this Work.\r\n// You cannot host, display, distribute or share this Work in any form,\r\n// including physical and digital. You cannot use this Work in any\r\n// commercial or non-commercial product, website or project. You cannot\r\n// sell this Work and you cannot mint an NFTs of it.\r\n// I share this Work for educational purposes, and you can link to it,\r\n// through an URL, proper attribution and unmodified screenshot, as part\r\n// of your educational material. If these conditions are too restrictive\r\n// please contact me and we'll definitely work it out.\r\n\r\n// A list of useful distance function to simple primitives. All\r\n// these functions (except for ellipsoid) return an exact\r\n// euclidean distance, meaning they produce a better SDF than\r\n// what you'd get if you were constructing them from boolean\r\n// operations (such as cutting an infinite cylinder with two planes).\r\n\r\n// List of other 3D SDFs:\r\n//    https://www.shadertoy.com/playlist/43cXRl\r\n// and\r\n//    https://iquilezles.org/articles/distfunctions\r\n\r\n#if HW_PERFORMANCE==0\r\n#define AA 1\r\n#else\r\n#define AA 2   // make this 2 or 3 for antialiasing\r\n#endif\r\n\r\n//------------------------------------------------------------------\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\nfloat dot2( in vec3 v ) { return dot(v,v); }\r\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\n\r\nfloat sdU( in vec3 p, in float r, in float le, vec2 w )\r\n{\r\n    p.x = (p.y>0.0) ? abs(p.x) : length(p.xy);\r\n    p.x = abs(p.x-r);\r\n    p.y = p.y - le;\r\n    float k = max(p.x,p.y);\r\n    vec2 q = vec2( (k<0.0) ? -k : length(max(p.xy,0.0)), abs(p.z) ) - w;\r\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nvec2 opU( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n//------------------------------------------------------------------\r\n\r\nvec2 map( in vec3 pos )\r\n{\r\n    vec2 res = vec2( 1e10, 0.0 );\r\n\r\n    {\r\n      res = opU( res, vec2( sdSphere(pos-vec3(0.0,0.25, 0.0), 0.25 ), 26.9 ) );\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n// https://iquilezles.org/articles/boxfunctions\r\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \r\n{\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\r\n\t             min( min( t2.x, t2.y ), t2.z ) );\r\n}\r\n\r\nvec2 raycast( in vec3 ro, in vec3 rd )\r\n{\r\n    vec2 res = vec2(-1.0,-1.0);\r\n\r\n    float tmin = 1.0;\r\n    float tmax = 20.0;\r\n\r\n    // raytrace floor plane\r\n    float tp1 = (0.0-ro.y)/rd.y;\r\n    if( tp1>0.0 )\r\n    {\r\n        tmax = min( tmax, tp1 );\r\n        res = vec2( tp1, 1.0 );\r\n    }\r\n    //else return res;\r\n    \r\n    // raymarch primitives   \r\n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\r\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\r\n    {\r\n        //return vec2(tb.x,2.0);\r\n        tmin = max(tb.x,tmin);\r\n        tmax = min(tb.y,tmax);\r\n\r\n        float t = tmin;\r\n        for( int i=0; i<70 && t<tmax; i++ )\r\n        {\r\n            vec2 h = map( ro+rd*t );\r\n            if( abs(h.x)<(0.0001*t) )\r\n            { \r\n                res = vec2(t,h.y); \r\n                break;\r\n            }\r\n            t += h.x;\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n// https://iquilezles.org/articles/rmshadows\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\r\n{\r\n    // bounding volume\r\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\r\n\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for( int i=ZERO; i<24; i++ )\r\n    {\r\n\t\tfloat h = map( ro + rd*t ).x;\r\n        float s = clamp(8.0*h/t,0.0,1.0);\r\n        res = min( res, s*s*(3.0-2.0*s) );\r\n        t += clamp( h, 0.02, 0.2 );\r\n        if( res<0.004 || t>tmax ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\n// https://iquilezles.org/articles/normalsSDF\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*map( pos + e.xyy ).x + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+0.0005*e).x;\r\n      //if( n.x+n.y+n.z>100.0 ) break;\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n\r\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=ZERO; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor ).x;\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.35 ) break;\r\n    }\r\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\r\n}\r\n\r\n// https://iquilezles.org/articles/checkerfiltering\r\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\r\n{\r\n    // filter kernel\r\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;                  \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\r\n{ \r\n    // background\r\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\r\n    \r\n    // raycast scene\r\n    vec2 res = raycast(ro,rd);\r\n    float t = res.x;\r\n\tfloat m = res.y;\r\n    if( m>-0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\r\n        vec3 ref = reflect( rd, nor );\r\n        \r\n        // material        \r\n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\r\n        float ks = 1.0;\r\n        \r\n        if( m<1.5 )\r\n        {\r\n            // project pixel footprint into the plane\r\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\r\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\r\n\r\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\r\n            col = 0.15 + f*vec3(0.05);\r\n            ks = 0.4;\r\n        }\r\n\r\n        // lighting\r\n        float occ = calcAO( pos, nor );\r\n        \r\n\t\tvec3 lin = vec3(0.0);\r\n\r\n        // sun\r\n        {\r\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\r\n            vec3  hal = normalize( lig-rd );\r\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\r\n          //if( dif>0.0001 )\r\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\r\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\r\n                  spe *= dif;\r\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\r\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\r\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\r\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\r\n        }\r\n        // sky\r\n        {\r\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\r\n                  dif *= occ;\r\n            float spe = smoothstep( -0.2, 0.2, ref.y );\r\n                  spe *= dif;\r\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\r\n          //if( spe>0.001 )\r\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\r\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\r\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\r\n        }\r\n        // back\r\n        {\r\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\r\n                  dif *= occ;\r\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\r\n        }\r\n        // sss\r\n        {\r\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\r\n                  dif *= occ;\r\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\r\n        }\r\n        \r\n\t\tcol = lin;\r\n\r\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\r\n    }\r\n\r\n\treturn vec3( clamp(col,0.0,1.0) );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv =          ( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 mo = iMouse.xy/iResolution.xy;\r\n\tfloat time = 32.0 + iTime*1.5;\r\n\r\n    // camera\t\r\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\r\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\r\n    // camera-to-world transformation\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n\r\n    vec3 tot = vec3(0.0);\r\n#if AA>1\r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\r\n#else    \r\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n#endif\r\n\r\n        // focal length\r\n        const float fl = 2.5;\r\n        \r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p,fl) );\r\n\r\n         // ray differentials\r\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\r\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\r\n        vec3 rdx = ca * normalize( vec3(px,fl) );\r\n        vec3 rdy = ca * normalize( vec3(py,fl) );\r\n        \r\n        // render\t\r\n        vec3 col = render( ro, rd, rdx, rdy );\r\n\r\n        // gain\r\n        // col = col*3.0/(2.5+col);\r\n        \r\n\t\t// gamma\r\n        col = pow( col, vec3(0.4545) );\r\n\r\n        tot += col;\r\n#if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n#endif\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}\r\n`;\r\n"],"mappings":"AAAA,OAAO,IAAMA,aAAa,GAAG,SAAhBA,aAAgB;EAAA;AAAA,CAAtB"},"metadata":{},"sourceType":"module"}