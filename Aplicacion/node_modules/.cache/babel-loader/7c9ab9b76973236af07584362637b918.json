{"ast":null,"code":"export var defaultShader = function defaultShader() {\n  return \"\\n// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\\n// I am the sole copyright owner of this Work.\\n// You cannot host, display, distribute or share this Work in any form,\\n// including physical and digital. You cannot use this Work in any\\n// commercial or non-commercial product, website or project. You cannot\\n// sell this Work and you cannot mint an NFTs of it.\\n// I share this Work for educational purposes, and you can link to it,\\n// through an URL, proper attribution and unmodified screenshot, as part\\n// of your educational material. If these conditions are too restrictive\\n// please contact me and we'll definitely work it out.\\n\\n// A list of useful distance function to simple primitives. All\\n// these functions (except for ellipsoid) return an exact\\n// euclidean distance, meaning they produce a better SDF than\\n// what you'd get if you were constructing them from boolean\\n// operations (such as cutting an infinite cylinder with two planes).\\n\\n// List of other 3D SDFs:\\n//    https://www.shadertoy.com/playlist/43cXRl\\n// and\\n//    https://iquilezles.org/articles/distfunctions\\n\\n#define AA 2// make this 2 or 3 for antialiasing\\n\\n//------------------------------------------------------------------\\nfloat dot2(in vec2 v){return dot(v,v);}\\nfloat dot2(in vec3 v){return dot(v,v);}\\nfloat ndot(in vec2 a,in vec2 b){return a.x*b.x-a.y*b.y;}\\n\\n\\nfloat sdPlane(vec3 p)\\n{\\n    return p.y;\\n}\\n\\nfloat sdSphere(vec3 p,float s)\\n{\\n    return length(p)-s;\\n}\\n\\nfloat sdU(in vec3 p,in float r,in float le,vec2 w)\\n{\\n    p.x=(p.y>0.)?abs(p.x):length(p.xy);\\n    p.x=abs(p.x-r);\\n    p.y=p.y-le;\\n    float k=max(p.x,p.y);\\n    vec2 q=vec2((k<0.)?-k:length(max(p.xy,0.)),abs(p.z))-w;\\n    return length(max(q,0.))+min(max(q.x,q.y),0.0);\\n}\\n\\n//------------------------------------------------------------------\\n\\nvec2 opU(vec2 d1,vec2 d2)\\n{\\n    return(d1.x<d2.x)?d1:d2;\\n}\\n\\n//------------------------------------------------------------------\\n\\n#define ZERO(min(iFrame,0.0))\\n\\n//------------------------------------------------------------------\\n\\nvec2 map(in vec3 pos)\\n{\\n    vec2 res=vec2(1e10,0.);\\n    \\n    {\\n        res=opU(res,vec2(sdSphere(pos-vec3(0.,.25,0.),.25),26.9));\\n    }\\n    \\n    return res;\\n}\\n\\n// https://iquilezles.org/articles/boxfunctions\\nvec2 iBox(in vec3 ro,in vec3 rd,in vec3 rad)\\n{\\n    vec3 m=1./rd;\\n    vec3 n=m*ro;\\n    vec3 k=abs(m)*rad;\\n    vec3 t1=-n-k;\\n    vec3 t2=-n+k;\\n    return vec2(max(max(t1.x,t1.y),t1.z),\\n    min(min(t2.x,t2.y),t2.z));\\n}\\n\\nvec2 raycast(in vec3 ro,in vec3 rd)\\n{\\n    vec2 res=vec2(-1.,-1.);\\n    \\n    float tmin=1.;\\n    float tmax=20.;\\n    \\n    // raytrace floor plane\\n    float tp1=(0.-ro.y)/rd.y;\\n    if(tp1>0.)\\n    {\\n        tmax=min(tmax,tp1);\\n        res=vec2(tp1,1.);\\n    }\\n    //else return res;\\n    \\n    // raymarch primitives\\n    vec2 tb=iBox(ro-vec3(0.,.4,-.5),rd,vec3(2.5,.41,3.));\\n    if(tb.x<tb.y&&tb.y>0.&&tb.x<tmax)\\n    {\\n        //return vec2(tb.x,2.0);\\n        tmin=max(tb.x,tmin);\\n        tmax=min(tb.y,tmax);\\n        \\n        float t=tmin;\\n        for(int i=0;i<70&&t<tmax;i++)\\n        {\\n            vec2 h=map(ro+rd*t);\\n            if(abs(h.x)<(.0001*t))\\n            {\\n                res=vec2(t,h.y);\\n                break;\\n            }\\n            t+=h.x;\\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n// https://iquilezles.org/articles/rmshadows\\nfloat calcSoftshadow(in vec3 ro,in vec3 rd,in float mint,in float tmax)\\n{\\n    // bounding volume\\n    float tp=(.8-ro.y)/rd.y;if(tp>0.)tmax=min(tmax,tp);\\n    \\n    float res=1.;\\n    float t=mint;\\n    for(int i=ZERO;i<24;i++)\\n    {\\n        float h=map(ro+rd*t).x;\\n        float s=clamp(8.*h/t,0.,1.);\\n        res=min(res,s*s*(3.-2.*s));\\n        t+=clamp(h,.02,.2);\\n        if(res<.004||t>tmax)break;\\n    }\\n    return clamp(res,0.,1.);\\n}\\n\\n// https://iquilezles.org/articles/normalsSDF\\nvec3 calcNormal(in vec3 pos)\\n{\\n    #if 0\\n    vec2 e=vec2(1.,-1.)*.5773*.0005;\\n    return normalize(e.xyy*map(pos+e.xyy).x+\\n    e.yyx*map(pos+e.yyx).x+\\n    e.yxy*map(pos+e.yxy).x+\\n    e.xxx*map(pos+e.xxx).x);\\n    #else\\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\\n    vec3 n=vec3(0.);\\n    for(int i=ZERO;i<4;i++)\\n    {\\n        vec3 e=.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\\n        n+=e*map(pos+.0005*e).x;\\n        //if( n.x+n.y+n.z>100.0 ) break;\\n    }\\n    return normalize(n);\\n    #endif\\n}\\n\\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\\nfloat calcAO(in vec3 pos,in vec3 nor)\\n{\\n    float occ=0.;\\n    float sca=1.;\\n    for(int i=ZERO;i<5;i++)\\n    {\\n        float h=.01+.12*float(i)/4.;\\n        float d=map(pos+h*nor).x;\\n        occ+=(h-d)*sca;\\n        sca*=.95;\\n        if(occ>.35)break;\\n    }\\n    return clamp(1.-3.*occ,0.,1.)*(.5+.5*nor.y);\\n}\\n\\n// https://iquilezles.org/articles/checkerfiltering\\nfloat checkersGradBox(in vec2 p,in vec2 dpdx,in vec2 dpdy)\\n{\\n    // filter kernel\\n    vec2 w=abs(dpdx)+abs(dpdy)+.001;\\n    // analytical integral (box filter)\\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\\n    // xor pattern\\n    return.5-.5*i.x*i.y;\\n}\\n\\nvec3 render(in vec3 ro,in vec3 rd,in vec3 rdx,in vec3 rdy)\\n{\\n    // background\\n    vec3 col=vec3(.7,.7,.9)-max(rd.y,0.)*.3;\\n    \\n    // raycast scene\\n    vec2 res=raycast(ro,rd);\\n    float t=res.x;\\n    float m=res.y;\\n    if(m>-.5)\\n    {\\n        vec3 pos=ro+t*rd;\\n        vec3 nor=(m<1.5)?vec3(0.,1.,0.):calcNormal(pos);\\n        vec3 ref=reflect(rd,nor);\\n        \\n        // material\\n        col=.2+.2*sin(m*2.+vec3(0.,1.,2.));\\n        float ks=1.;\\n        \\n        if(m<1.5)\\n        {\\n            // project pixel footprint into the plane\\n            vec3 dpdx=ro.y*(rd/rd.y-rdx/rdx.y);\\n            vec3 dpdy=ro.y*(rd/rd.y-rdy/rdy.y);\\n            \\n            float f=checkersGradBox(3.*pos.xz,3.*dpdx.xz,3.*dpdy.xz);\\n            col=.15+f*vec3(.05);\\n            ks=.4;\\n        }\\n        \\n        // lighting\\n        float occ=calcAO(pos,nor);\\n        \\n        vec3 lin=vec3(0.);\\n        \\n        // sun\\n        {\\n            vec3 lig=normalize(vec3(-.5,.4,-.6));\\n            vec3 hal=normalize(lig-rd);\\n            float dif=clamp(dot(nor,lig),0.,1.);\\n            //if( dif>0.0001 )\\n            dif*=calcSoftshadow(pos,lig,.02,2.5);\\n            float spe=pow(clamp(dot(nor,hal),0.,1.),16.);\\n            spe*=dif;\\n            spe*=.04+.96*pow(clamp(1.-dot(hal,lig),0.,1.),5.);\\n            //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\\n            lin+=col*2.20*dif*vec3(1.30,1.,.70);\\n            lin+=5.*spe*vec3(1.30,1.,.70)*ks;\\n        }\\n        // sky\\n        {\\n            float dif=sqrt(clamp(.5+.5*nor.y,0.,1.));\\n            dif*=occ;\\n            float spe=smoothstep(-.2,.2,ref.y);\\n            spe*=dif;\\n            spe*=.04+.96*pow(clamp(1.+dot(nor,rd),0.,1.),5.);\\n            //if( spe>0.001 )\\n            spe*=calcSoftshadow(pos,ref,.02,2.5);\\n            lin+=col*.60*dif*vec3(.40,.60,1.15);\\n            lin+=2.*spe*vec3(.40,.60,1.30)*ks;\\n        }\\n        // back\\n        {\\n            float dif=clamp(dot(nor,normalize(vec3(.5,0.,.6))),0.,1.)*clamp(1.-pos.y,0.,1.);\\n            dif*=occ;\\n            lin+=col*.55*dif*vec3(.25,.25,.25);\\n        }\\n        // sss\\n        {\\n            float dif=pow(clamp(1.+dot(nor,rd),0.,1.),2.);\\n            dif*=occ;\\n            lin+=col*.25*dif*vec3(1.,1.,1.);\\n        }\\n        \\n        col=lin;\\n        \\n        col=mix(col,vec3(.7,.7,.9),1.-exp(-.0001*t*t*t));\\n    }\\n    \\n    return vec3(clamp(col,0.,1.));\\n}\\n\\nmat3 setCamera(in vec3 ro,in vec3 ta,float cr)\\n{\\n    vec3 cw=normalize(ta-ro);\\n    vec3 cp=vec3(sin(cr),cos(cr),0.);\\n    vec3 cu=normalize(cross(cw,cp));\\n    vec3 cv=(cross(cu,cw));\\n    return mat3(cu,cv,cw);\\n}\\n\\nvoid main()\\n{\\n    vec2 mo=iMouse.xy/iResolution.xy;\\n    float time=32.+iTime*1.5;\\n    \\n    // camera\\n    vec3 ta=vec3(.5,-.5,-.6);\\n    vec3 ro=ta+vec3(4.5*cos(.1*time+7.*mo.x),1.3+2.*mo.y,4.5*sin(.1*time+7.*mo.x));\\n    // camera-to-world transformation\\n    mat3 ca=setCamera(ro,ta,0.);\\n    \\n    vec3 tot=vec3(0.);\\n    #if AA>1\\n    for(int m=ZERO;m<AA;m++)\\n    for(int n=ZERO;n<AA;n++)\\n    {\\n        // pixel coordinates\\n        vec2 o=vec2(float(m),float(n))/float(AA)-.5;\\n        vec2 p=(2.*(gl_FragCoor+o)-iResolution.xy)/iResolution.y;\\n        #else\\n        vec2 p=(2.*gl_FragCoor-iResolution.xy)/iResolution.y;\\n        #endif\\n        \\n        // focal length\\n        const float fl=2.5;\\n        \\n        // ray direction\\n        vec3 rd=ca*normalize(vec3(p,fl));\\n        \\n        // ray differentials\\n        vec2 px=(2.*(gl_FragCoor+vec2(1.,0.))-iResolution.xy)/iResolution.y;\\n        vec2 py=(2.*(gl_FragCoor+vec2(0.,1.))-iResolution.xy)/iResolution.y;\\n        vec3 rdx=ca*normalize(vec3(px,fl));\\n        vec3 rdy=ca*normalize(vec3(py,fl));\\n        \\n        // render\\n        vec3 col=render(ro,rd,rdx,rdy);\\n        \\n        // gain\\n        // col = col*3.0/(2.5+col);\\n        \\n        // gamma\\n        col=pow(col,vec3(.4545));\\n        \\n        tot+=col;\\n        #if AA>1\\n    }\\n    tot/=float(AA*AA);\\n    #endif\\n    \\n    gl_FragColor=vec4(tot,1.);\\n}\\n\";\n};","map":{"version":3,"names":["defaultShader"],"sources":["C:/Users/daniz/TFG/Aplicacion/src/defaultShader.js"],"sourcesContent":["export const defaultShader = () => `\r\n// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\r\n// I am the sole copyright owner of this Work.\r\n// You cannot host, display, distribute or share this Work in any form,\r\n// including physical and digital. You cannot use this Work in any\r\n// commercial or non-commercial product, website or project. You cannot\r\n// sell this Work and you cannot mint an NFTs of it.\r\n// I share this Work for educational purposes, and you can link to it,\r\n// through an URL, proper attribution and unmodified screenshot, as part\r\n// of your educational material. If these conditions are too restrictive\r\n// please contact me and we'll definitely work it out.\r\n\r\n// A list of useful distance function to simple primitives. All\r\n// these functions (except for ellipsoid) return an exact\r\n// euclidean distance, meaning they produce a better SDF than\r\n// what you'd get if you were constructing them from boolean\r\n// operations (such as cutting an infinite cylinder with two planes).\r\n\r\n// List of other 3D SDFs:\r\n//    https://www.shadertoy.com/playlist/43cXRl\r\n// and\r\n//    https://iquilezles.org/articles/distfunctions\r\n\r\n#define AA 2// make this 2 or 3 for antialiasing\r\n\r\n//------------------------------------------------------------------\r\nfloat dot2(in vec2 v){return dot(v,v);}\r\nfloat dot2(in vec3 v){return dot(v,v);}\r\nfloat ndot(in vec2 a,in vec2 b){return a.x*b.x-a.y*b.y;}\r\n\r\n\r\nfloat sdPlane(vec3 p)\r\n{\r\n    return p.y;\r\n}\r\n\r\nfloat sdSphere(vec3 p,float s)\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdU(in vec3 p,in float r,in float le,vec2 w)\r\n{\r\n    p.x=(p.y>0.)?abs(p.x):length(p.xy);\r\n    p.x=abs(p.x-r);\r\n    p.y=p.y-le;\r\n    float k=max(p.x,p.y);\r\n    vec2 q=vec2((k<0.)?-k:length(max(p.xy,0.)),abs(p.z))-w;\r\n    return length(max(q,0.))+min(max(q.x,q.y),0.0);\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nvec2 opU(vec2 d1,vec2 d2)\r\n{\r\n    return(d1.x<d2.x)?d1:d2;\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\n#define ZERO(min(iFrame,0.0))\r\n\r\n//------------------------------------------------------------------\r\n\r\nvec2 map(in vec3 pos)\r\n{\r\n    vec2 res=vec2(1e10,0.);\r\n    \r\n    {\r\n        res=opU(res,vec2(sdSphere(pos-vec3(0.,.25,0.),.25),26.9));\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n// https://iquilezles.org/articles/boxfunctions\r\nvec2 iBox(in vec3 ro,in vec3 rd,in vec3 rad)\r\n{\r\n    vec3 m=1./rd;\r\n    vec3 n=m*ro;\r\n    vec3 k=abs(m)*rad;\r\n    vec3 t1=-n-k;\r\n    vec3 t2=-n+k;\r\n    return vec2(max(max(t1.x,t1.y),t1.z),\r\n    min(min(t2.x,t2.y),t2.z));\r\n}\r\n\r\nvec2 raycast(in vec3 ro,in vec3 rd)\r\n{\r\n    vec2 res=vec2(-1.,-1.);\r\n    \r\n    float tmin=1.;\r\n    float tmax=20.;\r\n    \r\n    // raytrace floor plane\r\n    float tp1=(0.-ro.y)/rd.y;\r\n    if(tp1>0.)\r\n    {\r\n        tmax=min(tmax,tp1);\r\n        res=vec2(tp1,1.);\r\n    }\r\n    //else return res;\r\n    \r\n    // raymarch primitives\r\n    vec2 tb=iBox(ro-vec3(0.,.4,-.5),rd,vec3(2.5,.41,3.));\r\n    if(tb.x<tb.y&&tb.y>0.&&tb.x<tmax)\r\n    {\r\n        //return vec2(tb.x,2.0);\r\n        tmin=max(tb.x,tmin);\r\n        tmax=min(tb.y,tmax);\r\n        \r\n        float t=tmin;\r\n        for(int i=0;i<70&&t<tmax;i++)\r\n        {\r\n            vec2 h=map(ro+rd*t);\r\n            if(abs(h.x)<(.0001*t))\r\n            {\r\n                res=vec2(t,h.y);\r\n                break;\r\n            }\r\n            t+=h.x;\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n// https://iquilezles.org/articles/rmshadows\r\nfloat calcSoftshadow(in vec3 ro,in vec3 rd,in float mint,in float tmax)\r\n{\r\n    // bounding volume\r\n    float tp=(.8-ro.y)/rd.y;if(tp>0.)tmax=min(tmax,tp);\r\n    \r\n    float res=1.;\r\n    float t=mint;\r\n    for(int i=ZERO;i<24;i++)\r\n    {\r\n        float h=map(ro+rd*t).x;\r\n        float s=clamp(8.*h/t,0.,1.);\r\n        res=min(res,s*s*(3.-2.*s));\r\n        t+=clamp(h,.02,.2);\r\n        if(res<.004||t>tmax)break;\r\n    }\r\n    return clamp(res,0.,1.);\r\n}\r\n\r\n// https://iquilezles.org/articles/normalsSDF\r\nvec3 calcNormal(in vec3 pos)\r\n{\r\n    #if 0\r\n    vec2 e=vec2(1.,-1.)*.5773*.0005;\r\n    return normalize(e.xyy*map(pos+e.xyy).x+\r\n    e.yyx*map(pos+e.yyx).x+\r\n    e.yxy*map(pos+e.yxy).x+\r\n    e.xxx*map(pos+e.xxx).x);\r\n    #else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n=vec3(0.);\r\n    for(int i=ZERO;i<4;i++)\r\n    {\r\n        vec3 e=.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\r\n        n+=e*map(pos+.0005*e).x;\r\n        //if( n.x+n.y+n.z>100.0 ) break;\r\n    }\r\n    return normalize(n);\r\n    #endif\r\n}\r\n\r\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\r\nfloat calcAO(in vec3 pos,in vec3 nor)\r\n{\r\n    float occ=0.;\r\n    float sca=1.;\r\n    for(int i=ZERO;i<5;i++)\r\n    {\r\n        float h=.01+.12*float(i)/4.;\r\n        float d=map(pos+h*nor).x;\r\n        occ+=(h-d)*sca;\r\n        sca*=.95;\r\n        if(occ>.35)break;\r\n    }\r\n    return clamp(1.-3.*occ,0.,1.)*(.5+.5*nor.y);\r\n}\r\n\r\n// https://iquilezles.org/articles/checkerfiltering\r\nfloat checkersGradBox(in vec2 p,in vec2 dpdx,in vec2 dpdy)\r\n{\r\n    // filter kernel\r\n    vec2 w=abs(dpdx)+abs(dpdy)+.001;\r\n    // analytical integral (box filter)\r\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\r\n    // xor pattern\r\n    return.5-.5*i.x*i.y;\r\n}\r\n\r\nvec3 render(in vec3 ro,in vec3 rd,in vec3 rdx,in vec3 rdy)\r\n{\r\n    // background\r\n    vec3 col=vec3(.7,.7,.9)-max(rd.y,0.)*.3;\r\n    \r\n    // raycast scene\r\n    vec2 res=raycast(ro,rd);\r\n    float t=res.x;\r\n    float m=res.y;\r\n    if(m>-.5)\r\n    {\r\n        vec3 pos=ro+t*rd;\r\n        vec3 nor=(m<1.5)?vec3(0.,1.,0.):calcNormal(pos);\r\n        vec3 ref=reflect(rd,nor);\r\n        \r\n        // material\r\n        col=.2+.2*sin(m*2.+vec3(0.,1.,2.));\r\n        float ks=1.;\r\n        \r\n        if(m<1.5)\r\n        {\r\n            // project pixel footprint into the plane\r\n            vec3 dpdx=ro.y*(rd/rd.y-rdx/rdx.y);\r\n            vec3 dpdy=ro.y*(rd/rd.y-rdy/rdy.y);\r\n            \r\n            float f=checkersGradBox(3.*pos.xz,3.*dpdx.xz,3.*dpdy.xz);\r\n            col=.15+f*vec3(.05);\r\n            ks=.4;\r\n        }\r\n        \r\n        // lighting\r\n        float occ=calcAO(pos,nor);\r\n        \r\n        vec3 lin=vec3(0.);\r\n        \r\n        // sun\r\n        {\r\n            vec3 lig=normalize(vec3(-.5,.4,-.6));\r\n            vec3 hal=normalize(lig-rd);\r\n            float dif=clamp(dot(nor,lig),0.,1.);\r\n            //if( dif>0.0001 )\r\n            dif*=calcSoftshadow(pos,lig,.02,2.5);\r\n            float spe=pow(clamp(dot(nor,hal),0.,1.),16.);\r\n            spe*=dif;\r\n            spe*=.04+.96*pow(clamp(1.-dot(hal,lig),0.,1.),5.);\r\n            //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\r\n            lin+=col*2.20*dif*vec3(1.30,1.,.70);\r\n            lin+=5.*spe*vec3(1.30,1.,.70)*ks;\r\n        }\r\n        // sky\r\n        {\r\n            float dif=sqrt(clamp(.5+.5*nor.y,0.,1.));\r\n            dif*=occ;\r\n            float spe=smoothstep(-.2,.2,ref.y);\r\n            spe*=dif;\r\n            spe*=.04+.96*pow(clamp(1.+dot(nor,rd),0.,1.),5.);\r\n            //if( spe>0.001 )\r\n            spe*=calcSoftshadow(pos,ref,.02,2.5);\r\n            lin+=col*.60*dif*vec3(.40,.60,1.15);\r\n            lin+=2.*spe*vec3(.40,.60,1.30)*ks;\r\n        }\r\n        // back\r\n        {\r\n            float dif=clamp(dot(nor,normalize(vec3(.5,0.,.6))),0.,1.)*clamp(1.-pos.y,0.,1.);\r\n            dif*=occ;\r\n            lin+=col*.55*dif*vec3(.25,.25,.25);\r\n        }\r\n        // sss\r\n        {\r\n            float dif=pow(clamp(1.+dot(nor,rd),0.,1.),2.);\r\n            dif*=occ;\r\n            lin+=col*.25*dif*vec3(1.,1.,1.);\r\n        }\r\n        \r\n        col=lin;\r\n        \r\n        col=mix(col,vec3(.7,.7,.9),1.-exp(-.0001*t*t*t));\r\n    }\r\n    \r\n    return vec3(clamp(col,0.,1.));\r\n}\r\n\r\nmat3 setCamera(in vec3 ro,in vec3 ta,float cr)\r\n{\r\n    vec3 cw=normalize(ta-ro);\r\n    vec3 cp=vec3(sin(cr),cos(cr),0.);\r\n    vec3 cu=normalize(cross(cw,cp));\r\n    vec3 cv=(cross(cu,cw));\r\n    return mat3(cu,cv,cw);\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec2 mo=iMouse.xy/iResolution.xy;\r\n    float time=32.+iTime*1.5;\r\n    \r\n    // camera\r\n    vec3 ta=vec3(.5,-.5,-.6);\r\n    vec3 ro=ta+vec3(4.5*cos(.1*time+7.*mo.x),1.3+2.*mo.y,4.5*sin(.1*time+7.*mo.x));\r\n    // camera-to-world transformation\r\n    mat3 ca=setCamera(ro,ta,0.);\r\n    \r\n    vec3 tot=vec3(0.);\r\n    #if AA>1\r\n    for(int m=ZERO;m<AA;m++)\r\n    for(int n=ZERO;n<AA;n++)\r\n    {\r\n        // pixel coordinates\r\n        vec2 o=vec2(float(m),float(n))/float(AA)-.5;\r\n        vec2 p=(2.*(gl_FragCoor+o)-iResolution.xy)/iResolution.y;\r\n        #else\r\n        vec2 p=(2.*gl_FragCoor-iResolution.xy)/iResolution.y;\r\n        #endif\r\n        \r\n        // focal length\r\n        const float fl=2.5;\r\n        \r\n        // ray direction\r\n        vec3 rd=ca*normalize(vec3(p,fl));\r\n        \r\n        // ray differentials\r\n        vec2 px=(2.*(gl_FragCoor+vec2(1.,0.))-iResolution.xy)/iResolution.y;\r\n        vec2 py=(2.*(gl_FragCoor+vec2(0.,1.))-iResolution.xy)/iResolution.y;\r\n        vec3 rdx=ca*normalize(vec3(px,fl));\r\n        vec3 rdy=ca*normalize(vec3(py,fl));\r\n        \r\n        // render\r\n        vec3 col=render(ro,rd,rdx,rdy);\r\n        \r\n        // gain\r\n        // col = col*3.0/(2.5+col);\r\n        \r\n        // gamma\r\n        col=pow(col,vec3(.4545));\r\n        \r\n        tot+=col;\r\n        #if AA>1\r\n    }\r\n    tot/=float(AA*AA);\r\n    #endif\r\n    \r\n    gl_FragColor=vec4(tot,1.);\r\n}\r\n`;\r\n"],"mappings":"AAAA,OAAO,IAAMA,aAAa,GAAG,SAAhBA,aAAgB;EAAA;AAAA,CAAtB"},"metadata":{},"sourceType":"module"}