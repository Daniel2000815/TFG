{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = defaultCellRangeRenderer;\n\nvar _types = require(\"./types\");\n/**\r\n * Default implementation of cellRangeRenderer used by Grid.\r\n * This renderer supports cell-caching while the user is scrolling.\r\n */\n\n\nfunction defaultCellRangeRenderer(_ref) {\n  var cellCache = _ref.cellCache,\n      cellRenderer = _ref.cellRenderer,\n      columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,\n      columnStartIndex = _ref.columnStartIndex,\n      columnStopIndex = _ref.columnStopIndex,\n      deferredMeasurementCache = _ref.deferredMeasurementCache,\n      horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,\n      isScrolling = _ref.isScrolling,\n      isScrollingOptOut = _ref.isScrollingOptOut,\n      parent = _ref.parent,\n      rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,\n      rowStartIndex = _ref.rowStartIndex,\n      rowStopIndex = _ref.rowStopIndex,\n      styleCache = _ref.styleCache,\n      verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,\n      visibleColumnIndices = _ref.visibleColumnIndices,\n      visibleRowIndices = _ref.visibleRowIndices;\n  var renderedCells = []; // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\n  // User cannot scroll beyond these size limitations.\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\n  // See issue #576 for more.\n\n  var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();\n  var canCacheStyle = !isScrolling && !areOffsetsAdjusted;\n\n  for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n    var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\n\n    for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);\n      var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;\n      var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n      var style = void 0; // Cache style objects so shallow-compare doesn't re-render unnecessarily.\n\n      if (canCacheStyle && styleCache[key]) {\n        style = styleCache[key];\n      } else {\n        // In deferred mode, cells will be initially rendered before we know their size.\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\n        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {\n          // Position not-yet-measured cells at top/left 0,0,\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\n          // Positioning them further to the right/bottom influences their measured size.\n          style = {\n            height: 'auto',\n            left: 0,\n            position: 'absolute',\n            top: 0,\n            width: 'auto'\n          };\n        } else {\n          style = {\n            height: rowDatum.size,\n            left: columnDatum.offset + horizontalOffsetAdjustment,\n            position: 'absolute',\n            top: rowDatum.offset + verticalOffsetAdjustment,\n            width: columnDatum.size\n          };\n          styleCache[key] = style;\n        }\n      }\n\n      var cellRendererParams = {\n        columnIndex: columnIndex,\n        isScrolling: isScrolling,\n        isVisible: isVisible,\n        key: key,\n        parent: parent,\n        rowIndex: rowIndex,\n        style: style\n      };\n      var renderedCell = void 0; // Avoid re-creating cells while scrolling.\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n      // If a scroll is in progress- cache and reuse cells.\n      // This cache will be thrown away once scrolling completes.\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\n      // For more info refer to issue #395\n      //\n      // If isScrollingOptOut is specified, we always cache cells.\n      // For more info refer to issue #1028\n\n      if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {\n        if (!cellCache[key]) {\n          cellCache[key] = cellRenderer(cellRendererParams);\n        }\n\n        renderedCell = cellCache[key]; // If the user is no longer scrolling, don't cache cells.\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\n      } else {\n        renderedCell = cellRenderer(cellRendererParams);\n      }\n\n      if (renderedCell == null || renderedCell === false) {\n        continue;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        warnAboutMissingStyle(parent, renderedCell);\n      }\n\n      renderedCells.push(renderedCell);\n    }\n  }\n\n  return renderedCells;\n}\n\nfunction warnAboutMissingStyle(parent, renderedCell) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (renderedCell) {\n      // If the direct child is a CellMeasurer, then we should check its child\n      // See issue #611\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\n        renderedCell = renderedCell.props.children;\n      }\n\n      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {\n        parent.__warnedAboutMissingStyle = true;\n        console.warn('Rendered cell should include style property for positioning.');\n      }\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","defaultCellRangeRenderer","_types","require","_ref","cellCache","cellRenderer","columnSizeAndPositionManager","columnStartIndex","columnStopIndex","deferredMeasurementCache","horizontalOffsetAdjustment","isScrolling","isScrollingOptOut","parent","rowSizeAndPositionManager","rowStartIndex","rowStopIndex","styleCache","verticalOffsetAdjustment","visibleColumnIndices","visibleRowIndices","renderedCells","areOffsetsAdjusted","canCacheStyle","rowIndex","rowDatum","getSizeAndPositionOfCell","columnIndex","columnDatum","isVisible","start","stop","key","concat","style","has","height","left","position","top","width","size","offset","cellRendererParams","renderedCell","process","env","NODE_ENV","warnAboutMissingStyle","push","type","__internalCellMeasurerFlag","props","children","undefined","__warnedAboutMissingStyle","console","warn"],"sources":["G:/gitlab/TFG/Aplicacion/node_modules/rsuite/node_modules/react-virtualized/dist/commonjs/Grid/defaultCellRangeRenderer.js"],"sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports[\"default\"] = defaultCellRangeRenderer;\r\n\r\nvar _types = require(\"./types\");\r\n\r\n/**\r\n * Default implementation of cellRangeRenderer used by Grid.\r\n * This renderer supports cell-caching while the user is scrolling.\r\n */\r\nfunction defaultCellRangeRenderer(_ref) {\r\n  var cellCache = _ref.cellCache,\r\n      cellRenderer = _ref.cellRenderer,\r\n      columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,\r\n      columnStartIndex = _ref.columnStartIndex,\r\n      columnStopIndex = _ref.columnStopIndex,\r\n      deferredMeasurementCache = _ref.deferredMeasurementCache,\r\n      horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,\r\n      isScrolling = _ref.isScrolling,\r\n      isScrollingOptOut = _ref.isScrollingOptOut,\r\n      parent = _ref.parent,\r\n      rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,\r\n      rowStartIndex = _ref.rowStartIndex,\r\n      rowStopIndex = _ref.rowStopIndex,\r\n      styleCache = _ref.styleCache,\r\n      verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,\r\n      visibleColumnIndices = _ref.visibleColumnIndices,\r\n      visibleRowIndices = _ref.visibleRowIndices;\r\n  var renderedCells = []; // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\r\n  // User cannot scroll beyond these size limitations.\r\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\r\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\r\n  // See issue #576 for more.\r\n\r\n  var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();\r\n  var canCacheStyle = !isScrolling && !areOffsetsAdjusted;\r\n\r\n  for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\r\n    var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\r\n\r\n    for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\r\n      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);\r\n      var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;\r\n      var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\r\n      var style = void 0; // Cache style objects so shallow-compare doesn't re-render unnecessarily.\r\n\r\n      if (canCacheStyle && styleCache[key]) {\r\n        style = styleCache[key];\r\n      } else {\r\n        // In deferred mode, cells will be initially rendered before we know their size.\r\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\r\n        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {\r\n          // Position not-yet-measured cells at top/left 0,0,\r\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\r\n          // Positioning them further to the right/bottom influences their measured size.\r\n          style = {\r\n            height: 'auto',\r\n            left: 0,\r\n            position: 'absolute',\r\n            top: 0,\r\n            width: 'auto'\r\n          };\r\n        } else {\r\n          style = {\r\n            height: rowDatum.size,\r\n            left: columnDatum.offset + horizontalOffsetAdjustment,\r\n            position: 'absolute',\r\n            top: rowDatum.offset + verticalOffsetAdjustment,\r\n            width: columnDatum.size\r\n          };\r\n          styleCache[key] = style;\r\n        }\r\n      }\r\n\r\n      var cellRendererParams = {\r\n        columnIndex: columnIndex,\r\n        isScrolling: isScrolling,\r\n        isVisible: isVisible,\r\n        key: key,\r\n        parent: parent,\r\n        rowIndex: rowIndex,\r\n        style: style\r\n      };\r\n      var renderedCell = void 0; // Avoid re-creating cells while scrolling.\r\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\r\n      // If a scroll is in progress- cache and reuse cells.\r\n      // This cache will be thrown away once scrolling completes.\r\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\r\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\r\n      // For more info refer to issue #395\r\n      //\r\n      // If isScrollingOptOut is specified, we always cache cells.\r\n      // For more info refer to issue #1028\r\n\r\n      if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {\r\n        if (!cellCache[key]) {\r\n          cellCache[key] = cellRenderer(cellRendererParams);\r\n        }\r\n\r\n        renderedCell = cellCache[key]; // If the user is no longer scrolling, don't cache cells.\r\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\r\n      } else {\r\n        renderedCell = cellRenderer(cellRendererParams);\r\n      }\r\n\r\n      if (renderedCell == null || renderedCell === false) {\r\n        continue;\r\n      }\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        warnAboutMissingStyle(parent, renderedCell);\r\n      }\r\n\r\n      renderedCells.push(renderedCell);\r\n    }\r\n  }\r\n\r\n  return renderedCells;\r\n}\r\n\r\nfunction warnAboutMissingStyle(parent, renderedCell) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (renderedCell) {\r\n      // If the direct child is a CellMeasurer, then we should check its child\r\n      // See issue #611\r\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\r\n        renderedCell = renderedCell.props.children;\r\n      }\r\n\r\n      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {\r\n        parent.__warnedAboutMissingStyle = true;\r\n        console.warn('Rendered cell should include style property for positioning.');\r\n      }\r\n    }\r\n  }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}