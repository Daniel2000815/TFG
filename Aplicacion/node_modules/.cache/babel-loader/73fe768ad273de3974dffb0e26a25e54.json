{"ast":null,"code":"export var operators = function operators() {\n  return \"\\n    vec3 sdfTwist( in vec3 p, in float k )\\n    {\\n        float c = cos(k*p.y);\\n        float s = sin(k*p.y);\\n        mat2  m = mat2(c,-s,s,c);\\n        vec3  q = vec3(m*p.xz,p.y);\\n        return q;\\n    }\\n\\n    vec3 sdfBend(in vec3 p, in float k )\\n    {\\n        float c = cos(k*p.x);\\n        float s = sin(k*p.x);\\n        mat2  m = mat2(c,-s,s,c);\\n        vec3  q = vec3(m*p.xy,p.z);\\n        return q;\\n    }\\n    vec3 sdfRepeat( in vec3 p, in float s, in vec3 lim )\\n    {\\n        return p-s*clamp(floor(p/s+0.5),-lim,lim);\\n    }\\n\\n    float sdfUnion( float d1, float d2 ) {\\n        \\n        return min(d1,d2);\\n    }\\n\\n    float sdfSmoothUnion( float d1, float d2, float k ) {\\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\\n        return mix( d2, d1, h ) - k*h*(1.0-h); \\n    }\\n\\n    float sdfDifference( float d1, float d2 ) {\\n        \\n        return max(-d1,d2);\\n    }\\n\\n    float sdfSmoothDifference( float d1, float d2, float k ) {\\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\\n        return mix( d2, -d1, h ) + k*h*(1.0-h); \\n    }\\n\\n    float sdfIntersection( float d1, float d2 ) {\\n        \\n        return max(d1,d2);\\n    }\\n\\n    float sdfSmoothIntersection( float d1, float d2, float k ) {\\n        float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\\n        return mix( d2, d1, h ) + k*h*(1.0-h); \\n    }\\n\\n\";\n};","map":{"version":3,"names":["operators"],"sources":["G:/gitlab/TFG/Aplicacion/src/ShaderComponents/operators.js"],"sourcesContent":["export const operators = () => `\r\n    vec3 sdfTwist( in vec3 p, in float k )\r\n    {\r\n        float c = cos(k*p.y);\r\n        float s = sin(k*p.y);\r\n        mat2  m = mat2(c,-s,s,c);\r\n        vec3  q = vec3(m*p.xz,p.y);\r\n        return q;\r\n    }\r\n\r\n    vec3 sdfBend(in vec3 p, in float k )\r\n    {\r\n        float c = cos(k*p.x);\r\n        float s = sin(k*p.x);\r\n        mat2  m = mat2(c,-s,s,c);\r\n        vec3  q = vec3(m*p.xy,p.z);\r\n        return q;\r\n    }\r\n    vec3 sdfRepeat( in vec3 p, in float s, in vec3 lim )\r\n    {\r\n        return p-s*clamp(floor(p/s+0.5),-lim,lim);\r\n    }\r\n\r\n    float sdfUnion( float d1, float d2 ) {\r\n        \r\n        return min(d1,d2);\r\n    }\r\n\r\n    float sdfSmoothUnion( float d1, float d2, float k ) {\r\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\r\n        return mix( d2, d1, h ) - k*h*(1.0-h); \r\n    }\r\n\r\n    float sdfDifference( float d1, float d2 ) {\r\n        \r\n        return max(-d1,d2);\r\n    }\r\n\r\n    float sdfSmoothDifference( float d1, float d2, float k ) {\r\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\r\n        return mix( d2, -d1, h ) + k*h*(1.0-h); \r\n    }\r\n\r\n    float sdfIntersection( float d1, float d2 ) {\r\n        \r\n        return max(d1,d2);\r\n    }\r\n\r\n    float sdfSmoothIntersection( float d1, float d2, float k ) {\r\n        float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\r\n        return mix( d2, d1, h ) + k*h*(1.0-h); \r\n    }\r\n\r\n`"],"mappings":"AAAA,OAAO,IAAMA,SAAS,GAAG,SAAZA,SAAY;EAAA;AAAA,CAAlB"},"metadata":{},"sourceType":"module"}