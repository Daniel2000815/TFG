{"ast":null,"code":"/* global module */\n\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\nif (typeof module !== 'undefined' && typeof nerdamer === 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Algebra.js');\n}\n\n(function () {\n  \"use strict\";\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      Frac = core.Frac,\n      Settings = core.Settings,\n      isSymbol = core.Utils.isSymbol,\n      FN = core.groups.FN,\n      Symbol = core.Symbol,\n      text = core.Utils.text,\n      inBrackets = core.Utils.inBrackets,\n      isInt = core.Utils.isInt,\n      format = core.Utils.format,\n      even = core.Utils.even,\n      evaluate = core.Utils.evaluate,\n      N = core.groups.N,\n      S = core.groups.S,\n      FN = core.groups.FN,\n      PL = core.groups.PL,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      EX = core.groups.EX,\n      P = core.groups.P,\n      LOG = Settings.LOG,\n      EXP = 'exp',\n      ABS = 'abs',\n      SQRT = 'sqrt',\n      SIN = 'sin',\n      COS = 'cos',\n      TAN = 'tan',\n      SEC = 'sec',\n      CSC = 'csc',\n      COT = 'cot',\n      ASIN = 'asin',\n      ACOS = 'acos',\n      ATAN = 'atan',\n      ASEC = 'asec',\n      ACSC = 'acsc',\n      ACOT = 'acot',\n      SINH = 'sinh',\n      COSH = 'cosh',\n      TANH = 'tanh',\n      CSCH = 'csch',\n      SECH = 'sech',\n      COTH = 'coth',\n      ASECH = 'asech',\n      ACSCH = 'acsch',\n      ACOTH = 'acoth'; //custom errors\n\n  function NoIntegralFound(msg) {\n    this.message = msg || \"\";\n  }\n\n  NoIntegralFound.prototype = new Error(); //Preparations\n\n  Symbol.prototype.hasIntegral = function () {\n    return this.containsFunction('integrate');\n  }; //transforms a function\n\n\n  Symbol.prototype.fnTransform = function () {\n    if (this.group !== FN) return this;\n    var retval,\n        a = this.args[0];\n    var m = new Symbol(this.multiplier);\n    var sym = this.clone().toUnitMultiplier();\n\n    if (this.isLinear()) {\n      switch (this.fname) {\n        case SINH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\n          break;\n\n        case COSH:\n          retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\n          break;\n\n        case TANH:\n          retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\n          break;\n\n        case TAN:\n          retval = _.parse(format('sin({0})/cos({0})', a));\n          break;\n\n        case CSC:\n          retval = _.parse(format('1/sin({0})', a));\n          break;\n\n        case SEC:\n          retval = _.parse(format('1/cos({0})', a));\n          break;\n\n        default:\n          retval = sym;\n      }\n    } else if (this.power.equals(2)) {\n      switch (this.fname) {\n        case SIN:\n          retval = _.parse(format('1/2-cos(2*({0}))/2', a));\n          break;\n\n        case COS:\n          retval = _.parse(format('1/2+cos(2*({0}))/2', a));\n          break;\n\n        case TAN:\n          //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\n          retval = _.parse(format('sin({0})^2/cos({0})^2', a));\n          break;\n\n        case COSH:\n          retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\n          break;\n\n        case SINH:\n          retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\n          break;\n\n        case TANH:\n          retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\n          break;\n\n        case SEC:\n          retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\n          break;\n\n        default:\n          retval = sym;\n      }\n    } else if (this.fname === SEC) {\n      retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === CSC) {\n      retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\n    } else if (this.fname === TAN) {\n      if (this.power.lessThan(0)) {\n        retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\n      } else {\n        retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\n      }\n    } else if (this.fname === SIN && this.power.lessThan(0)) {\n      retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === COS && this.power.lessThan(0)) {\n      retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\n    } else if (this.fname === SIN && this.power.equals(3)) {\n      retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\n    } else if (this.fname === COS && this.power.equals(3)) {\n      retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\n    } //cos(a*x)^(2*n) or sin(a*x)^(2*n)\n    else if ((this.fname === COS || this.fname === SIN) && even(this.power)) {\n      var n = this.power / 2; //convert to a double angle\n\n      var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform(); //raise to the n and expand\n\n\n      var transformed = _.expand(_.pow(double_angle, _.parse(n)));\n\n      retval = new Symbol(0);\n      transformed.each(function (s) {\n        var t = s.fnTransform();\n        retval = _.add(retval, t);\n      }, true);\n    } else retval = sym;\n\n    return _.multiply(retval, m);\n  };\n\n  Symbol.prototype.hasTrig = function () {\n    if (this.isConstant(true) || this.group === S) return false;\n    if (this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname))) return true;\n\n    if (this.symbols) {\n      for (var x in this.symbols) {\n        if (this.symbols[x].hasTrig()) return true;\n      }\n    }\n\n    return false;\n  };\n\n  core.Expression.prototype.hasIntegral = function () {\n    return this.symbol.hasIntegral();\n  };\n  /**\r\n   * Attempts to rewrite a symbol under one common denominator\r\n   * @param {Symbol} symbol \r\n   */\n\n\n  core.Utils.toCommonDenominator = function (symbol) {\n    //transform x/a+x -> (ax+x)/a\n    if (symbol.isComposite() && symbol.isLinear()) {\n      var m = new Symbol(symbol.multiplier);\n      var denominator = new Symbol(1);\n      var numerator = new Symbol(0);\n      symbol.each(function (x) {\n        denominator = _.multiply(denominator, x.getDenom());\n      }, true); //remove the denomitor in each term\n\n      symbol.each(function (x) {\n        var num = x.getNum();\n        var den = x.getDenom();\n\n        var factor = _.multiply(num, _.divide(denominator.clone(), den));\n\n        numerator = _.add(numerator, factor);\n      });\n\n      var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\n\n      return retval;\n    }\n\n    return symbol;\n  }; //A function to check if a function name is an inverse trig function\n\n\n  core.Utils.in_inverse_trig = function (x) {\n    var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\n    return inv_trig_fns.indexOf(x) !== -1;\n  }; //A function to check if a function name is a trig function\n\n\n  core.Utils.in_trig = function (x) {\n    var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\n    return trig_fns.indexOf(x) !== -1;\n  };\n\n  core.Utils.in_htrig = function (x) {\n    var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\n    return trig_fns.indexOf(x) !== -1;\n  }; // Matrix functions\n\n\n  core.Matrix.jacobian = function (eqns, vars) {\n    var jacobian = new core.Matrix(); //get the variables if not supplied\n\n    if (!vars) {\n      vars = core.Utils.arrayGetVariables(eqns);\n    }\n\n    vars.forEach(function (v, i) {\n      eqns.forEach(function (eq, j) {\n        var e = core.Calculus.diff(eq.clone(), v);\n        jacobian.set(j, i, e);\n      });\n    });\n    return jacobian;\n  };\n\n  core.Matrix.prototype.max = function () {\n    var max = new Symbol(0);\n    this.each(function (x) {\n      var e = x.abs();\n      if (e.gt(max)) max = e;\n    });\n    return max;\n  };\n\n  core.Matrix.cMatrix = function (value, vars) {\n    var m = new core.Matrix(); //make an initial guess\n\n    vars.forEach(function (v, i) {\n      m.set(i, 0, _.parse(value));\n    });\n    return m;\n  };\n\n  var all_functions = core.Utils.all_functions = function (arr) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      if (arr[i].group !== FN) return false;\n    }\n\n    return true;\n  },\n      cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n    var a, b;\n    a = symbol1.args[0];\n    b = symbol2.args[0];\n    return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\n  },\n      cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\n    //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\n    //we technically know how to do this transform but more is needed for correct output\n    if (Number(symbol2.power) !== 1) return _.multiply(symbol1, symbol2);\n    var a;\n    a = symbol1.args[0];\n    return _.parse(format('(sin(2*({0})))/2', a));\n  },\n      sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\n    var a, b;\n    a = symbol1.args[0];\n    b = symbol2.args[0];\n    return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\n  },\n      trigTransform = core.Utils.trigTransform = function (arr) {\n    var map = {},\n        symbol,\n        t,\n        retval = new Symbol(1);\n\n    for (var i = 0, l = arr.length; i < l; i++) {\n      symbol = arr[i];\n\n      if (symbol.group === FN) {\n        var fname = symbol.fname;\n\n        if (fname === COS && map[SIN]) {\n          if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n            t = cosAsinBtransform(symbol, map[SIN]);\n          } else {\n            t = cosAsinAtransform(symbol, map[SIN]);\n          }\n\n          delete map[SIN];\n          retval = _.multiply(retval, t);\n        } else if (fname === SIN && map[COS]) {\n          if (map[COS].args[0].toString() !== symbol.args[0].toString()) {\n            t = cosAsinBtransform(symbol, map[COS]);\n          } else {\n            t = cosAsinAtransform(symbol, map[COS]);\n          }\n\n          delete map[COS];\n          retval = _.multiply(retval, t);\n        } else if (fname === SIN && map[SIN]) {\n          if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {\n            t = sinAsinBtransform(symbol, map[SIN]);\n            delete map[SIN];\n          } else {\n            //This should actually be redundant code but let's put just in case\n            t = _.multiply(symbol, map[SIN]);\n            delete map[SIN];\n          }\n\n          retval = t;\n        } else {\n          map[fname] = symbol;\n        }\n      } else retval = _.multiply(retval, symbol);\n    } //put back the remaining functions\n\n\n    for (var x in map) {\n      retval = _.multiply(retval, map[x]);\n    }\n\n    return retval;\n  };\n\n  core.Settings.integration_depth = 10;\n  core.Settings.max_lim_depth = 10;\n\n  var __ = core.Calculus = {\n    version: '1.4.6',\n    sum: function sum(fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        start = Number(start);\n        end = Number(end);\n        retval = core.Utils.block(modifier, function () {\n          var f = fn.text(),\n              subs = {\n            '~': true\n          },\n              //lock subs. Is this even being used?\n          retval = new core.Symbol(0);\n\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n\n            var ans = _.parse(f, subs);\n\n            retval = _.add(retval, ans);\n          }\n\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('sum', arguments);\n      }\n\n      return retval;\n    },\n    product: function product(fn, index, start, end) {\n      if (!(index.group === core.groups.S)) throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\n      index = index.value;\n      var retval;\n\n      if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\n        var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\n        retval = core.Utils.block(modifier, function () {\n          start = Number(start);\n          end = Number(end.multiplier);\n          var f = fn.text(),\n              subs = {},\n              retval = new core.Symbol(1);\n\n          for (var i = start; i <= end; i++) {\n            subs[index] = new Symbol(i);\n            retval = _.multiply(retval, _.parse(f, subs));\n          }\n\n          return retval;\n        });\n      } else {\n        retval = _.symfunction('product', arguments);\n      }\n\n      return retval;\n    },\n    diff: function diff(symbol, wrt, nth) {\n      if (core.Utils.isVector(symbol)) {\n        var vector = new core.Vector([]);\n        symbol.each(function (x) {\n          vector.elements.push(__.diff(x, wrt, nth));\n        });\n        return vector;\n      } else if (core.Utils.isMatrix(symbol)) {\n        var matrix = new core.Matrix();\n        symbol.each(function (x, i, j) {\n          matrix.set(i, j, __.diff(x, wrt, nth));\n        });\n        return matrix;\n      }\n\n      var d = isSymbol(wrt) ? wrt.text() : wrt; //the nth derivative\n\n      nth = isSymbol(nth) ? nth.multiplier : nth || 1;\n      if (d === undefined) d = core.Utils.variables(symbol)[0]; //unwrap sqrt\n\n      if (symbol.group === FN && symbol.fname === SQRT) {\n        var s = symbol.args[0],\n            sp = symbol.power.clone(); //these groups go to zero anyway so why waste time?\n\n        if (s.group !== N || s.group !== P) {\n          s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\n          s.multiplier = s.multiplier.multiply(symbol.multiplier);\n        }\n\n        symbol = s;\n      }\n\n      if (symbol.group === FN && !isSymbol(symbol.power)) {\n        var a = derive(_.parse(symbol));\n\n        var b = __.diff(symbol.args[0].clone(), d);\n\n        symbol = _.multiply(a, b); //chain rule\n      } else {\n        symbol = derive(symbol);\n      }\n\n      if (nth > 1) {\n        nth--;\n        symbol = __.diff(symbol, wrt, nth);\n      }\n\n      return symbol; // Equivalent to \"derivative of the outside\".\n\n      function polydiff(symbol) {\n        if (symbol.value === d || symbol.contains(d, true)) {\n          symbol.multiplier = symbol.multiplier.multiply(symbol.power);\n          symbol.power = symbol.power.subtract(new Frac(1));\n\n          if (symbol.power.equals(0)) {\n            symbol = Symbol(symbol.multiplier);\n          }\n        }\n\n        return symbol;\n      }\n\n      function derive(symbol) {\n        var g = symbol.group,\n            a,\n            b,\n            cp;\n\n        if (g === N || g === S && symbol.value !== d || g === P) {\n          symbol = Symbol(0);\n        } else if (g === S) {\n          symbol = polydiff(symbol);\n        } else if (g === CB) {\n          var m = symbol.multiplier.clone();\n          symbol.toUnitMultiplier();\n\n          var retval = _.multiply(product_rule(symbol), polydiff(symbol));\n\n          retval.multiplier = retval.multiplier.multiply(m);\n          return retval;\n        } else if (g === FN && symbol.power.equals(1)) {\n          // Table of known derivatives\n          switch (symbol.fname) {\n            case LOG:\n              cp = symbol.clone();\n              symbol = symbol.args[0].clone(); //get the arguments\n\n              symbol.power = symbol.power.negate();\n              symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\n              break;\n\n            case COS:\n              //cos -> -sin\n              symbol.fname = SIN;\n              symbol.multiplier.negate();\n              break;\n\n            case SIN:\n              //sin -> cos\n              symbol.fname = COS;\n              break;\n\n            case TAN:\n              //tan -> sec^2\n              symbol.fname = SEC;\n              symbol.power = new Frac(2);\n              break;\n\n            case SEC:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, TAN);\n              break;\n\n            case CSC:\n              symbol = qdiff(symbol, '-cot');\n              break;\n\n            case COT:\n              symbol.fname = CSC;\n              symbol.multiplier.negate();\n              symbol.power = new Frac(2);\n              break;\n\n            case ASIN:\n              symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case ACOS:\n              symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case ATAN:\n              symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n\n            case ABS:\n              m = symbol.multiplier.clone();\n              symbol.toUnitMultiplier(); //depending on the complexity of the symbol it's easier to just parse it into a new symbol\n              //this should really be readdressed soon\n\n              b = symbol.args[0].clone();\n              b.toUnitMultiplier();\n              symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\n              symbol.multiplier = m;\n              break;\n\n            case 'parens':\n              //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\n              //1*g'\n              symbol = Symbol(1);\n              break;\n\n            case 'cosh':\n              //cosh -> -sinh\n              symbol.fname = 'sinh';\n              break;\n\n            case 'sinh':\n              //sinh -> cosh\n              symbol.fname = 'cosh';\n              break;\n\n            case TANH:\n              //tanh -> sech^2\n              symbol.fname = SECH;\n              symbol.power = new Frac(2);\n              break;\n\n            case SECH:\n              // Use a clone if this gives errors\n              symbol = qdiff(symbol, '-tanh');\n              break;\n\n            case CSCH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\n              break;\n\n            case COTH:\n              var arg = String(symbol.args[0]);\n              return _.parse('-csch(' + arg + ')^2');\n              break;\n\n            case 'asinh':\n              symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case 'acosh':\n              symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\n              break;\n\n            case 'atanh':\n              symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\n              break;\n\n            case ASECH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\n              break;\n\n            case ACOTH:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\n              break;\n\n            case ACSCH:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\n              break;\n\n            case ASEC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n\n            case ACSC:\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\n              break;\n\n            case ACOT:\n              symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\n              break;\n\n            case 'S':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\n              break;\n\n            case 'C':\n              var arg = String(symbol.args[0]);\n              symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\n              break;\n\n            case 'Si':\n              var arg = symbol.args[0];\n              symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Shi':\n              var arg = symbol.args[0];\n              symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Ci':\n              var arg = symbol.args[0];\n              symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Chi':\n              var arg = symbol.args[0];\n              symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Ei':\n              var arg = symbol.args[0];\n              symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\n              break;\n\n            case 'Li':\n              var arg = symbol.args[0];\n              symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\n              break;\n\n            case 'erf':\n              symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\n              break;\n\n            case 'atan2':\n              var x_ = String(symbol.args[0]),\n                  y_ = String(symbol.args[1]);\n              symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\n              break;\n\n            case 'sign':\n              symbol = new Symbol(0);\n              break;\n\n            case 'sinc':\n              symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\n              break;\n\n            case Settings.LOG10:\n              symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\n              break;\n\n            default:\n              symbol = _.symfunction('diff', [symbol, wrt]);\n          }\n        } else if (g === EX || g === FN && isSymbol(symbol.power)) {\n          var value;\n\n          if (g === EX) {\n            value = symbol.value;\n          } else if (g === FN && symbol.contains(d)) {\n            value = symbol.fname + inBrackets(text(symbol.args[0]));\n          } else {\n            value = symbol.value + inBrackets(text(symbol.args[0]));\n          }\n\n          a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\n          b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\n          symbol = _.multiply(symbol, b);\n        } else if (g === FN && !symbol.power.equals(1)) {\n          b = symbol.clone();\n          b.toLinear();\n          b.toUnitMultiplier();\n          symbol = _.multiply(polydiff(symbol.clone()), derive(b));\n        } else if (g === CP || g === PL) {\n          // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\n          var c = symbol.clone();\n          var result = new Symbol(0);\n\n          for (var x in symbol.symbols) {\n            result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\n          }\n\n          symbol = _.multiply(polydiff(c), result);\n        }\n\n        symbol.updateHash();\n        return symbol;\n      }\n\n      ;\n\n      function qdiff(symbol, val, altVal) {\n        return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\n      }\n\n      ;\n\n      function product_rule(symbol) {\n        //grab all the symbols within the CB symbol\n        var symbols = symbol.collectSymbols(),\n            result = new Symbol(0),\n            l = symbols.length; //loop over all the symbols\n\n        for (var i = 0; i < l; i++) {\n          var df = __.diff(symbols[i].clone(), d);\n\n          for (var j = 0; j < l; j++) {\n            //skip the symbol of which we just pulled the derivative\n            if (i !== j) {\n              //multiply out the remaining symbols\n              df = _.multiply(df, symbols[j].clone());\n            }\n          } //add the derivative to the result\n\n\n          result = _.add(result, df);\n        }\n\n        return result; //done\n      }\n\n      ;\n    },\n    integration: {\n      u_substitution: function u_substitution(symbols, dx) {\n        function try_combo(a, b, f) {\n          var d = __.diff(b, dx);\n\n          var q = f ? f(a, b) : _.divide(a.clone(), d);\n          if (!q.contains(dx, true)) return q;\n          return null;\n        }\n\n        function do_fn_sub(fname, arg) {\n          var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\n\n          subbed = subbed.sub(new Symbol(u), arg);\n          subbed.updateHash();\n          return subbed;\n        }\n\n        var a = symbols[0].clone(),\n            b = symbols[1].clone(),\n            g1 = a.group,\n            g2 = b.group,\n            //may cause problems if person is using this already. Will need\n        //to find algorithm for detecting conflict\n        u = '__u__',\n            Q;\n\n        if (g1 === FN && g2 !== FN) {\n          //e.g. 2*x*cos(x^2)\n          var arg = a.args[0];\n          Q = try_combo(b, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(a.fname, arg));\n          Q = try_combo(b, a);\n\n          if (Q) {\n            return __.integration.poly_integrate(a);\n          }\n        } else if (g2 === FN && g1 !== FN) {\n          //e.g. 2*(x+1)*cos((x+1)^2\n          var arg = b.args[0];\n          Q = try_combo(a, arg.clone());\n          if (Q) return _.multiply(Q, do_fn_sub(b.fname, arg));\n        } else if (g1 === FN && g2 === FN) {\n          Q = try_combo(a.clone(), b.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(b.clone(), a.clone());\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n        } else if (g1 === EX && g2 !== EX) {\n          var p = a.power;\n          Q = try_combo(b, p.clone());\n\n          if (!Q) {\n            //one more try\n            var dc = __.integration.decompose_arg(p.clone(), dx); //consider the possibility of a^x^(n-1)*x^n dx\n\n\n            var xp = __.diff(dc[2].clone(), dx);\n\n            var dc2 = __.integration.decompose_arg(xp.clone(), dx); //if their powers equal, so if dx*p == b\n\n\n            if (_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\n              var m = _.divide(dc[0].clone(), dc2[0].clone());\n\n              var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\n\n              new_val = _.multiply(new_val, new Symbol(u));\n              return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\n            }\n          }\n\n          var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\n              retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\n\n          return retval;\n        } else if (g2 === EX && g1 !== EX) {\n          var p = b.power;\n          Q = try_combo(a, p.clone());\n\n          var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\n\n          return _.multiply(integrated.sub(new Symbol(u), p), Q);\n        } else if (a.isComposite() || b.isComposite()) {\n          var f = function f(a, b) {\n            var d = __.diff(b, dx);\n\n            var A = core.Algebra.Factor.factor(a),\n                B = core.Algebra.Factor.factor(d);\n\n            var q = _.divide(A, B);\n\n            return q;\n          };\n\n          var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\n              f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\n          Q = try_combo(f1.clone(), f2.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(b), Q);\n          Q = try_combo(f2.clone(), f1.clone(), f);\n          if (Q) return _.multiply(__.integration.poly_integrate(a), Q);\n        }\n      },\n      //simple integration of a single polynomial x^(n+1)/(n+1)\n      poly_integrate: function poly_integrate(x) {\n        var p = x.power.toString(),\n            m = x.multiplier.toDecimal(),\n            s = x.toUnitMultiplier().toLinear();\n\n        if (Number(p) === -1) {\n          return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\n        }\n\n        return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\n      },\n      //If we're just spinning wheels we want to stop. This is why we \n      //wrap integration in a try catch block and call this to stop.\n      stop: function stop(msg) {\n        msg = msg || 'Unable to compute integral!';\n        core.Utils.warn(msg);\n        throw new NoIntegralFound(msg);\n      },\n      partial_fraction: function partial_fraction(input, dx, depth, opt) {\n        //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\n        if (!isSymbol(dx)) dx = _.parse(dx);\n        var result, partial_fractions;\n        result = new Symbol(0);\n        partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\n\n        if (partial_fractions.group === CB && partial_fractions.isLinear()) {\n          //perform a quick check to make sure that all partial fractions are linear\n          partial_fractions.each(function (x) {\n            if (!x.isLinear()) __.integration.stop();\n          });\n          partial_fractions.each(function (x) {\n            result = _.add(result, __.integrate(x, dx, depth, opt));\n          });\n        } else {\n          result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\n        }\n\n        return result;\n      },\n      get_udv: function get_udv(symbol) {\n        var parts = [[\n          /*L*/\n        ], [\n          /*I*/\n        ], [\n          /*A*/\n        ], [\n          /*T*/\n        ], [\n          /*E*/\n        ]]; //first we sort them \n\n        var setSymbol = function setSymbol(x) {\n          var g = x.group;\n\n          if (g === FN) {\n            var fname = x.fname;\n            if (core.Utils.in_trig(fname) || core.Utils.in_htrig(fname)) parts[3].push(x);else if (core.Utils.in_inverse_trig(fname)) parts[1].push(x);else if (fname === LOG) parts[0].push(x);else {\n              __.integration.stop();\n            }\n          } else if (g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\n            parts[2].push(x);\n          } else if (g === EX || x.isComposite() && !x.isLinear()) parts[4].push(x);else __.integration.stop();\n        };\n\n        if (symbol.group === CB) symbol.each(function (x) {\n          setSymbol(Symbol.unwrapSQRT(x, true));\n        });else setSymbol(symbol);\n        var u,\n            dv = new Symbol(1); //compile u and dv\n\n        for (var i = 0; i < 5; i++) {\n          var part = parts[i],\n              t,\n              l = part.length;\n\n          if (l > 0) {\n            if (l > 1) {\n              t = new Symbol(1);\n\n              for (var j = 0; j < l; j++) {\n                t = _.multiply(t, part[j].clone());\n              }\n            } else t = part[0].clone();\n\n            if (!u) {\n              u = t; //the first u encountered gets chosen\n\n              u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\n            } else dv = _.multiply(dv, t); //everything else belongs to dv\n\n          }\n        }\n\n        return [u, dv];\n      },\n      trig_sub: function trig_sub(symbol, dx, depth, opt, parts, symbols) {\n        parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\n        var b = parts[3],\n            ax = parts[2],\n            a = parts[0],\n            x = parts[1];\n\n        if (x.power.equals(2) && a.greaterThan(0)) {\n          //use tan(x)\n          var t = core.Utils.getU(symbol),\n              //get an appropriate u\n          u = _.parse(TAN + inBrackets(t)),\n              //u\n          du = _.parse(SEC + inBrackets(t) + '^2'),\n              //du\n          f = _.multiply(symbol.sub(x, u), du);\n\n          var integral = __.integrate(f, t, depth, opt).sub(u, x);\n\n          core.Utils.clearU(u);\n          return integral;\n        }\n      },\n      by_parts: function by_parts(symbol, dx, depth, o) {\n        o.previous = o.previous || [];\n        var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s; //first LIATE\n\n        udv = __.integration.get_udv(symbol);\n        u = udv[0];\n        dv = udv[1];\n        du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\n        c = du.clone().stripVar(dx); //strip any coefficients\n\n        du = _.divide(du, c.clone());\n        v = __.integrate(dv.clone(), dx, depth || 0);\n        vdu = _.multiply(v.clone(), du);\n        vdu_s = vdu.toString(); //currently only supports e^x*(some trig)\n\n        if (o.previous.indexOf(vdu_s) !== -1 && core.Utils.in_trig(u.fname) && dv.isE()) {\n          //We're going to exploit the fact that vdu can never be constant\n          //to work out way out of this cycle. We'll return the length of\n          //the this.previous array until we're back at level one\n          o.is_cyclic = true; //return the integral. \n\n          return new Symbol(1);\n        } else o.previous.push(vdu_s);\n\n        uv = _.multiply(u, v); //clear the multiplier so we're dealing with a bare integral\n\n        m = vdu.multiplier.clone();\n        vdu.toUnitMultiplier();\n        integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\n        integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\n        retval = _.subtract(uv, integral_vdu); //we know that there cannot be constants so they're a holdover from a cyclic integral\n\n        if (o.is_cyclic) {\n          //start popping the previous stack so we know how deep in we are\n          o.previous.pop();\n\n          if (o.previous.length === 0) {\n            retval = _.expand(retval);\n            var rem = new Symbol(0);\n            retval.each(function (x) {\n              if (!x.contains(dx)) rem = _.add(rem, x.clone());\n            }); //get the actual uv\n\n            retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\n          }\n        }\n\n        return retval;\n      },\n\n      /*\r\n       * dependents: [Solve, integrate]\r\n       */\n      decompose_arg: core.Utils.decompose_fn\n    },\n    //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\n    integrate: function integrate(original_symbol, dt, depth, opt) {\n      //assume integration wrt independent variable if expression only has one variable\n      if (!dt) {\n        var vars = core.Utils.variables(original_symbol);\n        if (vars.length === 1) dt = vars[0]; //defaults to x\n\n        dt = dt || 'x';\n      } //add support for integrating vectors\n\n\n      if (core.Utils.isVector(original_symbol)) {\n        var vector = new core.Vector([]);\n        original_symbol.each(function (x) {\n          vector.elements.push(__.integrate(x, dt));\n        });\n        return vector;\n      }\n\n      if (!isNaN(dt)) _.error('variable expected but received ' + dt); //get rid of constants right away\n\n      if (original_symbol.isConstant(true)) return _.multiply(original_symbol.clone(), _.parse(dt)); //configurations options for integral. This is needed for tracking extra options\n      //e.g. cyclic integrals or additional settings\n\n      opt = opt || {};\n      return core.Utils.block('PARSE2NUMBER', function () {\n        //make a note of the original symbol. Set only if undefined\n        depth = depth || 0;\n        var dx = isSymbol(dt) ? dt.toString() : dt,\n            //we don't want the symbol in sqrt form. x^(1/2) is prefererred\n        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\n            g = symbol.group,\n            retval;\n\n        try {\n          //We stop integration after x amount of recursive calls\n          if (++depth > core.Settings.integration_depth) __.integration.stop('Maximum depth reached. Exiting!'); //constants. We first eliminate anything that doesn't have dx. Everything after this has \n          //to have dx or else it would have been taken care of below\n\n          if (!symbol.contains(dx, true)) {\n            retval = _.multiply(symbol.clone(), _.parse(dx));\n          } //e.g. 2*x\n          else if (g === S) {\n            retval = __.integration.poly_integrate(symbol, dx, depth);\n          } else if (g === EX) {\n            if (symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS)) __.integration.stop(); //check the base\n\n            if (symbol.contains(dx) && symbol.previousGroup !== FN) {\n              //if the symbol also contains dx then we stop since we currently \n              //don't know what to do with it e.g. x^x\n              if (symbol.power.contains(dx)) __.integration.stop();else {\n                var t = __.diff(symbol.clone().toLinear(), dx);\n\n                if (t.contains(dx)) __.integration.stop(); //since at this point it's the base only then we do standard single poly integration\n                //e.g. x^y\n\n                retval = __.integration.poly_integrate(symbol, dx, depth);\n              }\n            } //e.g. a^x or 9^x\n            else {\n              var a = __.diff(symbol.power.clone(), dx);\n\n              if (a.contains(dx)) {\n                var aa = a.stripVar(dx),\n                    x = _.divide(a.clone(), aa.clone());\n\n                if (x.group === S && x.isLinear()) {\n                  aa.multiplier = aa.multiplier.divide(new Frac(2));\n                  return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\n                } else __.integration.stop();\n              }\n\n              if (symbol.isE()) {\n                if (a.isLinear()) retval = symbol;else {\n                  if (a.isE() && a.power.group === S && a.power.power.equals(1)) retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);else __.integration.stop();\n                }\n              } else {\n                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\n\n                retval = _.divide(symbol, d);\n              }\n\n              retval = _.divide(retval, a);\n            }\n          } else if (symbol.isComposite() && symbol.isLinear()) {\n            var m = _.parse(symbol.multiplier);\n\n            symbol.toUnitMultiplier();\n            retval = new Symbol(0);\n            symbol.each(function (x) {\n              retval = _.add(retval, __.integrate(x, dx, depth));\n            });\n            retval = _.multiply(m, retval);\n          } else if (g === CP) {\n            if (symbol.power.greaterThan(1)) symbol = _.expand(symbol);\n\n            if (symbol.power.equals(1)) {\n              retval = new Symbol(0);\n              symbol.each(function (x) {\n                retval = _.add(retval, __.integrate(x, dx, depth));\n              }, true);\n            } else {\n              var p = Number(symbol.power),\n                  m = symbol.multiplier.clone(); //temporarily remove the multiplier\n\n              symbol.toUnitMultiplier();\n\n              var //below we consider the form ax+b\n              fn = symbol.clone().toLinear(),\n                  //get just the pure function without the power\n              decomp = __.integration.decompose_arg(fn, dx),\n                  //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\n              b = decomp[3],\n                  ax = decomp[2],\n                  a = decomp[0],\n                  x = decomp[1];\n\n              if (p === -1 && x.group !== PL && x.power.equals(2)) {\n                var b_is_positive = isInt(b) ? b > 0 : true; //we can now check for atan\n\n                if (x.group === S && x.power.equals(2) && b_is_positive) {\n                  ////then we have atan\n                  //abs is redundants since the sign appears in both denom and num.\n                  var unwrapAbs = function unwrapAbs(s) {\n                    var result = new Symbol(1);\n                    s.each(function (x) {\n                      result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\n                    });\n                    return result;\n                  };\n\n                  var A = a.clone(),\n                      B = b.clone();\n                  A = _.pow(A, new Symbol(1 / 2));\n                  B = _.pow(B, new Symbol(1 / 2)); //unwrap abs\n\n                  var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\n                      f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\n\n                  retval = _.divide(f, d);\n                } else if (x.group === S && x.isLinear()) {\n                  retval = _.divide(__.integration.poly_integrate(symbol), a);\n                } else {\n                  //1/(x^4+1)\n                  if (x.power.equals(4)) {\n                    //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\n                    var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\n                    var br = inBrackets; //apply rule: ax^4+b = (√ax^2+√2∜a∜bx+√b)(√ax^2-√2∜a∜bx+√b)\n                    //get quadratic factors\n\n                    A = _.parse(SQRT + br(a) + '*' + dx + '^2');\n                    B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\n                    C = _.parse(SQRT + br(b));\n                    f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\n                    f2 = _.add(_.subtract(A, B), C); //calculate numerators: [D+E, D-E] -> [√2*b^(3/4)+√b∜ax, √2*b^(3/4)-√b∜ax]\n\n                    D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\n                    E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx); //let F = 2b√2∜b\n\n                    F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4')); //calculate the factors\n\n                    L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\n                    L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\n                    retval = _.add(__.integrate(L1, dx, depth, opt), __.integrate(L2, dx, depth, opt));\n                  } else //let's try partial fractions\n                    retval = __.integration.partial_fraction(symbol, dx, depth);\n                }\n              } else if (p === -1 / 2) {\n                //detect asin and atan\n                if (x.group === S && x.power.equals(2)) {\n                  if (ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\n                    a.negate(); //it's asin\n\n                    if (b.isConstant() && a.isConstant()) {\n                      var d = _.symfunction(SQRT, [a.clone()]),\n                          d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\n\n                      retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\n                    } //I'm not sure about this one. I'm trusting Wolfram Alpha here\n                    else {\n                      var sqrt_a = _.symfunction(SQRT, [a]),\n                          sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\n\n                      retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\n                    }\n                  } else {\n                    /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\n                    __.integration.stop();\n                  }\n                } else {\n                  //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\n                  __.integration.stop();\n                }\n              } else if (p === 1 / 2 && x.power.equals(2) && a.greaterThan(0)) {\n                // TODO: Revisit\n                __.integration.stop();\n              } else {\n                if (x.isLinear() && x.group !== PL) retval = _.divide(__.integration.poly_integrate(symbol), a);else if (x.power.equals(2) && a.greaterThan(0)) {\n                  var sqa, sqb, aob, bsqi, n, integral, u, v, uv; //1/(a*x^2+b^2)^n\n                  //strip the value of b so b = 1\n\n                  sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\n\n                  sqb = _.parse(SQRT + inBrackets(b));\n                  aob = _.multiply(sqa.clone(), sqb.clone()).invert();\n                  bsqi = _.pow(b, new Symbol(symbol.power));\n                  uv = core.Utils.getU(symbol);\n                  u = _.multiply(aob, x.clone().toLinear());\n                  v = _.parse(ATAN + inBrackets(u)); //the conversion will be 1+tan(x)^2 -> sec(x)^2\n                  //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \n                  //then the remaining sec will be (n-1)*2;\n\n                  var n = (Math.abs(symbol.power) - 1) * 2; //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\n\n                  var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\n\n                  core.Utils.clearU(uv);\n                  return _.multiply(integral.sub(uv, v), bsqi);\n                } else {\n                  if (symbol.group !== CB && !symbol.power.lessThan(0)) {\n                    retval = __.integration.by_parts(symbol, dx, depth, opt);\n                  } else {\n                    var f = symbol.clone().toLinear();\n                    var factored = core.Algebra.Factor.factor(f);\n                    var was_factored = factored.toString() !== f.toString();\n\n                    if (core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\n                      try {\n                        var f1, fx, u, sq;\n                        sq = core.Algebra.sqComplete(f, dx);\n                        u = core.Utils.getU(f);\n                        f1 = sq.f.sub(sq.a, u);\n                        fx = _.pow(f1, _.parse(symbol.power));\n                        retval = __.integrate(fx, u).sub(u, sq.a);\n                      } catch (e) {\n                        __.integration.stop();\n                      }\n                    } else retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                  }\n                }\n              }\n\n              retval.multiplier = retval.multiplier.multiply(m);\n            }\n          } else if (g === FN) {\n            var arg = symbol.args[0],\n                m = symbol.multiplier.clone();\n            symbol.toUnitMultiplier();\n\n            var decomp = __.integration.decompose_arg(arg, dx); //easies way I can think of to get the coefficient and to make sure\n            //that the symbol is linear wrt dx. I'm not actually trying to get the \n            //derivative\n\n\n            var a = decomp[0],\n                x = decomp[1],\n                fname = symbol.fname; //log is a special case that can be handled with integration by parts\n\n            if (fname === LOG || fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear()) {\n              /*integration by parts */\n              var p = symbol.power.toString();\n              if (isInt(p)) depth = depth - p; //it needs more room to find the integral\n\n              if (!arg.isComposite()) retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));else {\n                //integral u du\n                var u = core.Utils.getU(symbol);\n\n                var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\n\n                var du = __.diff(arg, dx);\n\n                var u_du = _.multiply(f, du);\n\n                var integral = __.integrate(u_du, u, depth, opt);\n\n                retval = _.multiply(_.parse(m), integral.sub(u, arg));\n              }\n            } else if (fname === TAN && symbol.power.lessThan(0)) {\n              //convert to cotangent\n              var sym = symbol.clone();\n              sym.power.negate();\n              sym.fname = COT;\n              return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\n            } else {\n              if (!a.contains(dx, true) && symbol.isLinear()) {\n                //perform a deep search for safety\n                //first handle the special cases \n                if (fname === ABS) {\n                  //REVISIT **TODO**\n                  var x = _.divide(arg.clone(), a.clone());\n\n                  if (x.group === S && !x.power.lessThan(0)) {\n                    if (core.Utils.even(x.power)) {\n                      retval = __.integrate(arg, dx, depth);\n                    } else {\n                      var integrated = __.integrate(x, dx, depth);\n\n                      integrated.power = integrated.power.subtract(new Frac(1));\n                      retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\n                    }\n                  } else __.integration.stop();\n                } else {\n                  var ag = symbol.args[0].group,\n                      decomposed = __.integration.decompose_arg(arg, dx);\n\n                  if (!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc()) __.integration.stop();\n                  /**TODO**/\n                  //ASIN, ACOS, ATAN\n\n                  switch (fname) {\n                    case COS:\n                      retval = _.symfunction(SIN, [arg]);\n                      break;\n\n                    case SIN:\n                      retval = _.symfunction(COS, [arg]);\n                      retval.negate();\n                      break;\n\n                    case TAN:\n                      retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\n                      break;\n\n                    case SEC:\n                      retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\n                      break;\n\n                    case CSC:\n                      retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\n                      break;\n\n                    case COT:\n                      retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\n                      break;\n\n                    case SINH:\n                      retval = _.symfunction(COSH, [arg]);\n                      break;\n\n                    case COSH:\n                      retval = _.symfunction(SINH, [arg]);\n                      break;\n\n                    case TANH:\n                      retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\n                      break;\n\n                    case ASEC:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n\n                    case ACSC:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n\n                    case ACOT:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n                    //inverse htrig\n\n                    case ASECH:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n\n                    case ACSCH:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n\n                    case ACOTH:\n                      retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      break;\n                    //end inverse htrig\n                    //htrigh\n\n                    case SECH:\n                      retval = _.parse(format('atan(sinh({0}))', arg));\n                      break;\n\n                    case CSCH:\n                      retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\n                      break;\n\n                    case COTH:\n                      retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\n                      break;\n                    //end htrig\n\n                    case EXP:\n                      retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\n                      break;\n\n                    case 'S':\n                      var arg = symbol.args[0].clone(),\n                          dc = __.integration.decompose_arg(arg, dx),\n                          x_ = dc[1],\n                          a_ = dc[0];\n\n                      var b_ = dc[3];\n                      retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\n                      break;\n\n                    case 'C':\n                      var arg = symbol.args[0].clone(),\n                          dc = __.integration.decompose_arg(arg, dx),\n                          x_ = dc[1],\n                          a_ = dc[0];\n\n                      var b_ = dc[3];\n                      retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\n                      break;\n\n                    case 'erf':\n                      var arg = symbol.args[0].clone(),\n                          dc = __.integration.decompose_arg(arg, dx),\n                          x_ = dc[1],\n                          a_ = dc[0];\n\n                      retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\n                      break;\n\n                    case 'sign':\n                      retval = _.multiply(symbol.clone(), arg.clone());\n                      break;\n\n                    default:\n                      __.integration.stop();\n\n                  }\n\n                  retval = _.divide(retval, a);\n                }\n              } else if (x.isLinear()) {\n                if (fname === COS || fname === SIN) {\n                  var p = Number(symbol.power); //check to see if it's negative and then just transform it to sec or csc\n\n                  if (p < 0) {\n                    symbol.fname = fname === SIN ? CSC : SEC;\n                    symbol.invert().updateHash();\n                    retval = __.integrate(symbol, dx, depth);\n                  } else {\n                    var arg = symbol.args[0],\n                        rd = symbol.clone(),\n                        //cos^(n-1)\n                    rd2 = symbol.clone(),\n                        //cos^(n-2)\n                    q = new Symbol((p - 1) / p),\n                        //\n                    na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\n\n\n                    rd.power = rd.power.subtract(new Frac(1));\n                    rd2.power = rd2.power.subtract(new Frac(2));\n\n                    var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\n\n                    if (fname === SIN) t.negate();\n                    retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\n                  }\n                } //tan(x)^n or cot(x)^n\n                else if (fname === TAN || fname === COT) {\n                  //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                  if (symbol.args[0].isLinear(dx)) {\n                    var n = symbol.power.subtract(new Frac(1)).toString(),\n                        r = symbol.clone().toUnitMultiplier(),\n                        w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\n\n                    r.power = r.power.subtract(new Frac(2));\n                    if (r.power.equals(0)) r = _.parse(r);\n                    retval = _.subtract(w, __.integrate(r, dx, depth));\n                  }\n                } //sec(x)^n or csc(x)^n\n                else if (fname === SEC || fname === CSC) {\n                  //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\n                  var n1 = symbol.power.subtract(new Frac(1)).toString(),\n                      n2 = symbol.power.subtract(new Frac(2)).toString(),\n                      f2 = fname === SEC ? TAN : COT,\n                      r = symbol.clone().toUnitMultiplier(),\n                      parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\n                      w = _.parse(parse_str);\n\n                  r.power = r.power.subtract(new Frac(2));\n                  if (r.power.equals(0)) r = _.parse(r);\n                  retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\n                } else if ((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\n                  retval = __.integrate(symbol.fnTransform(), dx, depth);\n                } else __.integration.stop();\n              } else __.integration.stop();\n\n              retval.multiplier = retval.multiplier.multiply(m);\n            }\n          } else if (g === PL) {\n            retval = __.integration.partial_fraction(symbol, dx, depth);\n          } else if (g === CB) {\n            var den = symbol.getDenom();\n            if (den.group === S) symbol = _.expand(symbol); //separate the coefficient since all we care about are symbols containing dx\n\n            var coeff = symbol.stripVar(dx); //now get only those that apply\n\n            var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\n            //peform a correction for stripVar. This is a serious TODO!\n\n\n            if (coeff.contains(dx)) {\n              cfsymbol = _.multiply(cfsymbol, coeff);\n              coeff = new Symbol(1);\n            } //if we only have one symbol left then let's not waste time. Just pull the integral\n            //and let the chips fall where they may\n\n\n            if (cfsymbol.group !== CB) {\n              if (cfsymbol.equals(1)) {\n                return __.integrate(_.expand(symbol), dx, depth);\n              } //only factor for multivariate which are polynomials\n\n\n              if (cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\n                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\n              }\n\n              retval = __.integrate(cfsymbol, dx, depth);\n            } else {\n              //we collect the symbols and sort them descending group, descending power, descending alpabethically\n              var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\n                if (a.group === b.group) {\n                  if (Number(a.power) === Number(b.power)) if (a < b) return 1; //I want sin first\n                  else return -1;\n                  return b.power - a.power; //descending power\n                }\n\n                return b.group - a.group; //descending groups\n              }).map(function (x) {\n                var unwrapped = Symbol.unwrapSQRT(x, true);\n\n                if (unwrapped.fname === EXP) {\n                  return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\n                }\n\n                return unwrapped;\n              });\n              var l = symbols.length;\n\n              if (symbol.power < 0) {\n                if (l === 2) {\n                  return __.integrate(_.expand(symbol), dx, depth, opt);\n                }\n              } //otherwise the denominator is one lumped together symbol \n              else {\n                //generate an image for \n                if (l === 2) {\n                  //try u substitution\n                  try {\n                    retval = __.integration.u_substitution(symbols, dx);\n                  } catch (e) {\n                    /* failed :`(*/\n                    ;\n                  }\n\n                  if (!retval) {\n                    //no success with u substitution so let's try known combinations\n                    //are they two functions\n                    var g1 = symbols[0].group,\n                        g2 = symbols[1].group,\n                        sym1 = symbols[0],\n                        sym2 = symbols[1],\n                        fn1 = sym1.fname,\n                        fn2 = sym2.fname; //reset the symbol minus the coeff\n\n                    symbol = _.multiply(sym1.clone(), sym2.clone());\n\n                    if (g1 === FN && g2 === FN) {\n                      if (fn1 === LOG || fn2 === LOG) {\n                        retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\n                      } else {\n                        symbols.sort(function (a, b) {\n                          return b.fname > a.fname;\n                        });\n                        var arg1 = sym1.args[0]; //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\n\n                        if (!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S)) __.integration.stop();\n\n                        var decomp = __.integration.decompose_arg(arg1, dx);\n\n                        x = decomp[1], a = decomp[0];\n                        if (!x.isLinear()) //again... linear arguments only wrt x\n                          __.integration.stop(); //they have to have the same arguments and then we have cleared all the check to \n                        //make sure we can integrate FN & FN\n\n                        var arg2 = sym2.args[0]; //make sure that their argument matches\n\n                        if (arg1.equals(arg2)) {\n                          if (fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\n                            if (sym1.power.lessThan(0)) __.integration.stop(); //we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\n                            //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\n\n                            if (fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\n                              sym1.fname = TAN;\n                              sym1.updateHash();\n                              retval = __.integrate(sym1, dx, depth);\n                            } else {\n                              if (even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\n                                //transform sin^(2*n) to (1-cos^2)^n\n                                var n = Number(sym1.power) / 2,\n                                    new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\n\n                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                              } else if (even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\n                                //transform cos^(2*n) to (1-sin^2)^n\n                                var n = Number(sym1.power) / 2,\n                                    new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\n\n                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\n                              } else {\n                                var p1_even = core.Utils.even(sym1.power),\n                                    p2_even = core.Utils.even(sym2.power);\n                                retval = new Symbol(0);\n\n                                if (!p1_even || !p2_even) {\n                                  var u, r, trans; //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\n                                  //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\n\n                                  if (!p1_even) {\n                                    //u = sin(x)\n                                    u = sym2;\n                                    r = sym1;\n                                  } else {\n                                    u = sym1;\n                                    r = sym2;\n                                  } //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\n\n\n                                  var sign = u.fname === COS ? -1 : 1,\n                                      n = r.power,\n                                      //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \n                                  //even powers afterwards which can be transformed\n                                  k = (n - 1) / 2,\n                                      //make the transformation cos(x)^2 = 1 - sin(x)^2\n                                  trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\n                                      sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans))); //we can now just loop through and integrate each since it's now just a polynomial with functions\n\n\n                                  sym.each(function (x) {\n                                    retval = _.add(retval, __.integration.poly_integrate(x.clone()));\n                                  });\n                                } else {\n                                  //performs double angle transformation\n                                  var double_angle = function double_angle(symbol) {\n                                    var p = symbol.power,\n                                        k = p / 2,\n                                        e;\n                                    if (symbol.fname === COS) e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;else e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\n                                    return _.parse(e);\n                                  }; //they're both even so transform both using double angle identities and we'll just\n                                  //be able to integrate by the sum of integrals\n\n\n                                  var a = double_angle(sym1),\n                                      b = double_angle(sym2),\n                                      t = _.multiply(a, b);\n\n                                  var sym = _.expand(t);\n\n                                  sym.each(function (x) {\n                                    retval = _.add(retval, __.integrate(x, dx, depth));\n                                  });\n                                  return _.multiply(retval, coeff);\n                                }\n                              }\n                            }\n                          } //tan(x)*sec(x)^n \n                          else if (fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\n                            retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\n                          } else if (fn1 === TAN && fn2 === SEC && x.isLinear()) {\n                            //remaining: tan(x)^3*sec(x)^6\n                            if (sym1.isLinear() && sym2.isLinear()) {\n                              retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\n                            } else if (even(sym1.power)) {\n                              var p = Number(sym1.power) / 2; //transform tangent\n\n                              var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\n\n                              retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\n                            } else __.integration.stop();\n                          } else if (fn1 === SEC && fn2 === COS) {\n                            sym1.fname = COS;\n                            sym1.invert().updateHash();\n                            retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                          } else if (fn1 === SIN && fn2 === CSC) {\n                            sym2.fname = SIN;\n                            sym2.invert().updateHash();\n                            retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\n                          } //tan/cos\n                          else if (fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\n                            var t = _.multiply(sym1.fnTransform(), sym2);\n\n                            retval = __.integrate(_.expand(t), dx, depth);\n                          } else {\n                            var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\n\n                            retval = __.integrate(_.expand(t), dx, depth);\n                          }\n                        } //TODO: In progress\n                        else if ((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\n                          if (sym1.isLinear() && sym2.isLinear()) {\n                            //if in the form cos(a*x)*sin(b*x)\n                            if (sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\n                              //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\n                              var ax, bx;\n\n                              if (fn2 === SIN) {\n                                ax = sym1.args[0];\n                                bx = sym2.args[0];\n                              } else {\n                                bx = sym1.args[0];\n                                ax = sym2.args[0];\n                              } //make the transformation\n\n\n                              f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString())); //integrate it\n\n                              retval = __.integrate(f, dx, depth);\n                            } else {\n                              var transformed = trigTransform(symbols);\n                              retval = __.integrate(_.expand(transformed), dx, depth);\n                            }\n                          } else {\n                            var transformed = new Symbol(1);\n                            symbols.map(function (sym) {\n                              var s = sym.fnTransform();\n                              transformed = _.multiply(transformed, s);\n                            });\n\n                            var t = _.expand(transformed);\n\n                            retval = __.integrate(t, dx, depth);\n\n                            if (retval.hasIntegral()) {\n                              retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\n                            }\n                          }\n                        } else {\n                          __.integration.stop();\n                        }\n                      }\n                    } else if (g1 === FN && g2 === S) {\n                      var sym1_is_linear = sym1.isLinear();\n                      if (sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Ci', [sym1.args[0]]);else if (sym1.fname === COS && sym2.power.equals(-1)) {\n                        retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                      } else if (sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Chi', [sym1.args[0]]);else if (sym1.fname === COSH && sym2.power.equals(-1)) {\n                        retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                      } else if (sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Si', [sym1.args[0]]);else if (sym1.fname === SIN && sym2.power.equals(-1)) {\n                        retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                      } else if (sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1)) retval = _.symfunction('Shi', [sym1.args[0]]);else if (sym1.fname === SINH && sym2.power.equals(-1)) {\n                        retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\n                      } else if (sym1.fname === LOG && sym2.power.equals(-1)) {\n                        //log(x)^n/x = log(x)^(n+1)/(n+1)\n                        retval = __.integration.poly_integrate(sym1, dx, depth);\n                      } else if (sym1.fname === 'erf') {\n                        if (sym2.power.equals(1)) {\n                          var dc = __.integration.decompose_arg(sym1.args[0], dx),\n                              a_ = dc[0],\n                              x_ = dc[1],\n                              arg = sym1.args[0].toString();\n\n                          retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg));\n                        }\n                      } else {\n                        //since group S is guaranteed convergence we need not worry about tracking depth of integration\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      }\n                    } else if (g1 === EX && g2 === S) {\n                      var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\n\n                      if (sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\n                        retval = _.symfunction('Ei', [sym1.power.clone()]);\n                      } else if (fn1 === LOG && x.value === sym2.value) {\n                        retval = __.integration.poly_integrate(sym1, dx, depth);\n                      } else retval = __.integration.by_parts(symbol, dx, depth, opt);\n                    } else if (g1 === PL && g2 === S) {\n                      //first try to reduce the top\n                      if (sym2.value === sym1.value && sym1.power.equals(-1)) {\n                        //find the lowest power in the denominator\n                        var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols)); //get the lowest common value between denominator and numerator\n\n                        var pc = Math.min(pd, sym2.power); //reduce both denominator and numerator by that factor\n\n                        var factor = sym2.clone();\n                        factor.power = new Frac(pc);\n                        sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\n\n                        var t = new Symbol(0);\n                        sym1.each(function (x) {\n                          t = _.add(t, _.divide(x.clone(), factor.clone()));\n                        });\n                        t.multiplier = sym1.multiplier;\n                        symbol = _.divide(sym2, t);\n                      } else {\n                        symbol = _.expand(symbol);\n                      }\n\n                      retval = __.integration.partial_fraction(symbol, dx, depth);\n                    } else if (g1 === CP && g2 === S) {\n                      var f = sym1.clone().toLinear(),\n                          f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1); //handle cases x^(2*n)/sqrt(1-x^2)\n\n                      if (sym1.power.equals(-1 / 2)) {\n                        var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\n\n                        var a = decomp[0].negate(),\n                            x = decomp[1],\n                            b = decomp[3],\n                            p1 = Number(sym1.power),\n                            p2 = Number(sym2.power);\n\n                        if (isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\n                          //if the substitution \n                          var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)), _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])), _.pow(a.clone(), new Symbol(2)));\n\n                          c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\n\n                          var dummy = _.parse('sin(u)');\n\n                          dummy.power = dummy.power.multiply(sym2.power);\n\n                          var integral = __.integrate(dummy, 'u', depth);\n\n                          var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\n\n                          retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\n                        } else if (p1 === -1 / 2) {\n                          var u_transform = function u_transform(f, u) {\n                            var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\n\n                            if (!integral.hasIntegral()) return integral;\n                          };\n\n                          if (p2 === -1) {\n                            retval = u_transform(_.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(), 'sqrt(1-1/({0})^2)');\n                          } else if (p2 === -2) {\n                            //apply transformation to see if it matches asin(x)\n                            retval = u_transform(_.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(), 'sqrt(1-1/({0})^2)');\n                          }\n                        }\n                      } else if (sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\n                      } else if (!sym1.power.lessThan(0) && isInt(sym1.power)) {\n                        //sum of integrals\n                        var expanded = _.expand(sym1);\n\n                        retval = new Symbol(0);\n                        expanded.each(function (x) {\n                          if (x.group === PL) {\n                            x.each(function (y) {\n                              retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\n                            });\n                          } else retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\n                        });\n                      } else if (sym1.power.lessThan(-2)) {\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      } else if (sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\n                        var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                            a = decomp[0].negate(),\n                            x = decomp[1],\n                            b = decomp[3],\n                            fn = sym1.clone().toLinear();\n\n                        if (x.group !== PL && x.isLinear()) {\n                          var p = Number(sym2.power),\n                              du = '_u_',\n                              u = new Symbol(du),\n                              //pull the integral with the subsitution\n                          U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\n                              scope = {}; //generate a scope for resubbing the symbol\n\n\n                          scope[du] = fn;\n\n                          var U2 = _.parse(U, scope);\n\n                          retval = __.integrate(U2, dx, 0);\n                        } else if (sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\n                          //factor out coefficients\n                          var factors = new core.Algebra.Classes.Factors();\n                          sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\n                          var div = core.Algebra.divide(sym2, sym1); //it assumed that the result will be of group CB\n\n                          if (div.group !== CB) {\n                            retval = new Symbol(0);\n                            div.each(function (t) {\n                              retval = _.add(retval, __.integrate(t, dx, depth));\n                            }); //put back the factors\n\n                            factors.each(function (factor) {\n                              retval = _.divide(retval, factor);\n                            });\n                            retval = _.expand(retval);\n                          } else {\n                            //try something else\n                            retval = __.integration.by_parts(symbol, dx, depth, opt);\n                          }\n                        } else retval = __.integration.partial_fraction(symbol, dx, depth);\n                      } else {\n                        //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \n                        if (sym1.power.den.equals(2)) {\n                          //assume the function is in the form (a^2-b*x^n)^(m/2)\n                          var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\n                              //using the above definition\n                          a = dc[3],\n                              x = dc[1],\n                              b = dc[0],\n                              bx = dc[2];\n\n                          if (x.power.equals(2) && b.lessThan(0)) {\n                            //if n is even && b is negative\n                            //make a equal 1 so we can do a trig sub\n                            if (!a.equals(1)) {\n                              //divide a out of everything\n                              //move a to the coeff\n                              coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\n                            }\n\n                            var u = dx;\n\n                            var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\n                                du = _.symfunction(COS, [new Symbol(u)]),\n                                cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\n                                X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\n                                val = _.multiply(_.multiply(cosn, du), X),\n                                integral = __.integrate(val, u, depth); //but remember that u = asin(sqrt(b)*a*x)\n\n\n                            retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\n                          } else {\n                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\n                          }\n                        } else if (f_is_linear) {\n                          retval = __.integration.partial_fraction(symbol, dx, depth);\n                        }\n                      }\n                    } else if (sym1.isComposite() && sym2.isComposite()) {\n                      //sum of integrals\n                      retval = new Symbol(0);\n\n                      if (sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\n                        //combine and pull the integral of each\n                        var sym = _.expand(symbol);\n\n                        sym.each(function (x) {\n                          retval = _.add(retval, __.integrate(x, dx, depth));\n                        }, true);\n                      } else {\n                        var p1 = Number(sym1.power),\n                            p2 = Number(sym2.power);\n\n                        if (p1 < 0 && p2 > 0) {\n                          //swap\n                          var t = sym1;\n                          sym1 = sym2;\n                          sym2 = t;\n                        }\n\n                        if (p1 === -1 && p2 === -1) {\n                          retval = __.integration.partial_fraction(symbol, dx);\n                        } else {\n                          sym1.each(function (x) {\n                            var k = _.multiply(x, sym2.clone());\n\n                            var integral = __.integrate(k, dx, depth);\n\n                            retval = _.add(retval, integral);\n                          });\n                        }\n                      }\n                    } else if (g1 === CP && symbols[0].power.greaterThan(0)) {\n                      sym1 = _.expand(sym1);\n                      retval = new Symbol(0);\n                      sym1.each(function (x) {\n                        retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\n                      }, true);\n                    } else if (g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\n                      sym1 = sym1.fnTransform();\n                      retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\n                    } else if (g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\n                      if (g2 === FN && g1 === CP) {\n                        var t = sym1;\n                        sym1 = sym2;\n                        sym2 = t; //swap\n                      }\n\n                      var du, sym2_clone, p, q, sa, sb;\n                      du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\n                      sym2_clone = Symbol.unwrapSQRT(sym2, true);\n\n                      if (du.power.equals(sym2_clone.power)) {\n                        p = new Symbol(sym2.power);\n                        sa = du.clone().toLinear();\n                        sb = sym2.clone().toLinear();\n                        q = core.Algebra.divide(sa.toLinear(), sb);\n\n                        if (q.isConstant()) {\n                          var nq = _.pow(q, p.negate());\n\n                          retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\n                        }\n                      } else {\n                        retval = __.integration.by_parts(symbol, dx, depth, opt);\n                      }\n                    } else {\n                      var syma = sym1.clone().toLinear();\n                      var symb = sym2.clone().toLinear();\n\n                      if (g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx) && !syma.contains(dx) && !symb.contains(dx)) {\n                        retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))', syma.toString(), symb.toString(), sym1.power.multiplier.toString(), sym2.power.multiplier.toString(), dx));\n                      } else retval = __.integration.by_parts(symbol, dx, depth, opt);\n                    }\n                  }\n                } else if (l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\n                  var first = symbols[0];\n\n                  if (first.group === CP) {\n                    //TODO {support higher powers of x in the future}\n                    if (first.power.greaterThan(1)) first = _.expand(first);\n\n                    var r = _.multiply(symbols[1], symbols[2]);\n\n                    retval = new Symbol(0);\n                    first.each(function (x) {\n                      var t = _.multiply(x, r.clone());\n\n                      var intg = __.integrate(t, dx, depth);\n\n                      retval = _.add(retval, intg);\n                    }, true);\n                  } else {\n                    //try integration by parts although technically it will never work\n                    retval = __.integration.by_parts(symbol, dx, depth, opt);\n                  }\n                } else if (all_functions(symbols)) {\n                  var t = new Symbol(1);\n\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    t = _.multiply(t, symbols[i].fnTransform());\n                  }\n\n                  t = _.expand(t);\n                  retval = __.integrate(t, dx, depth);\n                } else {\n                  //one more go\n                  var transformed = trigTransform(symbols);\n                  retval = __.integrate(_.expand(transformed), dx, depth);\n                }\n              }\n            }\n\n            retval = _.multiply(retval, coeff);\n          } //if an integral was found then we return it\n\n\n          if (retval) return retval;\n        } catch (error) {\n          //do nothing if it's a NoIntegralFound error otherwise let it bubble\n          if (!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero)) throw error;\n        } //no symbol found so we return the integral again\n\n\n        return _.symfunction('integrate', [original_symbol, dt]);\n      }, false);\n    },\n    defint: function defint(symbol, from, to, dx) {\n      dx = dx || 'x'; //make x the default variable of integration\n\n      var get_value = function get_value(integral, vars, point) {\n        try {\n          return _.parse(integral, vars);\n        } catch (e) {\n          //it failed for some reason so return the limit\n          var lim = __.Limit.limit(integral, dx, point);\n\n          return lim;\n        }\n      };\n\n      var vars = core.Utils.variables(symbol),\n          hasTrig = symbol.hasTrig();\n      var retval, integral; // Fix #593 - Only assume the first variable if dx is not defined.\n\n      if (vars.length === 1 && !dx) dx = vars[0];\n\n      if (!hasTrig) {\n        integral = __.integrate(symbol, dx);\n      }\n\n      if (!hasTrig && !integral.hasIntegral()) {\n        var upper = {},\n            lower = {},\n            a,\n            b;\n        upper[dx] = to;\n        lower[dx] = from;\n        a = get_value(integral, upper, to, dx);\n        b = get_value(integral, lower, from, dx);\n        retval = _.subtract(a, b);\n      } else if (vars.length === 1 && from.isConstant() && to.isConstant()) {\n        var f = core.Utils.build(symbol);\n        retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\n      } else retval = _.symfunction('defint', [symbol, from, to, dx]);\n\n      return retval;\n    },\n    Limit: {\n      interval: function interval(start, end) {\n        return _.parse(format('[{0}, {1}]', start, end));\n      },\n      diverges: function diverges() {\n        return __.Limit.interval('-Infinity', 'Infinity');\n      },\n      divide: function divide(f, g, x, lim, depth) {\n        if (depth++ > Settings.max_lim_depth) {\n          return;\n        }\n\n        var fin = f.clone(),\n            gin = g.clone(); //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\n        //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\n        //the two-sided limit.\n        //Known limit\n\n        if (g.fname === ABS) {\n          var sign = f.sign();\n          var lim_sign = lim.sign();\n          if (lim.isInfinity) return _.multiply(new Symbol(sign), new Symbol(lim_sign));else if (lim.equals(0)) {\n            var fm = _.parse(f.multiplier);\n\n            var gm = _.parse(g.multiplier);\n\n            return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\n          } else {\n            //TODO: Support more limits\n            __.Limit.diverges();\n          }\n        }\n\n        var isInfinity = function isInfinity(L) {\n          if (core.Utils.isVector(L)) {\n            for (var i = 0; i < L.elements.length; i++) {\n              if (!L.elements[i].isInfinity) return false;\n            }\n\n            return true;\n          }\n\n          return L.isInfinity;\n        };\n\n        var equals = function equals(L, v) {\n          if (core.Utils.isVector(L)) {\n            return false;\n          }\n\n          return L.equals(v);\n        };\n\n        var retval;\n\n        do {\n          var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\n          var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth)); //if it's in indeterminate form apply L'Hospital's rule\n\n          var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0); //pull the derivatives\n\n          if (indeterminate) {\n            var ft = __.diff(f.clone(), x);\n\n            var gt = __.diff(g.clone(), x);\n\n            var t_symbol = _.expand(_.divide(ft, gt));\n\n            f = t_symbol.getNum();\n            g = t_symbol.getDenom();\n          }\n        } while (indeterminate); //REMEMBER: \n        //- 1/cos(x)\n        //n/0 is still possible since we only checked for 0/0\n\n\n        var den_is_zero = lim2.equals(0);\n        var p = Number(gin.power);\n\n        if (lim.isConstant(true) && den_is_zero) {\n          retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\n        } else if (den_is_zero) {\n          retval = __.Limit.diverges();\n        } else {\n          retval = _.divide(lim1, lim2);\n        }\n\n        return retval;\n      },\n      rewriteToLog: function rewriteToLog(symbol) {\n        var p = symbol.power.clone();\n        symbol.toLinear();\n        return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\n      },\n      getSubbed: function getSubbed(f, x, lim) {\n        var retval; //1. rewrite EX with base e\n\n        if (f.group === EX) {\n          f = __.rewriteToLog(f);\n        } //2. try simple substitution\n\n\n        try {\n          retval = f.sub(x, lim);\n        } catch (e) {\n          //Nope. No go, so just return the unsubbed function so we can test the limit instead.\n          retval = f;\n        }\n\n        return retval;\n      },\n      isInterval: function isInterval(limit) {\n        return core.Utils.isVector(limit);\n      },\n      isConvergent: function isConvergent(limit) {\n        //it's not convergent if it lies on the interval -Infinity to Infinity\n        if ( //It lies on the interval -Infinity to Infinity\n        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity || //We weren't able to calculate the limit\n        limit.containsFunction('limit')) {\n          return false; //Then no\n        }\n\n        return true; //It is\n      },\n      limit: function limit(symbol, x, lim, depth) {\n        //Simplify the symbol\n        if (symbol.isLinear() && symbol.isComposite()) {\n          //Apply sum of limits\n          var limit = new Symbol(0);\n          symbol.each(function (s) {\n            limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\n          }, true);\n          return limit;\n        }\n\n        ;\n        symbol = core.Algebra.Simplify.simplify(symbol);\n        depth = depth || 1;\n\n        if (depth++ > Settings.max_lim_depth) {\n          return;\n        } //store the multiplier\n\n\n        var m = _.parse(symbol.multiplier); //strip the multiplier\n\n\n        symbol.toUnitMultiplier();\n\n        try {\n          //https://en.wikipedia.org/wiki/List_of_limits\n          var retval; //we try the simplest option first where c is some limit\n          //lim a as x->c = a where c \n\n          if (symbol.isConstant(true)) {\n            retval = symbol;\n          } else {\n            var point = {};\n            point[x] = lim; //lim x as x->c = c where c\n\n            try {\n              //evaluate the function at the given limit\n              var t = _.parse(symbol.sub(x, lim), point); //a constant or infinity is known so we're done\n\n\n              if (t.isConstant(true) || t.isInfinity) retval = t;\n            } catch (e) {\n              /*Nothing. Maybe we tried to divide by zero.*/\n            }\n\n            ;\n\n            if (!retval) {\n              //split the symbol in the numerator and the denominator\n              var num = symbol.getNum();\n              var den = symbol.getDenom();\n\n              if (den.isConstant(true)) {\n                //We still don't have a limit so we generate tests.\n                if (symbol.group === EX) {\n                  //https://en.wikipedia.org/wiki/List_of_limits\n                  //Speed boost for exponentials by detecting patterns\n                  var f = symbol.clone().toLinear();\n                  var p = symbol.power.clone();\n\n                  var _num = f.getNum();\n\n                  var _den = f.getDenom();\n\n                  var fn = core.Utils.decompose_fn(_den, x, true); //start detection of pattern (x/(x+1))^x\n\n                  if (_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\n                    retval = _.parse(format('(1/e^({0}))', fn.b));\n                  } else {\n                    var symbol_ = __.Limit.rewriteToLog(symbol.clone()); //get the base\n\n\n                    var pow = symbol_.power.clone();\n                    var base = symbol_.clone().toLinear();\n\n                    var lim_base = __.Limit.limit(base, x, lim, depth);\n\n                    var lim_pow = __.Limit.limit(pow, x, lim, depth);\n\n                    retval = _.pow(lim_base, lim_pow);\n                  }\n                } else if (symbol.group === FN && symbol.args.length === 1) {\n                  var evaluates; //Squeeze theorem lim f(g(x)) = lim f(lim g))\n\n                  var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\n\n                  if (core.Utils.isVector(arg)) {\n                    //get the limit over that interval\n                    retval = arg.map(function (e) {\n                      var clone = symbol.clone();\n                      clone.args[0] = e;\n                      return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\n                    });\n                    return _.multiply(m, retval);\n                  } //if the argument is constant then we're done\n                  else if (arg.isConstant(true)) {\n                    //double check that it evaluates\n                    var trial = _.symfunction(symbol.fname, [arg]); //trial evaluation\n\n\n                    try {\n                      evaluate(trial);\n                      evaluates = true;\n                    } catch (e) {\n                      evaluates = false;\n                    }\n                  }\n\n                  if (evaluates) {\n                    retval = trial;\n                  } else {\n                    //if the limit converges. We'll deal with non-convergent ones later\n                    if (__.Limit.isConvergent(arg)) {\n                      if (symbol.fname === LOG) {\n                        switch (arg.toString()) {\n                          //lim -> 0\n                          case '0':\n                            retval = Symbol.infinity().negate();\n                            break;\n\n                          case 'Infinity':\n                            retval = Symbol.infinity();\n                            break;\n\n                          case '-Infinity':\n                            retval = Symbol.infinity();\n                            break;\n                        }\n                      } else if ((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\n                        retval = __.Limit.interval(-1, 1);\n                      } else if (symbol.fname === TAN) {\n                        var s_arg = symbol.args[0];\n                        var n = s_arg.getNum();\n                        var d = s_arg.getDenom();\n                        var pi = n.toUnitMultiplier();\n\n                        if (lim.isInfinity || pi.equals('pi') && d.equals(2)) {\n                          retval = divergent();\n                        }\n                      } else if (symbol.fname === Settings.FACTORIAL) {\n                        if (arg.isInfinity) return Symbol.infinity();\n                      }\n                    }\n                  }\n                } else if (symbol.group === S) {\n                  if (symbol.power > 0) //these functions always converge to the limit\n                    return _.parse(symbol, point);else {\n                    //we're dealing with 1/x^n but remember that infinity has already been dealt\n                    //with by substitution\n                    if (core.Utils.even(symbol.power)) {\n                      //even powers converge to infinity\n                      retval = Symbol.infinity();\n                    } else {\n                      //odd ones don't\n                      retval = __.Limit.diverges();\n                    }\n                  }\n                } else if (symbol.group === CB) {\n                  var lim1, lim2; //loop through all the symbols\n                  //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\n                  //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\n\n                  var symbols = symbol.collectSymbols().sort(function (a, b) {\n                    return a.group - b.group;\n                  });\n                  var f = symbols.pop(); //calculate the first limit so we can keep going down the list\n\n                  lim1 = evaluate(__.Limit.limit(f, x, lim, depth)); //reduces all the limits one at a time\n\n                  while (symbols.length) {\n                    //get the second limit\n                    var g = symbols.pop(); //get the limit of g\n\n                    lim2 = evaluate(__.Limit.limit(g, x, lim, depth)); //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\n\n                    if (lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2)) {\n                      if (g.containsFunction(LOG)) {\n                        //swap them\n                        g = [f, f = g][0];\n                      } //invert the symbol\n\n\n                      g.invert(); // Product of infinities\n\n                      if (lim1.isInfinity && lim2.isInfinity) {\n                        lim1 = Symbol.infinity();\n                      } else {\n                        lim1 = __.Limit.divide(f, g, x, lim, depth);\n                      }\n                    } else {\n                      //lim f*g = (lim f)*(lim g)\n                      lim1 = _.multiply(lim1, lim2); //let f*g equal f and h equal g \n\n                      f = _.multiply(f, g);\n                    }\n                  } //Done, lim1 is the limit we're looking for     \n\n\n                  retval = lim1;\n                } else if (symbol.isComposite()) {\n                  var _lim;\n\n                  if (!symbol.isLinear()) symbol = _.expand(symbol); //Apply lim f+g = (lim f)+(lim g)\n\n                  retval = new Symbol(0);\n                  var symbols = symbol.collectSymbols().sort(function (a, b) {\n                    return b.group - a.group;\n                  });\n                  var _symbols = []; //Analyze the functions first\n\n                  var fns = new Symbol(0);\n\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    var sym = symbols[i].clone();\n\n                    if (sym.group === FN || sym.group === CB && sym.hasFunc()) {\n                      fns = _.add(fns, sym);\n                    } else _symbols.push(sym);\n                  }\n\n                  _symbols.unshift(fns); //make sure that we didn't just repackage the exact same symbol\n\n\n                  if (_symbols.length !== 1) {\n                    symbols = _symbols;\n                  }\n\n                  for (var i = 0, l = symbols.length; i < l; i++) {\n                    var sym = symbols[i]; //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\n\n                    try {\n                      _lim = __.Limit.limit(sym, x, lim, depth);\n                    } catch (e) {\n                      _lim = __.Limit.diverges();\n                    }\n\n                    try {\n                      retval = _.add(retval, _lim);\n                    } catch (e) {\n                      if (depth++ > Settings.max_lim_depth) {\n                        return;\n                      }\n\n                      ;\n                      retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\n                    }\n                  }\n                }\n              } else {\n                retval = __.Limit.divide(num, den, x, lim, depth);\n              }\n            }\n          } //if we still don't have a solution\n\n\n          if (!retval) //return it symbolically\n            retval = _.symfunction('limit', [symbol, x, lim]);\n        } catch (e) {\n          //if all else fails return the symbolic function\n          retval = _.symfunction('limit', [symbol, x, lim]);\n        }\n\n        return _.multiply(m, retval);\n      }\n    },\n    Fresnel: {\n      S: function S(x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n\n        return _.symfunction('S', arguments);\n      },\n      C: function C(x) {\n        if (x.isConstant(true)) {\n          return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\n        }\n\n        return _.symfunction('C', arguments);\n      }\n    }\n  };\n\n  nerdamer.register([{\n    name: 'diff',\n    visible: true,\n    numargs: [1, 3],\n    build: function build() {\n      return __.diff;\n    }\n  }, {\n    name: 'sum',\n    visible: true,\n    numargs: 4,\n    build: function build() {\n      return __.sum;\n    }\n  }, {\n    name: 'product',\n    visible: true,\n    numargs: 4,\n    build: function build() {\n      return __.product;\n    }\n  }, {\n    name: 'integrate',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      return __.integrate;\n    }\n  }, {\n    name: 'defint',\n    visible: true,\n    numargs: [3, 4],\n    build: function build() {\n      return __.defint;\n    }\n  }, {\n    name: 'S',\n    visible: true,\n    numargs: 1,\n    build: function build() {\n      return __.Fresnel.S;\n    }\n  }, {\n    name: 'C',\n    visible: true,\n    numargs: 1,\n    build: function build() {\n      return __.Fresnel.C;\n    }\n  }, {\n    name: 'limit',\n    visible: true,\n    numargs: [3, 4],\n    build: function build() {\n      return __.Limit.limit;\n    }\n  }]); //link registered functions externally\n\n  nerdamer.updateAPI();\n})();","map":{"version":3,"names":["module","nerdamer","require","core","getCore","_","PARSER","Frac","Settings","isSymbol","Utils","FN","groups","Symbol","text","inBrackets","isInt","format","even","evaluate","N","S","PL","CP","CB","EX","P","LOG","EXP","ABS","SQRT","SIN","COS","TAN","SEC","CSC","COT","ASIN","ACOS","ATAN","ASEC","ACSC","ACOT","SINH","COSH","TANH","CSCH","SECH","COTH","ASECH","ACSCH","ACOTH","NoIntegralFound","msg","message","prototype","Error","hasIntegral","containsFunction","fnTransform","group","retval","a","args","m","multiplier","sym","clone","toUnitMultiplier","isLinear","fname","parse","power","equals","lessThan","negate","n","double_angle","pow","toLinear","transformed","expand","each","s","t","add","multiply","hasTrig","isConstant","in_trig","in_inverse_trig","symbols","x","Expression","symbol","toCommonDenominator","isComposite","denominator","numerator","getDenom","num","getNum","den","factor","divide","Algebra","inv_trig_fns","indexOf","trig_fns","in_htrig","Matrix","jacobian","eqns","vars","arrayGetVariables","forEach","v","i","eq","j","e","Calculus","diff","set","max","abs","gt","cMatrix","value","all_functions","arr","l","length","cosAsinBtransform","cosAsinBtranform","symbol1","symbol2","b","cosAsinAtransform","cosAsinAtranform","Number","sinAsinBtransform","trigTransform","map","toString","integration_depth","max_lim_depth","__","version","sum","fn","index","start","end","exceptions","NerdamerTypeError","isNumericSymbol","modifier","block","f","subs","ans","symfunction","arguments","product","wrt","nth","isVector","vector","Vector","elements","push","isMatrix","matrix","d","undefined","variables","sp","derive","polydiff","contains","subtract","g","cp","product_rule","qdiff","arg","String","x_","y_","LOG10","c","result","updateHash","val","altVal","collectSymbols","df","integration","u_substitution","dx","try_combo","q","do_fn_sub","subbed","integrate","u","sub","g1","g2","Q","poly_integrate","p","dc","decompose_arg","xp","dc2","new_val","by_parts","integrated","A","Factor","B","f1","f2","toDecimal","stop","warn","partial_fraction","input","depth","opt","partial_fractions","PartFrac","partfrac","get_udv","parts","setSymbol","unwrapSQRT","dv","part","trig_sub","ax","greaterThan","getU","du","integral","clearU","o","previous","udv","vdu","uv","integral_vdu","vdu_s","stripVar","isE","is_cyclic","pop","rem","decompose_fn","original_symbol","dt","isNaN","error","previousGroup","PARENTHESIS","aa","decomp","b_is_positive","unwrapAbs","C","D","E","F","f3","f4","L1","L2","br","d2","sqrt_a","sqrt_ax","sqa","sqb","aob","bsqi","invert","Math","factored","was_factored","degree","fx","sq","sqComplete","u_du","ag","decomposed","hasFunc","a_","b_","rd","rd2","na","r","w","n1","n2","parse_str","coeff","cfsymbol","isPoly","sort","unwrapped","sym1","sym2","fn1","fn2","arg1","arg2","new_sym","p1_even","p2_even","trans","sign","k","bx","sym1_is_linear","pd","min","apply","keys","pc","f_is_linear","p1","p2","dummy","bksub","u_transform","sqrt","expanded","y","U","scope","U2","factors","Classes","Factors","coeffFactor","div","cosn","X","sym2_clone","sa","sb","nq","syma","symb","first","intg","DivisionByZero","defint","from","to","get_value","point","lim","Limit","limit","upper","lower","build","Math2","num_integrate","interval","diverges","fin","gin","lim_sign","isInfinity","fm","gm","L","lim1","lim2","indeterminate","ft","t_symbol","den_is_zero","infinity","rewriteToLog","getSubbed","isInterval","isConvergent","Simplify","simplify","_num","_den","isOne","symbol_","base","lim_base","lim_pow","evaluates","trial","s_arg","pi","divergent","FACTORIAL","_lim","_symbols","fns","unshift","Fresnel","register","name","visible","numargs","updateAPI"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/nerdamer/Calculus.js"],"sourcesContent":["/* global module */\r\n\r\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\nif((typeof module) !== 'undefined' && typeof nerdamer === 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Algebra.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            Frac = core.Frac,\r\n            Settings = core.Settings,\r\n            isSymbol = core.Utils.isSymbol,\r\n            FN = core.groups.FN,\r\n            Symbol = core.Symbol,\r\n            text = core.Utils.text,\r\n            inBrackets = core.Utils.inBrackets,\r\n            isInt = core.Utils.isInt,\r\n            format = core.Utils.format,\r\n            even = core.Utils.even,\r\n            evaluate = core.Utils.evaluate,\r\n            N = core.groups.N,\r\n            S = core.groups.S,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            EX = core.groups.EX,\r\n            P = core.groups.P,\r\n            LOG = Settings.LOG,\r\n            EXP = 'exp',\r\n            ABS = 'abs',\r\n            SQRT = 'sqrt',\r\n            SIN = 'sin',\r\n            COS = 'cos',\r\n            TAN = 'tan',\r\n            SEC = 'sec',\r\n            CSC = 'csc',\r\n            COT = 'cot',\r\n            ASIN = 'asin',\r\n            ACOS = 'acos',\r\n            ATAN = 'atan',\r\n            ASEC = 'asec',\r\n            ACSC = 'acsc',\r\n            ACOT = 'acot',\r\n            SINH = 'sinh',\r\n            COSH = 'cosh',\r\n            TANH = 'tanh',\r\n            CSCH = 'csch',\r\n            SECH = 'sech',\r\n            COTH = 'coth',\r\n            ASECH = 'asech',\r\n            ACSCH = 'acsch',\r\n            ACOTH = 'acoth';\r\n\r\n    //custom errors\r\n    function NoIntegralFound(msg) {\r\n        this.message = msg || \"\";\r\n    }\r\n    NoIntegralFound.prototype = new Error();\r\n\r\n    //Preparations\r\n    Symbol.prototype.hasIntegral = function () {\r\n        return this.containsFunction('integrate');\r\n    };\r\n    //transforms a function\r\n    Symbol.prototype.fnTransform = function () {\r\n        if(this.group !== FN)\r\n            return this;\r\n        var retval, a = this.args[0];\r\n        var m = new Symbol(this.multiplier);\r\n        var sym = this.clone().toUnitMultiplier();\r\n        if(this.isLinear()) {\r\n            switch(this.fname) {\r\n                case SINH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\r\n                    break;\r\n                case TAN:\r\n                    retval = _.parse(format('sin({0})/cos({0})', a));\r\n                    break;\r\n                case CSC:\r\n                    retval = _.parse(format('1/sin({0})', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('1/cos({0})', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.power.equals(2)) {\r\n            switch(this.fname) {\r\n                case SIN:\r\n                    retval = _.parse(format('1/2-cos(2*({0}))/2', a));\r\n                    break;\r\n                case COS:\r\n                    retval = _.parse(format('1/2+cos(2*({0}))/2', a));\r\n                    break;\r\n                case TAN:\r\n                    //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\r\n                    retval = _.parse(format('sin({0})^2/cos({0})^2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case SINH:\r\n                    retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.fname === SEC) {\r\n            retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === CSC) {\r\n            retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === TAN) {\r\n            if(this.power.lessThan(0)) {\r\n                retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\r\n            }\r\n            else {\r\n                retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\r\n            }\r\n        }\r\n        else if(this.fname === SIN && this.power.lessThan(0)) {\r\n            retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === COS && this.power.lessThan(0)) {\r\n            retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === SIN && this.power.equals(3)) {\r\n            retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\r\n        }\r\n        else if(this.fname === COS && this.power.equals(3)) {\r\n            retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\r\n        }\r\n        //cos(a*x)^(2*n) or sin(a*x)^(2*n)\r\n        else if((this.fname === COS || this.fname === SIN) && even(this.power)) {\r\n            var n = this.power / 2;\r\n            //convert to a double angle\r\n            var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();\r\n            //raise to the n and expand\r\n            var transformed = _.expand(_.pow(double_angle, _.parse(n)));\r\n\r\n            retval = new Symbol(0);\r\n\r\n            transformed.each(function (s) {\r\n                var t = s.fnTransform();\r\n                retval = _.add(retval, t);\r\n            }, true);\r\n        }\r\n        else\r\n            retval = sym;\r\n\r\n        return _.multiply(retval, m);\r\n    };\r\n\r\n    Symbol.prototype.hasTrig = function () {\r\n        if(this.isConstant(true) || this.group === S)\r\n            return false;\r\n        if(this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))\r\n            return true;\r\n        if(this.symbols) {\r\n            for(var x in this.symbols)\r\n                if(this.symbols[x].hasTrig())\r\n                    return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    core.Expression.prototype.hasIntegral = function () {\r\n        return this.symbol.hasIntegral();\r\n    };\r\n    /**\r\n     * Attempts to rewrite a symbol under one common denominator\r\n     * @param {Symbol} symbol \r\n     */\r\n    core.Utils.toCommonDenominator = function (symbol) {\r\n        //transform x/a+x -> (ax+x)/a\r\n        if(symbol.isComposite() && symbol.isLinear()) {\r\n            var m = new Symbol(symbol.multiplier);\r\n            var denominator = new Symbol(1);\r\n            var numerator = new Symbol(0);\r\n            symbol.each(function (x) {\r\n                denominator = _.multiply(denominator, x.getDenom());\r\n            }, true);\r\n\r\n            //remove the denomitor in each term\r\n            symbol.each(function (x) {\r\n                var num = x.getNum();\r\n                var den = x.getDenom();\r\n                var factor = _.multiply(num, _.divide(denominator.clone(), den));\r\n                numerator = _.add(numerator, factor);\r\n            });\r\n            var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\r\n            return retval;\r\n        }\r\n        return symbol;\r\n    };\r\n    //A function to check if a function name is an inverse trig function\r\n    core.Utils.in_inverse_trig = function (x) {\r\n        var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\r\n        return inv_trig_fns.indexOf(x) !== -1;\r\n    };\r\n    //A function to check if a function name is a trig function\r\n    core.Utils.in_trig = function (x) {\r\n        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    core.Utils.in_htrig = function (x) {\r\n        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    // Matrix functions\r\n    core.Matrix.jacobian = function (eqns, vars) {\r\n        var jacobian = new core.Matrix();\r\n        //get the variables if not supplied\r\n        if(!vars) {\r\n            vars = core.Utils.arrayGetVariables(eqns);\r\n        }\r\n\r\n        vars.forEach(function (v, i) {\r\n            eqns.forEach(function (eq, j) {\r\n                var e = core.Calculus.diff(eq.clone(), v);\r\n                jacobian.set(j, i, e);\r\n            });\r\n        });\r\n\r\n        return jacobian;\r\n    };\r\n\r\n    core.Matrix.prototype.max = function () {\r\n        var max = new Symbol(0);\r\n        this.each(function (x) {\r\n            var e = x.abs();\r\n            if(e.gt(max))\r\n                max = e;\r\n        });\r\n        return max;\r\n    };\r\n\r\n    core.Matrix.cMatrix = function (value, vars) {\r\n        var m = new core.Matrix();\r\n        //make an initial guess\r\n        vars.forEach(function (v, i) {\r\n            m.set(i, 0, _.parse(value));\r\n        });\r\n        return m;\r\n    };\r\n\r\n    var all_functions = core.Utils.all_functions = function (arr) {\r\n        for(var i = 0, l = arr.length; i < l; i++)\r\n            if(arr[i].group !== FN)\r\n                return false;\r\n        return true;\r\n    },\r\n            cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\r\n            },\r\n            cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\r\n                //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\r\n                //we technically know how to do this transform but more is needed for correct output\r\n                if(Number(symbol2.power) !== 1)\r\n                    return _.multiply(symbol1, symbol2);\r\n                var a;\r\n                a = symbol1.args[0];\r\n                return _.parse(format('(sin(2*({0})))/2', a));\r\n            },\r\n            sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\r\n            },\r\n            trigTransform = core.Utils.trigTransform = function (arr) {\r\n                var map = {}, symbol, t,\r\n                        retval = new Symbol(1);\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    symbol = arr[i];\r\n\r\n                    if(symbol.group === FN) {\r\n                        var fname = symbol.fname;\r\n\r\n                        if(fname === COS && map[SIN]) {\r\n\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[SIN]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[SIN]);\r\n                            }\r\n                            delete map[SIN];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[COS]) {\r\n                            if(map[COS].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[COS]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[COS]);\r\n                            }\r\n                            delete map[COS];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[SIN]) {\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = sinAsinBtransform(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n                            else {\r\n                                //This should actually be redundant code but let's put just in case\r\n                                t = _.multiply(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n\r\n                            retval = t;\r\n                        }\r\n                        else {\r\n                            map[fname] = symbol;\r\n                        }\r\n                    }\r\n                    else\r\n                        retval = _.multiply(retval, symbol);\r\n                }\r\n\r\n                //put back the remaining functions\r\n                for(var x in map)\r\n                    retval = _.multiply(retval, map[x]);\r\n\r\n                return retval;\r\n\r\n            };\r\n\r\n    core.Settings.integration_depth = 10;\r\n\r\n    core.Settings.max_lim_depth = 10;\r\n\r\n    var __ = core.Calculus = {\r\n\r\n        version: '1.4.6',\r\n\r\n        sum: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                start = Number(start);\r\n                end = Number(end);\r\n                retval = core.Utils.block(modifier, function () {\r\n                    var f = fn.text(),\r\n                            subs = {'~': true}, //lock subs. Is this even being used?\r\n                            retval = new core.Symbol(0);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        var ans = _.parse(f, subs);\r\n                        retval = _.add(retval, ans);\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('sum', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        product: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                retval = core.Utils.block(modifier, function () {\r\n                    start = Number(start);\r\n                    end = Number(end.multiplier);\r\n\r\n                    var f = fn.text(),\r\n                            subs = {},\r\n                            retval = new core.Symbol(1);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        retval = _.multiply(retval, _.parse(f, subs));\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('product', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        diff: function (symbol, wrt, nth) {\r\n            if(core.Utils.isVector(symbol)) {\r\n                var vector = new core.Vector([]);\r\n                symbol.each(function (x) {\r\n                    vector.elements.push(__.diff(x, wrt, nth));\r\n                });\r\n                return vector;\r\n            }\r\n            else if(core.Utils.isMatrix(symbol)) {\r\n                var matrix = new core.Matrix();\r\n                symbol.each(function (x, i, j) {\r\n                    matrix.set(i, j, __.diff(x, wrt, nth));\r\n                });\r\n                return matrix;\r\n            }\r\n\r\n            var d = isSymbol(wrt) ? wrt.text() : wrt;\r\n            //the nth derivative\r\n            nth = isSymbol(nth) ? nth.multiplier : nth || 1;\r\n\r\n            if(d === undefined)\r\n                d = core.Utils.variables(symbol)[0];\r\n\r\n            //unwrap sqrt\r\n            if(symbol.group === FN && symbol.fname === SQRT) {\r\n                var s = symbol.args[0],\r\n                        sp = symbol.power.clone();\r\n                //these groups go to zero anyway so why waste time?\r\n                if(s.group !== N || s.group !== P) {\r\n                    s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\r\n                    s.multiplier = s.multiplier.multiply(symbol.multiplier);\r\n                }\r\n\r\n                symbol = s;\r\n            }\r\n\r\n            if(symbol.group === FN && !isSymbol(symbol.power)) {\r\n                var a = derive(_.parse(symbol));\r\n                var b = __.diff(symbol.args[0].clone(), d);\r\n                symbol = _.multiply(a, b);//chain rule\r\n            }\r\n            else {\r\n                symbol = derive(symbol);\r\n            }\r\n\r\n            if(nth > 1) {\r\n                nth--;\r\n                symbol = __.diff(symbol, wrt, nth);\r\n            }\r\n\r\n            return symbol;\r\n\r\n            // Equivalent to \"derivative of the outside\".\r\n            function polydiff(symbol) {\r\n                if(symbol.value === d || symbol.contains(d, true)) {\r\n                    symbol.multiplier = symbol.multiplier.multiply(symbol.power);\r\n                    symbol.power = symbol.power.subtract(new Frac(1));\r\n                    if(symbol.power.equals(0)) {\r\n                        symbol = Symbol(symbol.multiplier);\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            }\r\n            \r\n            function derive(symbol) {\r\n                var g = symbol.group, a, b, cp;\r\n\r\n                if(g === N || g === S && symbol.value !== d || g === P) {\r\n                    symbol = Symbol(0);\r\n                }\r\n                else if(g === S) {\r\n                    symbol = polydiff(symbol);\r\n                }\r\n                else if(g === CB) {\r\n                    var m = symbol.multiplier.clone();\r\n                    symbol.toUnitMultiplier();\r\n                    var retval = _.multiply(product_rule(symbol), polydiff(symbol));\r\n                    retval.multiplier = retval.multiplier.multiply(m);\r\n                    return retval;\r\n                }\r\n                else if(g === FN && symbol.power.equals(1)) {\r\n                    // Table of known derivatives\r\n                    switch(symbol.fname) {\r\n                        case LOG:\r\n                            cp = symbol.clone();\r\n                            symbol = symbol.args[0].clone();//get the arguments\r\n                            symbol.power = symbol.power.negate();\r\n                            symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\r\n                            break;\r\n                        case COS:\r\n                            //cos -> -sin\r\n                            symbol.fname = SIN;\r\n                            symbol.multiplier.negate();\r\n                            break;\r\n                        case SIN:\r\n                            //sin -> cos\r\n                            symbol.fname = COS;\r\n                            break;\r\n                        case TAN:\r\n                            //tan -> sec^2\r\n                            symbol.fname = SEC;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SEC:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, TAN);\r\n                            break;\r\n                        case CSC:\r\n                            symbol = qdiff(symbol, '-cot');\r\n                            break;\r\n                        case COT:\r\n                            symbol.fname = CSC;\r\n                            symbol.multiplier.negate();\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case ASIN:\r\n                            symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ACOS:\r\n                            symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ATAN:\r\n                            symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ABS:\r\n                            m = symbol.multiplier.clone();\r\n                            symbol.toUnitMultiplier();\r\n                            //depending on the complexity of the symbol it's easier to just parse it into a new symbol\r\n                            //this should really be readdressed soon\r\n                            b = symbol.args[0].clone();\r\n                            b.toUnitMultiplier();\r\n                            symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\r\n                            symbol.multiplier = m;\r\n                            break;\r\n                        case 'parens':\r\n                            //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\r\n                            //1*g'\r\n                            symbol = Symbol(1);\r\n                            break;\r\n                        case 'cosh':\r\n                            //cosh -> -sinh\r\n                            symbol.fname = 'sinh';\r\n                            break;\r\n                        case 'sinh':\r\n                            //sinh -> cosh\r\n                            symbol.fname = 'cosh';\r\n                            break;\r\n                        case TANH:\r\n                            //tanh -> sech^2\r\n                            symbol.fname = SECH;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SECH:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, '-tanh');\r\n                            break;\r\n                        case CSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\r\n                            break;\r\n                        case COTH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-csch(' + arg + ')^2');\r\n                            break;\r\n                        case 'asinh':\r\n                            symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'acosh':\r\n                            symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'atanh':\r\n                            symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ASECH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOTH:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\r\n                            break;\r\n                        case ACSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ASEC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACSC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOT:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\r\n                            break;\r\n                        case 'S':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'C':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'Si':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Shi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ci':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Chi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ei':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Li':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\r\n                            break;\r\n                        case 'erf':\r\n                            symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\r\n                            break;\r\n                        case 'atan2':\r\n                            var x_ = String(symbol.args[0]),\r\n                                    y_ = String(symbol.args[1]);\r\n                            symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\r\n                            break;\r\n                        case 'sign':\r\n                            symbol = new Symbol(0);\r\n                            break;\r\n                        case 'sinc':\r\n                            symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\r\n                            break;\r\n                        case Settings.LOG10:\r\n                            symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\r\n                            break;\r\n                        default:\r\n                            symbol = _.symfunction('diff', [symbol, wrt]);\r\n                    }\r\n                }\r\n                else if(g === EX || g === FN && isSymbol(symbol.power)) {\r\n                    var value;\r\n                    if(g === EX) {\r\n                        value = symbol.value;\r\n                    }\r\n                    else if(g === FN && symbol.contains(d)) {\r\n                        value = symbol.fname + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    else {\r\n                        value = symbol.value + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\r\n                    b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\r\n                    symbol = _.multiply(symbol, b);\r\n                }\r\n                else if(g === FN && !symbol.power.equals(1)) {\r\n                    b = symbol.clone();\r\n                    b.toLinear();\r\n                    b.toUnitMultiplier();\r\n                    symbol = _.multiply(polydiff(symbol.clone()), derive(b));\r\n                }\r\n                else if(g === CP || g === PL) {\r\n                    // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\r\n                    var c = symbol.clone();\r\n                    var result = new Symbol(0);\r\n                    for(var x in symbol.symbols) {\r\n                        result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\r\n                    }\r\n                    symbol = _.multiply(polydiff(c), result);\r\n                }\r\n\r\n                symbol.updateHash();\r\n\r\n                return symbol;\r\n            }\r\n            ;\r\n\r\n            function qdiff(symbol, val, altVal) {\r\n                return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\r\n            }\r\n            ;\r\n\r\n            function product_rule(symbol) {\r\n                //grab all the symbols within the CB symbol\r\n                var symbols = symbol.collectSymbols(),\r\n                        result = new Symbol(0),\r\n                        l = symbols.length;\r\n                //loop over all the symbols\r\n                for(var i = 0; i < l; i++) {\r\n                    var df = __.diff(symbols[i].clone(), d);\r\n                    for(var j = 0; j < l; j++) {\r\n                        //skip the symbol of which we just pulled the derivative\r\n                        if(i !== j) {\r\n                            //multiply out the remaining symbols\r\n                            df = _.multiply(df, symbols[j].clone());\r\n                        }\r\n                    }\r\n                    //add the derivative to the result\r\n                    result = _.add(result, df);\r\n                }\r\n                return result; //done\r\n            }\r\n            ;\r\n        },\r\n        integration: {\r\n            u_substitution: function (symbols, dx) {\r\n                function try_combo(a, b, f) {\r\n                    var d = __.diff(b, dx);\r\n                    var q = f ? f(a, b) : _.divide(a.clone(), d);\r\n                    if(!q.contains(dx, true))\r\n                        return q;\r\n                    return null;\r\n                }\r\n                function do_fn_sub(fname, arg) {\r\n                    var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\r\n                    subbed = subbed.sub(new Symbol(u), arg);\r\n                    subbed.updateHash();\r\n                    return subbed;\r\n                }\r\n\r\n                var a = symbols[0].clone(),\r\n                        b = symbols[1].clone(),\r\n                        g1 = a.group,\r\n                        g2 = b.group,\r\n                        //may cause problems if person is using this already. Will need\r\n                        //to find algorithm for detecting conflict\r\n                        u = '__u__',\r\n                        Q;\r\n                if(g1 === FN && g2 !== FN) {\r\n                    //e.g. 2*x*cos(x^2)\r\n                    var arg = a.args[0];\r\n                    Q = try_combo(b, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(a.fname, arg));\r\n                    Q = try_combo(b, a);\r\n                    if(Q) {\r\n                        return __.integration.poly_integrate(a);\r\n                    }\r\n                }\r\n                else if(g2 === FN && g1 !== FN) {\r\n                    //e.g. 2*(x+1)*cos((x+1)^2\r\n                    var arg = b.args[0];\r\n                    Q = try_combo(a, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(b.fname, arg));\r\n                }\r\n                else if(g1 === FN && g2 === FN) {\r\n                    Q = try_combo(a.clone(), b.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(b.clone(), a.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                }\r\n                else if(g1 === EX && g2 !== EX) {\r\n                    var p = a.power;\r\n                    Q = try_combo(b, p.clone());\r\n                    if(!Q) {\r\n                        //one more try\r\n                        var dc = __.integration.decompose_arg(p.clone(), dx);\r\n                        //consider the possibility of a^x^(n-1)*x^n dx\r\n                        var xp = __.diff(dc[2].clone(), dx);\r\n                        var dc2 = __.integration.decompose_arg(xp.clone(), dx);\r\n                        //if their powers equal, so if dx*p == b\r\n                        if(_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\r\n                            var m = _.divide(dc[0].clone(), dc2[0].clone());\r\n\r\n                            var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\r\n                            new_val = _.multiply(new_val, new Symbol(u));\r\n                            return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\r\n                        }\r\n\r\n                    }\r\n                    var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\r\n                            retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n\r\n\r\n                    return retval;\r\n                }\r\n                else if(g2 === EX && g1 !== EX) {\r\n                    var p = b.power;\r\n                    Q = try_combo(a, p.clone());\r\n                    var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\r\n                    return _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n                }\r\n                else if(a.isComposite() || b.isComposite()) {\r\n                    var f = function (a, b) {\r\n                        var d = __.diff(b, dx);\r\n                        var A = core.Algebra.Factor.factor(a),\r\n                                B = core.Algebra.Factor.factor(d);\r\n                        var q = _.divide(A, B);\r\n                        return q;\r\n                    };\r\n                    var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\r\n                            f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\r\n                    Q = try_combo(f1.clone(), f2.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(f2.clone(), f1.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(a), Q);\r\n                }\r\n            },\r\n            //simple integration of a single polynomial x^(n+1)/(n+1)\r\n            poly_integrate: function (x) {\r\n                var p = x.power.toString(),\r\n                        m = x.multiplier.toDecimal(),\r\n                        s = x.toUnitMultiplier().toLinear();\r\n                if(Number(p) === -1) {\r\n                    return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\r\n                }\r\n                return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\r\n            },\r\n            //If we're just spinning wheels we want to stop. This is why we \r\n            //wrap integration in a try catch block and call this to stop.\r\n            stop: function (msg) {\r\n                msg = msg || 'Unable to compute integral!';\r\n                core.Utils.warn(msg);\r\n                throw new NoIntegralFound(msg);\r\n            },\r\n            partial_fraction: function (input, dx, depth, opt) {\r\n                //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\r\n                if(!isSymbol(dx))\r\n                    dx = _.parse(dx);\r\n\r\n                var result, partial_fractions;\r\n                result = new Symbol(0);\r\n                partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\r\n\r\n                if(partial_fractions.group === CB && partial_fractions.isLinear()) {\r\n                    //perform a quick check to make sure that all partial fractions are linear\r\n                    partial_fractions.each(function (x) {\r\n                        if(!x.isLinear())\r\n                            __.integration.stop();\r\n                    });\r\n                    partial_fractions.each(function (x) {\r\n                        result = _.add(result, __.integrate(x, dx, depth, opt));\r\n                    });\r\n                }\r\n                else {\r\n                    result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\r\n                }\r\n                return result;\r\n            },\r\n            get_udv: function (symbol) {\r\n                var parts = [[/*L*/], [/*I*/], [/*A*/], [/*T*/], [/*E*/]];\r\n                //first we sort them \r\n                var setSymbol = function (x) {\r\n                    var g = x.group;\r\n                    if(g === FN) {\r\n                        var fname = x.fname;\r\n                        if(core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))\r\n                            parts[3].push(x);\r\n                        else if(core.Utils.in_inverse_trig(fname))\r\n                            parts[1].push(x);\r\n                        else if(fname === LOG)\r\n                            parts[0].push(x);\r\n                        else {\r\n                            __.integration.stop();\r\n                        }\r\n                    }\r\n                    else if(g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\r\n                        parts[2].push(x);\r\n                    }\r\n                    else if(g === EX || x.isComposite() && !x.isLinear())\r\n                        parts[4].push(x);\r\n                    else\r\n                        __.integration.stop();\r\n                };\r\n\r\n                if(symbol.group === CB)\r\n                    symbol.each(function (x) {\r\n                        setSymbol(Symbol.unwrapSQRT(x, true));\r\n                    });\r\n                else\r\n                    setSymbol(symbol);\r\n                var u, dv = new Symbol(1);\r\n                //compile u and dv\r\n                for(var i = 0; i < 5; i++) {\r\n                    var part = parts[i], t,\r\n                            l = part.length;\r\n                    if(l > 0) {\r\n                        if(l > 1) {\r\n                            t = new Symbol(1);\r\n                            for(var j = 0; j < l; j++)\r\n                                t = _.multiply(t, part[j].clone());\r\n                        }\r\n                        else\r\n                            t = part[0].clone();\r\n\r\n                        if(!u) {\r\n                            u = t;//the first u encountered gets chosen\r\n                            u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\r\n                        }\r\n                        else\r\n                            dv = _.multiply(dv, t); //everything else belongs to dv\r\n                    }\r\n                }\r\n\r\n                return [u, dv];\r\n            },\r\n\r\n            trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\r\n                parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\r\n                var b = parts[3],\r\n                        ax = parts[2],\r\n                        a = parts[0],\r\n                        x = parts[1];\r\n                if(x.power.equals(2) && a.greaterThan(0)) {\r\n                    //use tan(x)\r\n                    var t = core.Utils.getU(symbol), //get an appropriate u\r\n                            u = _.parse(TAN + inBrackets(t)), //u\r\n                            du = _.parse(SEC + inBrackets(t) + '^2'), //du\r\n                            f = _.multiply(symbol.sub(x, u), du);\r\n                    var integral = __.integrate(f, t, depth, opt).sub(u, x);\r\n                    core.Utils.clearU(u);\r\n                    return integral;\r\n                }\r\n            },\r\n\r\n            by_parts: function (symbol, dx, depth, o) {\r\n                o.previous = o.previous || [];\r\n                var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;\r\n                //first LIATE\r\n                udv = __.integration.get_udv(symbol);\r\n                u = udv[0];\r\n                dv = udv[1];\r\n                du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\r\n                c = du.clone().stripVar(dx);\r\n                //strip any coefficients\r\n                du = _.divide(du, c.clone());\r\n                v = __.integrate(dv.clone(), dx, depth || 0);\r\n                vdu = _.multiply(v.clone(), du);\r\n                vdu_s = vdu.toString();\r\n                //currently only supports e^x*(some trig)\r\n                if(o.previous.indexOf(vdu_s) !== -1 && (core.Utils.in_trig(u.fname)) && dv.isE()) {\r\n                    //We're going to exploit the fact that vdu can never be constant\r\n                    //to work out way out of this cycle. We'll return the length of\r\n                    //the this.previous array until we're back at level one\r\n                    o.is_cyclic = true;\r\n                    //return the integral. \r\n                    return new Symbol(1);\r\n                }\r\n                else\r\n                    o.previous.push(vdu_s);\r\n\r\n                uv = _.multiply(u, v);\r\n                //clear the multiplier so we're dealing with a bare integral\r\n                m = vdu.multiplier.clone();\r\n                vdu.toUnitMultiplier();\r\n                integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\r\n                integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\r\n                retval = _.subtract(uv, integral_vdu);\r\n                //we know that there cannot be constants so they're a holdover from a cyclic integral\r\n                if(o.is_cyclic) {\r\n                    //start popping the previous stack so we know how deep in we are\r\n                    o.previous.pop();\r\n                    if(o.previous.length === 0) {\r\n                        retval = _.expand(retval);\r\n                        var rem = new Symbol(0);\r\n                        retval.each(function (x) {\r\n                            if(!x.contains(dx))\r\n                                rem = _.add(rem, x.clone());\r\n                        });\r\n                        //get the actual uv\r\n                        retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\r\n                    }\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            /*\r\n             * dependents: [Solve, integrate]\r\n             */\r\n            decompose_arg: core.Utils.decompose_fn\r\n        },\r\n        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\r\n        integrate: function (original_symbol, dt, depth, opt) {\r\n            //assume integration wrt independent variable if expression only has one variable\r\n            if(!dt) {\r\n                var vars = core.Utils.variables(original_symbol);\r\n                if(vars.length === 1)\r\n                    dt = vars[0];\r\n                //defaults to x\r\n                dt = dt || 'x';\r\n            }\r\n            //add support for integrating vectors\r\n            if(core.Utils.isVector(original_symbol)) {\r\n                var vector = new core.Vector([]);\r\n                original_symbol.each(function (x) {\r\n                    vector.elements.push(__.integrate(x, dt));\r\n                });\r\n                return vector;\r\n            }\r\n            if(!isNaN(dt))\r\n                _.error('variable expected but received ' + dt);\r\n            //get rid of constants right away\r\n            if(original_symbol.isConstant(true))\r\n                return _.multiply(original_symbol.clone(), _.parse(dt));\r\n\r\n            //configurations options for integral. This is needed for tracking extra options\r\n            //e.g. cyclic integrals or additional settings\r\n            opt = opt || {};\r\n            return core.Utils.block('PARSE2NUMBER', function () {\r\n                //make a note of the original symbol. Set only if undefined\r\n                depth = depth || 0;\r\n                var dx = isSymbol(dt) ? dt.toString() : dt,\r\n                        //we don't want the symbol in sqrt form. x^(1/2) is prefererred\r\n                        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\r\n                        g = symbol.group,\r\n                        retval;\r\n\r\n                try {\r\n                    //We stop integration after x amount of recursive calls\r\n                    if(++depth > core.Settings.integration_depth)\r\n                        __.integration.stop('Maximum depth reached. Exiting!');\r\n\r\n                    //constants. We first eliminate anything that doesn't have dx. Everything after this has \r\n                    //to have dx or else it would have been taken care of below\r\n                    if(!symbol.contains(dx, true)) {\r\n                        retval = _.multiply(symbol.clone(), _.parse(dx));\r\n                    }\r\n                    //e.g. 2*x\r\n                    else if(g === S) {\r\n                        retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                    }\r\n                    else if(g === EX) {\r\n                        if(symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS))\r\n                            __.integration.stop();\r\n                        //check the base\r\n                        if(symbol.contains(dx) && symbol.previousGroup !== FN) {\r\n                            //if the symbol also contains dx then we stop since we currently \r\n                            //don't know what to do with it e.g. x^x\r\n                            if(symbol.power.contains(dx))\r\n                                __.integration.stop();\r\n                            else {\r\n                                var t = __.diff(symbol.clone().toLinear(), dx);\r\n                                if(t.contains(dx))\r\n                                    __.integration.stop();\r\n                                //since at this point it's the base only then we do standard single poly integration\r\n                                //e.g. x^y\r\n                                retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                            }\r\n                        }\r\n                        //e.g. a^x or 9^x\r\n                        else {\r\n                            var a = __.diff(symbol.power.clone(), dx);\r\n                            if(a.contains(dx)) {\r\n                                var aa = a.stripVar(dx),\r\n                                        x = _.divide(a.clone(), aa.clone());\r\n                                if(x.group === S && x.isLinear()) {\r\n                                    aa.multiplier = aa.multiplier.divide(new Frac(2));\r\n                                    return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            if(symbol.isE()) {\r\n                                if(a.isLinear())\r\n                                    retval = symbol;\r\n                                else {\r\n                                    if(a.isE() && a.power.group === S && a.power.power.equals(1))\r\n                                        retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\r\n                                retval = _.divide(symbol, d);\r\n                            }\r\n                            retval = _.divide(retval, a);\r\n                        }\r\n                    }\r\n                    else if(symbol.isComposite() && symbol.isLinear()) {\r\n                        var m = _.parse(symbol.multiplier);\r\n                        symbol.toUnitMultiplier();\r\n                        retval = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            retval = _.add(retval, __.integrate(x, dx, depth));\r\n                        });\r\n                        retval = _.multiply(m, retval);\r\n                    }\r\n                    else if(g === CP) {\r\n                        if(symbol.power.greaterThan(1))\r\n                            symbol = _.expand(symbol);\r\n                        if(symbol.power.equals(1)) {\r\n                            retval = new Symbol(0);\r\n                            symbol.each(function (x) {\r\n                                retval = _.add(retval, __.integrate(x, dx, depth));\r\n                            }, true);\r\n                        }\r\n                        else {\r\n                            var p = Number(symbol.power),\r\n                                    m = symbol.multiplier.clone();//temporarily remove the multiplier\r\n                            symbol.toUnitMultiplier();\r\n                            var //below we consider the form ax+b\r\n                                    fn = symbol.clone().toLinear(), //get just the pure function without the power\r\n                                    decomp = __.integration.decompose_arg(fn, dx),\r\n                                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\r\n                                    b = decomp[3],\r\n                                    ax = decomp[2],\r\n                                    a = decomp[0],\r\n                                    x = decomp[1];\r\n                            if(p === -1 && x.group !== PL && x.power.equals(2)) {\r\n                                var b_is_positive = isInt(b) ? b > 0 : true;\r\n                                //we can now check for atan\r\n                                if(x.group === S && x.power.equals(2) && b_is_positive) {\r\n                                    ////then we have atan\r\n                                    //abs is redundants since the sign appears in both denom and num.\r\n                                    var unwrapAbs = function (s) {\r\n                                        var result = new Symbol(1);\r\n                                        s.each(function (x) {\r\n                                            result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\r\n                                        });\r\n                                        return result;\r\n                                    };\r\n                                    var A = a.clone(),\r\n                                            B = b.clone();\r\n                                    A = _.pow(A, new Symbol(1 / 2));\r\n                                    B = _.pow(B, new Symbol(1 / 2));\r\n                                    //unwrap abs\r\n\r\n                                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\r\n                                            f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\r\n                                    retval = _.divide(f, d);\r\n                                }\r\n                                else if(x.group === S && x.isLinear()) {\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                }\r\n                                else {\r\n                                    //1/(x^4+1)\r\n                                    if(x.power.equals(4)) {\r\n                                        //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\r\n                                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\r\n                                        var br = inBrackets;\r\n                                        //apply rule: ax^4+b = (√ax^2+√2∜a∜bx+√b)(√ax^2-√2∜a∜bx+√b)\r\n                                        //get quadratic factors\r\n                                        A = _.parse(SQRT + br(a) + '*' + dx + '^2');\r\n                                        B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        C = _.parse(SQRT + br(b));\r\n                                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\r\n                                        f2 = _.add(_.subtract(A, B), C);\r\n                                        //calculate numerators: [D+E, D-E] -> [√2*b^(3/4)+√b∜ax, √2*b^(3/4)-√b∜ax]\r\n                                        D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\r\n                                        E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        //let F = 2b√2∜b\r\n                                        F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4'));\r\n                                        //calculate the factors\r\n                                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\r\n                                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\r\n                                        retval = _.add(\r\n                                                __.integrate(L1, dx, depth, opt),\r\n                                                __.integrate(L2, dx, depth, opt)\r\n                                                );\r\n                                    }\r\n                                    else\r\n                                        //let's try partial fractions\r\n                                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                }\r\n                            }\r\n                            else if(p === -1 / 2) {\r\n                                //detect asin and atan\r\n                                if(x.group === S && x.power.equals(2)) {\r\n                                    if(ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\r\n                                        a.negate();\r\n                                        //it's asin\r\n                                        if(b.isConstant() && a.isConstant()) {\r\n                                            var d = _.symfunction(SQRT, [a.clone()]),\r\n                                                    d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\r\n                                            retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\r\n                                        }\r\n                                        //I'm not sure about this one. I'm trusting Wolfram Alpha here\r\n                                        else {\r\n                                            var sqrt_a = _.symfunction(SQRT, [a]),\r\n                                                    sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\r\n                                            retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\r\n                                        __.integration.stop();\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\r\n                                    __.integration.stop();\r\n                                }\r\n                            }\r\n                            else if(p === 1/2 && x.power.equals(2) && a.greaterThan(0)) {\r\n                                // TODO: Revisit\r\n                                __.integration.stop();\r\n                            }\r\n                            else {\r\n                                if(x.isLinear() && x.group !== PL)\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                else if(x.power.equals(2) && a.greaterThan(0)) {\r\n                                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv;\r\n                                    //1/(a*x^2+b^2)^n\r\n                                    //strip the value of b so b = 1\r\n                                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\r\n                                    sqb = _.parse(SQRT + inBrackets(b));\r\n                                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\r\n                                    bsqi = _.pow(b, new Symbol(symbol.power));\r\n                                    uv = core.Utils.getU(symbol);\r\n                                    u = _.multiply(aob, x.clone().toLinear());\r\n                                    v = _.parse(ATAN + inBrackets(u));\r\n                                    //the conversion will be 1+tan(x)^2 -> sec(x)^2\r\n                                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \r\n                                    //then the remaining sec will be (n-1)*2;\r\n                                    var n = (Math.abs(symbol.power) - 1) * 2;\r\n                                    //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\r\n                                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\r\n                                    core.Utils.clearU(uv);\r\n                                    return _.multiply(integral.sub(uv, v), bsqi);\r\n                                }\r\n                                else {\r\n                                    if(symbol.group !== CB && !symbol.power.lessThan(0)) {\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n                                    else {\r\n                                        var f = symbol.clone().toLinear();\r\n                                        var factored = core.Algebra.Factor.factor(f);\r\n                                        var was_factored = factored.toString() !== f.toString();\r\n                                        if(core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\r\n                                            try {\r\n                                                var f1, fx, u, sq;\r\n                                                sq = core.Algebra.sqComplete(f, dx);\r\n                                                u = core.Utils.getU(f);\r\n                                                f1 = sq.f.sub(sq.a, u);\r\n                                                fx = _.pow(f1, _.parse(symbol.power));\r\n                                                retval = __.integrate(fx, u).sub(u, sq.a);\r\n                                            }\r\n                                            catch(e) {\r\n                                                __.integration.stop();\r\n                                            }\r\n                                        }\r\n                                        else\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                    }\r\n                                }\r\n                            }\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === FN) {\r\n                        var arg = symbol.args[0],\r\n                                m = symbol.multiplier.clone();\r\n                        symbol.toUnitMultiplier();\r\n                        var decomp = __.integration.decompose_arg(arg, dx);\r\n                        //easies way I can think of to get the coefficient and to make sure\r\n                        //that the symbol is linear wrt dx. I'm not actually trying to get the \r\n                        //derivative\r\n                        var a = decomp[0],\r\n                                x = decomp[1],\r\n                                fname = symbol.fname;\r\n                        //log is a special case that can be handled with integration by parts\r\n                        if(fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) {\r\n                            /*integration by parts */\r\n                            var p = symbol.power.toString();\r\n                            if(isInt(p))\r\n                                depth = depth - p; //it needs more room to find the integral\r\n\r\n                            if(!arg.isComposite())\r\n                                retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));\r\n                            else {\r\n                                //integral u du\r\n                                var u = core.Utils.getU(symbol);\r\n                                var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\r\n                                var du = __.diff(arg, dx);\r\n                                var u_du = _.multiply(f, du);\r\n                                var integral = __.integrate(u_du, u, depth, opt);\r\n                                retval = _.multiply(_.parse(m), integral.sub(u, arg));\r\n                            }\r\n\r\n                        }\r\n                        else if(fname === TAN && symbol.power.lessThan(0)) {\r\n                            //convert to cotangent\r\n                            var sym = symbol.clone();\r\n                            sym.power.negate();\r\n                            sym.fname = COT;\r\n                            return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\r\n                        }\r\n                        else {\r\n                            if(!a.contains(dx, true) && symbol.isLinear()) { //perform a deep search for safety\r\n                                //first handle the special cases \r\n                                if(fname === ABS) {\r\n                                    //REVISIT **TODO**\r\n                                    var x = _.divide(arg.clone(), a.clone());\r\n                                    if(x.group === S && !x.power.lessThan(0)) {\r\n                                        if(core.Utils.even(x.power)) {\r\n                                            retval = __.integrate(arg, dx, depth);\r\n                                        }\r\n                                        else {\r\n                                            var integrated = __.integrate(x, dx, depth);\r\n                                            integrated.power = integrated.power.subtract(new Frac(1));\r\n                                            retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\r\n                                        }\r\n                                    }\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                                else {\r\n                                    var ag = symbol.args[0].group,\r\n                                            decomposed = __.integration.decompose_arg(arg, dx);\r\n\r\n                                    if(!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())\r\n                                        __.integration.stop();\r\n                                    /**TODO**/ //ASIN, ACOS, ATAN\r\n                                    switch(fname) {\r\n                                        case COS:\r\n                                            retval = _.symfunction(SIN, [arg]);\r\n                                            break;\r\n                                        case SIN:\r\n                                            retval = _.symfunction(COS, [arg]);\r\n                                            retval.negate();\r\n                                            break;\r\n                                        case TAN:\r\n                                            retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\r\n                                            break;\r\n                                        case SEC:\r\n                                            retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\r\n                                            break;\r\n                                        case CSC:\r\n                                            retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\r\n                                            break;\r\n                                        case COT:\r\n                                            retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\r\n                                            break;\r\n                                        case SINH:\r\n                                            retval = _.symfunction(COSH, [arg]);\r\n                                            break;\r\n                                        case COSH:\r\n                                            retval = _.symfunction(SINH, [arg]);\r\n                                            break;\r\n                                        case TANH:\r\n                                            retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\r\n                                            break;\r\n                                        case ASEC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOT:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //inverse htrig\r\n                                        case ASECH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSCH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOTH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //end inverse htrig\r\n                                            //htrigh\r\n                                        case SECH:\r\n                                            retval = _.parse(format('atan(sinh({0}))', arg));\r\n                                            break;\r\n                                        case CSCH:\r\n                                            retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\r\n                                            break;\r\n                                        case COTH:\r\n                                            retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\r\n                                            break;\r\n                                            //end htrig\r\n                                        case EXP:\r\n                                            retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\r\n                                            break;\r\n                                        case 'S':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\r\n                                            break;\r\n                                        case 'C':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\r\n                                            break;\r\n                                        case 'erf':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\r\n                                            break;\r\n                                        case 'sign':\r\n                                            retval = _.multiply(symbol.clone(), arg.clone());\r\n                                            break;\r\n                                        default:\r\n                                            __.integration.stop();\r\n                                    }\r\n\r\n                                    retval = _.divide(retval, a);\r\n                                }\r\n                            }\r\n                            else if(x.isLinear()) {\r\n                                if(fname === COS || fname === SIN) {\r\n                                    var p = Number(symbol.power);\r\n                                    //check to see if it's negative and then just transform it to sec or csc\r\n                                    if(p < 0) {\r\n                                        symbol.fname = fname === SIN ? CSC : SEC;\r\n                                        symbol.invert().updateHash();\r\n                                        retval = __.integrate(symbol, dx, depth);\r\n                                    }\r\n                                    else {\r\n                                        var arg = symbol.args[0],\r\n                                                rd = symbol.clone(), //cos^(n-1)\r\n                                                rd2 = symbol.clone(), //cos^(n-2)\r\n                                                q = new Symbol((p - 1) / p), //\r\n                                                na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\r\n                                        rd.power = rd.power.subtract(new Frac(1));\r\n                                        rd2.power = rd2.power.subtract(new Frac(2));\r\n\r\n                                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\r\n                                        if(fname === SIN)\r\n                                            t.negate();\r\n                                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\r\n                                    }\r\n                                }\r\n                                //tan(x)^n or cot(x)^n\r\n                                else if(fname === TAN || fname === COT) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    if(symbol.args[0].isLinear(dx)) {\r\n                                        var n = symbol.power.subtract(new Frac(1)).toString(),\r\n                                                r = symbol.clone().toUnitMultiplier(),\r\n                                                w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\r\n                                        r.power = r.power.subtract(new Frac(2));\r\n                                        if(r.power.equals(0))\r\n                                            r = _.parse(r);\r\n                                        retval = _.subtract(w, __.integrate(r, dx, depth));\r\n                                    }\r\n                                }\r\n                                //sec(x)^n or csc(x)^n\r\n                                else if(fname === SEC || fname === CSC) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    var n1 = symbol.power.subtract(new Frac(1)).toString(),\r\n                                            n2 = symbol.power.subtract(new Frac(2)).toString(),\r\n                                            f2 = fname === SEC ? TAN : COT,\r\n                                            r = symbol.clone().toUnitMultiplier(),\r\n                                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\r\n                                            w = _.parse(parse_str);\r\n                                    r.power = r.power.subtract(new Frac(2));\r\n                                    if(r.power.equals(0))\r\n                                        r = _.parse(r);\r\n                                    retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\r\n                                }\r\n                                else if((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\r\n                                    retval = __.integrate(symbol.fnTransform(), dx, depth);\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            else\r\n                                __.integration.stop();\r\n\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === PL) {\r\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                    }\r\n                    else if(g === CB) {\r\n                        var den = symbol.getDenom();\r\n                        if(den.group === S)\r\n                            symbol = _.expand(symbol);\r\n\r\n                        //separate the coefficient since all we care about are symbols containing dx\r\n                        var coeff = symbol.stripVar(dx);\r\n                        //now get only those that apply\r\n                        var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\r\n                        //peform a correction for stripVar. This is a serious TODO!\r\n                        if(coeff.contains(dx)) {\r\n                            cfsymbol = _.multiply(cfsymbol, coeff);\r\n                            coeff = new Symbol(1);\r\n                        }\r\n\r\n                        //if we only have one symbol left then let's not waste time. Just pull the integral\r\n                        //and let the chips fall where they may\r\n                        if(cfsymbol.group !== CB) {\r\n                            if(cfsymbol.equals(1)) {\r\n                                return __.integrate(_.expand(symbol), dx, depth);\r\n                            }\r\n\r\n                            //only factor for multivariate which are polynomials\r\n                            if(cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\r\n                                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\r\n                            }\r\n\r\n                            retval = __.integrate(cfsymbol, dx, depth);\r\n                        }\r\n                        else {\r\n                            //we collect the symbols and sort them descending group, descending power, descending alpabethically\r\n                            var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\r\n                                if(a.group === b.group) {\r\n                                    if(Number(a.power) === Number(b.power))\r\n                                        if(a < b)\r\n                                            return 1; //I want sin first\r\n                                        else\r\n                                            return -1;\r\n                                    return b.power - a.power; //descending power\r\n                                }\r\n                                return b.group - a.group; //descending groups\r\n                            }).map(function (x) {\r\n                                var unwrapped = Symbol.unwrapSQRT(x, true);\r\n                                if(unwrapped.fname === EXP) {\r\n                                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\r\n                                }\r\n                                return unwrapped;\r\n                            });\r\n                            var l = symbols.length;\r\n                            if(symbol.power < 0) {\r\n                                if(l === 2) {\r\n                                    return __.integrate(_.expand(symbol), dx, depth, opt);\r\n                                }\r\n                            }\r\n                            //otherwise the denominator is one lumped together symbol \r\n                            else {\r\n                                //generate an image for \r\n                                if(l === 2) {\r\n                                    //try u substitution\r\n                                    try {\r\n                                        retval = __.integration.u_substitution(symbols, dx);\r\n                                    }\r\n                                    catch(e) {/* failed :`(*/\r\n                                        ;\r\n                                    }\r\n\r\n                                    if(!retval) {\r\n                                        //no success with u substitution so let's try known combinations\r\n                                        //are they two functions\r\n                                        var g1 = symbols[0].group,\r\n                                                g2 = symbols[1].group,\r\n                                                sym1 = symbols[0],\r\n                                                sym2 = symbols[1],\r\n                                                fn1 = sym1.fname,\r\n                                                fn2 = sym2.fname;\r\n                                        //reset the symbol minus the coeff\r\n                                        symbol = _.multiply(sym1.clone(), sym2.clone());\r\n                                        if(g1 === FN && g2 === FN) {\r\n                                            if(fn1 === LOG || fn2 === LOG) {\r\n                                                retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\r\n                                            }\r\n                                            else {\r\n                                                symbols.sort(function (a, b) {\r\n                                                    return b.fname > a.fname;\r\n                                                });\r\n                                                var arg1 = sym1.args[0];\r\n                                                //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\r\n                                                if(!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))\r\n                                                    __.integration.stop();\r\n\r\n                                                var decomp = __.integration.decompose_arg(arg1, dx);\r\n                                                x = decomp[1],\r\n                                                        a = decomp[0];\r\n                                                if(!x.isLinear()) //again... linear arguments only wrt x\r\n                                                    __.integration.stop();\r\n\r\n                                                //they have to have the same arguments and then we have cleared all the check to \r\n                                                //make sure we can integrate FN & FN\r\n                                                var arg2 = sym2.args[0];\r\n                                                //make sure that their argument matches\r\n                                                if(arg1.equals(arg2)) {\r\n                                                    if(fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\r\n                                                        if(sym1.power.lessThan(0))\r\n                                                            __.integration.stop();//we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\r\n                                                        //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\r\n                                                        if(fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\r\n                                                            sym1.fname = TAN;\r\n                                                            sym1.updateHash();\r\n                                                            retval = __.integrate(sym1, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            if(even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\r\n                                                                //transform sin^(2*n) to (1-cos^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else if(even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\r\n                                                                //transform cos^(2*n) to (1-sin^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else {\r\n                                                                var p1_even = core.Utils.even(sym1.power),\r\n                                                                        p2_even = core.Utils.even(sym2.power);\r\n                                                                retval = new Symbol(0);\r\n                                                                if(!p1_even || !p2_even) {\r\n                                                                    var u, r, trans;\r\n                                                                    //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\r\n                                                                    //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\r\n                                                                    if(!p1_even) {\r\n                                                                        //u = sin(x)\r\n                                                                        u = sym2;\r\n                                                                        r = sym1;\r\n                                                                    }\r\n                                                                    else {\r\n                                                                        u = sym1;\r\n                                                                        r = sym2;\r\n                                                                    }\r\n                                                                    //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\r\n                                                                    var sign = u.fname === COS ? -1 : 1,\r\n                                                                            n = r.power,\r\n                                                                            //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \r\n                                                                            //even powers afterwards which can be transformed\r\n                                                                            k = (n - 1) / 2,\r\n                                                                            //make the transformation cos(x)^2 = 1 - sin(x)^2\r\n                                                                            trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\r\n                                                                            sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));\r\n                                                                    //we can now just loop through and integrate each since it's now just a polynomial with functions\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\r\n                                                                    });\r\n                                                                }\r\n                                                                else {\r\n                                                                    //performs double angle transformation\r\n                                                                    var double_angle = function (symbol) {\r\n                                                                        var p = symbol.power,\r\n                                                                                k = p / 2, e;\r\n                                                                        if(symbol.fname === COS)\r\n                                                                            e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n                                                                        else\r\n                                                                            e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n\r\n                                                                        return _.parse(e);\r\n                                                                    };\r\n                                                                    //they're both even so transform both using double angle identities and we'll just\r\n                                                                    //be able to integrate by the sum of integrals\r\n                                                                    var a = double_angle(sym1),\r\n                                                                            b = double_angle(sym2),\r\n                                                                            t = _.multiply(a, b);\r\n                                                                    var sym = _.expand(t);\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                                    });\r\n                                                                    return _.multiply(retval, coeff);\r\n                                                                }\r\n                                                            }\r\n                                                        }\r\n                                                    }\r\n                                                    //tan(x)*sec(x)^n \r\n                                                    else if(fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\r\n                                                        retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\r\n                                                    }\r\n                                                    else if(fn1 === TAN && fn2 === SEC && x.isLinear()) {\r\n                                                        //remaining: tan(x)^3*sec(x)^6\r\n                                                        if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                            retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\r\n                                                        }\r\n                                                        else if(even(sym1.power)) {\r\n                                                            var p = Number(sym1.power) / 2;\r\n                                                            //transform tangent\r\n                                                            var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\r\n                                                            retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\r\n                                                        }\r\n                                                        else\r\n                                                            __.integration.stop();\r\n                                                    }\r\n                                                    else if(fn1 === SEC && fn2 === COS) {\r\n                                                        sym1.fname = COS;\r\n                                                        sym1.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    else if(fn1 === SIN && fn2 === CSC) {\r\n                                                        sym2.fname = SIN;\r\n                                                        sym2.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    //tan/cos\r\n                                                    else if(fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2);\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                    else {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                }\r\n                                                //TODO: In progress\r\n                                                else if((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\r\n\r\n                                                    if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                        //if in the form cos(a*x)*sin(b*x)\r\n                                                        if(sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\r\n                                                            //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\r\n                                                            var ax, bx;\r\n                                                            if(fn2 === SIN) {\r\n                                                                ax = sym1.args[0];\r\n                                                                bx = sym2.args[0];\r\n                                                            }\r\n                                                            else {\r\n                                                                bx = sym1.args[0];\r\n                                                                ax = sym2.args[0];\r\n                                                            }\r\n\r\n                                                            //make the transformation\r\n                                                            f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString()));\r\n\r\n                                                            //integrate it\r\n                                                            retval = __.integrate(f, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            var transformed = trigTransform(symbols);\r\n                                                            retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                    else {\r\n                                                        var transformed = new Symbol(1);\r\n                                                        symbols.map(function (sym) {\r\n                                                            var s = sym.fnTransform();\r\n                                                            transformed = _.multiply(transformed, s);\r\n                                                        });\r\n                                                        var t = _.expand(transformed);\r\n\r\n                                                        retval = __.integrate(t, dx, depth);\r\n\r\n                                                        if(retval.hasIntegral()) {\r\n                                                            retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                                else {\r\n                                                    __.integration.stop();\r\n                                                }\r\n\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === FN && g2 === S) {\r\n                                            var sym1_is_linear = sym1.isLinear();\r\n                                            if(sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Ci', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COS && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Chi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COSH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Si', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SIN && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Shi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SINH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === LOG && sym2.power.equals(-1)) {\r\n                                                //log(x)^n/x = log(x)^(n+1)/(n+1)\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === 'erf') {\r\n                                                if(sym2.power.equals(1)) {\r\n                                                    var dc = __.integration.decompose_arg(sym1.args[0], dx),\r\n                                                            a_ = dc[0],\r\n                                                            x_ = dc[1],\r\n                                                            arg = sym1.args[0].toString();\r\n                                                    retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg))\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                //since group S is guaranteed convergence we need not worry about tracking depth of integration\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === EX && g2 === S) {\r\n                                            var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\r\n                                            if(sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\r\n                                                retval = _.symfunction('Ei', [sym1.power.clone()]);\r\n                                            }\r\n                                            else if(fn1 === LOG && x.value === sym2.value) {\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                        else if(g1 === PL && g2 === S) {\r\n                                            //first try to reduce the top\r\n                                            if(sym2.value === sym1.value && sym1.power.equals(-1)) {\r\n                                                //find the lowest power in the denominator\r\n                                                var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));\r\n                                                //get the lowest common value between denominator and numerator\r\n                                                var pc = Math.min(pd, sym2.power);\r\n                                                //reduce both denominator and numerator by that factor\r\n                                                var factor = sym2.clone();\r\n                                                factor.power = new Frac(pc);\r\n                                                sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\r\n                                                var t = new Symbol(0);\r\n                                                sym1.each(function (x) {\r\n                                                    t = _.add(t, _.divide(x.clone(), factor.clone()));\r\n                                                });\r\n                                                t.multiplier = sym1.multiplier;\r\n                                                symbol = _.divide(sym2, t);\r\n                                            }\r\n                                            else {\r\n                                                symbol = _.expand(symbol);\r\n                                            }\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                        }\r\n                                        else if(g1 === CP && g2 === S) {\r\n                                            var f = sym1.clone().toLinear(),\r\n                                                    f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);\r\n                                            //handle cases x^(2*n)/sqrt(1-x^2)\r\n                                            if(sym1.power.equals(-1 / 2)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\r\n                                                var a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\r\n                                                    //if the substitution \r\n                                                    var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)),\r\n                                                            _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])),\r\n                                                            _.pow(a.clone(), new Symbol(2)));\r\n                                                    c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\r\n                                                    var dummy = _.parse('sin(u)');\r\n                                                    dummy.power = dummy.power.multiply(sym2.power);\r\n                                                    var integral = __.integrate(dummy, 'u', depth);\r\n                                                    var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\r\n                                                    retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\r\n                                                }\r\n                                                else if(p1 === -1 / 2) {\r\n                                                    var u_transform = function (f, u) {\r\n                                                        var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\r\n                                                        if(!integral.hasIntegral())\r\n                                                            return integral;\r\n                                                    }\r\n                                                    if(p2 === -1) {\r\n                                                        retval = u_transform(\r\n                                                                _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                    else if(p2 === -2) {\r\n                                                        //apply transformation to see if it matches asin(x)\r\n                                                        retval = u_transform(\r\n                                                                _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            else if(sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\r\n                                                retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else if(!sym1.power.lessThan(0) && isInt(sym1.power)) {\r\n                                                //sum of integrals\r\n                                                var expanded = _.expand(sym1);\r\n                                                retval = new Symbol(0);\r\n                                                expanded.each(function (x) {\r\n                                                    if(x.group === PL) {\r\n                                                        x.each(function (y) {\r\n                                                            retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\r\n                                                        });\r\n                                                    }\r\n                                                    else\r\n                                                        retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\r\n                                                });\r\n                                            }\r\n                                            else if(sym1.power.lessThan(-2)) {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                            else if(sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                        a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        fn = sym1.clone().toLinear();\r\n\r\n                                                if(x.group !== PL && x.isLinear()) {\r\n                                                    var p = Number(sym2.power),\r\n                                                            du = '_u_',\r\n                                                            u = new Symbol(du),\r\n                                                            //pull the integral with the subsitution\r\n                                                            U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\r\n                                                            scope = {};\r\n\r\n                                                    //generate a scope for resubbing the symbol\r\n                                                    scope[du] = fn;\r\n                                                    var U2 = _.parse(U, scope);\r\n                                                    retval = __.integrate(U2, dx, 0);\r\n                                                }\r\n                                                else if(sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\r\n\r\n                                                    //factor out coefficients\r\n                                                    var factors = new core.Algebra.Classes.Factors();\r\n                                                    sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\r\n                                                    var div = core.Algebra.divide(sym2, sym1);\r\n                                                    //it assumed that the result will be of group CB\r\n                                                    if(div.group !== CB) {\r\n                                                        retval = new Symbol(0);\r\n                                                        div.each(function (t) {\r\n                                                            retval = _.add(retval, __.integrate(t, dx, depth));\r\n                                                        });\r\n                                                        //put back the factors\r\n                                                        factors.each(function (factor) {\r\n                                                            retval = _.divide(retval, factor);\r\n                                                        });\r\n\r\n                                                        retval = _.expand(retval);\r\n                                                    }\r\n                                                    else {\r\n                                                        //try something else\r\n                                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else {\r\n                                                //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \r\n                                                if(sym1.power.den.equals(2)) {\r\n                                                    //assume the function is in the form (a^2-b*x^n)^(m/2)\r\n                                                    var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                            //using the above definition\r\n                                                            a = dc[3], x = dc[1], b = dc[0], bx = dc[2];\r\n                                                    if(x.power.equals(2) && b.lessThan(0)) { //if n is even && b is negative\r\n                                                        //make a equal 1 so we can do a trig sub\r\n                                                        if(!a.equals(1)) { //divide a out of everything\r\n                                                            //move a to the coeff\r\n                                                            coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\r\n                                                        }\r\n                                                        var u = dx;\r\n                                                        var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\r\n                                                                du = _.symfunction(COS, [new Symbol(u)]),\r\n                                                                cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\r\n                                                                X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\r\n                                                                val = _.multiply(_.multiply(cosn, du), X),\r\n                                                                integral = __.integrate(val, u, depth);\r\n                                                        //but remember that u = asin(sqrt(b)*a*x)\r\n                                                        retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\r\n                                                    }\r\n                                                    else {\r\n                                                        retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else if(f_is_linear) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n                                        else if(sym1.isComposite() && sym2.isComposite()) {\r\n                                            //sum of integrals\r\n                                            retval = new Symbol(0);\r\n                                            if(sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\r\n                                                //combine and pull the integral of each\r\n                                                var sym = _.expand(symbol);\r\n                                                sym.each(function (x) {\r\n                                                    retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                }, true);\r\n                                            }\r\n                                            else {\r\n                                                var p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(p1 < 0 && p2 > 0) {\r\n                                                    //swap\r\n                                                    var t = sym1;\r\n                                                    sym1 = sym2;\r\n                                                    sym2 = t;\r\n                                                }\r\n                                                if(p1 === -1 && p2 === -1) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx);\r\n                                                }\r\n                                                else {\r\n                                                    sym1.each(function (x) {\r\n                                                        var k = _.multiply(x, sym2.clone());\r\n                                                        var integral = __.integrate(k, dx, depth);\r\n                                                        retval = _.add(retval, integral);\r\n                                                    });\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === CP && symbols[0].power.greaterThan(0)) {\r\n                                            sym1 = _.expand(sym1);\r\n                                            retval = new Symbol(0);\r\n                                            sym1.each(function (x) {\r\n                                                retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\r\n                                            }, true);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\r\n                                            sym1 = sym1.fnTransform();\r\n                                            retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\r\n                                            if(g2 === FN && g1 === CP) {\r\n                                                var t = sym1;\r\n                                                sym1 = sym2;\r\n                                                sym2 = t; //swap\r\n                                            }\r\n                                            var du, sym2_clone, p, q, sa, sb;\r\n                                            du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\r\n                                            sym2_clone = Symbol.unwrapSQRT(sym2, true);\r\n                                            if(du.power.equals(sym2_clone.power)) {\r\n                                                p = new Symbol(sym2.power);\r\n                                                sa = du.clone().toLinear();\r\n                                                sb = sym2.clone().toLinear();\r\n                                                q = core.Algebra.divide(sa.toLinear(), sb);\r\n                                                if(q.isConstant()) {\r\n                                                    var nq = _.pow(q, p.negate());\r\n                                                    retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            var syma = sym1.clone().toLinear();\r\n                                            var symb = sym2.clone().toLinear();\r\n                                            if(g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx)\r\n                                                    && !syma.contains(dx) && !symb.contains(dx)) {\r\n                                                retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))',\r\n                                                        syma.toString(),\r\n                                                        symb.toString(),\r\n                                                        sym1.power.multiplier.toString(),\r\n                                                        sym2.power.multiplier.toString(),\r\n                                                        dx\r\n                                                        ));\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\r\n                                    var first = symbols[0];\r\n                                    if(first.group === CP) { //TODO {support higher powers of x in the future}\r\n                                        if(first.power.greaterThan(1))\r\n                                            first = _.expand(first);\r\n                                        var r = _.multiply(symbols[1], symbols[2]);\r\n                                        retval = new Symbol(0);\r\n                                        first.each(function (x) {\r\n                                            var t = _.multiply(x, r.clone());\r\n                                            var intg = __.integrate(t, dx, depth);\r\n                                            retval = _.add(retval, intg);\r\n                                        }, true);\r\n                                    }\r\n                                    else {\r\n                                        //try integration by parts although technically it will never work\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n\r\n                                }\r\n                                else if(all_functions(symbols)) {\r\n                                    var t = new Symbol(1);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        t = _.multiply(t, symbols[i].fnTransform());\r\n                                    }\r\n                                    t = _.expand(t);\r\n                                    retval = __.integrate(t, dx, depth);\r\n                                }\r\n                                else {\r\n                                    //one more go\r\n                                    var transformed = trigTransform(symbols);\r\n                                    retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        retval = _.multiply(retval, coeff);\r\n                    }\r\n                    //if an integral was found then we return it\r\n                    if(retval)\r\n                        return retval;\r\n                }\r\n\r\n                catch(error) {\r\n                    //do nothing if it's a NoIntegralFound error otherwise let it bubble\r\n                    if(!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero))\r\n                        throw error;\r\n                }\r\n\r\n                //no symbol found so we return the integral again\r\n                return _.symfunction('integrate', [original_symbol, dt]);\r\n            }, false);\r\n        },\r\n        defint: function (symbol, from, to, dx) {\r\n            dx = dx || 'x'; //make x the default variable of integration\r\n            var get_value = function (integral, vars, point) {\r\n                try {\r\n                    return _.parse(integral, vars);\r\n                }\r\n                catch(e) {\r\n                    //it failed for some reason so return the limit\r\n                    var lim = __.Limit.limit(integral, dx, point);\r\n                    return lim;\r\n                }\r\n            };\r\n\r\n            var vars = core.Utils.variables(symbol),\r\n                    hasTrig = symbol.hasTrig();\r\n            var retval, integral;\r\n\r\n            // Fix #593 - Only assume the first variable if dx is not defined.\r\n            if(vars.length === 1 && !dx)\r\n                dx = vars[0];\r\n\r\n            if(!hasTrig) {\r\n                integral = __.integrate(symbol, dx);\r\n            }\r\n\r\n            if(!hasTrig && !integral.hasIntegral()) {\r\n                var upper = {},\r\n                        lower = {},\r\n                        a, b;\r\n                upper[dx] = to;\r\n                lower[dx] = from;\r\n\r\n                a = get_value(integral, upper, to, dx);\r\n                b = get_value(integral, lower, from, dx);\r\n                retval = _.subtract(a, b);\r\n            }\r\n            else if(vars.length === 1 && from.isConstant() && to.isConstant()) {\r\n\r\n                var f = core.Utils.build(symbol);\r\n                retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\r\n            }\r\n            else\r\n                retval = _.symfunction('defint', [symbol, from, to, dx]);\r\n            return retval;\r\n        },\r\n\r\n        Limit: {\r\n            interval: function (start, end) {\r\n                return _.parse(format('[{0}, {1}]', start, end));\r\n            },\r\n            diverges: function () {\r\n                return __.Limit.interval('-Infinity', 'Infinity');\r\n            },\r\n            divide: function (f, g, x, lim, depth) {\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                var fin = f.clone(), gin = g.clone();\r\n\r\n                //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\r\n                //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\r\n                //the two-sided limit.\r\n                //Known limit\r\n                if(g.fname === ABS) {\r\n                    var sign = f.sign();\r\n                    var lim_sign = lim.sign();\r\n\r\n                    if(lim.isInfinity)\r\n                        return _.multiply(new Symbol(sign), new Symbol(lim_sign));\r\n\r\n                    else if(lim.equals(0)) {\r\n                        var fm = _.parse(f.multiplier);\r\n                        var gm = _.parse(g.multiplier);\r\n                        return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\r\n                    }\r\n                    else {\r\n                        //TODO: Support more limits\r\n                        __.Limit.diverges();\r\n                    }\r\n                }\r\n\r\n                var isInfinity = function (L) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        for(var i = 0; i < L.elements.length; i++)\r\n                            if(!L.elements[i].isInfinity)\r\n                                return false;\r\n                        return true;\r\n                    }\r\n                    return L.isInfinity;\r\n                };\r\n\r\n                var equals = function (L, v) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        return false;\r\n                    }\r\n                    return L.equals(v);\r\n                };\r\n\r\n                var retval;\r\n                do {\r\n                    var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\r\n                    var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));\r\n\r\n                    //if it's in indeterminate form apply L'Hospital's rule\r\n                    var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);\r\n                    //pull the derivatives\r\n                    if(indeterminate) {\r\n                        var ft = __.diff(f.clone(), x);\r\n                        var gt = __.diff(g.clone(), x);\r\n\r\n                        var t_symbol = _.expand(_.divide(ft, gt));\r\n                        f = t_symbol.getNum();\r\n                        g = t_symbol.getDenom();\r\n\r\n                    }\r\n                }\r\n                while(indeterminate)\r\n\r\n                //REMEMBER: \r\n                //- 1/cos(x)\r\n                //n/0 is still possible since we only checked for 0/0\r\n                var den_is_zero = lim2.equals(0);\r\n                var p = Number(gin.power);\r\n\r\n                if(lim.isConstant(true) && den_is_zero) {\r\n                    retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\r\n                }\r\n                else if(den_is_zero) {\r\n                    retval = __.Limit.diverges();\r\n                }\r\n                else {\r\n                    retval = _.divide(lim1, lim2);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            rewriteToLog: function (symbol) {\r\n                var p = symbol.power.clone();\r\n                symbol.toLinear();\r\n                return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\r\n            },\r\n            getSubbed: function (f, x, lim) {\r\n                var retval;\r\n                //1. rewrite EX with base e\r\n                if(f.group === EX) {\r\n                    f = __.rewriteToLog(f);\r\n                }\r\n                //2. try simple substitution\r\n                try {\r\n                    retval = f.sub(x, lim);\r\n                }\r\n                catch(e) {\r\n                    //Nope. No go, so just return the unsubbed function so we can test the limit instead.\r\n                    retval = f;\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            isInterval: function (limit) {\r\n                return core.Utils.isVector(limit);\r\n            },\r\n            isConvergent: function (limit) {\r\n                //it's not convergent if it lies on the interval -Infinity to Infinity\r\n                if(\r\n                        //It lies on the interval -Infinity to Infinity\r\n                        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity ||\r\n                        //We weren't able to calculate the limit\r\n                        limit.containsFunction('limit')\r\n                        ) {\r\n                    return false; //Then no\r\n                }\r\n                return true; //It is\r\n            },\r\n            limit: function (symbol, x, lim, depth) {\r\n                //Simplify the symbol\r\n                if(symbol.isLinear() && symbol.isComposite()) {\r\n\r\n                    //Apply sum of limits\r\n                    var limit = new Symbol(0);\r\n                    symbol.each(function (s) {\r\n                        limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\r\n                    }, true);\r\n\r\n                    return limit;\r\n                }\r\n                ;\r\n\r\n                symbol = core.Algebra.Simplify.simplify(symbol);\r\n\r\n                depth = depth || 1;\r\n\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                //store the multiplier\r\n                var m = _.parse(symbol.multiplier);\r\n                //strip the multiplier\r\n                symbol.toUnitMultiplier();\r\n                try {\r\n                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                    var retval;\r\n                    //we try the simplest option first where c is some limit\r\n                    //lim a as x->c = a where c \r\n                    if(symbol.isConstant(true)) {\r\n                        retval = symbol;\r\n                    }\r\n                    else {\r\n                        var point = {};\r\n                        point[x] = lim;\r\n                        //lim x as x->c = c where c\r\n\r\n                        try {\r\n\r\n                            //evaluate the function at the given limit\r\n                            var t = _.parse(symbol.sub(x, lim), point);\r\n\r\n                            //a constant or infinity is known so we're done\r\n                            if(t.isConstant(true) || t.isInfinity)\r\n                                retval = t;\r\n\r\n                        }\r\n                        catch(e) { /*Nothing. Maybe we tried to divide by zero.*/\r\n                        }\r\n                        ;\r\n\r\n                        if(!retval) {\r\n                            //split the symbol in the numerator and the denominator\r\n                            var num = symbol.getNum();\r\n                            var den = symbol.getDenom();\r\n\r\n                            if(den.isConstant(true)) {\r\n                                //We still don't have a limit so we generate tests.\r\n                                if(symbol.group === EX) {\r\n                                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                                    //Speed boost for exponentials by detecting patterns\r\n                                    var f = symbol.clone().toLinear();\r\n                                    var p = symbol.power.clone();\r\n                                    var _num = f.getNum();\r\n                                    var _den = f.getDenom();\r\n                                    var fn = core.Utils.decompose_fn(_den, x, true);\r\n                                    //start detection of pattern (x/(x+1))^x\r\n                                    if(_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\r\n                                        retval = _.parse(format('(1/e^({0}))', fn.b));\r\n                                    }\r\n                                    else {\r\n                                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());\r\n                                        //get the base\r\n                                        var pow = symbol_.power.clone();\r\n                                        var base = symbol_.clone().toLinear();\r\n                                        var lim_base = __.Limit.limit(base, x, lim, depth);\r\n                                        var lim_pow = __.Limit.limit(pow, x, lim, depth);\r\n                                        retval = _.pow(lim_base, lim_pow);\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === FN && symbol.args.length === 1) {\r\n                                    var evaluates;\r\n                                    //Squeeze theorem lim f(g(x)) = lim f(lim g))\r\n                                    var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\r\n                                    if(core.Utils.isVector(arg)) {\r\n                                        //get the limit over that interval\r\n                                        retval = arg.map(function (e) {\r\n                                            var clone = symbol.clone();\r\n                                            clone.args[0] = e;\r\n                                            return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\r\n                                        });\r\n\r\n                                        return _.multiply(m, retval);\r\n                                    }\r\n                                    //if the argument is constant then we're done\r\n                                    else if(arg.isConstant(true)) {\r\n\r\n                                        //double check that it evaluates\r\n                                        var trial = _.symfunction(symbol.fname, [arg]);\r\n                                        //trial evaluation\r\n                                        try {\r\n                                            evaluate(trial);\r\n                                            evaluates = true;\r\n                                        }\r\n                                        catch(e) {\r\n\r\n                                            evaluates = false;\r\n                                        }\r\n                                    }\r\n                                    if(evaluates) {\r\n                                        retval = trial;\r\n                                    }\r\n                                    else {\r\n                                        //if the limit converges. We'll deal with non-convergent ones later\r\n                                        if(__.Limit.isConvergent(arg)) {\r\n                                            if(symbol.fname === LOG) {\r\n                                                switch(arg.toString()) {\r\n                                                    //lim -> 0\r\n                                                    case '0':\r\n                                                        retval = Symbol.infinity().negate();\r\n                                                        break;\r\n                                                    case 'Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                    case '-Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                }\r\n                                            }\r\n                                            else if((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\r\n                                                retval = __.Limit.interval(-1, 1);\r\n                                            }\r\n                                            else if((symbol.fname === TAN)) {\r\n                                                var s_arg = symbol.args[0];\r\n                                                var n = s_arg.getNum();\r\n                                                var d = s_arg.getDenom();\r\n                                                var pi = n.toUnitMultiplier();\r\n                                                if(lim.isInfinity || pi.equals('pi') && d.equals(2)) {\r\n                                                    retval = divergent();\r\n                                                }\r\n                                            }\r\n                                            else if(symbol.fname === Settings.FACTORIAL) {\r\n                                                if(arg.isInfinity)\r\n                                                    return Symbol.infinity();\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === S) {\r\n                                    if(symbol.power > 0)\r\n                                        //these functions always converge to the limit\r\n                                        return _.parse(symbol, point);\r\n                                    else {\r\n                                        //we're dealing with 1/x^n but remember that infinity has already been dealt\r\n                                        //with by substitution\r\n                                        if(core.Utils.even(symbol.power)) {\r\n                                            //even powers converge to infinity\r\n                                            retval = Symbol.infinity();\r\n                                        }\r\n                                        else {\r\n                                            //odd ones don't\r\n                                            retval = __.Limit.diverges();\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === CB) {\r\n\r\n                                    var lim1, lim2;\r\n                                    //loop through all the symbols\r\n                                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\r\n                                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return a.group - b.group;\r\n                                    });\r\n\r\n                                    var f = symbols.pop();\r\n                                    //calculate the first limit so we can keep going down the list\r\n                                    lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\r\n\r\n                                    //reduces all the limits one at a time\r\n                                    while(symbols.length) {\r\n                                        //get the second limit\r\n                                        var g = symbols.pop();\r\n                                        //get the limit of g\r\n                                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));\r\n\r\n                                        //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\r\n                                        if((lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2))) {\r\n                                            if(g.containsFunction(LOG)) {\r\n                                                //swap them\r\n                                                g = [f, f = g][0];\r\n                                            }\r\n                                            //invert the symbol\r\n                                            g.invert();\r\n\r\n                                            // Product of infinities\r\n                                            if(lim1.isInfinity && lim2.isInfinity) {\r\n                                                lim1 = Symbol.infinity()\r\n                                            }\r\n                                            else {\r\n                                                lim1 = __.Limit.divide(f, g, x, lim, depth);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            //lim f*g = (lim f)*(lim g)\r\n                                            lim1 = _.multiply(lim1, lim2);\r\n                                            //let f*g equal f and h equal g \r\n                                            f = _.multiply(f, g);\r\n                                        }\r\n                                    }\r\n\r\n                                    //Done, lim1 is the limit we're looking for     \r\n                                    retval = lim1;\r\n                                }\r\n                                else if(symbol.isComposite()) {\r\n                                    var _lim;\r\n                                    if(!symbol.isLinear())\r\n                                        symbol = _.expand(symbol);\r\n                                    //Apply lim f+g = (lim f)+(lim g)\r\n                                    retval = new Symbol(0);\r\n\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return b.group - a.group;\r\n                                    });\r\n\r\n                                    var _symbols = [];\r\n                                    //Analyze the functions first\r\n                                    var fns = new Symbol(0);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i].clone();\r\n                                        if(sym.group === FN || sym.group === CB && sym.hasFunc()) {\r\n                                            fns = _.add(fns, sym);\r\n                                        }\r\n                                        else\r\n                                            _symbols.push(sym);\r\n                                    }\r\n                                    _symbols.unshift(fns);\r\n\r\n                                    //make sure that we didn't just repackage the exact same symbol\r\n                                    if(_symbols.length !== 1) {\r\n                                        symbols = _symbols;\r\n                                    }\r\n\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i];\r\n                                        //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\r\n                                        try {\r\n                                            _lim = __.Limit.limit(sym, x, lim, depth);\r\n                                        }\r\n                                        catch(e) {\r\n                                            _lim = __.Limit.diverges();\r\n                                        }\r\n\r\n                                        try {\r\n                                            retval = _.add(retval, _lim);\r\n                                        }\r\n                                        catch(e) {\r\n                                            if(depth++ > Settings.max_lim_depth) {\r\n                                                return;\r\n                                            }\r\n                                            ;\r\n                                            retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                retval = __.Limit.divide(num, den, x, lim, depth);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //if we still don't have a solution\r\n                    if(!retval)\r\n                        //return it symbolically\r\n                        retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n                catch(e) {\r\n                    //if all else fails return the symbolic function\r\n                    retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n\r\n                return _.multiply(m, retval);\r\n            }\r\n        },\r\n        Fresnel: {\r\n            S: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('S', arguments);\r\n            },\r\n            C: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('C', arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'diff',\r\n            visible: true,\r\n            numargs: [1, 3],\r\n            build: function () {\r\n                return __.diff;\r\n            }\r\n        },\r\n        {\r\n            name: 'sum',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.sum;\r\n            }\r\n        },\r\n        {\r\n            name: 'product',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.product;\r\n            }\r\n        },\r\n        {\r\n            name: 'integrate',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.integrate;\r\n            }\r\n        },\r\n        {\r\n            name: 'defint',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.defint;\r\n            }\r\n        },\r\n        {\r\n            name: 'S',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.S;\r\n            }\r\n        },\r\n        {\r\n            name: 'C',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.C;\r\n            }\r\n        },\r\n        {\r\n            name: 'limit',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.Limit.limit;\r\n            }\r\n        }\r\n    ]);\r\n    //link registered functions externally\r\n    nerdamer.updateAPI();\r\n\r\n})();"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAI,OAAOA,MAAR,KAAoB,WAApB,IAAmC,OAAOC,QAAP,KAAoB,WAA1D,EAAuE;EACnE,IAAIA,QAAQ,GAAGC,OAAO,CAAC,oBAAD,CAAtB;;EACAA,OAAO,CAAC,cAAD,CAAP;AACH;;AAED,CAAC,YAAY;EACT;;EAEA,IAAIC,IAAI,GAAGF,QAAQ,CAACG,OAAT,EAAX;EAAA,IACQC,CAAC,GAAGF,IAAI,CAACG,MADjB;EAAA,IAEQC,IAAI,GAAGJ,IAAI,CAACI,IAFpB;EAAA,IAGQC,QAAQ,GAAGL,IAAI,CAACK,QAHxB;EAAA,IAIQC,QAAQ,GAAGN,IAAI,CAACO,KAAL,CAAWD,QAJ9B;EAAA,IAKQE,EAAE,GAAGR,IAAI,CAACS,MAAL,CAAYD,EALzB;EAAA,IAMQE,MAAM,GAAGV,IAAI,CAACU,MANtB;EAAA,IAOQC,IAAI,GAAGX,IAAI,CAACO,KAAL,CAAWI,IAP1B;EAAA,IAQQC,UAAU,GAAGZ,IAAI,CAACO,KAAL,CAAWK,UARhC;EAAA,IASQC,KAAK,GAAGb,IAAI,CAACO,KAAL,CAAWM,KAT3B;EAAA,IAUQC,MAAM,GAAGd,IAAI,CAACO,KAAL,CAAWO,MAV5B;EAAA,IAWQC,IAAI,GAAGf,IAAI,CAACO,KAAL,CAAWQ,IAX1B;EAAA,IAYQC,QAAQ,GAAGhB,IAAI,CAACO,KAAL,CAAWS,QAZ9B;EAAA,IAaQC,CAAC,GAAGjB,IAAI,CAACS,MAAL,CAAYQ,CAbxB;EAAA,IAcQC,CAAC,GAAGlB,IAAI,CAACS,MAAL,CAAYS,CAdxB;EAAA,IAeQV,EAAE,GAAGR,IAAI,CAACS,MAAL,CAAYD,EAfzB;EAAA,IAgBQW,EAAE,GAAGnB,IAAI,CAACS,MAAL,CAAYU,EAhBzB;EAAA,IAiBQC,EAAE,GAAGpB,IAAI,CAACS,MAAL,CAAYW,EAjBzB;EAAA,IAkBQC,EAAE,GAAGrB,IAAI,CAACS,MAAL,CAAYY,EAlBzB;EAAA,IAmBQC,EAAE,GAAGtB,IAAI,CAACS,MAAL,CAAYa,EAnBzB;EAAA,IAoBQC,CAAC,GAAGvB,IAAI,CAACS,MAAL,CAAYc,CApBxB;EAAA,IAqBQC,GAAG,GAAGnB,QAAQ,CAACmB,GArBvB;EAAA,IAsBQC,GAAG,GAAG,KAtBd;EAAA,IAuBQC,GAAG,GAAG,KAvBd;EAAA,IAwBQC,IAAI,GAAG,MAxBf;EAAA,IAyBQC,GAAG,GAAG,KAzBd;EAAA,IA0BQC,GAAG,GAAG,KA1Bd;EAAA,IA2BQC,GAAG,GAAG,KA3Bd;EAAA,IA4BQC,GAAG,GAAG,KA5Bd;EAAA,IA6BQC,GAAG,GAAG,KA7Bd;EAAA,IA8BQC,GAAG,GAAG,KA9Bd;EAAA,IA+BQC,IAAI,GAAG,MA/Bf;EAAA,IAgCQC,IAAI,GAAG,MAhCf;EAAA,IAiCQC,IAAI,GAAG,MAjCf;EAAA,IAkCQC,IAAI,GAAG,MAlCf;EAAA,IAmCQC,IAAI,GAAG,MAnCf;EAAA,IAoCQC,IAAI,GAAG,MApCf;EAAA,IAqCQC,IAAI,GAAG,MArCf;EAAA,IAsCQC,IAAI,GAAG,MAtCf;EAAA,IAuCQC,IAAI,GAAG,MAvCf;EAAA,IAwCQC,IAAI,GAAG,MAxCf;EAAA,IAyCQC,IAAI,GAAG,MAzCf;EAAA,IA0CQC,IAAI,GAAG,MA1Cf;EAAA,IA2CQC,KAAK,GAAG,OA3ChB;EAAA,IA4CQC,KAAK,GAAG,OA5ChB;EAAA,IA6CQC,KAAK,GAAG,OA7ChB,CAHS,CAkDT;;EACA,SAASC,eAAT,CAAyBC,GAAzB,EAA8B;IAC1B,KAAKC,OAAL,GAAeD,GAAG,IAAI,EAAtB;EACH;;EACDD,eAAe,CAACG,SAAhB,GAA4B,IAAIC,KAAJ,EAA5B,CAtDS,CAwDT;;EACA3C,MAAM,CAAC0C,SAAP,CAAiBE,WAAjB,GAA+B,YAAY;IACvC,OAAO,KAAKC,gBAAL,CAAsB,WAAtB,CAAP;EACH,CAFD,CAzDS,CA4DT;;;EACA7C,MAAM,CAAC0C,SAAP,CAAiBI,WAAjB,GAA+B,YAAY;IACvC,IAAG,KAAKC,KAAL,KAAejD,EAAlB,EACI,OAAO,IAAP;IACJ,IAAIkD,MAAJ;IAAA,IAAYC,CAAC,GAAG,KAAKC,IAAL,CAAU,CAAV,CAAhB;IACA,IAAIC,CAAC,GAAG,IAAInD,MAAJ,CAAW,KAAKoD,UAAhB,CAAR;IACA,IAAIC,GAAG,GAAG,KAAKC,KAAL,GAAaC,gBAAb,EAAV;;IACA,IAAG,KAAKC,QAAL,EAAH,EAAoB;MAChB,QAAO,KAAKC,KAAZ;QACI,KAAK3B,IAAL;UACIkB,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,wBAAD,EAA2B6C,CAA3B,CAAd,CAAT;UACA;;QACJ,KAAKlB,IAAL;UACIiB,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,wBAAD,EAA2B6C,CAA3B,CAAd,CAAT;UACA;;QACJ,KAAKjB,IAAL;UACIgB,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,2CAAD,EAA8C6C,CAA9C,CAAd,CAAT;UACA;;QACJ,KAAK7B,GAAL;UACI4B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,mBAAD,EAAsB6C,CAAtB,CAAd,CAAT;UACA;;QACJ,KAAK3B,GAAL;UACI0B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,YAAD,EAAe6C,CAAf,CAAd,CAAT;UACA;;QACJ,KAAK5B,GAAL;UACI2B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,YAAD,EAAe6C,CAAf,CAAd,CAAT;UACA;;QACJ;UACID,MAAM,GAAGK,GAAT;MApBR;IAsBH,CAvBD,MAwBK,IAAG,KAAKM,KAAL,CAAWC,MAAX,CAAkB,CAAlB,CAAH,EAAyB;MAC1B,QAAO,KAAKH,KAAZ;QACI,KAAKvC,GAAL;UACI8B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,oBAAD,EAAuB6C,CAAvB,CAAd,CAAT;UACA;;QACJ,KAAK9B,GAAL;UACI6B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,oBAAD,EAAuB6C,CAAvB,CAAd,CAAT;UACA;;QACJ,KAAK7B,GAAL;UACI;UACA4B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,uBAAD,EAA0B6C,CAA1B,CAAd,CAAT;UACA;;QACJ,KAAKlB,IAAL;UACIiB,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,qBAAD,EAAwB6C,CAAxB,CAAd,CAAT;UACA;;QACJ,KAAKnB,IAAL;UACIkB,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,sBAAD,EAAyB6C,CAAzB,CAAd,CAAT;UACA;;QACJ,KAAKjB,IAAL;UACIgB,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,sCAAD,EAAyC6C,CAAzC,CAAd,CAAT;UACA;;QACJ,KAAK5B,GAAL;UACI2B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,qCAAD,EAAwC6C,CAAxC,CAAd,CAAT;UACA;;QACJ;UACID,MAAM,GAAGK,GAAT;MAxBR;IA0BH,CA3BI,MA4BA,IAAG,KAAKI,KAAL,KAAepC,GAAlB,EAAuB;MACxB2B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,kBAAD,EAAqB,KAAK8C,IAAL,CAAU,CAAV,CAArB,EAAmC,KAAKS,KAAxC,CAAd,CAAT;IACH,CAFI,MAGA,IAAG,KAAKF,KAAL,KAAenC,GAAlB,EAAuB;MACxB0B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,kBAAD,EAAqB,KAAK8C,IAAL,CAAU,CAAV,CAArB,EAAmC,KAAKS,KAAxC,CAAd,CAAT;IACH,CAFI,MAGA,IAAG,KAAKF,KAAL,KAAerC,GAAlB,EAAuB;MACxB,IAAG,KAAKuC,KAAL,CAAWE,QAAX,CAAoB,CAApB,CAAH,EAA2B;QACvBb,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,kCAAD,EAAqC,KAAK8C,IAAL,CAAU,CAAV,CAArC,EAAmD,KAAKS,KAAL,CAAWG,MAAX,EAAnD,CAAd,CAAT;MACH,CAFD,MAGK;QACDd,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,+BAAD,EAAkC,KAAK8C,IAAL,CAAU,CAAV,CAAlC,EAAgD,KAAKS,KAArD,CAAd,CAAT;MACH;IACJ,CAPI,MAQA,IAAG,KAAKF,KAAL,KAAevC,GAAf,IAAsB,KAAKyC,KAAL,CAAWE,QAAX,CAAoB,CAApB,CAAzB,EAAiD;MAClDb,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,mBAAD,EAAsB,KAAK8C,IAAL,CAAU,CAAV,CAAtB,EAAoC,KAAKS,KAAL,CAAWG,MAAX,EAApC,CAAd,CAAT;IACH,CAFI,MAGA,IAAG,KAAKL,KAAL,KAAetC,GAAf,IAAsB,KAAKwC,KAAL,CAAWE,QAAX,CAAoB,CAApB,CAAzB,EAAiD;MAClDb,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,mBAAD,EAAsB,KAAK8C,IAAL,CAAU,CAAV,CAAtB,EAAoC,KAAKS,KAAL,CAAWG,MAAX,EAApC,CAAd,CAAT;IACH,CAFI,MAGA,IAAG,KAAKL,KAAL,KAAevC,GAAf,IAAsB,KAAKyC,KAAL,CAAWC,MAAX,CAAkB,CAAlB,CAAzB,EAA+C;MAChDZ,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,6BAAD,EAAgC,KAAK8C,IAAL,CAAU,CAAV,CAAhC,CAAd,CAAT;IACH,CAFI,MAGA,IAAG,KAAKO,KAAL,KAAetC,GAAf,IAAsB,KAAKwC,KAAL,CAAWC,MAAX,CAAkB,CAAlB,CAAzB,EAA+C;MAChDZ,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,6BAAD,EAAgC,KAAK8C,IAAL,CAAU,CAAV,CAAhC,CAAd,CAAT;IACH,CAFI,CAGL;IAHK,KAIA,IAAG,CAAC,KAAKO,KAAL,KAAetC,GAAf,IAAsB,KAAKsC,KAAL,KAAevC,GAAtC,KAA8Cb,IAAI,CAAC,KAAKsD,KAAN,CAArD,EAAmE;MACpE,IAAII,CAAC,GAAG,KAAKJ,KAAL,GAAa,CAArB,CADoE,CAEpE;;MACA,IAAIK,YAAY,GAAGxE,CAAC,CAACyE,GAAF,CAAM,KAAKX,KAAL,GAAaY,QAAb,EAAN,EAA+B1E,CAAC,CAACkE,KAAF,CAAQ,CAAR,CAA/B,EAA2CZ,WAA3C,EAAnB,CAHoE,CAIpE;;;MACA,IAAIqB,WAAW,GAAG3E,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACyE,GAAF,CAAMD,YAAN,EAAoBxE,CAAC,CAACkE,KAAF,CAAQK,CAAR,CAApB,CAAT,CAAlB;;MAEAf,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;MAEAmE,WAAW,CAACE,IAAZ,CAAiB,UAAUC,CAAV,EAAa;QAC1B,IAAIC,CAAC,GAAGD,CAAC,CAACxB,WAAF,EAAR;QACAE,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcuB,CAAd,CAAT;MACH,CAHD,EAGG,IAHH;IAIH,CAbI,MAeDvB,MAAM,GAAGK,GAAT;;IAEJ,OAAO7D,CAAC,CAACiF,QAAF,CAAWzB,MAAX,EAAmBG,CAAnB,CAAP;EACH,CAvGD;;EAyGAnD,MAAM,CAAC0C,SAAP,CAAiBgC,OAAjB,GAA2B,YAAY;IACnC,IAAG,KAAKC,UAAL,CAAgB,IAAhB,KAAyB,KAAK5B,KAAL,KAAevC,CAA3C,EACI,OAAO,KAAP;IACJ,IAAG,KAAKiD,KAAL,KAAenE,IAAI,CAACO,KAAL,CAAW+E,OAAX,CAAmB,KAAKnB,KAAxB,KAAkCnE,IAAI,CAACO,KAAL,CAAWgF,eAAX,CAA2B,KAAKpB,KAAhC,CAAjD,CAAH,EACI,OAAO,IAAP;;IACJ,IAAG,KAAKqB,OAAR,EAAiB;MACb,KAAI,IAAIC,CAAR,IAAa,KAAKD,OAAlB;QACI,IAAG,KAAKA,OAAL,CAAaC,CAAb,EAAgBL,OAAhB,EAAH,EACI,OAAO,IAAP;MAFR;IAGH;;IACD,OAAO,KAAP;EACH,CAXD;;EAaApF,IAAI,CAAC0F,UAAL,CAAgBtC,SAAhB,CAA0BE,WAA1B,GAAwC,YAAY;IAChD,OAAO,KAAKqC,MAAL,CAAYrC,WAAZ,EAAP;EACH,CAFD;EAGA;AACJ;AACA;AACA;;;EACItD,IAAI,CAACO,KAAL,CAAWqF,mBAAX,GAAiC,UAAUD,MAAV,EAAkB;IAC/C;IACA,IAAGA,MAAM,CAACE,WAAP,MAAwBF,MAAM,CAACzB,QAAP,EAA3B,EAA8C;MAC1C,IAAIL,CAAC,GAAG,IAAInD,MAAJ,CAAWiF,MAAM,CAAC7B,UAAlB,CAAR;MACA,IAAIgC,WAAW,GAAG,IAAIpF,MAAJ,CAAW,CAAX,CAAlB;MACA,IAAIqF,SAAS,GAAG,IAAIrF,MAAJ,CAAW,CAAX,CAAhB;MACAiF,MAAM,CAACZ,IAAP,CAAY,UAAUU,CAAV,EAAa;QACrBK,WAAW,GAAG5F,CAAC,CAACiF,QAAF,CAAWW,WAAX,EAAwBL,CAAC,CAACO,QAAF,EAAxB,CAAd;MACH,CAFD,EAEG,IAFH,EAJ0C,CAQ1C;;MACAL,MAAM,CAACZ,IAAP,CAAY,UAAUU,CAAV,EAAa;QACrB,IAAIQ,GAAG,GAAGR,CAAC,CAACS,MAAF,EAAV;QACA,IAAIC,GAAG,GAAGV,CAAC,CAACO,QAAF,EAAV;;QACA,IAAII,MAAM,GAAGlG,CAAC,CAACiF,QAAF,CAAWc,GAAX,EAAgB/F,CAAC,CAACmG,MAAF,CAASP,WAAW,CAAC9B,KAAZ,EAAT,EAA8BmC,GAA9B,CAAhB,CAAb;;QACAJ,SAAS,GAAG7F,CAAC,CAACgF,GAAF,CAAMa,SAAN,EAAiBK,MAAjB,CAAZ;MACH,CALD;;MAMA,IAAI1C,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWtB,CAAX,EAAc7D,IAAI,CAACsG,OAAL,CAAaD,MAAb,CAAoBnG,CAAC,CAAC4E,MAAF,CAASiB,SAAT,CAApB,EAAyC7F,CAAC,CAAC4E,MAAF,CAASgB,WAAT,CAAzC,CAAd,CAAb;;MACA,OAAOpC,MAAP;IACH;;IACD,OAAOiC,MAAP;EACH,CArBD,CA1LS,CAgNT;;;EACA3F,IAAI,CAACO,KAAL,CAAWgF,eAAX,GAA6B,UAAUE,CAAV,EAAa;IACtC,IAAIc,YAAY,GAAG,CAACrE,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmBE,IAAnB,EAAyBD,IAAzB,EAA+BE,IAA/B,CAAnB;IACA,OAAOgE,YAAY,CAACC,OAAb,CAAqBf,CAArB,MAA4B,CAAC,CAApC;EACH,CAHD,CAjNS,CAqNT;;;EACAzF,IAAI,CAACO,KAAL,CAAW+E,OAAX,GAAqB,UAAUG,CAAV,EAAa;IAC9B,IAAIgB,QAAQ,GAAG,CAAC5E,GAAD,EAAMD,GAAN,EAAWE,GAAX,EAAgBC,GAAhB,EAAqBC,GAArB,EAA0BC,GAA1B,CAAf;IACA,OAAOwE,QAAQ,CAACD,OAAT,CAAiBf,CAAjB,MAAwB,CAAC,CAAhC;EACH,CAHD;;EAKAzF,IAAI,CAACO,KAAL,CAAWmG,QAAX,GAAsB,UAAUjB,CAAV,EAAa;IAC/B,IAAIgB,QAAQ,GAAG,CAACjE,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmBK,KAAnB,EAA0BD,KAA1B,EAAiCE,KAAjC,CAAf;IACA,OAAOyD,QAAQ,CAACD,OAAT,CAAiBf,CAAjB,MAAwB,CAAC,CAAhC;EACH,CAHD,CA3NS,CAgOT;;;EACAzF,IAAI,CAAC2G,MAAL,CAAYC,QAAZ,GAAuB,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;IACzC,IAAIF,QAAQ,GAAG,IAAI5G,IAAI,CAAC2G,MAAT,EAAf,CADyC,CAEzC;;IACA,IAAG,CAACG,IAAJ,EAAU;MACNA,IAAI,GAAG9G,IAAI,CAACO,KAAL,CAAWwG,iBAAX,CAA6BF,IAA7B,CAAP;IACH;;IAEDC,IAAI,CAACE,OAAL,CAAa,UAAUC,CAAV,EAAaC,CAAb,EAAgB;MACzBL,IAAI,CAACG,OAAL,CAAa,UAAUG,EAAV,EAAcC,CAAd,EAAiB;QAC1B,IAAIC,CAAC,GAAGrH,IAAI,CAACsH,QAAL,CAAcC,IAAd,CAAmBJ,EAAE,CAACnD,KAAH,EAAnB,EAA+BiD,CAA/B,CAAR;QACAL,QAAQ,CAACY,GAAT,CAAaJ,CAAb,EAAgBF,CAAhB,EAAmBG,CAAnB;MACH,CAHD;IAIH,CALD;IAOA,OAAOT,QAAP;EACH,CAfD;;EAiBA5G,IAAI,CAAC2G,MAAL,CAAYvD,SAAZ,CAAsBqE,GAAtB,GAA4B,YAAY;IACpC,IAAIA,GAAG,GAAG,IAAI/G,MAAJ,CAAW,CAAX,CAAV;IACA,KAAKqE,IAAL,CAAU,UAAUU,CAAV,EAAa;MACnB,IAAI4B,CAAC,GAAG5B,CAAC,CAACiC,GAAF,EAAR;MACA,IAAGL,CAAC,CAACM,EAAF,CAAKF,GAAL,CAAH,EACIA,GAAG,GAAGJ,CAAN;IACP,CAJD;IAKA,OAAOI,GAAP;EACH,CARD;;EAUAzH,IAAI,CAAC2G,MAAL,CAAYiB,OAAZ,GAAsB,UAAUC,KAAV,EAAiBf,IAAjB,EAAuB;IACzC,IAAIjD,CAAC,GAAG,IAAI7D,IAAI,CAAC2G,MAAT,EAAR,CADyC,CAEzC;;IACAG,IAAI,CAACE,OAAL,CAAa,UAAUC,CAAV,EAAaC,CAAb,EAAgB;MACzBrD,CAAC,CAAC2D,GAAF,CAAMN,CAAN,EAAS,CAAT,EAAYhH,CAAC,CAACkE,KAAF,CAAQyD,KAAR,CAAZ;IACH,CAFD;IAGA,OAAOhE,CAAP;EACH,CAPD;;EASA,IAAIiE,aAAa,GAAG9H,IAAI,CAACO,KAAL,CAAWuH,aAAX,GAA2B,UAAUC,GAAV,EAAe;IAC1D,KAAI,IAAIb,CAAC,GAAG,CAAR,EAAWc,CAAC,GAAGD,GAAG,CAACE,MAAvB,EAA+Bf,CAAC,GAAGc,CAAnC,EAAsCd,CAAC,EAAvC;MACI,IAAGa,GAAG,CAACb,CAAD,CAAH,CAAOzD,KAAP,KAAiBjD,EAApB,EACI,OAAO,KAAP;IAFR;;IAGA,OAAO,IAAP;EACH,CALD;EAAA,IAMQ0H,iBAAiB,GAAGlI,IAAI,CAACO,KAAL,CAAW4H,gBAAX,GAA8B,UAAUC,OAAV,EAAmBC,OAAnB,EAA4B;IAC1E,IAAI1E,CAAJ,EAAO2E,CAAP;IACA3E,CAAC,GAAGyE,OAAO,CAACxE,IAAR,CAAa,CAAb,CAAJ;IACA0E,CAAC,GAAGD,OAAO,CAACzE,IAAR,CAAa,CAAb,CAAJ;IACA,OAAO1D,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,uCAAD,EAA0C6C,CAA1C,EAA6C2E,CAA7C,CAAd,CAAP;EACH,CAXT;EAAA,IAYQC,iBAAiB,GAAGvI,IAAI,CAACO,KAAL,CAAWiI,gBAAX,GAA8B,UAAUJ,OAAV,EAAmBC,OAAnB,EAA4B;IAC1E;IACA;IACA,IAAGI,MAAM,CAACJ,OAAO,CAAChE,KAAT,CAAN,KAA0B,CAA7B,EACI,OAAOnE,CAAC,CAACiF,QAAF,CAAWiD,OAAX,EAAoBC,OAApB,CAAP;IACJ,IAAI1E,CAAJ;IACAA,CAAC,GAAGyE,OAAO,CAACxE,IAAR,CAAa,CAAb,CAAJ;IACA,OAAO1D,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,kBAAD,EAAqB6C,CAArB,CAAd,CAAP;EACH,CApBT;EAAA,IAqBQ+E,iBAAiB,GAAG1I,IAAI,CAACO,KAAL,CAAW4H,gBAAX,GAA8B,UAAUC,OAAV,EAAmBC,OAAnB,EAA4B;IAC1E,IAAI1E,CAAJ,EAAO2E,CAAP;IACA3E,CAAC,GAAGyE,OAAO,CAACxE,IAAR,CAAa,CAAb,CAAJ;IACA0E,CAAC,GAAGD,OAAO,CAACzE,IAAR,CAAa,CAAb,CAAJ;IACA,OAAO1D,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,uCAAD,EAA0C6C,CAA1C,EAA6C2E,CAA7C,CAAd,CAAP;EACH,CA1BT;EAAA,IA2BQK,aAAa,GAAG3I,IAAI,CAACO,KAAL,CAAWoI,aAAX,GAA2B,UAAUZ,GAAV,EAAe;IACtD,IAAIa,GAAG,GAAG,EAAV;IAAA,IAAcjD,MAAd;IAAA,IAAsBV,CAAtB;IAAA,IACQvB,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CADjB;;IAEA,KAAI,IAAIwG,CAAC,GAAG,CAAR,EAAWc,CAAC,GAAGD,GAAG,CAACE,MAAvB,EAA+Bf,CAAC,GAAGc,CAAnC,EAAsCd,CAAC,EAAvC,EAA2C;MACvCvB,MAAM,GAAGoC,GAAG,CAACb,CAAD,CAAZ;;MAEA,IAAGvB,MAAM,CAAClC,KAAP,KAAiBjD,EAApB,EAAwB;QACpB,IAAI2D,KAAK,GAAGwB,MAAM,CAACxB,KAAnB;;QAEA,IAAGA,KAAK,KAAKtC,GAAV,IAAiB+G,GAAG,CAAChH,GAAD,CAAvB,EAA8B;UAE1B,IAAGgH,GAAG,CAAChH,GAAD,CAAH,CAASgC,IAAT,CAAc,CAAd,EAAiBiF,QAAjB,OAAgClD,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeiF,QAAf,EAAnC,EAA8D;YAC1D5D,CAAC,GAAGiD,iBAAiB,CAACvC,MAAD,EAASiD,GAAG,CAAChH,GAAD,CAAZ,CAArB;UACH,CAFD,MAGK;YACDqD,CAAC,GAAGsD,iBAAiB,CAAC5C,MAAD,EAASiD,GAAG,CAAChH,GAAD,CAAZ,CAArB;UACH;;UACD,OAAOgH,GAAG,CAAChH,GAAD,CAAV;UAEA8B,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWzB,MAAX,EAAmBuB,CAAnB,CAAT;QACH,CAXD,MAYK,IAAGd,KAAK,KAAKvC,GAAV,IAAiBgH,GAAG,CAAC/G,GAAD,CAAvB,EAA8B;UAC/B,IAAG+G,GAAG,CAAC/G,GAAD,CAAH,CAAS+B,IAAT,CAAc,CAAd,EAAiBiF,QAAjB,OAAgClD,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeiF,QAAf,EAAnC,EAA8D;YAC1D5D,CAAC,GAAGiD,iBAAiB,CAACvC,MAAD,EAASiD,GAAG,CAAC/G,GAAD,CAAZ,CAArB;UACH,CAFD,MAGK;YACDoD,CAAC,GAAGsD,iBAAiB,CAAC5C,MAAD,EAASiD,GAAG,CAAC/G,GAAD,CAAZ,CAArB;UACH;;UACD,OAAO+G,GAAG,CAAC/G,GAAD,CAAV;UAEA6B,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWzB,MAAX,EAAmBuB,CAAnB,CAAT;QACH,CAVI,MAWA,IAAGd,KAAK,KAAKvC,GAAV,IAAiBgH,GAAG,CAAChH,GAAD,CAAvB,EAA8B;UAC/B,IAAGgH,GAAG,CAAChH,GAAD,CAAH,CAASgC,IAAT,CAAc,CAAd,EAAiBiF,QAAjB,OAAgClD,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeiF,QAAf,EAAnC,EAA8D;YAC1D5D,CAAC,GAAGyD,iBAAiB,CAAC/C,MAAD,EAASiD,GAAG,CAAChH,GAAD,CAAZ,CAArB;YACA,OAAOgH,GAAG,CAAChH,GAAD,CAAV;UACH,CAHD,MAIK;YACD;YACAqD,CAAC,GAAG/E,CAAC,CAACiF,QAAF,CAAWQ,MAAX,EAAmBiD,GAAG,CAAChH,GAAD,CAAtB,CAAJ;YACA,OAAOgH,GAAG,CAAChH,GAAD,CAAV;UACH;;UAED8B,MAAM,GAAGuB,CAAT;QACH,CAZI,MAaA;UACD2D,GAAG,CAACzE,KAAD,CAAH,GAAawB,MAAb;QACH;MACJ,CA1CD,MA4CIjC,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWzB,MAAX,EAAmBiC,MAAnB,CAAT;IACP,CAnDqD,CAqDtD;;;IACA,KAAI,IAAIF,CAAR,IAAamD,GAAb;MACIlF,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWzB,MAAX,EAAmBkF,GAAG,CAACnD,CAAD,CAAtB,CAAT;IADJ;;IAGA,OAAO/B,MAAP;EAEH,CAtFT;;EAwFA1D,IAAI,CAACK,QAAL,CAAcyI,iBAAd,GAAkC,EAAlC;EAEA9I,IAAI,CAACK,QAAL,CAAc0I,aAAd,GAA8B,EAA9B;;EAEA,IAAIC,EAAE,GAAGhJ,IAAI,CAACsH,QAAL,GAAgB;IAErB2B,OAAO,EAAE,OAFY;IAIrBC,GAAG,EAAE,aAAUC,EAAV,EAAcC,KAAd,EAAqBC,KAArB,EAA4BC,GAA5B,EAAiC;MAClC,IAAG,EAAEF,KAAK,CAAC3F,KAAN,KAAgBzD,IAAI,CAACS,MAAL,CAAYS,CAA9B,CAAH,EACI,MAAM,IAAIlB,IAAI,CAACuJ,UAAL,CAAgBC,iBAApB,CAAsC,2BAA2B7I,IAAI,CAACyI,KAAD,CAA/B,GAAyC,WAA/E,CAAN;MACJA,KAAK,GAAGA,KAAK,CAACvB,KAAd;MACA,IAAInE,MAAJ;;MACA,IAAG1D,IAAI,CAACO,KAAL,CAAWkJ,eAAX,CAA2BJ,KAA3B,KAAqCrJ,IAAI,CAACO,KAAL,CAAWkJ,eAAX,CAA2BH,GAA3B,CAAxC,EAAyE;QACrE,IAAII,QAAQ,GAAGJ,GAAG,GAAGD,KAAN,GAAc,GAAd,GAAoB,EAApB,GAAyB,cAAxC;QACAA,KAAK,GAAGZ,MAAM,CAACY,KAAD,CAAd;QACAC,GAAG,GAAGb,MAAM,CAACa,GAAD,CAAZ;QACA5F,MAAM,GAAG1D,IAAI,CAACO,KAAL,CAAWoJ,KAAX,CAAiBD,QAAjB,EAA2B,YAAY;UAC5C,IAAIE,CAAC,GAAGT,EAAE,CAACxI,IAAH,EAAR;UAAA,IACQkJ,IAAI,GAAG;YAAC,KAAK;UAAN,CADf;UAAA,IAC4B;UACpBnG,MAAM,GAAG,IAAI1D,IAAI,CAACU,MAAT,CAAgB,CAAhB,CAFjB;;UAIA,KAAI,IAAIwG,CAAC,GAAGmC,KAAZ,EAAmBnC,CAAC,IAAIoC,GAAxB,EAA6BpC,CAAC,EAA9B,EAAkC;YAC9B2C,IAAI,CAACT,KAAD,CAAJ,GAAc,IAAI1I,MAAJ,CAAWwG,CAAX,CAAd;;YACA,IAAI4C,GAAG,GAAG5J,CAAC,CAACkE,KAAF,CAAQwF,CAAR,EAAWC,IAAX,CAAV;;YACAnG,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcoG,GAAd,CAAT;UACH;;UACD,OAAOpG,MAAP;QACH,CAXQ,CAAT;MAYH,CAhBD,MAiBK;QACDA,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,KAAd,EAAqBC,SAArB,CAAT;MACH;;MAED,OAAOtG,MAAP;IACH,CA/BoB;IAgCrBuG,OAAO,EAAE,iBAAUd,EAAV,EAAcC,KAAd,EAAqBC,KAArB,EAA4BC,GAA5B,EAAiC;MACtC,IAAG,EAAEF,KAAK,CAAC3F,KAAN,KAAgBzD,IAAI,CAACS,MAAL,CAAYS,CAA9B,CAAH,EACI,MAAM,IAAIlB,IAAI,CAACuJ,UAAL,CAAgBC,iBAApB,CAAsC,2BAA2B7I,IAAI,CAACyI,KAAD,CAA/B,GAAyC,WAA/E,CAAN;MACJA,KAAK,GAAGA,KAAK,CAACvB,KAAd;MACA,IAAInE,MAAJ;;MACA,IAAG1D,IAAI,CAACO,KAAL,CAAWkJ,eAAX,CAA2BJ,KAA3B,KAAqCrJ,IAAI,CAACO,KAAL,CAAWkJ,eAAX,CAA2BH,GAA3B,CAAxC,EAAyE;QACrE,IAAII,QAAQ,GAAGJ,GAAG,GAAGD,KAAN,GAAc,GAAd,GAAoB,EAApB,GAAyB,cAAxC;QACA3F,MAAM,GAAG1D,IAAI,CAACO,KAAL,CAAWoJ,KAAX,CAAiBD,QAAjB,EAA2B,YAAY;UAC5CL,KAAK,GAAGZ,MAAM,CAACY,KAAD,CAAd;UACAC,GAAG,GAAGb,MAAM,CAACa,GAAG,CAACxF,UAAL,CAAZ;UAEA,IAAI8F,CAAC,GAAGT,EAAE,CAACxI,IAAH,EAAR;UAAA,IACQkJ,IAAI,GAAG,EADf;UAAA,IAEQnG,MAAM,GAAG,IAAI1D,IAAI,CAACU,MAAT,CAAgB,CAAhB,CAFjB;;UAIA,KAAI,IAAIwG,CAAC,GAAGmC,KAAZ,EAAmBnC,CAAC,IAAIoC,GAAxB,EAA6BpC,CAAC,EAA9B,EAAkC;YAC9B2C,IAAI,CAACT,KAAD,CAAJ,GAAc,IAAI1I,MAAJ,CAAWwG,CAAX,CAAd;YACAxD,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWzB,MAAX,EAAmBxD,CAAC,CAACkE,KAAF,CAAQwF,CAAR,EAAWC,IAAX,CAAnB,CAAT;UACH;;UACD,OAAOnG,MAAP;QACH,CAbQ,CAAT;MAcH,CAhBD,MAiBK;QACDA,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,SAAd,EAAyBC,SAAzB,CAAT;MACH;;MAED,OAAOtG,MAAP;IACH,CA3DoB;IA4DrB6D,IAAI,EAAE,cAAU5B,MAAV,EAAkBuE,GAAlB,EAAuBC,GAAvB,EAA4B;MAC9B,IAAGnK,IAAI,CAACO,KAAL,CAAW6J,QAAX,CAAoBzE,MAApB,CAAH,EAAgC;QAC5B,IAAI0E,MAAM,GAAG,IAAIrK,IAAI,CAACsK,MAAT,CAAgB,EAAhB,CAAb;QACA3E,MAAM,CAACZ,IAAP,CAAY,UAAUU,CAAV,EAAa;UACrB4E,MAAM,CAACE,QAAP,CAAgBC,IAAhB,CAAqBxB,EAAE,CAACzB,IAAH,CAAQ9B,CAAR,EAAWyE,GAAX,EAAgBC,GAAhB,CAArB;QACH,CAFD;QAGA,OAAOE,MAAP;MACH,CAND,MAOK,IAAGrK,IAAI,CAACO,KAAL,CAAWkK,QAAX,CAAoB9E,MAApB,CAAH,EAAgC;QACjC,IAAI+E,MAAM,GAAG,IAAI1K,IAAI,CAAC2G,MAAT,EAAb;QACAhB,MAAM,CAACZ,IAAP,CAAY,UAAUU,CAAV,EAAayB,CAAb,EAAgBE,CAAhB,EAAmB;UAC3BsD,MAAM,CAAClD,GAAP,CAAWN,CAAX,EAAcE,CAAd,EAAiB4B,EAAE,CAACzB,IAAH,CAAQ9B,CAAR,EAAWyE,GAAX,EAAgBC,GAAhB,CAAjB;QACH,CAFD;QAGA,OAAOO,MAAP;MACH;;MAED,IAAIC,CAAC,GAAGrK,QAAQ,CAAC4J,GAAD,CAAR,GAAgBA,GAAG,CAACvJ,IAAJ,EAAhB,GAA6BuJ,GAArC,CAhB8B,CAiB9B;;MACAC,GAAG,GAAG7J,QAAQ,CAAC6J,GAAD,CAAR,GAAgBA,GAAG,CAACrG,UAApB,GAAiCqG,GAAG,IAAI,CAA9C;MAEA,IAAGQ,CAAC,KAAKC,SAAT,EACID,CAAC,GAAG3K,IAAI,CAACO,KAAL,CAAWsK,SAAX,CAAqBlF,MAArB,EAA6B,CAA7B,CAAJ,CArB0B,CAuB9B;;MACA,IAAGA,MAAM,CAAClC,KAAP,KAAiBjD,EAAjB,IAAuBmF,MAAM,CAACxB,KAAP,KAAiBxC,IAA3C,EAAiD;QAC7C,IAAIqD,CAAC,GAAGW,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAR;QAAA,IACQkH,EAAE,GAAGnF,MAAM,CAACtB,KAAP,CAAaL,KAAb,EADb,CAD6C,CAG7C;;QACA,IAAGgB,CAAC,CAACvB,KAAF,KAAYxC,CAAZ,IAAiB+D,CAAC,CAACvB,KAAF,KAAYlC,CAAhC,EAAmC;UAC/ByD,CAAC,CAACX,KAAF,GAAU/D,QAAQ,CAAC0E,CAAC,CAACX,KAAH,CAAR,GAAoBnE,CAAC,CAACiF,QAAF,CAAWH,CAAC,CAACX,KAAb,EAAoBnE,CAAC,CAACiF,QAAF,CAAW,IAAIzE,MAAJ,CAAW,IAAI,CAAf,CAAX,CAApB,EAAmDoK,EAAnD,CAApB,GAA6E9F,CAAC,CAACX,KAAF,CAAQc,QAAR,CAAiB,IAAI/E,IAAJ,CAAS,GAAT,CAAjB,EAAgC+E,QAAhC,CAAyC2F,EAAzC,CAAvF;UACA9F,CAAC,CAAClB,UAAF,GAAekB,CAAC,CAAClB,UAAF,CAAaqB,QAAb,CAAsBQ,MAAM,CAAC7B,UAA7B,CAAf;QACH;;QAED6B,MAAM,GAAGX,CAAT;MACH;;MAED,IAAGW,MAAM,CAAClC,KAAP,KAAiBjD,EAAjB,IAAuB,CAACF,QAAQ,CAACqF,MAAM,CAACtB,KAAR,CAAnC,EAAmD;QAC/C,IAAIV,CAAC,GAAGoH,MAAM,CAAC7K,CAAC,CAACkE,KAAF,CAAQuB,MAAR,CAAD,CAAd;;QACA,IAAI2C,CAAC,GAAGU,EAAE,CAACzB,IAAH,CAAQ5B,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeI,KAAf,EAAR,EAAgC2G,CAAhC,CAAR;;QACAhF,MAAM,GAAGzF,CAAC,CAACiF,QAAF,CAAWxB,CAAX,EAAc2E,CAAd,CAAT,CAH+C,CAGrB;MAC7B,CAJD,MAKK;QACD3C,MAAM,GAAGoF,MAAM,CAACpF,MAAD,CAAf;MACH;;MAED,IAAGwE,GAAG,GAAG,CAAT,EAAY;QACRA,GAAG;QACHxE,MAAM,GAAGqD,EAAE,CAACzB,IAAH,CAAQ5B,MAAR,EAAgBuE,GAAhB,EAAqBC,GAArB,CAAT;MACH;;MAED,OAAOxE,MAAP,CAlD8B,CAoD9B;;MACA,SAASqF,QAAT,CAAkBrF,MAAlB,EAA0B;QACtB,IAAGA,MAAM,CAACkC,KAAP,KAAiB8C,CAAjB,IAAsBhF,MAAM,CAACsF,QAAP,CAAgBN,CAAhB,EAAmB,IAAnB,CAAzB,EAAmD;UAC/ChF,MAAM,CAAC7B,UAAP,GAAoB6B,MAAM,CAAC7B,UAAP,CAAkBqB,QAAlB,CAA2BQ,MAAM,CAACtB,KAAlC,CAApB;UACAsB,MAAM,CAACtB,KAAP,GAAesB,MAAM,CAACtB,KAAP,CAAa6G,QAAb,CAAsB,IAAI9K,IAAJ,CAAS,CAAT,CAAtB,CAAf;;UACA,IAAGuF,MAAM,CAACtB,KAAP,CAAaC,MAAb,CAAoB,CAApB,CAAH,EAA2B;YACvBqB,MAAM,GAAGjF,MAAM,CAACiF,MAAM,CAAC7B,UAAR,CAAf;UACH;QACJ;;QAED,OAAO6B,MAAP;MACH;;MAED,SAASoF,MAAT,CAAgBpF,MAAhB,EAAwB;QACpB,IAAIwF,CAAC,GAAGxF,MAAM,CAAClC,KAAf;QAAA,IAAsBE,CAAtB;QAAA,IAAyB2E,CAAzB;QAAA,IAA4B8C,EAA5B;;QAEA,IAAGD,CAAC,KAAKlK,CAAN,IAAWkK,CAAC,KAAKjK,CAAN,IAAWyE,MAAM,CAACkC,KAAP,KAAiB8C,CAAvC,IAA4CQ,CAAC,KAAK5J,CAArD,EAAwD;UACpDoE,MAAM,GAAGjF,MAAM,CAAC,CAAD,CAAf;QACH,CAFD,MAGK,IAAGyK,CAAC,KAAKjK,CAAT,EAAY;UACbyE,MAAM,GAAGqF,QAAQ,CAACrF,MAAD,CAAjB;QACH,CAFI,MAGA,IAAGwF,CAAC,KAAK9J,EAAT,EAAa;UACd,IAAIwC,CAAC,GAAG8B,MAAM,CAAC7B,UAAP,CAAkBE,KAAlB,EAAR;UACA2B,MAAM,CAAC1B,gBAAP;;UACA,IAAIP,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWkG,YAAY,CAAC1F,MAAD,CAAvB,EAAiCqF,QAAQ,CAACrF,MAAD,CAAzC,CAAb;;UACAjC,MAAM,CAACI,UAAP,GAAoBJ,MAAM,CAACI,UAAP,CAAkBqB,QAAlB,CAA2BtB,CAA3B,CAApB;UACA,OAAOH,MAAP;QACH,CANI,MAOA,IAAGyH,CAAC,KAAK3K,EAAN,IAAYmF,MAAM,CAACtB,KAAP,CAAaC,MAAb,CAAoB,CAApB,CAAf,EAAuC;UACxC;UACA,QAAOqB,MAAM,CAACxB,KAAd;YACI,KAAK3C,GAAL;cACI4J,EAAE,GAAGzF,MAAM,CAAC3B,KAAP,EAAL;cACA2B,MAAM,GAAGA,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeI,KAAf,EAAT,CAFJ,CAEoC;;cAChC2B,MAAM,CAACtB,KAAP,GAAesB,MAAM,CAACtB,KAAP,CAAaG,MAAb,EAAf;cACAmB,MAAM,CAAC7B,UAAP,GAAoBsH,EAAE,CAACtH,UAAH,CAAcuC,MAAd,CAAqBV,MAAM,CAAC7B,UAA5B,CAApB;cACA;;YACJ,KAAKjC,GAAL;cACI;cACA8D,MAAM,CAACxB,KAAP,GAAevC,GAAf;cACA+D,MAAM,CAAC7B,UAAP,CAAkBU,MAAlB;cACA;;YACJ,KAAK5C,GAAL;cACI;cACA+D,MAAM,CAACxB,KAAP,GAAetC,GAAf;cACA;;YACJ,KAAKC,GAAL;cACI;cACA6D,MAAM,CAACxB,KAAP,GAAepC,GAAf;cACA4D,MAAM,CAACtB,KAAP,GAAe,IAAIjE,IAAJ,CAAS,CAAT,CAAf;cACA;;YACJ,KAAK2B,GAAL;cACI;cACA4D,MAAM,GAAG2F,KAAK,CAAC3F,MAAD,EAAS7D,GAAT,CAAd;cACA;;YACJ,KAAKE,GAAL;cACI2D,MAAM,GAAG2F,KAAK,CAAC3F,MAAD,EAAS,MAAT,CAAd;cACA;;YACJ,KAAK1D,GAAL;cACI0D,MAAM,CAACxB,KAAP,GAAenC,GAAf;cACA2D,MAAM,CAAC7B,UAAP,CAAkBU,MAAlB;cACAmB,MAAM,CAACtB,KAAP,GAAe,IAAIjE,IAAJ,CAAS,CAAT,CAAf;cACA;;YACJ,KAAK8B,IAAL;cACIyD,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,cAAczD,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAlB,GAAqC,YAA7C,CAAT;cACA;;YACJ,KAAKzB,IAAL;cACIwD,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,eAAezD,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAnB,GAAsC,YAA9C,CAAT;cACA;;YACJ,KAAKxB,IAAL;cACIuD,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,SAASzD,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAb,GAAgC,WAAxC,CAAT;cACA;;YACJ,KAAKlC,GAAL;cACImC,CAAC,GAAG8B,MAAM,CAAC7B,UAAP,CAAkBE,KAAlB,EAAJ;cACA2B,MAAM,CAAC1B,gBAAP,GAFJ,CAGI;cACA;;cACAqE,CAAC,GAAG3C,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeI,KAAf,EAAJ;cACAsE,CAAC,CAACrE,gBAAF;cACA0B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQxD,UAAU,CAACD,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAL,CAAV,GAAmC,MAAnC,GAA4ChD,UAAU,CAACD,IAAI,CAAC2H,CAAD,CAAL,CAA9D,CAAT;cACA3C,MAAM,CAAC7B,UAAP,GAAoBD,CAApB;cACA;;YACJ,KAAK,QAAL;cACI;cACA;cACA8B,MAAM,GAAGjF,MAAM,CAAC,CAAD,CAAf;cACA;;YACJ,KAAK,MAAL;cACI;cACAiF,MAAM,CAACxB,KAAP,GAAe,MAAf;cACA;;YACJ,KAAK,MAAL;cACI;cACAwB,MAAM,CAACxB,KAAP,GAAe,MAAf;cACA;;YACJ,KAAKzB,IAAL;cACI;cACAiD,MAAM,CAACxB,KAAP,GAAevB,IAAf;cACA+C,MAAM,CAACtB,KAAP,GAAe,IAAIjE,IAAJ,CAAS,CAAT,CAAf;cACA;;YACJ,KAAKwC,IAAL;cACI;cACA+C,MAAM,GAAG2F,KAAK,CAAC3F,MAAD,EAAS,OAAT,CAAd;cACA;;YACJ,KAAKhD,IAAL;cACI,IAAI4I,GAAG,GAAGC,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAhB;cACA,OAAO1D,CAAC,CAACkE,KAAF,CAAQ,WAAWmH,GAAX,GAAiB,SAAjB,GAA6BA,GAA7B,GAAmC,GAA3C,CAAP;cACA;;YACJ,KAAK1I,IAAL;cACI,IAAI0I,GAAG,GAAGC,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAhB;cACA,OAAO1D,CAAC,CAACkE,KAAF,CAAQ,WAAWmH,GAAX,GAAiB,KAAzB,CAAP;cACA;;YACJ,KAAK,OAAL;cACI5F,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,cAAczD,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAlB,GAAqC,YAA7C,CAAT;cACA;;YACJ,KAAK,OAAL;cACI+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,eAAezD,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAnB,GAAsC,YAA9C,CAAT;cACA;;YACJ,KAAK,OAAL;cACI+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,SAASzD,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAb,GAAgC,WAAxC,CAAT;cACA;;YACJ,KAAKd,KAAL;cACI,IAAIyI,GAAG,GAAGC,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAhB;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,iBAAiBmH,GAAjB,GAAuB,UAAvB,GAAoCA,GAApC,GAA0C,MAAlD,CAAT;cACA;;YACJ,KAAKvI,KAAL;cACI2C,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,UAAUuB,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV,GAA2B,QAAnC,CAAT;cACA;;YACJ,KAAKb,KAAL;cACI,IAAIwI,GAAG,GAAGC,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAhB;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,iBAAiBmH,GAAjB,GAAuB,UAAvB,GAAoCA,GAApC,GAA0C,MAAlD,CAAT;cACA;;YACJ,KAAKlJ,IAAL;cACI,IAAIkJ,GAAG,GAAGC,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAhB;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,kBAAkBmH,GAAlB,GAAwB,QAAxB,GAAmCA,GAAnC,GAAyC,MAAjD,CAAT;cACA;;YACJ,KAAKjJ,IAAL;cACI,IAAIiJ,GAAG,GAAGC,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAhB;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,mBAAmBmH,GAAnB,GAAyB,QAAzB,GAAoCA,GAApC,GAA0C,MAAlD,CAAT;cACA;;YACJ,KAAKhJ,IAAL;cACIoD,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,UAAUuB,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV,GAA2B,QAAnC,CAAT;cACA;;YACJ,KAAK,GAAL;cACI,IAAI2H,GAAG,GAAGC,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAhB;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,cAAcmH,GAAd,GAAoB,SAA5B,CAAT;cACA;;YACJ,KAAK,GAAL;cACI,IAAIA,GAAG,GAAGC,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAhB;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,cAAcmH,GAAd,GAAoB,SAA5B,CAAT;cACA;;YACJ,KAAK,IAAL;cACI,IAAIA,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,SAASmH,GAAT,GAAe,KAAf,GAAuBA,GAAvB,GAA6B,GAArC,CAAT;cACA;;YACJ,KAAK,KAAL;cACI,IAAIA,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,UAAUmH,GAAV,GAAgB,KAAhB,GAAwBA,GAAxB,GAA8B,GAAtC,CAAT;cACA;;YACJ,KAAK,IAAL;cACI,IAAIA,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,SAASmH,GAAT,GAAe,KAAf,GAAuBA,GAAvB,GAA6B,GAArC,CAAT;cACA;;YACJ,KAAK,KAAL;cACI,IAAIA,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,UAAUmH,GAAV,GAAgB,KAAhB,GAAwBA,GAAxB,GAA8B,GAAtC,CAAT;cACA;;YACJ,KAAK,IAAL;cACI,IAAIA,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,QAAQmH,GAAR,GAAc,KAAd,GAAsBA,GAAtB,GAA4B,GAApC,CAAT;cACA;;YACJ,KAAK,IAAL;cACI,IAAIA,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV;cACA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,OAAO/D,QAAQ,CAACmB,GAAhB,GAAsB,GAAtB,GAA4B+J,GAA5B,GAAkC,GAA1C,CAAT;cACA;;YACJ,KAAK,KAAL;cACI5F,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,aAAauB,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAb,GAA8B,gBAAtC,CAAT;cACA;;YACJ,KAAK,OAAL;cACI,IAAI6H,EAAE,GAAGD,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAf;cAAA,IACQ8H,EAAE,GAAGF,MAAM,CAAC7F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CADnB;cAEA+B,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,MAAMsH,EAAN,GAAW,MAAX,GAAoBA,EAApB,GAAyB,OAAzB,GAAmCD,EAAnC,GAAwC,MAAhD,CAAT;cACA;;YACJ,KAAK,MAAL;cACI9F,MAAM,GAAG,IAAIjF,MAAJ,CAAW,CAAX,CAAT;cACA;;YACJ,KAAK,MAAL;cACIiF,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,sCAAD,EAAyC6E,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAzC,CAAd,CAAT;cACA;;YACJ,KAAKvD,QAAQ,CAACsL,KAAd;cACIhG,MAAM,GAAGzF,CAAC,CAACkE,KAAF,CAAQ,SAASuB,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAT,GAA0B,IAA1B,GAAiCvD,QAAQ,CAACmB,GAA1C,GAAgD,OAAxD,CAAT;cACA;;YACJ;cACImE,MAAM,GAAGzF,CAAC,CAAC6J,WAAF,CAAc,MAAd,EAAsB,CAACpE,MAAD,EAASuE,GAAT,CAAtB,CAAT;UAnKR;QAqKH,CAvKI,MAwKA,IAAGiB,CAAC,KAAK7J,EAAN,IAAY6J,CAAC,KAAK3K,EAAN,IAAYF,QAAQ,CAACqF,MAAM,CAACtB,KAAR,CAAnC,EAAmD;UACpD,IAAIwD,KAAJ;;UACA,IAAGsD,CAAC,KAAK7J,EAAT,EAAa;YACTuG,KAAK,GAAGlC,MAAM,CAACkC,KAAf;UACH,CAFD,MAGK,IAAGsD,CAAC,KAAK3K,EAAN,IAAYmF,MAAM,CAACsF,QAAP,CAAgBN,CAAhB,CAAf,EAAmC;YACpC9C,KAAK,GAAGlC,MAAM,CAACxB,KAAP,GAAevD,UAAU,CAACD,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAL,CAAjC;UACH,CAFI,MAGA;YACDiE,KAAK,GAAGlC,MAAM,CAACkC,KAAP,GAAejH,UAAU,CAACD,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAL,CAAjC;UACH;;UACDD,CAAC,GAAGzD,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAACkE,KAAF,CAAQ5C,GAAG,GAAGZ,UAAU,CAACiH,KAAD,CAAxB,CAAX,EAA6ClC,MAAM,CAACtB,KAAP,CAAaL,KAAb,EAA7C,CAAJ;UACAsE,CAAC,GAAGU,EAAE,CAACzB,IAAH,CAAQrH,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAACkE,KAAF,CAAQ5C,GAAG,GAAGZ,UAAU,CAACiH,KAAD,CAAxB,CAAX,EAA6ClC,MAAM,CAACtB,KAAP,CAAaL,KAAb,EAA7C,CAAR,EAA4E2G,CAA5E,CAAJ;UACAhF,MAAM,GAAGzF,CAAC,CAACiF,QAAF,CAAWQ,MAAX,EAAmB2C,CAAnB,CAAT;QACH,CAdI,MAeA,IAAG6C,CAAC,KAAK3K,EAAN,IAAY,CAACmF,MAAM,CAACtB,KAAP,CAAaC,MAAb,CAAoB,CAApB,CAAhB,EAAwC;UACzCgE,CAAC,GAAG3C,MAAM,CAAC3B,KAAP,EAAJ;UACAsE,CAAC,CAAC1D,QAAF;UACA0D,CAAC,CAACrE,gBAAF;UACA0B,MAAM,GAAGzF,CAAC,CAACiF,QAAF,CAAW6F,QAAQ,CAACrF,MAAM,CAAC3B,KAAP,EAAD,CAAnB,EAAqC+G,MAAM,CAACzC,CAAD,CAA3C,CAAT;QACH,CALI,MAMA,IAAG6C,CAAC,KAAK/J,EAAN,IAAY+J,CAAC,KAAKhK,EAArB,EAAyB;UAC1B;UACA,IAAIyK,CAAC,GAAGjG,MAAM,CAAC3B,KAAP,EAAR;UACA,IAAI6H,MAAM,GAAG,IAAInL,MAAJ,CAAW,CAAX,CAAb;;UACA,KAAI,IAAI+E,CAAR,IAAaE,MAAM,CAACH,OAApB,EAA6B;YACzBqG,MAAM,GAAG3L,CAAC,CAACgF,GAAF,CAAM2G,MAAN,EAAc7C,EAAE,CAACzB,IAAH,CAAQ5B,MAAM,CAACH,OAAP,CAAeC,CAAf,EAAkBzB,KAAlB,EAAR,EAAmC2G,CAAnC,CAAd,CAAT;UACH;;UACDhF,MAAM,GAAGzF,CAAC,CAACiF,QAAF,CAAW6F,QAAQ,CAACY,CAAD,CAAnB,EAAwBC,MAAxB,CAAT;QACH;;QAEDlG,MAAM,CAACmG,UAAP;QAEA,OAAOnG,MAAP;MACH;;MACD;;MAEA,SAAS2F,KAAT,CAAe3F,MAAf,EAAuBoG,GAAvB,EAA4BC,MAA5B,EAAoC;QAChC,OAAO9L,CAAC,CAACiF,QAAF,CAAWQ,MAAX,EAAmBzF,CAAC,CAACkE,KAAF,CAAQ2H,GAAG,GAAGnL,UAAU,CAACoL,MAAM,IAAIrL,IAAI,CAACgF,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAD,CAAf,CAAxB,CAAnB,CAAP;MACH;;MACD;;MAEA,SAASyH,YAAT,CAAsB1F,MAAtB,EAA8B;QAC1B;QACA,IAAIH,OAAO,GAAGG,MAAM,CAACsG,cAAP,EAAd;QAAA,IACQJ,MAAM,GAAG,IAAInL,MAAJ,CAAW,CAAX,CADjB;QAAA,IAEQsH,CAAC,GAAGxC,OAAO,CAACyC,MAFpB,CAF0B,CAK1B;;QACA,KAAI,IAAIf,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGc,CAAnB,EAAsBd,CAAC,EAAvB,EAA2B;UACvB,IAAIgF,EAAE,GAAGlD,EAAE,CAACzB,IAAH,CAAQ/B,OAAO,CAAC0B,CAAD,CAAP,CAAWlD,KAAX,EAAR,EAA4B2G,CAA5B,CAAT;;UACA,KAAI,IAAIvD,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGY,CAAnB,EAAsBZ,CAAC,EAAvB,EAA2B;YACvB;YACA,IAAGF,CAAC,KAAKE,CAAT,EAAY;cACR;cACA8E,EAAE,GAAGhM,CAAC,CAACiF,QAAF,CAAW+G,EAAX,EAAe1G,OAAO,CAAC4B,CAAD,CAAP,CAAWpD,KAAX,EAAf,CAAL;YACH;UACJ,CARsB,CASvB;;;UACA6H,MAAM,GAAG3L,CAAC,CAACgF,GAAF,CAAM2G,MAAN,EAAcK,EAAd,CAAT;QACH;;QACD,OAAOL,MAAP,CAlB0B,CAkBX;MAClB;;MACD;IACH,CApXoB;IAqXrBM,WAAW,EAAE;MACTC,cAAc,EAAE,wBAAU5G,OAAV,EAAmB6G,EAAnB,EAAuB;QACnC,SAASC,SAAT,CAAmB3I,CAAnB,EAAsB2E,CAAtB,EAAyBsB,CAAzB,EAA4B;UACxB,IAAIe,CAAC,GAAG3B,EAAE,CAACzB,IAAH,CAAQe,CAAR,EAAW+D,EAAX,CAAR;;UACA,IAAIE,CAAC,GAAG3C,CAAC,GAAGA,CAAC,CAACjG,CAAD,EAAI2E,CAAJ,CAAJ,GAAapI,CAAC,CAACmG,MAAF,CAAS1C,CAAC,CAACK,KAAF,EAAT,EAAoB2G,CAApB,CAAtB;UACA,IAAG,CAAC4B,CAAC,CAACtB,QAAF,CAAWoB,EAAX,EAAe,IAAf,CAAJ,EACI,OAAOE,CAAP;UACJ,OAAO,IAAP;QACH;;QACD,SAASC,SAAT,CAAmBrI,KAAnB,EAA0BoH,GAA1B,EAA+B;UAC3B,IAAIkB,MAAM,GAAGzD,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC6J,WAAF,CAAc5F,KAAd,EAAqB,CAAC,IAAIzD,MAAJ,CAAWiM,CAAX,CAAD,CAArB,CAAb,EAAoDA,CAApD,EAAuD,CAAvD,CAAb;;UACAF,MAAM,GAAGA,MAAM,CAACG,GAAP,CAAW,IAAIlM,MAAJ,CAAWiM,CAAX,CAAX,EAA0BpB,GAA1B,CAAT;UACAkB,MAAM,CAACX,UAAP;UACA,OAAOW,MAAP;QACH;;QAED,IAAI9I,CAAC,GAAG6B,OAAO,CAAC,CAAD,CAAP,CAAWxB,KAAX,EAAR;QAAA,IACQsE,CAAC,GAAG9C,OAAO,CAAC,CAAD,CAAP,CAAWxB,KAAX,EADZ;QAAA,IAEQ6I,EAAE,GAAGlJ,CAAC,CAACF,KAFf;QAAA,IAGQqJ,EAAE,GAAGxE,CAAC,CAAC7E,KAHf;QAAA,IAIQ;QACA;QACAkJ,CAAC,GAAG,OANZ;QAAA,IAOQI,CAPR;;QAQA,IAAGF,EAAE,KAAKrM,EAAP,IAAasM,EAAE,KAAKtM,EAAvB,EAA2B;UACvB;UACA,IAAI+K,GAAG,GAAG5H,CAAC,CAACC,IAAF,CAAO,CAAP,CAAV;UACAmJ,CAAC,GAAGT,SAAS,CAAChE,CAAD,EAAIiD,GAAG,CAACvH,KAAJ,EAAJ,CAAb;UACA,IAAG+I,CAAH,EACI,OAAO7M,CAAC,CAACiF,QAAF,CAAW4H,CAAX,EAAcP,SAAS,CAAC7I,CAAC,CAACQ,KAAH,EAAUoH,GAAV,CAAvB,CAAP;UACJwB,CAAC,GAAGT,SAAS,CAAChE,CAAD,EAAI3E,CAAJ,CAAb;;UACA,IAAGoJ,CAAH,EAAM;YACF,OAAO/D,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BrJ,CAA9B,CAAP;UACH;QACJ,CAVD,MAWK,IAAGmJ,EAAE,KAAKtM,EAAP,IAAaqM,EAAE,KAAKrM,EAAvB,EAA2B;UAC5B;UACA,IAAI+K,GAAG,GAAGjD,CAAC,CAAC1E,IAAF,CAAO,CAAP,CAAV;UACAmJ,CAAC,GAAGT,SAAS,CAAC3I,CAAD,EAAI4H,GAAG,CAACvH,KAAJ,EAAJ,CAAb;UACA,IAAG+I,CAAH,EACI,OAAO7M,CAAC,CAACiF,QAAF,CAAW4H,CAAX,EAAcP,SAAS,CAAClE,CAAC,CAACnE,KAAH,EAAUoH,GAAV,CAAvB,CAAP;QACP,CANI,MAOA,IAAGsB,EAAE,KAAKrM,EAAP,IAAasM,EAAE,KAAKtM,EAAvB,EAA2B;UAC5BuM,CAAC,GAAGT,SAAS,CAAC3I,CAAC,CAACK,KAAF,EAAD,EAAYsE,CAAC,CAACtE,KAAF,EAAZ,CAAb;UACA,IAAG+I,CAAH,EACI,OAAO7M,CAAC,CAACiF,QAAF,CAAW6D,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8B1E,CAA9B,CAAX,EAA6CyE,CAA7C,CAAP;UACJA,CAAC,GAAGT,SAAS,CAAChE,CAAC,CAACtE,KAAF,EAAD,EAAYL,CAAC,CAACK,KAAF,EAAZ,CAAb;UACA,IAAG+I,CAAH,EACI,OAAO7M,CAAC,CAACiF,QAAF,CAAW6D,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8B1E,CAA9B,CAAX,EAA6CyE,CAA7C,CAAP;QACP,CAPI,MAQA,IAAGF,EAAE,KAAKvL,EAAP,IAAawL,EAAE,KAAKxL,EAAvB,EAA2B;UAC5B,IAAI2L,CAAC,GAAGtJ,CAAC,CAACU,KAAV;UACA0I,CAAC,GAAGT,SAAS,CAAChE,CAAD,EAAI2E,CAAC,CAACjJ,KAAF,EAAJ,CAAb;;UACA,IAAG,CAAC+I,CAAJ,EAAO;YACH;YACA,IAAIG,EAAE,GAAGlE,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BF,CAAC,CAACjJ,KAAF,EAA7B,EAAwCqI,EAAxC,CAAT,CAFG,CAGH;;;YACA,IAAIe,EAAE,GAAGpE,EAAE,CAACzB,IAAH,CAAQ2F,EAAE,CAAC,CAAD,CAAF,CAAMlJ,KAAN,EAAR,EAAuBqI,EAAvB,CAAT;;YACA,IAAIgB,GAAG,GAAGrE,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BC,EAAE,CAACpJ,KAAH,EAA7B,EAAyCqI,EAAzC,CAAV,CALG,CAMH;;;YACA,IAAGnM,CAAC,CAACiF,QAAF,CAAW+H,EAAE,CAAC,CAAD,CAAb,EAAkBG,GAAG,CAAC,CAAD,CAArB,EAA0BhJ,KAA1B,CAAgCC,MAAhC,CAAuCgE,CAAC,CAACjE,KAAzC,CAAH,EAAoD;cAChD,IAAIR,CAAC,GAAG3D,CAAC,CAACmG,MAAF,CAAS6G,EAAE,CAAC,CAAD,CAAF,CAAMlJ,KAAN,EAAT,EAAwBqJ,GAAG,CAAC,CAAD,CAAH,CAAOrJ,KAAP,EAAxB,CAAR;;cAEA,IAAIsJ,OAAO,GAAGpN,CAAC,CAACiF,QAAF,CAAWtB,CAAC,CAACG,KAAF,EAAX,EAAsB9D,CAAC,CAACyE,GAAF,CAAM,IAAIjE,MAAJ,CAAWiD,CAAC,CAACkE,KAAb,CAAN,EAA2B3H,CAAC,CAACiF,QAAF,CAAW+H,EAAE,CAAC,CAAD,CAAb,EAAkB,IAAIxM,MAAJ,CAAWiM,CAAX,CAAlB,CAA3B,CAAtB,CAAd;;cACAW,OAAO,GAAGpN,CAAC,CAACiF,QAAF,CAAWmI,OAAX,EAAoB,IAAI5M,MAAJ,CAAWiM,CAAX,CAApB,CAAV;cACA,OAAO3D,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwBD,OAAxB,EAAiCX,CAAjC,EAAoC,CAApC,EAAuC,EAAvC,EAA2CC,GAA3C,CAA+CD,CAA/C,EAAkDO,EAAE,CAAC,CAAD,CAAF,CAAMlJ,KAAN,EAAlD,CAAP;YACH;UAEJ;;UACD,IAAIwJ,UAAU,GAAGxE,EAAE,CAAC0D,SAAH,CAAa/I,CAAC,CAACiJ,GAAF,CAAMK,CAAC,CAACjJ,KAAF,EAAN,EAAiB,IAAItD,MAAJ,CAAWiM,CAAX,CAAjB,CAAb,EAA8CA,CAA9C,EAAiD,CAAjD,CAAjB;UAAA,IACQjJ,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWqI,UAAU,CAACZ,GAAX,CAAe,IAAIlM,MAAJ,CAAWiM,CAAX,CAAf,EAA8BM,CAA9B,CAAX,EAA6CF,CAA7C,CADjB;;UAIA,OAAOrJ,MAAP;QACH,CAxBI,MAyBA,IAAGoJ,EAAE,KAAKxL,EAAP,IAAauL,EAAE,KAAKvL,EAAvB,EAA2B;UAC5B,IAAI2L,CAAC,GAAG3E,CAAC,CAACjE,KAAV;UACA0I,CAAC,GAAGT,SAAS,CAAC3I,CAAD,EAAIsJ,CAAC,CAACjJ,KAAF,EAAJ,CAAb;;UACA,IAAIwJ,UAAU,GAAGxE,EAAE,CAAC0D,SAAH,CAAapE,CAAC,CAACsE,GAAF,CAAMK,CAAN,EAAS,IAAIvM,MAAJ,CAAWiM,CAAX,CAAT,CAAb,EAAsCA,CAAtC,EAAyC,CAAzC,CAAjB;;UACA,OAAOzM,CAAC,CAACiF,QAAF,CAAWqI,UAAU,CAACZ,GAAX,CAAe,IAAIlM,MAAJ,CAAWiM,CAAX,CAAf,EAA8BM,CAA9B,CAAX,EAA6CF,CAA7C,CAAP;QACH,CALI,MAMA,IAAGpJ,CAAC,CAACkC,WAAF,MAAmByC,CAAC,CAACzC,WAAF,EAAtB,EAAuC;UACxC,IAAI+D,CAAC,GAAG,SAAJA,CAAI,CAAUjG,CAAV,EAAa2E,CAAb,EAAgB;YACpB,IAAIqC,CAAC,GAAG3B,EAAE,CAACzB,IAAH,CAAQe,CAAR,EAAW+D,EAAX,CAAR;;YACA,IAAIoB,CAAC,GAAGzN,IAAI,CAACsG,OAAL,CAAaoH,MAAb,CAAoBtH,MAApB,CAA2BzC,CAA3B,CAAR;YAAA,IACQgK,CAAC,GAAG3N,IAAI,CAACsG,OAAL,CAAaoH,MAAb,CAAoBtH,MAApB,CAA2BuE,CAA3B,CADZ;;YAEA,IAAI4B,CAAC,GAAGrM,CAAC,CAACmG,MAAF,CAASoH,CAAT,EAAYE,CAAZ,CAAR;;YACA,OAAOpB,CAAP;UACH,CAND;;UAOA,IAAIqB,EAAE,GAAGjK,CAAC,CAACkC,WAAF,KAAkBlC,CAAC,CAACK,KAAF,GAAUY,QAAV,EAAlB,GAAyCjB,CAAC,CAACK,KAAF,EAAlD;UAAA,IACQ6J,EAAE,GAAGvF,CAAC,CAACzC,WAAF,KAAkByC,CAAC,CAACtE,KAAF,GAAUY,QAAV,EAAlB,GAAyC0D,CAAC,CAACtE,KAAF,EADtD;UAEA+I,CAAC,GAAGT,SAAS,CAACsB,EAAE,CAAC5J,KAAH,EAAD,EAAa6J,EAAE,CAAC7J,KAAH,EAAb,EAAyB4F,CAAzB,CAAb;UACA,IAAGmD,CAAH,EACI,OAAO7M,CAAC,CAACiF,QAAF,CAAW6D,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8B1E,CAA9B,CAAX,EAA6CyE,CAA7C,CAAP;UACJA,CAAC,GAAGT,SAAS,CAACuB,EAAE,CAAC7J,KAAH,EAAD,EAAa4J,EAAE,CAAC5J,KAAH,EAAb,EAAyB4F,CAAzB,CAAb;UACA,IAAGmD,CAAH,EACI,OAAO7M,CAAC,CAACiF,QAAF,CAAW6D,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BrJ,CAA9B,CAAX,EAA6CoJ,CAA7C,CAAP;QACP;MACJ,CAlGQ;MAmGT;MACAC,cAAc,EAAE,wBAAUvH,CAAV,EAAa;QACzB,IAAIwH,CAAC,GAAGxH,CAAC,CAACpB,KAAF,CAAQwE,QAAR,EAAR;QAAA,IACQhF,CAAC,GAAG4B,CAAC,CAAC3B,UAAF,CAAagK,SAAb,EADZ;QAAA,IAEQ9I,CAAC,GAAGS,CAAC,CAACxB,gBAAF,GAAqBW,QAArB,EAFZ;;QAGA,IAAG6D,MAAM,CAACwE,CAAD,CAAN,KAAc,CAAC,CAAlB,EAAqB;UACjB,OAAO/M,CAAC,CAACiF,QAAF,CAAW,IAAIzE,MAAJ,CAAWmD,CAAX,CAAX,EAA0B3D,CAAC,CAAC6J,WAAF,CAAcvI,GAAd,EAAmB,CAACwD,CAAD,CAAnB,CAA1B,CAAP;QACH;;QACD,OAAO9E,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,iCAAD,EAAoC+C,CAApC,EAAuCmB,CAAvC,EAA0CiI,CAA1C,CAAd,CAAP;MACH,CA5GQ;MA6GT;MACA;MACAc,IAAI,EAAE,cAAU7K,GAAV,EAAe;QACjBA,GAAG,GAAGA,GAAG,IAAI,6BAAb;QACAlD,IAAI,CAACO,KAAL,CAAWyN,IAAX,CAAgB9K,GAAhB;QACA,MAAM,IAAID,eAAJ,CAAoBC,GAApB,CAAN;MACH,CAnHQ;MAoHT+K,gBAAgB,EAAE,0BAAUC,KAAV,EAAiB7B,EAAjB,EAAqB8B,KAArB,EAA4BC,GAA5B,EAAiC;QAC/C;QACA,IAAG,CAAC9N,QAAQ,CAAC+L,EAAD,CAAZ,EACIA,EAAE,GAAGnM,CAAC,CAACkE,KAAF,CAAQiI,EAAR,CAAL;QAEJ,IAAIR,MAAJ,EAAYwC,iBAAZ;QACAxC,MAAM,GAAG,IAAInL,MAAJ,CAAW,CAAX,CAAT;QACA2N,iBAAiB,GAAGrO,IAAI,CAACsG,OAAL,CAAagI,QAAb,CAAsBC,QAAtB,CAA+BL,KAA/B,EAAsC7B,EAAtC,CAApB;;QAEA,IAAGgC,iBAAiB,CAAC5K,KAAlB,KAA4BpC,EAA5B,IAAkCgN,iBAAiB,CAACnK,QAAlB,EAArC,EAAmE;UAC/D;UACAmK,iBAAiB,CAACtJ,IAAlB,CAAuB,UAAUU,CAAV,EAAa;YAChC,IAAG,CAACA,CAAC,CAACvB,QAAF,EAAJ,EACI8E,EAAE,CAACmD,WAAH,CAAe4B,IAAf;UACP,CAHD;UAIAM,iBAAiB,CAACtJ,IAAlB,CAAuB,UAAUU,CAAV,EAAa;YAChCoG,MAAM,GAAG3L,CAAC,CAACgF,GAAF,CAAM2G,MAAN,EAAc7C,EAAE,CAAC0D,SAAH,CAAajH,CAAb,EAAgB4G,EAAhB,EAAoB8B,KAApB,EAA2BC,GAA3B,CAAd,CAAT;UACH,CAFD;QAGH,CATD,MAUK;UACDvC,MAAM,GAAG3L,CAAC,CAACgF,GAAF,CAAM2G,MAAN,EAAc7C,EAAE,CAAC0D,SAAH,CAAa2B,iBAAb,EAAgChC,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAd,CAAT;QACH;;QACD,OAAOvC,MAAP;MACH,CA3IQ;MA4IT2C,OAAO,EAAE,iBAAU7I,MAAV,EAAkB;QACvB,IAAI8I,KAAK,GAAG,CAAC;UAAC;QAAD,CAAD,EAAU;UAAC;QAAD,CAAV,EAAmB;UAAC;QAAD,CAAnB,EAA4B;UAAC;QAAD,CAA5B,EAAqC;UAAC;QAAD,CAArC,CAAZ,CADuB,CAEvB;;QACA,IAAIC,SAAS,GAAG,SAAZA,SAAY,CAAUjJ,CAAV,EAAa;UACzB,IAAI0F,CAAC,GAAG1F,CAAC,CAAChC,KAAV;;UACA,IAAG0H,CAAC,KAAK3K,EAAT,EAAa;YACT,IAAI2D,KAAK,GAAGsB,CAAC,CAACtB,KAAd;YACA,IAAGnE,IAAI,CAACO,KAAL,CAAW+E,OAAX,CAAmBnB,KAAnB,KAA6BnE,IAAI,CAACO,KAAL,CAAWmG,QAAX,CAAoBvC,KAApB,CAAhC,EACIsK,KAAK,CAAC,CAAD,CAAL,CAASjE,IAAT,CAAc/E,CAAd,EADJ,KAEK,IAAGzF,IAAI,CAACO,KAAL,CAAWgF,eAAX,CAA2BpB,KAA3B,CAAH,EACDsK,KAAK,CAAC,CAAD,CAAL,CAASjE,IAAT,CAAc/E,CAAd,EADC,KAEA,IAAGtB,KAAK,KAAK3C,GAAb,EACDiN,KAAK,CAAC,CAAD,CAAL,CAASjE,IAAT,CAAc/E,CAAd,EADC,KAEA;cACDuD,EAAE,CAACmD,WAAH,CAAe4B,IAAf;YACH;UACJ,CAXD,MAYK,IAAG5C,CAAC,KAAKjK,CAAN,IAAWuE,CAAC,CAACI,WAAF,MAAmBJ,CAAC,CAACvB,QAAF,EAA9B,IAA8CiH,CAAC,KAAK9J,EAAN,IAAYoE,CAAC,CAACvB,QAAF,EAA7D,EAA2E;YAC5EuK,KAAK,CAAC,CAAD,CAAL,CAASjE,IAAT,CAAc/E,CAAd;UACH,CAFI,MAGA,IAAG0F,CAAC,KAAK7J,EAAN,IAAYmE,CAAC,CAACI,WAAF,MAAmB,CAACJ,CAAC,CAACvB,QAAF,EAAnC,EACDuK,KAAK,CAAC,CAAD,CAAL,CAASjE,IAAT,CAAc/E,CAAd,EADC,KAGDuD,EAAE,CAACmD,WAAH,CAAe4B,IAAf;QACP,CArBD;;QAuBA,IAAGpI,MAAM,CAAClC,KAAP,KAAiBpC,EAApB,EACIsE,MAAM,CAACZ,IAAP,CAAY,UAAUU,CAAV,EAAa;UACrBiJ,SAAS,CAAChO,MAAM,CAACiO,UAAP,CAAkBlJ,CAAlB,EAAqB,IAArB,CAAD,CAAT;QACH,CAFD,EADJ,KAKIiJ,SAAS,CAAC/I,MAAD,CAAT;QACJ,IAAIgH,CAAJ;QAAA,IAAOiC,EAAE,GAAG,IAAIlO,MAAJ,CAAW,CAAX,CAAZ,CAhCuB,CAiCvB;;QACA,KAAI,IAAIwG,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,CAAnB,EAAsBA,CAAC,EAAvB,EAA2B;UACvB,IAAI2H,IAAI,GAAGJ,KAAK,CAACvH,CAAD,CAAhB;UAAA,IAAqBjC,CAArB;UAAA,IACQ+C,CAAC,GAAG6G,IAAI,CAAC5G,MADjB;;UAEA,IAAGD,CAAC,GAAG,CAAP,EAAU;YACN,IAAGA,CAAC,GAAG,CAAP,EAAU;cACN/C,CAAC,GAAG,IAAIvE,MAAJ,CAAW,CAAX,CAAJ;;cACA,KAAI,IAAI0G,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGY,CAAnB,EAAsBZ,CAAC,EAAvB;gBACInC,CAAC,GAAG/E,CAAC,CAACiF,QAAF,CAAWF,CAAX,EAAc4J,IAAI,CAACzH,CAAD,CAAJ,CAAQpD,KAAR,EAAd,CAAJ;cADJ;YAEH,CAJD,MAMIiB,CAAC,GAAG4J,IAAI,CAAC,CAAD,CAAJ,CAAQ7K,KAAR,EAAJ;;YAEJ,IAAG,CAAC2I,CAAJ,EAAO;cACHA,CAAC,GAAG1H,CAAJ,CADG,CACG;;cACN0H,CAAC,CAAC7I,UAAF,GAAe6I,CAAC,CAAC7I,UAAF,CAAaqB,QAAb,CAAsBQ,MAAM,CAAC7B,UAA7B,CAAf,CAFG,CAEsD;YAC5D,CAHD,MAKI8K,EAAE,GAAG1O,CAAC,CAACiF,QAAF,CAAWyJ,EAAX,EAAe3J,CAAf,CAAL,CAdE,CAcsB;;UAC/B;QACJ;;QAED,OAAO,CAAC0H,CAAD,EAAIiC,EAAJ,CAAP;MACH,CApMQ;MAsMTE,QAAQ,EAAE,kBAAUnJ,MAAV,EAAkB0G,EAAlB,EAAsB8B,KAAtB,EAA6BC,GAA7B,EAAkCK,KAAlC,EAAyCjJ,OAAzC,EAAkD;QACxDiJ,KAAK,GAAGA,KAAK,IAAIzF,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BxH,MAAM,CAAC3B,KAAP,GAAeY,QAAf,EAA7B,EAAwDyH,EAAxD,CAAjB;QACA,IAAI/D,CAAC,GAAGmG,KAAK,CAAC,CAAD,CAAb;QAAA,IACQM,EAAE,GAAGN,KAAK,CAAC,CAAD,CADlB;QAAA,IAEQ9K,CAAC,GAAG8K,KAAK,CAAC,CAAD,CAFjB;QAAA,IAGQhJ,CAAC,GAAGgJ,KAAK,CAAC,CAAD,CAHjB;;QAIA,IAAGhJ,CAAC,CAACpB,KAAF,CAAQC,MAAR,CAAe,CAAf,KAAqBX,CAAC,CAACqL,WAAF,CAAc,CAAd,CAAxB,EAA0C;UACtC;UACA,IAAI/J,CAAC,GAAGjF,IAAI,CAACO,KAAL,CAAW0O,IAAX,CAAgBtJ,MAAhB,CAAR;UAAA,IAAiC;UACzBgH,CAAC,GAAGzM,CAAC,CAACkE,KAAF,CAAQtC,GAAG,GAAGlB,UAAU,CAACqE,CAAD,CAAxB,CADZ;UAAA,IAC0C;UAClCiK,EAAE,GAAGhP,CAAC,CAACkE,KAAF,CAAQrC,GAAG,GAAGnB,UAAU,CAACqE,CAAD,CAAhB,GAAsB,IAA9B,CAFb;UAAA,IAEkD;UAC1C2E,CAAC,GAAG1J,CAAC,CAACiF,QAAF,CAAWQ,MAAM,CAACiH,GAAP,CAAWnH,CAAX,EAAckH,CAAd,CAAX,EAA6BuC,EAA7B,CAHZ;;UAIA,IAAIC,QAAQ,GAAGnG,EAAE,CAAC0D,SAAH,CAAa9C,CAAb,EAAgB3E,CAAhB,EAAmBkJ,KAAnB,EAA0BC,GAA1B,EAA+BxB,GAA/B,CAAmCD,CAAnC,EAAsClH,CAAtC,CAAf;;UACAzF,IAAI,CAACO,KAAL,CAAW6O,MAAX,CAAkBzC,CAAlB;UACA,OAAOwC,QAAP;QACH;MACJ,CAtNQ;MAwNT5B,QAAQ,EAAE,kBAAU5H,MAAV,EAAkB0G,EAAlB,EAAsB8B,KAAtB,EAA6BkB,CAA7B,EAAgC;QACtCA,CAAC,CAACC,QAAF,GAAaD,CAAC,CAACC,QAAF,IAAc,EAA3B;QACA,IAAIC,GAAJ,EAAS5C,CAAT,EAAYiC,EAAZ,EAAgBM,EAAhB,EAAoBjI,CAApB,EAAuBuI,GAAvB,EAA4BC,EAA5B,EAAgC/L,MAAhC,EAAwCgM,YAAxC,EAAsD7L,CAAtD,EAAyD+H,CAAzD,EAA4D+D,KAA5D,CAFsC,CAGtC;;QACAJ,GAAG,GAAGvG,EAAE,CAACmD,WAAH,CAAeqC,OAAf,CAAuB7I,MAAvB,CAAN;QACAgH,CAAC,GAAG4C,GAAG,CAAC,CAAD,CAAP;QACAX,EAAE,GAAGW,GAAG,CAAC,CAAD,CAAR;QACAL,EAAE,GAAGxO,MAAM,CAACiO,UAAP,CAAkBzO,CAAC,CAAC4E,MAAF,CAASkE,EAAE,CAACzB,IAAH,CAAQoF,CAAC,CAAC3I,KAAF,EAAR,EAAmBqI,EAAnB,CAAT,CAAlB,EAAoD,IAApD,CAAL;QACAT,CAAC,GAAGsD,EAAE,CAAClL,KAAH,GAAW4L,QAAX,CAAoBvD,EAApB,CAAJ,CARsC,CAStC;;QACA6C,EAAE,GAAGhP,CAAC,CAACmG,MAAF,CAAS6I,EAAT,EAAatD,CAAC,CAAC5H,KAAF,EAAb,CAAL;QACAiD,CAAC,GAAG+B,EAAE,CAAC0D,SAAH,CAAakC,EAAE,CAAC5K,KAAH,EAAb,EAAyBqI,EAAzB,EAA6B8B,KAAK,IAAI,CAAtC,CAAJ;QACAqB,GAAG,GAAGtP,CAAC,CAACiF,QAAF,CAAW8B,CAAC,CAACjD,KAAF,EAAX,EAAsBkL,EAAtB,CAAN;QACAS,KAAK,GAAGH,GAAG,CAAC3G,QAAJ,EAAR,CAbsC,CActC;;QACA,IAAGwG,CAAC,CAACC,QAAF,CAAW9I,OAAX,CAAmBmJ,KAAnB,MAA8B,CAAC,CAA/B,IAAqC3P,IAAI,CAACO,KAAL,CAAW+E,OAAX,CAAmBqH,CAAC,CAACxI,KAArB,CAArC,IAAqEyK,EAAE,CAACiB,GAAH,EAAxE,EAAkF;UAC9E;UACA;UACA;UACAR,CAAC,CAACS,SAAF,GAAc,IAAd,CAJ8E,CAK9E;;UACA,OAAO,IAAIpP,MAAJ,CAAW,CAAX,CAAP;QACH,CAPD,MASI2O,CAAC,CAACC,QAAF,CAAW9E,IAAX,CAAgBmF,KAAhB;;QAEJF,EAAE,GAAGvP,CAAC,CAACiF,QAAF,CAAWwH,CAAX,EAAc1F,CAAd,CAAL,CA1BsC,CA2BtC;;QACApD,CAAC,GAAG2L,GAAG,CAAC1L,UAAJ,CAAeE,KAAf,EAAJ;QACAwL,GAAG,CAACvL,gBAAJ;QACAyL,YAAY,GAAGxP,CAAC,CAACiF,QAAF,CAAW6D,EAAE,CAAC0D,SAAH,CAAa8C,GAAG,CAACxL,KAAJ,EAAb,EAA0BqI,EAA1B,EAA8B8B,KAA9B,EAAqCkB,CAArC,CAAX,EAAoDzD,CAApD,CAAf;QACA8D,YAAY,CAAC5L,UAAb,GAA0B4L,YAAY,CAAC5L,UAAb,CAAwBqB,QAAxB,CAAiCtB,CAAjC,CAA1B;QACAH,MAAM,GAAGxD,CAAC,CAACgL,QAAF,CAAWuE,EAAX,EAAeC,YAAf,CAAT,CAhCsC,CAiCtC;;QACA,IAAGL,CAAC,CAACS,SAAL,EAAgB;UACZ;UACAT,CAAC,CAACC,QAAF,CAAWS,GAAX;;UACA,IAAGV,CAAC,CAACC,QAAF,CAAWrH,MAAX,KAAsB,CAAzB,EAA4B;YACxBvE,MAAM,GAAGxD,CAAC,CAAC4E,MAAF,CAASpB,MAAT,CAAT;YACA,IAAIsM,GAAG,GAAG,IAAItP,MAAJ,CAAW,CAAX,CAAV;YACAgD,MAAM,CAACqB,IAAP,CAAY,UAAUU,CAAV,EAAa;cACrB,IAAG,CAACA,CAAC,CAACwF,QAAF,CAAWoB,EAAX,CAAJ,EACI2D,GAAG,GAAG9P,CAAC,CAACgF,GAAF,CAAM8K,GAAN,EAAWvK,CAAC,CAACzB,KAAF,EAAX,CAAN;YACP,CAHD,EAHwB,CAOxB;;YACAN,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAACgL,QAAF,CAAWxH,MAAX,EAAmBsM,GAAG,CAAChM,KAAJ,EAAnB,CAAT,EAA0C9D,CAAC,CAACgL,QAAF,CAAW,IAAIxK,MAAJ,CAAW,CAAX,CAAX,EAA0BsP,GAA1B,CAA1C,CAAT;UACH;QACJ;;QAED,OAAOtM,MAAP;MACH,CA1QQ;;MA2QT;AACZ;AACA;MACYyJ,aAAa,EAAEnN,IAAI,CAACO,KAAL,CAAW0P;IA9QjB,CArXQ;IAqoBrB;IACAvD,SAAS,EAAE,mBAAUwD,eAAV,EAA2BC,EAA3B,EAA+BhC,KAA/B,EAAsCC,GAAtC,EAA2C;MAClD;MACA,IAAG,CAAC+B,EAAJ,EAAQ;QACJ,IAAIrJ,IAAI,GAAG9G,IAAI,CAACO,KAAL,CAAWsK,SAAX,CAAqBqF,eAArB,CAAX;QACA,IAAGpJ,IAAI,CAACmB,MAAL,KAAgB,CAAnB,EACIkI,EAAE,GAAGrJ,IAAI,CAAC,CAAD,CAAT,CAHA,CAIJ;;QACAqJ,EAAE,GAAGA,EAAE,IAAI,GAAX;MACH,CARiD,CASlD;;;MACA,IAAGnQ,IAAI,CAACO,KAAL,CAAW6J,QAAX,CAAoB8F,eAApB,CAAH,EAAyC;QACrC,IAAI7F,MAAM,GAAG,IAAIrK,IAAI,CAACsK,MAAT,CAAgB,EAAhB,CAAb;QACA4F,eAAe,CAACnL,IAAhB,CAAqB,UAAUU,CAAV,EAAa;UAC9B4E,MAAM,CAACE,QAAP,CAAgBC,IAAhB,CAAqBxB,EAAE,CAAC0D,SAAH,CAAajH,CAAb,EAAgB0K,EAAhB,CAArB;QACH,CAFD;QAGA,OAAO9F,MAAP;MACH;;MACD,IAAG,CAAC+F,KAAK,CAACD,EAAD,CAAT,EACIjQ,CAAC,CAACmQ,KAAF,CAAQ,oCAAoCF,EAA5C,EAlB8C,CAmBlD;;MACA,IAAGD,eAAe,CAAC7K,UAAhB,CAA2B,IAA3B,CAAH,EACI,OAAOnF,CAAC,CAACiF,QAAF,CAAW+K,eAAe,CAAClM,KAAhB,EAAX,EAAoC9D,CAAC,CAACkE,KAAF,CAAQ+L,EAAR,CAApC,CAAP,CArB8C,CAuBlD;MACA;;MACA/B,GAAG,GAAGA,GAAG,IAAI,EAAb;MACA,OAAOpO,IAAI,CAACO,KAAL,CAAWoJ,KAAX,CAAiB,cAAjB,EAAiC,YAAY;QAChD;QACAwE,KAAK,GAAGA,KAAK,IAAI,CAAjB;QACA,IAAI9B,EAAE,GAAG/L,QAAQ,CAAC6P,EAAD,CAAR,GAAeA,EAAE,CAACtH,QAAH,EAAf,GAA+BsH,EAAxC;QAAA,IACQ;QACAxK,MAAM,GAAGjF,MAAM,CAACiO,UAAP,CAAkBuB,eAAe,CAAClM,KAAhB,EAAlB,EAA2C,IAA3C,CAFjB;QAAA,IAGQmH,CAAC,GAAGxF,MAAM,CAAClC,KAHnB;QAAA,IAIQC,MAJR;;QAMA,IAAI;UACA;UACA,IAAG,EAAEyK,KAAF,GAAUnO,IAAI,CAACK,QAAL,CAAcyI,iBAA3B,EACIE,EAAE,CAACmD,WAAH,CAAe4B,IAAf,CAAoB,iCAApB,EAHJ,CAKA;UACA;;UACA,IAAG,CAACpI,MAAM,CAACsF,QAAP,CAAgBoB,EAAhB,EAAoB,IAApB,CAAJ,EAA+B;YAC3B3I,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWQ,MAAM,CAAC3B,KAAP,EAAX,EAA2B9D,CAAC,CAACkE,KAAF,CAAQiI,EAAR,CAA3B,CAAT;UACH,CAFD,CAGA;UAHA,KAIK,IAAGlB,CAAC,KAAKjK,CAAT,EAAY;YACbwC,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BrH,MAA9B,EAAsC0G,EAAtC,EAA0C8B,KAA1C,CAAT;UACH,CAFI,MAGA,IAAGhD,CAAC,KAAK7J,EAAT,EAAa;YACd,IAAGqE,MAAM,CAAC2K,aAAP,KAAyB9P,EAAzB,IAA+B,EAAEmF,MAAM,CAACxB,KAAP,KAAiB,MAAjB,IAA2BwB,MAAM,CAACxB,KAAP,KAAiB9D,QAAQ,CAACkQ,WAAvD,CAAlC,EACIvH,EAAE,CAACmD,WAAH,CAAe4B,IAAf,GAFU,CAGd;;YACA,IAAGpI,MAAM,CAACsF,QAAP,CAAgBoB,EAAhB,KAAuB1G,MAAM,CAAC2K,aAAP,KAAyB9P,EAAnD,EAAuD;cACnD;cACA;cACA,IAAGmF,MAAM,CAACtB,KAAP,CAAa4G,QAAb,CAAsBoB,EAAtB,CAAH,EACIrD,EAAE,CAACmD,WAAH,CAAe4B,IAAf,GADJ,KAEK;gBACD,IAAI9I,CAAC,GAAG+D,EAAE,CAACzB,IAAH,CAAQ5B,MAAM,CAAC3B,KAAP,GAAeY,QAAf,EAAR,EAAmCyH,EAAnC,CAAR;;gBACA,IAAGpH,CAAC,CAACgG,QAAF,CAAWoB,EAAX,CAAH,EACIrD,EAAE,CAACmD,WAAH,CAAe4B,IAAf,GAHH,CAID;gBACA;;gBACArK,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BrH,MAA9B,EAAsC0G,EAAtC,EAA0C8B,KAA1C,CAAT;cACH;YACJ,CAbD,CAcA;YAdA,KAeK;cACD,IAAIxK,CAAC,GAAGqF,EAAE,CAACzB,IAAH,CAAQ5B,MAAM,CAACtB,KAAP,CAAaL,KAAb,EAAR,EAA8BqI,EAA9B,CAAR;;cACA,IAAG1I,CAAC,CAACsH,QAAF,CAAWoB,EAAX,CAAH,EAAmB;gBACf,IAAImE,EAAE,GAAG7M,CAAC,CAACiM,QAAF,CAAWvD,EAAX,CAAT;gBAAA,IACQ5G,CAAC,GAAGvF,CAAC,CAACmG,MAAF,CAAS1C,CAAC,CAACK,KAAF,EAAT,EAAoBwM,EAAE,CAACxM,KAAH,EAApB,CADZ;;gBAEA,IAAGyB,CAAC,CAAChC,KAAF,KAAYvC,CAAZ,IAAiBuE,CAAC,CAACvB,QAAF,EAApB,EAAkC;kBAC9BsM,EAAE,CAAC1M,UAAH,GAAgB0M,EAAE,CAAC1M,UAAH,CAAcuC,MAAd,CAAqB,IAAIjG,IAAJ,CAAS,CAAT,CAArB,CAAhB;kBACA,OAAOF,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,qDAAD,EAAwD0P,EAAxD,EAA4DnE,EAA5D,EAAgE1G,MAAM,CAAC7B,UAAvE,CAAd,CAAP;gBACH,CAHD,MAKIkF,EAAE,CAACmD,WAAH,CAAe4B,IAAf;cACP;;cACD,IAAGpI,MAAM,CAACkK,GAAP,EAAH,EAAiB;gBACb,IAAGlM,CAAC,CAACO,QAAF,EAAH,EACIR,MAAM,GAAGiC,MAAT,CADJ,KAEK;kBACD,IAAGhC,CAAC,CAACkM,GAAF,MAAWlM,CAAC,CAACU,KAAF,CAAQZ,KAAR,KAAkBvC,CAA7B,IAAkCyC,CAAC,CAACU,KAAF,CAAQA,KAAR,CAAcC,MAAd,CAAqB,CAArB,CAArC,EACIZ,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAAC6J,WAAF,CAAc,IAAd,EAAoB,CAACpE,MAAM,CAACtB,KAAP,CAAaL,KAAb,EAAD,CAApB,CAAX,EAAwD2B,MAAM,CAACtB,KAA/D,CAAT,CADJ,KAGI2E,EAAE,CAACmD,WAAH,CAAe4B,IAAf;gBACP;cACJ,CATD,MAUK;gBACD,IAAIpD,CAAC,GAAGzK,CAAC,CAAC6J,WAAF,CAAcvI,GAAd,EAAmB,CAACtB,CAAC,CAACkE,KAAF,CAAQuB,MAAM,CAACkC,KAAf,CAAD,CAAnB,CAAR;;gBACAnE,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAASV,MAAT,EAAiBgF,CAAjB,CAAT;cACH;;cACDjH,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAAS3C,MAAT,EAAiBC,CAAjB,CAAT;YACH;UACJ,CA/CI,MAgDA,IAAGgC,MAAM,CAACE,WAAP,MAAwBF,MAAM,CAACzB,QAAP,EAA3B,EAA8C;YAC/C,IAAIL,CAAC,GAAG3D,CAAC,CAACkE,KAAF,CAAQuB,MAAM,CAAC7B,UAAf,CAAR;;YACA6B,MAAM,CAAC1B,gBAAP;YACAP,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;YACAiF,MAAM,CAACZ,IAAP,CAAY,UAAUU,CAAV,EAAa;cACrB/B,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcsF,EAAE,CAAC0D,SAAH,CAAajH,CAAb,EAAgB4G,EAAhB,EAAoB8B,KAApB,CAAd,CAAT;YACH,CAFD;YAGAzK,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWtB,CAAX,EAAcH,MAAd,CAAT;UACH,CARI,MASA,IAAGyH,CAAC,KAAK/J,EAAT,EAAa;YACd,IAAGuE,MAAM,CAACtB,KAAP,CAAa2K,WAAb,CAAyB,CAAzB,CAAH,EACIrJ,MAAM,GAAGzF,CAAC,CAAC4E,MAAF,CAASa,MAAT,CAAT;;YACJ,IAAGA,MAAM,CAACtB,KAAP,CAAaC,MAAb,CAAoB,CAApB,CAAH,EAA2B;cACvBZ,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;cACAiF,MAAM,CAACZ,IAAP,CAAY,UAAUU,CAAV,EAAa;gBACrB/B,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcsF,EAAE,CAAC0D,SAAH,CAAajH,CAAb,EAAgB4G,EAAhB,EAAoB8B,KAApB,CAAd,CAAT;cACH,CAFD,EAEG,IAFH;YAGH,CALD,MAMK;cACD,IAAIlB,CAAC,GAAGxE,MAAM,CAAC9C,MAAM,CAACtB,KAAR,CAAd;cAAA,IACQR,CAAC,GAAG8B,MAAM,CAAC7B,UAAP,CAAkBE,KAAlB,EADZ,CADC,CAEqC;;cACtC2B,MAAM,CAAC1B,gBAAP;;cACA,IAAI;cACIkF,EAAE,GAAGxD,MAAM,CAAC3B,KAAP,GAAeY,QAAf,EADb;cAAA,IACwC;cAChC6L,MAAM,GAAGzH,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BhE,EAA7B,EAAiCkD,EAAjC,CAFjB;cAAA,IAGQ;cACA/D,CAAC,GAAGmI,MAAM,CAAC,CAAD,CAJlB;cAAA,IAKQ1B,EAAE,GAAG0B,MAAM,CAAC,CAAD,CALnB;cAAA,IAMQ9M,CAAC,GAAG8M,MAAM,CAAC,CAAD,CANlB;cAAA,IAOQhL,CAAC,GAAGgL,MAAM,CAAC,CAAD,CAPlB;;cAQA,IAAGxD,CAAC,KAAK,CAAC,CAAP,IAAYxH,CAAC,CAAChC,KAAF,KAAYtC,EAAxB,IAA8BsE,CAAC,CAACpB,KAAF,CAAQC,MAAR,CAAe,CAAf,CAAjC,EAAoD;gBAChD,IAAIoM,aAAa,GAAG7P,KAAK,CAACyH,CAAD,CAAL,GAAWA,CAAC,GAAG,CAAf,GAAmB,IAAvC,CADgD,CAEhD;;gBACA,IAAG7C,CAAC,CAAChC,KAAF,KAAYvC,CAAZ,IAAiBuE,CAAC,CAACpB,KAAF,CAAQC,MAAR,CAAe,CAAf,CAAjB,IAAsCoM,aAAzC,EAAwD;kBACpD;kBACA;kBACA,IAAIC,SAAS,GAAG,SAAZA,SAAY,CAAU3L,CAAV,EAAa;oBACzB,IAAI6G,MAAM,GAAG,IAAInL,MAAJ,CAAW,CAAX,CAAb;oBACAsE,CAAC,CAACD,IAAF,CAAO,UAAUU,CAAV,EAAa;sBAChBoG,MAAM,GAAG3L,CAAC,CAACiF,QAAF,CAAW0G,MAAX,EAAmBpG,CAAC,CAACtB,KAAF,KAAY,KAAZ,GAAoBsB,CAAC,CAAC7B,IAAF,CAAO,CAAP,CAApB,GAAgC6B,CAAnD,CAAT;oBACH,CAFD;oBAGA,OAAOoG,MAAP;kBACH,CAND;;kBAOA,IAAI4B,CAAC,GAAG9J,CAAC,CAACK,KAAF,EAAR;kBAAA,IACQ2J,CAAC,GAAGrF,CAAC,CAACtE,KAAF,EADZ;kBAEAyJ,CAAC,GAAGvN,CAAC,CAACyE,GAAF,CAAM8I,CAAN,EAAS,IAAI/M,MAAJ,CAAW,IAAI,CAAf,CAAT,CAAJ;kBACAiN,CAAC,GAAGzN,CAAC,CAACyE,GAAF,CAAMgJ,CAAN,EAAS,IAAIjN,MAAJ,CAAW,IAAI,CAAf,CAAT,CAAJ,CAboD,CAcpD;;kBAEA,IAAIiK,CAAC,GAAGzK,CAAC,CAACiF,QAAF,CAAWwL,SAAS,CAAChD,CAAD,CAApB,EAAyBgD,SAAS,CAAClD,CAAD,CAAlC,CAAR;kBAAA,IACQ7D,CAAC,GAAG1J,CAAC,CAAC6J,WAAF,CAAc3H,IAAd,EAAoB,CAAClC,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAACiF,QAAF,CAAWxB,CAAX,EAAc8B,CAAC,CAACb,QAAF,EAAd,CAAT,EAAsC+F,CAAC,CAAC3G,KAAF,EAAtC,CAAD,CAApB,CADZ;;kBAEAN,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAASuD,CAAT,EAAYe,CAAZ,CAAT;gBACH,CAnBD,MAoBK,IAAGlF,CAAC,CAAChC,KAAF,KAAYvC,CAAZ,IAAiBuE,CAAC,CAACvB,QAAF,EAApB,EAAkC;kBACnCR,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAAS2C,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BrH,MAA9B,CAAT,EAAgDhC,CAAhD,CAAT;gBACH,CAFI,MAGA;kBACD;kBACA,IAAG8B,CAAC,CAACpB,KAAF,CAAQC,MAAR,CAAe,CAAf,CAAH,EAAsB;oBAClB;oBACA,IAAImJ,CAAJ,EAAOE,CAAP,EAAUiD,CAAV,EAAaC,CAAb,EAAgBC,CAAhB,EAAmBC,CAAnB,EAAsBnD,EAAtB,EAA0BC,EAA1B,EAA8BmD,EAA9B,EAAkCC,EAAlC,EAAsCC,EAAtC,EAA0CC,EAA1C;oBACA,IAAIC,EAAE,GAAGxQ,UAAT,CAHkB,CAIlB;oBACA;;oBACA6M,CAAC,GAAGvN,CAAC,CAACkE,KAAF,CAAQzC,IAAI,GAAGyP,EAAE,CAACzN,CAAD,CAAT,GAAe,GAAf,GAAqB0I,EAArB,GAA0B,IAAlC,CAAJ;oBACAsB,CAAC,GAAGzN,CAAC,CAACkE,KAAF,CAAQzC,IAAI,GAAGyP,EAAE,CAAC,CAAD,CAAT,GAAe,GAAf,GAAqBA,EAAE,CAACzN,CAAD,CAAvB,GAA6B,GAA7B,GAAmCyN,EAAE,CAAC,KAAD,CAArC,GAA+C,GAA/C,GAAqDA,EAAE,CAAC9I,CAAD,CAAvD,GAA6D,GAA7D,GAAmE8I,EAAE,CAAC,KAAD,CAArE,GAA+E,GAA/E,GAAqF/E,EAA7F,CAAJ;oBACAuE,CAAC,GAAG1Q,CAAC,CAACkE,KAAF,CAAQzC,IAAI,GAAGyP,EAAE,CAAC9I,CAAD,CAAjB,CAAJ;oBACAsF,EAAE,GAAG1N,CAAC,CAACgF,GAAF,CAAMhF,CAAC,CAACgF,GAAF,CAAMuI,CAAC,CAACzJ,KAAF,EAAN,EAAiB2J,CAAC,CAAC3J,KAAF,EAAjB,CAAN,EAAmC4M,CAAC,CAAC5M,KAAF,EAAnC,CAAL;oBACA6J,EAAE,GAAG3N,CAAC,CAACgF,GAAF,CAAMhF,CAAC,CAACgL,QAAF,CAAWuC,CAAX,EAAcE,CAAd,CAAN,EAAwBiD,CAAxB,CAAL,CAVkB,CAWlB;;oBACAC,CAAC,GAAG3Q,CAAC,CAACkE,KAAF,CAAQzC,IAAI,GAAGyP,EAAE,CAAC,CAAD,CAAT,GAAe,GAAf,GAAqBA,EAAE,CAAC9I,CAAD,CAAvB,GAA6B,GAA7B,GAAmC8I,EAAE,CAAC,KAAD,CAA7C,CAAJ;oBACAN,CAAC,GAAG5Q,CAAC,CAACkE,KAAF,CAAQzC,IAAI,GAAGyP,EAAE,CAAC9I,CAAD,CAAT,GAAe,GAAf,GAAqB8I,EAAE,CAAC9I,CAAD,CAAvB,GAA6B,GAA7B,GAAmC8I,EAAE,CAAC,KAAD,CAArC,GAA+C,GAA/C,GAAqD/E,EAA7D,CAAJ,CAbkB,CAclB;;oBACA0E,CAAC,GAAG7Q,CAAC,CAACkE,KAAF,CAAQ,IAAI,GAAJ,GAAUgN,EAAE,CAAC9I,CAAD,CAAZ,GAAkB,GAAlB,GAAwB3G,IAAxB,GAA+ByP,EAAE,CAAC,CAAD,CAAjC,GAAuC,GAAvC,GAA6CA,EAAE,CAAC9I,CAAD,CAA/C,GAAqD,GAArD,GAA2D8I,EAAE,CAAC,KAAD,CAArE,CAAJ,CAfkB,CAgBlB;;oBACAF,EAAE,GAAGhR,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAACgL,QAAF,CAAW2F,CAAC,CAAC7M,KAAF,EAAX,EAAsB8M,CAAC,CAAC9M,KAAF,EAAtB,CAAT,EAA2C9D,CAAC,CAACiF,QAAF,CAAW4L,CAAC,CAAC/M,KAAF,EAAX,EAAsB6J,EAAtB,CAA3C,CAAL;oBACAsD,EAAE,GAAGjR,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAACgF,GAAF,CAAM2L,CAAN,EAASC,CAAT,CAAT,EAAsB5Q,CAAC,CAACiF,QAAF,CAAW4L,CAAX,EAAcnD,EAAE,CAAC5J,KAAH,EAAd,CAAtB,CAAL;oBACAN,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CACD8D,EAAE,CAAC0D,SAAH,CAAawE,EAAb,EAAiB7E,EAAjB,EAAqB8B,KAArB,EAA4BC,GAA5B,CADC,EAEDpF,EAAE,CAAC0D,SAAH,CAAayE,EAAb,EAAiB9E,EAAjB,EAAqB8B,KAArB,EAA4BC,GAA5B,CAFC,CAAT;kBAIH,CAvBD,MAyBI;oBACA1K,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAe8B,gBAAf,CAAgCtI,MAAhC,EAAwC0G,EAAxC,EAA4C8B,KAA5C,CAAT;gBACP;cACJ,CAxDD,MAyDK,IAAGlB,CAAC,KAAK,CAAC,CAAD,GAAK,CAAd,EAAiB;gBAClB;gBACA,IAAGxH,CAAC,CAAChC,KAAF,KAAYvC,CAAZ,IAAiBuE,CAAC,CAACpB,KAAF,CAAQC,MAAR,CAAe,CAAf,CAApB,EAAuC;kBACnC,IAAGyK,EAAE,CAACjL,UAAH,CAAcS,QAAd,CAAuB,CAAvB,KAA6B,CAAC+D,CAAC,CAACxE,UAAF,CAAaS,QAAb,CAAsB,CAAtB,CAAjC,EAA2D;oBACvDZ,CAAC,CAACa,MAAF,GADuD,CAEvD;;oBACA,IAAG8D,CAAC,CAACjD,UAAF,MAAkB1B,CAAC,CAAC0B,UAAF,EAArB,EAAqC;sBACjC,IAAIsF,CAAC,GAAGzK,CAAC,CAAC6J,WAAF,CAAcpI,IAAd,EAAoB,CAACgC,CAAC,CAACK,KAAF,EAAD,CAApB,CAAR;sBAAA,IACQqN,EAAE,GAAGnR,CAAC,CAAC6J,WAAF,CAAcpI,IAAd,EAAoB,CAACzB,CAAC,CAACiF,QAAF,CAAWxB,CAAC,CAACK,KAAF,EAAX,EAAsBsE,CAAtB,CAAD,CAApB,CADb;;sBAEA5E,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAAC6J,WAAF,CAAc7H,IAAd,EAAoB,CAAChC,CAAC,CAACmG,MAAF,CAAS0I,EAAE,CAACnK,QAAH,EAAT,EAAwByM,EAAxB,CAAD,CAApB,CAAT,EAA6D1G,CAA7D,CAAT;oBACH,CAJD,CAKA;oBALA,KAMK;sBACD,IAAI2G,MAAM,GAAGpR,CAAC,CAAC6J,WAAF,CAAcpI,IAAd,EAAoB,CAACgC,CAAD,CAApB,CAAb;sBAAA,IACQ4N,OAAO,GAAGrR,CAAC,CAACiF,QAAF,CAAWmM,MAAM,CAACtN,KAAP,EAAX,EAA2ByB,CAAC,CAACzB,KAAF,GAAUY,QAAV,EAA3B,CADlB;;sBAEAlB,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAAC6J,WAAF,CAAc3H,IAAd,EAAoB,CAAClC,CAAC,CAACmG,MAAF,CAASkL,OAAT,EAAkBrR,CAAC,CAAC6J,WAAF,CAAcpI,IAAd,EAAoB,CAACwH,EAAE,CAACnF,KAAH,EAAD,CAApB,CAAlB,CAAD,CAApB,CAAT,EAAsFsN,MAAtF,CAAT;oBACH;kBACJ,CAdD,MAeK;oBACD;oBACAtI,EAAE,CAACmD,WAAH,CAAe4B,IAAf;kBACH;gBACJ,CApBD,MAqBK;kBACD;kBACA/E,EAAE,CAACmD,WAAH,CAAe4B,IAAf;gBACH;cACJ,CA3BI,MA4BA,IAAGd,CAAC,KAAK,IAAE,CAAR,IAAaxH,CAAC,CAACpB,KAAF,CAAQC,MAAR,CAAe,CAAf,CAAb,IAAkCX,CAAC,CAACqL,WAAF,CAAc,CAAd,CAArC,EAAuD;gBACxD;gBACAhG,EAAE,CAACmD,WAAH,CAAe4B,IAAf;cACH,CAHI,MAIA;gBACD,IAAGtI,CAAC,CAACvB,QAAF,MAAgBuB,CAAC,CAAChC,KAAF,KAAYtC,EAA/B,EACIuC,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAAS2C,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BrH,MAA9B,CAAT,EAAgDhC,CAAhD,CAAT,CADJ,KAEK,IAAG8B,CAAC,CAACpB,KAAF,CAAQC,MAAR,CAAe,CAAf,KAAqBX,CAAC,CAACqL,WAAF,CAAc,CAAd,CAAxB,EAA0C;kBAC3C,IAAIwC,GAAJ,EAASC,GAAT,EAAcC,GAAd,EAAmBC,IAAnB,EAAyBlN,CAAzB,EAA4B0K,QAA5B,EAAsCxC,CAAtC,EAAyC1F,CAAzC,EAA4CwI,EAA5C,CAD2C,CAE3C;kBACA;;kBACA+B,GAAG,GAAGtR,CAAC,CAACkE,KAAF,CAAQzC,IAAI,GAAGf,UAAU,CAAC+C,CAAD,CAAzB,CAAN,CAJ2C,CAIN;;kBACrC8N,GAAG,GAAGvR,CAAC,CAACkE,KAAF,CAAQzC,IAAI,GAAGf,UAAU,CAAC0H,CAAD,CAAzB,CAAN;kBACAoJ,GAAG,GAAGxR,CAAC,CAACiF,QAAF,CAAWqM,GAAG,CAACxN,KAAJ,EAAX,EAAwByN,GAAG,CAACzN,KAAJ,EAAxB,EAAqC4N,MAArC,EAAN;kBACAD,IAAI,GAAGzR,CAAC,CAACyE,GAAF,CAAM2D,CAAN,EAAS,IAAI5H,MAAJ,CAAWiF,MAAM,CAACtB,KAAlB,CAAT,CAAP;kBACAoL,EAAE,GAAGzP,IAAI,CAACO,KAAL,CAAW0O,IAAX,CAAgBtJ,MAAhB,CAAL;kBACAgH,CAAC,GAAGzM,CAAC,CAACiF,QAAF,CAAWuM,GAAX,EAAgBjM,CAAC,CAACzB,KAAF,GAAUY,QAAV,EAAhB,CAAJ;kBACAqC,CAAC,GAAG/G,CAAC,CAACkE,KAAF,CAAQhC,IAAI,GAAGxB,UAAU,CAAC+L,CAAD,CAAzB,CAAJ,CAV2C,CAW3C;kBACA;kBACA;;kBACA,IAAIlI,CAAC,GAAG,CAACoN,IAAI,CAACnK,GAAL,CAAS/B,MAAM,CAACtB,KAAhB,IAAyB,CAA1B,IAA+B,CAAvC,CAd2C,CAe3C;;kBACA,IAAI8K,QAAQ,GAAGnG,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACkE,KAAF,CAAQvC,GAAG,GAAGjB,UAAU,CAAC6O,EAAD,CAAhB,GAAuB,GAAvB,GAA6BhL,CAArC,CAAb,CAAf;;kBACAzE,IAAI,CAACO,KAAL,CAAW6O,MAAX,CAAkBK,EAAlB;kBACA,OAAOvP,CAAC,CAACiF,QAAF,CAAWgK,QAAQ,CAACvC,GAAT,CAAa6C,EAAb,EAAiBxI,CAAjB,CAAX,EAAgC0K,IAAhC,CAAP;gBACH,CAnBI,MAoBA;kBACD,IAAGhM,MAAM,CAAClC,KAAP,KAAiBpC,EAAjB,IAAuB,CAACsE,MAAM,CAACtB,KAAP,CAAaE,QAAb,CAAsB,CAAtB,CAA3B,EAAqD;oBACjDb,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;kBACH,CAFD,MAGK;oBACD,IAAIxE,CAAC,GAAGjE,MAAM,CAAC3B,KAAP,GAAeY,QAAf,EAAR;oBACA,IAAIkN,QAAQ,GAAG9R,IAAI,CAACsG,OAAL,CAAaoH,MAAb,CAAoBtH,MAApB,CAA2BwD,CAA3B,CAAf;oBACA,IAAImI,YAAY,GAAGD,QAAQ,CAACjJ,QAAT,OAAwBe,CAAC,CAACf,QAAF,EAA3C;;oBACA,IAAG7I,IAAI,CAACsG,OAAL,CAAa0L,MAAb,CAAoBpI,CAApB,EAAuB1J,CAAC,CAACkE,KAAF,CAAQiI,EAAR,CAAvB,EAAoC/H,MAApC,CAA2C,CAA3C,KAAiD,CAACyN,YAArD,EAAmE;sBAC/D,IAAI;wBACA,IAAInE,EAAJ,EAAQqE,EAAR,EAAYtF,CAAZ,EAAeuF,EAAf;wBACAA,EAAE,GAAGlS,IAAI,CAACsG,OAAL,CAAa6L,UAAb,CAAwBvI,CAAxB,EAA2ByC,EAA3B,CAAL;wBACAM,CAAC,GAAG3M,IAAI,CAACO,KAAL,CAAW0O,IAAX,CAAgBrF,CAAhB,CAAJ;wBACAgE,EAAE,GAAGsE,EAAE,CAACtI,CAAH,CAAKgD,GAAL,CAASsF,EAAE,CAACvO,CAAZ,EAAegJ,CAAf,CAAL;wBACAsF,EAAE,GAAG/R,CAAC,CAACyE,GAAF,CAAMiJ,EAAN,EAAU1N,CAAC,CAACkE,KAAF,CAAQuB,MAAM,CAACtB,KAAf,CAAV,CAAL;wBACAX,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAauF,EAAb,EAAiBtF,CAAjB,EAAoBC,GAApB,CAAwBD,CAAxB,EAA2BuF,EAAE,CAACvO,CAA9B,CAAT;sBACH,CAPD,CAQA,OAAM0D,CAAN,EAAS;wBACL2B,EAAE,CAACmD,WAAH,CAAe4B,IAAf;sBACH;oBACJ,CAZD,MAcIrK,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAe8B,gBAAf,CAAgCtI,MAAhC,EAAwC0G,EAAxC,EAA4C8B,KAA5C,EAAmDC,GAAnD,CAAT;kBACP;gBACJ;cACJ;;cACD1K,MAAM,CAACI,UAAP,GAAoBJ,MAAM,CAACI,UAAP,CAAkBqB,QAAlB,CAA2BtB,CAA3B,CAApB;YACH;UACJ,CAjKI,MAkKA,IAAGsH,CAAC,KAAK3K,EAAT,EAAa;YACd,IAAI+K,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV;YAAA,IACQC,CAAC,GAAG8B,MAAM,CAAC7B,UAAP,CAAkBE,KAAlB,EADZ;YAEA2B,MAAM,CAAC1B,gBAAP;;YACA,IAAIwM,MAAM,GAAGzH,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6B5B,GAA7B,EAAkCc,EAAlC,CAAb,CAJc,CAKd;YACA;YACA;;;YACA,IAAI1I,CAAC,GAAG8M,MAAM,CAAC,CAAD,CAAd;YAAA,IACQhL,CAAC,GAAGgL,MAAM,CAAC,CAAD,CADlB;YAAA,IAEQtM,KAAK,GAAGwB,MAAM,CAACxB,KAFvB,CARc,CAWd;;YACA,IAAGA,KAAK,KAAK3C,GAAV,IAAkB2C,KAAK,KAAKjC,IAAV,IAAkBiC,KAAK,KAAKhC,IAA5B,IAAoCgC,KAAK,KAAK/B,IAAV,IAAkBqD,CAAC,CAACvB,QAAF,EAA3E,EAA0F;cACtF;cACA,IAAI+I,CAAC,GAAGtH,MAAM,CAACtB,KAAP,CAAawE,QAAb,EAAR;cACA,IAAGhI,KAAK,CAACoM,CAAD,CAAR,EACIkB,KAAK,GAAGA,KAAK,GAAGlB,CAAhB,CAJkF,CAI/D;;cAEvB,IAAG,CAAC1B,GAAG,CAAC1F,WAAJ,EAAJ,EACInC,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAACkE,KAAF,CAAQP,CAAR,CAAX,EAAuBmF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAvB,CAAT,CADJ,KAEK;gBACD;gBACA,IAAIzB,CAAC,GAAG3M,IAAI,CAACO,KAAL,CAAW0O,IAAX,CAAgBtJ,MAAhB,CAAR;;gBACA,IAAIiE,CAAC,GAAG1J,CAAC,CAACyE,GAAF,CAAMzE,CAAC,CAACkE,KAAF,CAAQ5C,GAAG,GAAGZ,UAAU,CAAC+L,CAAD,CAAxB,CAAN,EAAoC,IAAIjM,MAAJ,CAAWuM,CAAX,CAApC,CAAR;;gBACA,IAAIiC,EAAE,GAAGlG,EAAE,CAACzB,IAAH,CAAQgE,GAAR,EAAac,EAAb,CAAT;;gBACA,IAAI+F,IAAI,GAAGlS,CAAC,CAACiF,QAAF,CAAWyE,CAAX,EAAcsF,EAAd,CAAX;;gBACA,IAAIC,QAAQ,GAAGnG,EAAE,CAAC0D,SAAH,CAAa0F,IAAb,EAAmBzF,CAAnB,EAAsBwB,KAAtB,EAA6BC,GAA7B,CAAf;;gBACA1K,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAACkE,KAAF,CAAQP,CAAR,CAAX,EAAuBsL,QAAQ,CAACvC,GAAT,CAAaD,CAAb,EAAgBpB,GAAhB,CAAvB,CAAT;cACH;YAEJ,CAlBD,MAmBK,IAAGpH,KAAK,KAAKrC,GAAV,IAAiB6D,MAAM,CAACtB,KAAP,CAAaE,QAAb,CAAsB,CAAtB,CAApB,EAA8C;cAC/C;cACA,IAAIR,GAAG,GAAG4B,MAAM,CAAC3B,KAAP,EAAV;cACAD,GAAG,CAACM,KAAJ,CAAUG,MAAV;cACAT,GAAG,CAACI,KAAJ,GAAYlC,GAAZ;cACA,OAAO/B,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAACkE,KAAF,CAAQP,CAAR,CAAX,EAAuBmF,EAAE,CAAC0D,SAAH,CAAa3I,GAAb,EAAkBsI,EAAlB,EAAsB8B,KAAtB,CAAvB,CAAP;YACH,CANI,MAOA;cACD,IAAG,CAACxK,CAAC,CAACsH,QAAF,CAAWoB,EAAX,EAAe,IAAf,CAAD,IAAyB1G,MAAM,CAACzB,QAAP,EAA5B,EAA+C;gBAAE;gBAC7C;gBACA,IAAGC,KAAK,KAAKzC,GAAb,EAAkB;kBACd;kBACA,IAAI+D,CAAC,GAAGvF,CAAC,CAACmG,MAAF,CAASkF,GAAG,CAACvH,KAAJ,EAAT,EAAsBL,CAAC,CAACK,KAAF,EAAtB,CAAR;;kBACA,IAAGyB,CAAC,CAAChC,KAAF,KAAYvC,CAAZ,IAAiB,CAACuE,CAAC,CAACpB,KAAF,CAAQE,QAAR,CAAiB,CAAjB,CAArB,EAA0C;oBACtC,IAAGvE,IAAI,CAACO,KAAL,CAAWQ,IAAX,CAAgB0E,CAAC,CAACpB,KAAlB,CAAH,EAA6B;sBACzBX,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAanB,GAAb,EAAkBc,EAAlB,EAAsB8B,KAAtB,CAAT;oBACH,CAFD,MAGK;sBACD,IAAIX,UAAU,GAAGxE,EAAE,CAAC0D,SAAH,CAAajH,CAAb,EAAgB4G,EAAhB,EAAoB8B,KAApB,CAAjB;;sBACAX,UAAU,CAACnJ,KAAX,GAAmBmJ,UAAU,CAACnJ,KAAX,CAAiB6G,QAAjB,CAA0B,IAAI9K,IAAJ,CAAS,CAAT,CAA1B,CAAnB;sBACAsD,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAAC6J,WAAF,CAAcrI,GAAd,EAAmB,CAAC+D,CAAC,CAACb,QAAF,EAAD,CAAnB,CAAX,EAA+C4I,UAA/C,CAAX,EAAuE7J,CAAvE,CAAT;oBACH;kBACJ,CATD,MAWIqF,EAAE,CAACmD,WAAH,CAAe4B,IAAf;gBACP,CAfD,MAgBK;kBACD,IAAIsE,EAAE,GAAG1M,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeH,KAAxB;kBAAA,IACQ6O,UAAU,GAAGtJ,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6B5B,GAA7B,EAAkCc,EAAlC,CADrB;;kBAGA,IAAG,EAAEgG,EAAE,KAAKjR,EAAP,IAAaiR,EAAE,KAAKnR,CAApB,IAAyBmR,EAAE,KAAKhR,EAAlC,KAAyC,CAACiR,UAAU,CAAC,CAAD,CAAV,CAAcjO,KAAd,CAAoBC,MAApB,CAA2B,CAA3B,CAA1C,IAA2EiH,GAAG,CAACgH,OAAJ,EAA9E,EACIvJ,EAAE,CAACmD,WAAH,CAAe4B,IAAf;kBACJ;kBAAW;;kBACX,QAAO5J,KAAP;oBACI,KAAKtC,GAAL;sBACI6B,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAcnI,GAAd,EAAmB,CAAC2J,GAAD,CAAnB,CAAT;sBACA;;oBACJ,KAAK3J,GAAL;sBACI8B,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAclI,GAAd,EAAmB,CAAC0J,GAAD,CAAnB,CAAT;sBACA7H,MAAM,CAACc,MAAP;sBACA;;oBACJ,KAAK1C,GAAL;sBACI4B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAACT,QAAQ,CAACmB,GAAT,GAAe,YAAhB,EAA8B+J,GAA9B,CAAd,CAAT;sBACA;;oBACJ,KAAKxJ,GAAL;sBACI2B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAACT,QAAQ,CAACmB,GAAT,GAAe,qBAAhB,EAAuC+J,GAAvC,CAAd,CAAT;sBACA;;oBACJ,KAAKvJ,GAAL;sBACI0B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,MAAMT,QAAQ,CAACmB,GAAf,GAAqB,qBAAtB,EAA6C+J,GAA7C,CAAd,CAAT;sBACA;;oBACJ,KAAKtJ,GAAL;sBACIyB,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAACT,QAAQ,CAACmB,GAAT,GAAe,YAAhB,EAA8B+J,GAA9B,CAAd,CAAT;sBACA;;oBACJ,KAAK/I,IAAL;sBACIkB,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAActH,IAAd,EAAoB,CAAC8I,GAAD,CAApB,CAAT;sBACA;;oBACJ,KAAK9I,IAAL;sBACIiB,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAcvH,IAAd,EAAoB,CAAC+I,GAAD,CAApB,CAAT;sBACA;;oBACJ,KAAK7I,IAAL;sBACIgB,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAACT,QAAQ,CAACmB,GAAT,GAAe,aAAhB,EAA+B+J,GAA/B,CAAd,CAAT;sBACA;;oBACJ,KAAKlJ,IAAL;sBACIqB,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;sBACA;;oBACJ,KAAK9L,IAAL;sBACIoB,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;sBACA;;oBACJ,KAAK7L,IAAL;sBACImB,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;sBACA;oBACA;;oBACJ,KAAKtL,KAAL;sBACIY,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;sBACA;;oBACJ,KAAKrL,KAAL;sBACIW,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;sBACA;;oBACJ,KAAKpL,KAAL;sBACIU,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;sBACA;oBACA;oBACA;;oBACJ,KAAKxL,IAAL;sBACIc,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,iBAAD,EAAoByK,GAApB,CAAd,CAAT;sBACA;;oBACJ,KAAK5I,IAAL;sBACIe,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAACT,QAAQ,CAACmB,GAAT,GAAe,iBAAhB,EAAmC+J,GAAnC,CAAd,CAAT;sBACA;;oBACJ,KAAK1I,IAAL;sBACIa,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAACT,QAAQ,CAACmB,GAAT,GAAe,aAAhB,EAA+B+J,GAA/B,CAAd,CAAT;sBACA;oBACA;;oBACJ,KAAK9J,GAAL;sBACIiC,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,SAAD,EAAYyK,GAAZ,CAAd,CAAb,EAA8Cc,EAA9C,EAAkD8B,KAAlD,CAAT;sBACA;;oBACJ,KAAK,GAAL;sBACI,IAAI5C,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeI,KAAf,EAAV;sBAAA,IACQkJ,EAAE,GAAGlE,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6B5B,GAA7B,EAAkCc,EAAlC,CADb;sBAAA,IAEQZ,EAAE,GAAGyB,EAAE,CAAC,CAAD,CAFf;sBAAA,IAGQsF,EAAE,GAAGtF,EAAE,CAAC,CAAD,CAHf;;sBAIA,IAAIuF,EAAE,GAAGvF,EAAE,CAAC,CAAD,CAAX;sBACAxJ,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,8FAAD,EAAiG0R,EAAjG,EAAqGC,EAArG,EAAyGhN,CAAzG,CAAd,CAAT;sBACA;;oBACJ,KAAK,GAAL;sBACI,IAAI8F,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeI,KAAf,EAAV;sBAAA,IACQkJ,EAAE,GAAGlE,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6B5B,GAA7B,EAAkCc,EAAlC,CADb;sBAAA,IAEQZ,EAAE,GAAGyB,EAAE,CAAC,CAAD,CAFf;sBAAA,IAGQsF,EAAE,GAAGtF,EAAE,CAAC,CAAD,CAHf;;sBAIA,IAAIuF,EAAE,GAAGvF,EAAE,CAAC,CAAD,CAAX;sBACAxJ,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,8FAAD,EAAiG0R,EAAjG,EAAqGC,EAArG,EAAyGhH,EAAzG,CAAd,CAAT;sBACA;;oBACJ,KAAK,KAAL;sBACI,IAAIF,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeI,KAAf,EAAV;sBAAA,IACQkJ,EAAE,GAAGlE,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6B5B,GAA7B,EAAkCc,EAAlC,CADb;sBAAA,IAEQZ,EAAE,GAAGyB,EAAE,CAAC,CAAD,CAFf;sBAAA,IAGQsF,EAAE,GAAGtF,EAAE,CAAC,CAAD,CAHf;;sBAIAxJ,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,4DAAD,EAA+D0R,EAA/D,EAAmE/G,EAAnE,EAAuEF,GAAvE,CAAd,CAAT;sBACA;;oBACJ,KAAK,MAAL;sBACI7H,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWQ,MAAM,CAAC3B,KAAP,EAAX,EAA2BuH,GAAG,CAACvH,KAAJ,EAA3B,CAAT;sBACA;;oBACJ;sBACIgF,EAAE,CAACmD,WAAH,CAAe4B,IAAf;;kBA1FR;;kBA6FArK,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAAS3C,MAAT,EAAiBC,CAAjB,CAAT;gBACH;cACJ,CAxHD,MAyHK,IAAG8B,CAAC,CAACvB,QAAF,EAAH,EAAiB;gBAClB,IAAGC,KAAK,KAAKtC,GAAV,IAAiBsC,KAAK,KAAKvC,GAA9B,EAAmC;kBAC/B,IAAIqL,CAAC,GAAGxE,MAAM,CAAC9C,MAAM,CAACtB,KAAR,CAAd,CAD+B,CAE/B;;kBACA,IAAG4I,CAAC,GAAG,CAAP,EAAU;oBACNtH,MAAM,CAACxB,KAAP,GAAeA,KAAK,KAAKvC,GAAV,GAAgBI,GAAhB,GAAsBD,GAArC;oBACA4D,MAAM,CAACiM,MAAP,GAAgB9F,UAAhB;oBACApI,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAa/G,MAAb,EAAqB0G,EAArB,EAAyB8B,KAAzB,CAAT;kBACH,CAJD,MAKK;oBACD,IAAI5C,GAAG,GAAG5F,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAV;oBAAA,IACQ8O,EAAE,GAAG/M,MAAM,CAAC3B,KAAP,EADb;oBAAA,IAC6B;oBACrB2O,GAAG,GAAGhN,MAAM,CAAC3B,KAAP,EAFd;oBAAA,IAE8B;oBACtBuI,CAAC,GAAG,IAAI7L,MAAJ,CAAW,CAACuM,CAAC,GAAG,CAAL,IAAUA,CAArB,CAHZ;oBAAA,IAGqC;oBAC7B2F,EAAE,GAAG1S,CAAC,CAACiF,QAAF,CAAWxB,CAAC,CAACK,KAAF,EAAX,EAAsB,IAAItD,MAAJ,CAAWuM,CAAX,CAAtB,EAAqC2E,MAArC,EAJb,CADC,CAK2D;;;oBAC5Dc,EAAE,CAACrO,KAAH,GAAWqO,EAAE,CAACrO,KAAH,CAAS6G,QAAT,CAAkB,IAAI9K,IAAJ,CAAS,CAAT,CAAlB,CAAX;oBACAuS,GAAG,CAACtO,KAAJ,GAAYsO,GAAG,CAACtO,KAAJ,CAAU6G,QAAV,CAAmB,IAAI9K,IAAJ,CAAS,CAAT,CAAnB,CAAZ;;oBAEA,IAAI6E,CAAC,GAAG/E,CAAC,CAAC6J,WAAF,CAAc5F,KAAK,KAAKtC,GAAV,GAAgBD,GAAhB,GAAsBC,GAApC,EAAyC,CAAC0J,GAAG,CAACvH,KAAJ,EAAD,CAAzC,CAAR;;oBACA,IAAGG,KAAK,KAAKvC,GAAb,EACIqD,CAAC,CAACT,MAAF;oBACJd,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMhF,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAACiF,QAAF,CAAWyN,EAAX,EAAeF,EAAf,CAAX,EAA+BzN,CAA/B,CAAN,EAAyC/E,CAAC,CAACiF,QAAF,CAAWoH,CAAX,EAAcvD,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACkE,KAAF,CAAQuO,GAAR,CAAb,EAA2BtG,EAA3B,EAA+B8B,KAA/B,CAAd,CAAzC,CAAT;kBACH;gBACJ,CAtBD,CAuBA;gBAvBA,KAwBK,IAAGhK,KAAK,KAAKrC,GAAV,IAAiBqC,KAAK,KAAKlC,GAA9B,EAAmC;kBACpC;kBACA,IAAG0D,MAAM,CAAC/B,IAAP,CAAY,CAAZ,EAAeM,QAAf,CAAwBmI,EAAxB,CAAH,EAAgC;oBAC5B,IAAI5H,CAAC,GAAGkB,MAAM,CAACtB,KAAP,CAAa6G,QAAb,CAAsB,IAAI9K,IAAJ,CAAS,CAAT,CAAtB,EAAmCyI,QAAnC,EAAR;oBAAA,IACQgK,CAAC,GAAGlN,MAAM,CAAC3B,KAAP,GAAeC,gBAAf,EADZ;oBAAA,IAEQ6O,CAAC,GAAG5S,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,CAACqD,KAAK,KAAKlC,GAAV,GAAgB,GAAhB,GAAsB,EAAvB,IAA6B,4BAA9B,EAA4DwC,CAA5D,EAA+D8G,GAA/D,EAAoE5H,CAApE,EAAuEQ,KAAvE,CAAd,CAFZ;;oBAGA0O,CAAC,CAACxO,KAAF,GAAUwO,CAAC,CAACxO,KAAF,CAAQ6G,QAAR,CAAiB,IAAI9K,IAAJ,CAAS,CAAT,CAAjB,CAAV;oBACA,IAAGyS,CAAC,CAACxO,KAAF,CAAQC,MAAR,CAAe,CAAf,CAAH,EACIuO,CAAC,GAAG3S,CAAC,CAACkE,KAAF,CAAQyO,CAAR,CAAJ;oBACJnP,MAAM,GAAGxD,CAAC,CAACgL,QAAF,CAAW4H,CAAX,EAAc9J,EAAE,CAAC0D,SAAH,CAAamG,CAAb,EAAgBxG,EAAhB,EAAoB8B,KAApB,CAAd,CAAT;kBACH;gBACJ,CAXI,CAYL;gBAZK,KAaA,IAAGhK,KAAK,KAAKpC,GAAV,IAAiBoC,KAAK,KAAKnC,GAA9B,EAAmC;kBACpC;kBACA,IAAI+Q,EAAE,GAAGpN,MAAM,CAACtB,KAAP,CAAa6G,QAAb,CAAsB,IAAI9K,IAAJ,CAAS,CAAT,CAAtB,EAAmCyI,QAAnC,EAAT;kBAAA,IACQmK,EAAE,GAAGrN,MAAM,CAACtB,KAAP,CAAa6G,QAAb,CAAsB,IAAI9K,IAAJ,CAAS,CAAT,CAAtB,EAAmCyI,QAAnC,EADb;kBAAA,IAEQgF,EAAE,GAAG1J,KAAK,KAAKpC,GAAV,GAAgBD,GAAhB,GAAsBG,GAFnC;kBAAA,IAGQ4Q,CAAC,GAAGlN,MAAM,CAAC3B,KAAP,GAAeC,gBAAf,EAHZ;kBAAA,IAIQgP,SAAS,GAAGnS,MAAM,CAAC,CAACqD,KAAK,KAAKnC,GAAV,GAAgB,GAAhB,GAAsB,EAAvB,IAA6B,qCAA9B,EAAqE2B,CAArE,EAAwEoP,EAAxE,EAA4EC,EAA5E,EAAgFzH,GAAhF,EAAqFpH,KAArF,EAA4F0J,EAA5F,CAJ1B;kBAAA,IAKQiF,CAAC,GAAG5S,CAAC,CAACkE,KAAF,CAAQ6O,SAAR,CALZ;;kBAMAJ,CAAC,CAACxO,KAAF,GAAUwO,CAAC,CAACxO,KAAF,CAAQ6G,QAAR,CAAiB,IAAI9K,IAAJ,CAAS,CAAT,CAAjB,CAAV;kBACA,IAAGyS,CAAC,CAACxO,KAAF,CAAQC,MAAR,CAAe,CAAf,CAAH,EACIuO,CAAC,GAAG3S,CAAC,CAACkE,KAAF,CAAQyO,CAAR,CAAJ;kBACJnP,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAM4N,CAAN,EAAS5S,CAAC,CAACiF,QAAF,CAAW,IAAIzE,MAAJ,CAAWsS,EAAE,GAAGD,EAAhB,CAAX,EAAgC/J,EAAE,CAAC0D,SAAH,CAAamG,CAAb,EAAgBxG,EAAhB,EAAoB8B,KAApB,CAAhC,CAAT,CAAT;gBACH,CAZI,MAaA,IAAG,CAAChK,KAAK,KAAK1B,IAAV,IAAkB0B,KAAK,KAAK3B,IAA7B,KAAsCmD,MAAM,CAACtB,KAAP,CAAaC,MAAb,CAAoB,CAApB,CAAzC,EAAiE;kBAClEZ,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAa/G,MAAM,CAACnC,WAAP,EAAb,EAAmC6I,EAAnC,EAAuC8B,KAAvC,CAAT;gBACH,CAFI,MAIDnF,EAAE,CAACmD,WAAH,CAAe4B,IAAf;cACP,CAxDI,MA0DD/E,EAAE,CAACmD,WAAH,CAAe4B,IAAf;;cAEJrK,MAAM,CAACI,UAAP,GAAoBJ,MAAM,CAACI,UAAP,CAAkBqB,QAAlB,CAA2BtB,CAA3B,CAApB;YACH;UACJ,CA9NI,MA+NA,IAAGsH,CAAC,KAAKhK,EAAT,EAAa;YACduC,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAe8B,gBAAf,CAAgCtI,MAAhC,EAAwC0G,EAAxC,EAA4C8B,KAA5C,CAAT;UACH,CAFI,MAGA,IAAGhD,CAAC,KAAK9J,EAAT,EAAa;YACd,IAAI8E,GAAG,GAAGR,MAAM,CAACK,QAAP,EAAV;YACA,IAAGG,GAAG,CAAC1C,KAAJ,KAAcvC,CAAjB,EACIyE,MAAM,GAAGzF,CAAC,CAAC4E,MAAF,CAASa,MAAT,CAAT,CAHU,CAKd;;YACA,IAAIuN,KAAK,GAAGvN,MAAM,CAACiK,QAAP,CAAgBvD,EAAhB,CAAZ,CANc,CAOd;;YACA,IAAI8G,QAAQ,GAAGjT,CAAC,CAACmG,MAAF,CAASV,MAAM,CAAC3B,KAAP,EAAT,EAAyBkP,KAAK,CAAClP,KAAN,EAAzB,CAAf,CARc,CAQ0C;YACxD;;;YACA,IAAGkP,KAAK,CAACjI,QAAN,CAAeoB,EAAf,CAAH,EAAuB;cACnB8G,QAAQ,GAAGjT,CAAC,CAACiF,QAAF,CAAWgO,QAAX,EAAqBD,KAArB,CAAX;cACAA,KAAK,GAAG,IAAIxS,MAAJ,CAAW,CAAX,CAAR;YACH,CAba,CAed;YACA;;;YACA,IAAGyS,QAAQ,CAAC1P,KAAT,KAAmBpC,EAAtB,EAA0B;cACtB,IAAG8R,QAAQ,CAAC7O,MAAT,CAAgB,CAAhB,CAAH,EAAuB;gBACnB,OAAO0E,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAASa,MAAT,CAAb,EAA+B0G,EAA/B,EAAmC8B,KAAnC,CAAP;cACH,CAHqB,CAKtB;;;cACA,IAAGgF,QAAQ,CAACnP,KAAT,GAAiBY,QAAjB,GAA4BwO,MAA5B,CAAmC,IAAnC,KAA4CpT,IAAI,CAACO,KAAL,CAAWsK,SAAX,CAAqBsI,QAArB,EAA+BlL,MAA/B,GAAwC,CAAvF,EAA0F;gBACtFkL,QAAQ,GAAGnT,IAAI,CAACsG,OAAL,CAAaoH,MAAb,CAAoBtH,MAApB,CAA2B+M,QAA3B,CAAX;cACH;;cAEDzP,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAayG,QAAb,EAAuB9G,EAAvB,EAA2B8B,KAA3B,CAAT;YACH,CAXD,MAYK;cACD;cACA,IAAI3I,OAAO,GAAG2N,QAAQ,CAAClH,cAAT,GAA0BoH,IAA1B,CAA+B,UAAU1P,CAAV,EAAa2E,CAAb,EAAgB;gBACzD,IAAG3E,CAAC,CAACF,KAAF,KAAY6E,CAAC,CAAC7E,KAAjB,EAAwB;kBACpB,IAAGgF,MAAM,CAAC9E,CAAC,CAACU,KAAH,CAAN,KAAoBoE,MAAM,CAACH,CAAC,CAACjE,KAAH,CAA7B,EACI,IAAGV,CAAC,GAAG2E,CAAP,EACI,OAAO,CAAP,CADJ,CACc;kBADd,KAGI,OAAO,CAAC,CAAR;kBACR,OAAOA,CAAC,CAACjE,KAAF,GAAUV,CAAC,CAACU,KAAnB,CANoB,CAMM;gBAC7B;;gBACD,OAAOiE,CAAC,CAAC7E,KAAF,GAAUE,CAAC,CAACF,KAAnB,CATyD,CAS/B;cAC7B,CAVa,EAUXmF,GAVW,CAUP,UAAUnD,CAAV,EAAa;gBAChB,IAAI6N,SAAS,GAAG5S,MAAM,CAACiO,UAAP,CAAkBlJ,CAAlB,EAAqB,IAArB,CAAhB;;gBACA,IAAG6N,SAAS,CAACnP,KAAV,KAAoB1C,GAAvB,EAA4B;kBACxB,OAAOvB,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,eAAD,EAAkBwS,SAAS,CAAC1P,IAAV,CAAe,CAAf,CAAlB,EAAqC0P,SAAS,CAACxP,UAA/C,CAAd,CAAP;gBACH;;gBACD,OAAOwP,SAAP;cACH,CAhBa,CAAd;cAiBA,IAAItL,CAAC,GAAGxC,OAAO,CAACyC,MAAhB;;cACA,IAAGtC,MAAM,CAACtB,KAAP,GAAe,CAAlB,EAAqB;gBACjB,IAAG2D,CAAC,KAAK,CAAT,EAAY;kBACR,OAAOgB,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAASa,MAAT,CAAb,EAA+B0G,EAA/B,EAAmC8B,KAAnC,EAA0CC,GAA1C,CAAP;gBACH;cACJ,CAJD,CAKA;cALA,KAMK;gBACD;gBACA,IAAGpG,CAAC,KAAK,CAAT,EAAY;kBACR;kBACA,IAAI;oBACAtE,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeC,cAAf,CAA8B5G,OAA9B,EAAuC6G,EAAvC,CAAT;kBACH,CAFD,CAGA,OAAMhF,CAAN,EAAS;oBAAC;oBACN;kBACH;;kBAED,IAAG,CAAC3D,MAAJ,EAAY;oBACR;oBACA;oBACA,IAAImJ,EAAE,GAAGrH,OAAO,CAAC,CAAD,CAAP,CAAW/B,KAApB;oBAAA,IACQqJ,EAAE,GAAGtH,OAAO,CAAC,CAAD,CAAP,CAAW/B,KADxB;oBAAA,IAEQ8P,IAAI,GAAG/N,OAAO,CAAC,CAAD,CAFtB;oBAAA,IAGQgO,IAAI,GAAGhO,OAAO,CAAC,CAAD,CAHtB;oBAAA,IAIQiO,GAAG,GAAGF,IAAI,CAACpP,KAJnB;oBAAA,IAKQuP,GAAG,GAAGF,IAAI,CAACrP,KALnB,CAHQ,CASR;;oBACAwB,MAAM,GAAGzF,CAAC,CAACiF,QAAF,CAAWoO,IAAI,CAACvP,KAAL,EAAX,EAAyBwP,IAAI,CAACxP,KAAL,EAAzB,CAAT;;oBACA,IAAG6I,EAAE,KAAKrM,EAAP,IAAasM,EAAE,KAAKtM,EAAvB,EAA2B;sBACvB,IAAGiT,GAAG,KAAKjS,GAAR,IAAekS,GAAG,KAAKlS,GAA1B,EAA+B;wBAC3BkC,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAM,CAAC3B,KAAP,EAAxB,EAAwCqI,EAAxC,EAA4C8B,KAA5C,EAAmDC,GAAnD,CAAT;sBACH,CAFD,MAGK;wBACD5I,OAAO,CAAC6N,IAAR,CAAa,UAAU1P,CAAV,EAAa2E,CAAb,EAAgB;0BACzB,OAAOA,CAAC,CAACnE,KAAF,GAAUR,CAAC,CAACQ,KAAnB;wBACH,CAFD;wBAGA,IAAIwP,IAAI,GAAGJ,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAX,CAJC,CAKD;;wBACA,IAAG,CAAC+P,IAAI,CAACzP,QAAL,EAAD,IAAoB,EAAEyP,IAAI,CAAClQ,KAAL,KAAerC,EAAf,IAAqBuS,IAAI,CAAClQ,KAAL,KAAepC,EAApC,IAA0CsS,IAAI,CAAClQ,KAAL,KAAevC,CAA3D,CAAvB,EACI8H,EAAE,CAACmD,WAAH,CAAe4B,IAAf;;wBAEJ,IAAI0C,MAAM,GAAGzH,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BwG,IAA7B,EAAmCtH,EAAnC,CAAb;;wBACA5G,CAAC,GAAGgL,MAAM,CAAC,CAAD,CAAV,EACQ9M,CAAC,GAAG8M,MAAM,CAAC,CAAD,CADlB;wBAEA,IAAG,CAAChL,CAAC,CAACvB,QAAF,EAAJ,EAAkB;0BACd8E,EAAE,CAACmD,WAAH,CAAe4B,IAAf,GAbH,CAeD;wBACA;;wBACA,IAAI6F,IAAI,GAAGJ,IAAI,CAAC5P,IAAL,CAAU,CAAV,CAAX,CAjBC,CAkBD;;wBACA,IAAG+P,IAAI,CAACrP,MAAL,CAAYsP,IAAZ,CAAH,EAAsB;0BAClB,IAAGH,GAAG,KAAK7R,GAAR,IAAe8R,GAAG,KAAK7R,GAAvB,IAA8B4R,GAAG,KAAK5R,GAAR,IAAe6R,GAAG,KAAK9R,GAAxD,EAA6D;4BACzD,IAAG2R,IAAI,CAAClP,KAAL,CAAWE,QAAX,CAAoB,CAApB,CAAH,EACIyE,EAAE,CAACmD,WAAH,CAAe4B,IAAf,GAFqD,CAE/B;4BAC1B;;4BACA,IAAG0F,GAAG,KAAK7R,GAAR,IAAe2R,IAAI,CAAClP,KAAL,CAAWa,GAAX,CAAesO,IAAI,CAACnP,KAApB,EAA2BC,MAA3B,CAAkC,CAAlC,CAAlB,EAAwD;8BACpDiP,IAAI,CAACpP,KAAL,GAAarC,GAAb;8BACAyR,IAAI,CAACzH,UAAL;8BACApI,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAa6G,IAAb,EAAmBlH,EAAnB,EAAuB8B,KAAvB,CAAT;4BACH,CAJD,MAKK;8BACD,IAAGpN,IAAI,CAACwS,IAAI,CAAClP,KAAN,CAAJ,IAAoBqP,GAAG,KAAK7R,GAA5B,IAAmC2R,IAAI,CAACnP,KAAL,CAAWE,QAAX,CAAoB,CAApB,CAAtC,EAA8D;gCAC1D;gCACA,IAAIE,CAAC,GAAGgE,MAAM,CAAC8K,IAAI,CAAClP,KAAN,CAAN,GAAqB,CAA7B;gCAAA,IACQwP,OAAO,GAAG3T,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,sBAAD,EAAyByS,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAzB,EAAuCa,CAAvC,CAAd,CADlB;;gCAEAf,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACiF,QAAF,CAAW0O,OAAX,EAAoBL,IAAI,CAACxP,KAAL,EAApB,CAAT,CAAb,EAA0DqI,EAA1D,EAA8D8B,KAA9D,EAAqEC,GAArE,CAAT;8BACH,CALD,MAMK,IAAGrN,IAAI,CAACwS,IAAI,CAAClP,KAAN,CAAJ,IAAoBqP,GAAG,KAAK9R,GAA5B,IAAmC4R,IAAI,CAACnP,KAAL,CAAWE,QAAX,CAAoB,CAApB,CAAtC,EAA8D;gCAC/D;gCACA,IAAIE,CAAC,GAAGgE,MAAM,CAAC8K,IAAI,CAAClP,KAAN,CAAN,GAAqB,CAA7B;gCAAA,IACQwP,OAAO,GAAG3T,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,sBAAD,EAAyByS,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAzB,EAAuCa,CAAvC,CAAd,CADlB;;gCAEAf,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACiF,QAAF,CAAW0O,OAAX,EAAoBL,IAAI,CAACxP,KAAL,EAApB,CAAT,CAAb,EAA0DqI,EAA1D,EAA8D8B,KAA9D,EAAqEC,GAArE,CAAT;8BACH,CALI,MAMA;gCACD,IAAI0F,OAAO,GAAG9T,IAAI,CAACO,KAAL,CAAWQ,IAAX,CAAgBwS,IAAI,CAAClP,KAArB,CAAd;gCAAA,IACQ0P,OAAO,GAAG/T,IAAI,CAACO,KAAL,CAAWQ,IAAX,CAAgByS,IAAI,CAACnP,KAArB,CADlB;gCAEAX,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;;gCACA,IAAG,CAACoT,OAAD,IAAY,CAACC,OAAhB,EAAyB;kCACrB,IAAIpH,CAAJ,EAAOkG,CAAP,EAAUmB,KAAV,CADqB,CAErB;kCACA;;kCACA,IAAG,CAACF,OAAJ,EAAa;oCACT;oCACAnH,CAAC,GAAG6G,IAAJ;oCACAX,CAAC,GAAGU,IAAJ;kCACH,CAJD,MAKK;oCACD5G,CAAC,GAAG4G,IAAJ;oCACAV,CAAC,GAAGW,IAAJ;kCACH,CAZoB,CAarB;;;kCACA,IAAIS,IAAI,GAAGtH,CAAC,CAACxI,KAAF,KAAYtC,GAAZ,GAAkB,CAAC,CAAnB,GAAuB,CAAlC;kCAAA,IACQ4C,CAAC,GAAGoO,CAAC,CAACxO,KADd;kCAAA,IAEQ;kCACA;kCACA6P,CAAC,GAAG,CAACzP,CAAC,GAAG,CAAL,IAAU,CAJtB;kCAAA,IAKQ;kCACAuP,KAAK,GAAG9T,CAAC,CAACkE,KAAF,CAAQ,QAAQuI,CAAC,CAACxI,KAAV,GAAkBnE,IAAI,CAACO,KAAL,CAAWK,UAAX,CAAsB+S,IAAtB,CAAlB,GAAgD,MAAhD,GAAyDO,CAAjE,CANhB;kCAAA,IAOQnQ,GAAG,GAAG7D,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACiF,QAAF,CAAW,IAAIzE,MAAJ,CAAWuT,IAAX,CAAX,EAA6B/T,CAAC,CAACiF,QAAF,CAAWwH,CAAC,CAAC3I,KAAF,EAAX,EAAsBgQ,KAAtB,CAA7B,CAAT,CAPd,CAdqB,CAsBrB;;;kCACAjQ,GAAG,CAACgB,IAAJ,CAAS,UAAUU,CAAV,EAAa;oCAClB/B,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcsF,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BvH,CAAC,CAACzB,KAAF,EAA9B,CAAd,CAAT;kCACH,CAFD;gCAGH,CA1BD,MA2BK;kCACD;kCACA,IAAIU,YAAY,GAAG,SAAfA,YAAe,CAAUiB,MAAV,EAAkB;oCACjC,IAAIsH,CAAC,GAAGtH,MAAM,CAACtB,KAAf;oCAAA,IACQ6P,CAAC,GAAGjH,CAAC,GAAG,CADhB;oCAAA,IACmB5F,CADnB;oCAEA,IAAG1B,MAAM,CAACxB,KAAP,KAAiBtC,GAApB,EACIwF,CAAC,GAAG,oBAAoB1B,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAApB,GAAqC,SAArC,GAAiDsQ,CAArD,CADJ,KAGI7M,CAAC,GAAG,oBAAoB1B,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAApB,GAAqC,SAArC,GAAiDsQ,CAArD;oCAEJ,OAAOhU,CAAC,CAACkE,KAAF,CAAQiD,CAAR,CAAP;kCACH,CATD,CAFC,CAYD;kCACA;;;kCACA,IAAI1D,CAAC,GAAGe,YAAY,CAAC6O,IAAD,CAApB;kCAAA,IACQjL,CAAC,GAAG5D,YAAY,CAAC8O,IAAD,CADxB;kCAAA,IAEQvO,CAAC,GAAG/E,CAAC,CAACiF,QAAF,CAAWxB,CAAX,EAAc2E,CAAd,CAFZ;;kCAGA,IAAIvE,GAAG,GAAG7D,CAAC,CAAC4E,MAAF,CAASG,CAAT,CAAV;;kCACAlB,GAAG,CAACgB,IAAJ,CAAS,UAAUU,CAAV,EAAa;oCAClB/B,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcsF,EAAE,CAAC0D,SAAH,CAAajH,CAAb,EAAgB4G,EAAhB,EAAoB8B,KAApB,CAAd,CAAT;kCACH,CAFD;kCAGA,OAAOjO,CAAC,CAACiF,QAAF,CAAWzB,MAAX,EAAmBwP,KAAnB,CAAP;gCACH;8BACJ;4BACJ;0BACJ,CA9ED,CA+EA;0BA/EA,KAgFK,IAAGO,GAAG,KAAK1R,GAAR,IAAe2R,GAAG,KAAK5R,GAAvB,IAA8B2D,CAAC,CAACvB,QAAF,EAA9B,IAA8CsP,IAAI,CAACtP,QAAL,EAAjD,EAAkE;4BACnER,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,sBAAD,EAAyByS,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAzB,EAAuC2P,IAAI,CAAClP,KAA5C,CAAd,CAAT;0BACH,CAFI,MAGA,IAAGoP,GAAG,KAAK3R,GAAR,IAAe4R,GAAG,KAAK3R,GAAvB,IAA8B0D,CAAC,CAACvB,QAAF,EAAjC,EAA+C;4BAChD;4BACA,IAAGqP,IAAI,CAACrP,QAAL,MAAmBsP,IAAI,CAACtP,QAAL,EAAtB,EAAuC;8BACnCR,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAAC6J,WAAF,CAAchI,GAAd,EAAmB,CAAC4R,IAAI,CAAC3P,KAAL,EAAD,CAAnB,CAAT,EAA6CL,CAA7C,CAAT;4BACH,CAFD,MAGK,IAAG5C,IAAI,CAACwS,IAAI,CAAClP,KAAN,CAAP,EAAqB;8BACtB,IAAI4I,CAAC,GAAGxE,MAAM,CAAC8K,IAAI,CAAClP,KAAN,CAAN,GAAqB,CAA7B,CADsB,CAEtB;;8BACA,IAAIY,CAAC,GAAG/E,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,sBAAD,EAAyByS,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAzB,EAAuCqJ,CAAvC,CAAd,CAAR;;8BACAvJ,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACiF,QAAF,CAAWF,CAAX,EAAcuO,IAAd,CAAT,CAAb,EAA4CnH,EAA5C,EAAgD8B,KAAhD,CAAT;4BACH,CALI,MAODnF,EAAE,CAACmD,WAAH,CAAe4B,IAAf;0BACP,CAbI,MAcA,IAAG0F,GAAG,KAAK1R,GAAR,IAAe2R,GAAG,KAAK7R,GAA1B,EAA+B;4BAChC0R,IAAI,CAACpP,KAAL,GAAatC,GAAb;4BACA0R,IAAI,CAAC3B,MAAL,GAAc9F,UAAd;4BACApI,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACiF,QAAF,CAAWoO,IAAX,EAAiBC,IAAjB,CAAb,EAAqCnH,EAArC,EAAyC8B,KAAzC,CAAT;0BACH,CAJI,MAKA,IAAGsF,GAAG,KAAK7R,GAAR,IAAe8R,GAAG,KAAK1R,GAA1B,EAA+B;4BAChCwR,IAAI,CAACrP,KAAL,GAAavC,GAAb;4BACA4R,IAAI,CAAC5B,MAAL,GAAc9F,UAAd;4BACApI,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACiF,QAAF,CAAWoO,IAAX,EAAiBC,IAAjB,CAAb,EAAqCnH,EAArC,EAAyC8B,KAAzC,CAAT;0BACH,CAJI,CAKL;0BALK,KAMA,IAAGsF,GAAG,KAAK3R,GAAR,KAAgB4R,GAAG,KAAK7R,GAAR,IAAe6R,GAAG,KAAK9R,GAAvC,KAA+C4R,IAAI,CAACnP,KAAL,CAAWE,QAAX,CAAoB,CAApB,CAAlD,EAA0E;4BAC3E,IAAIU,CAAC,GAAG/E,CAAC,CAACiF,QAAF,CAAWoO,IAAI,CAAC/P,WAAL,EAAX,EAA+BgQ,IAA/B,CAAR;;4BACA9P,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAASG,CAAT,CAAb,EAA0BoH,EAA1B,EAA8B8B,KAA9B,CAAT;0BACH,CAHI,MAIA;4BACD,IAAIlJ,CAAC,GAAG/E,CAAC,CAACiF,QAAF,CAAWoO,IAAI,CAAC/P,WAAL,EAAX,EAA+BgQ,IAAI,CAAChQ,WAAL,EAA/B,CAAR;;4BACAE,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAASG,CAAT,CAAb,EAA0BoH,EAA1B,EAA8B8B,KAA9B,CAAT;0BACH;wBACJ,CArHD,CAsHA;wBAtHA,KAuHK,IAAG,CAACsF,GAAG,KAAK7R,GAAR,IAAe6R,GAAG,KAAK5R,GAAxB,MAAiC6R,GAAG,KAAK9R,GAAR,IAAe8R,GAAG,KAAK7R,GAAxD,CAAH,EAAiE;0BAElE,IAAG0R,IAAI,CAACrP,QAAL,MAAmBsP,IAAI,CAACtP,QAAL,EAAtB,EAAuC;4BACnC;4BACA,IAAGqP,IAAI,CAAC3P,IAAL,CAAU,CAAV,EAAaM,QAAb,MAA2BsP,IAAI,CAAC5P,IAAL,CAAU,CAAV,EAAaM,QAAb,EAA9B,EAAuD;8BACnD;8BACA,IAAI6K,EAAJ,EAAQoF,EAAR;;8BACA,IAAGT,GAAG,KAAK9R,GAAX,EAAgB;gCACZmN,EAAE,GAAGwE,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAL;gCACAuQ,EAAE,GAAGX,IAAI,CAAC5P,IAAL,CAAU,CAAV,CAAL;8BACH,CAHD,MAIK;gCACDuQ,EAAE,GAAGZ,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAL;gCACAmL,EAAE,GAAGyE,IAAI,CAAC5P,IAAL,CAAU,CAAV,CAAL;8BACH,CAVkD,CAYnD;;;8BACAgG,CAAC,GAAG1J,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,uCAAD,EAA0CiO,EAAE,CAAClG,QAAH,EAA1C,EAAyDsL,EAAE,CAACtL,QAAH,EAAzD,CAAd,CAAJ,CAbmD,CAenD;;8BACAnF,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAa9C,CAAb,EAAgByC,EAAhB,EAAoB8B,KAApB,CAAT;4BACH,CAjBD,MAkBK;8BACD,IAAItJ,WAAW,GAAG8D,aAAa,CAACnD,OAAD,CAA/B;8BACA9B,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAASD,WAAT,CAAb,EAAoCwH,EAApC,EAAwC8B,KAAxC,CAAT;4BACH;0BACJ,CAxBD,MAyBK;4BACD,IAAItJ,WAAW,GAAG,IAAInE,MAAJ,CAAW,CAAX,CAAlB;4BACA8E,OAAO,CAACoD,GAAR,CAAY,UAAU7E,GAAV,EAAe;8BACvB,IAAIiB,CAAC,GAAGjB,GAAG,CAACP,WAAJ,EAAR;8BACAqB,WAAW,GAAG3E,CAAC,CAACiF,QAAF,CAAWN,WAAX,EAAwBG,CAAxB,CAAd;4BACH,CAHD;;4BAIA,IAAIC,CAAC,GAAG/E,CAAC,CAAC4E,MAAF,CAASD,WAAT,CAAR;;4BAEAnB,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAazH,CAAb,EAAgBoH,EAAhB,EAAoB8B,KAApB,CAAT;;4BAEA,IAAGzK,MAAM,CAACJ,WAAP,EAAH,EAAyB;8BACrBI,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAa/D,aAAa,CAAC9D,WAAW,CAACoH,cAAZ,EAAD,CAA1B,EAA0DI,EAA1D,EAA8D8B,KAA9D,CAAT;4BACH;0BACJ;wBACJ,CAzCI,MA0CA;0BACDnF,EAAE,CAACmD,WAAH,CAAe4B,IAAf;wBACH;sBAEJ;oBACJ,CA7LD,MA8LK,IAAGlB,EAAE,KAAKrM,EAAP,IAAasM,EAAE,KAAK5L,CAAvB,EAA0B;sBAC3B,IAAIkT,cAAc,GAAGb,IAAI,CAACrP,QAAL,EAArB;sBACA,IAAGqP,IAAI,CAACpP,KAAL,KAAetC,GAAf,IAAsBuS,cAAtB,IAAwCZ,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAA3C,EACIZ,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,IAAd,EAAoB,CAACwJ,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAD,CAApB,CAAT,CADJ,KAEK,IAAG2P,IAAI,CAACpP,KAAL,KAAetC,GAAf,IAAsB2R,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAAzB,EAAgD;wBACjDZ,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACiF,QAAF,CAAWoO,IAAI,CAAC/P,WAAL,EAAX,EAA+BgQ,IAAI,CAACxP,KAAL,EAA/B,CAAb,EAA2DqI,EAA3D,EAA+D8B,KAA/D,CAAT;sBACH,CAFI,MAGA,IAAGoF,IAAI,CAACpP,KAAL,KAAe1B,IAAf,IAAuB2R,cAAvB,IAAyCZ,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAA5C,EACDZ,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,KAAd,EAAqB,CAACwJ,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAD,CAArB,CAAT,CADC,KAEA,IAAG2P,IAAI,CAACpP,KAAL,KAAe1B,IAAf,IAAuB+Q,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAA1B,EAAiD;wBAClDZ,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACiF,QAAF,CAAWoO,IAAI,CAAC/P,WAAL,EAAX,EAA+BgQ,IAAI,CAACxP,KAAL,EAA/B,CAAb,EAA2DqI,EAA3D,EAA+D8B,KAA/D,CAAT;sBACH,CAFI,MAGA,IAAGoF,IAAI,CAACpP,KAAL,KAAevC,GAAf,IAAsBwS,cAAtB,IAAwCZ,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAA3C,EACDZ,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,IAAd,EAAoB,CAACwJ,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAD,CAApB,CAAT,CADC,KAEA,IAAG2P,IAAI,CAACpP,KAAL,KAAevC,GAAf,IAAsB4R,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAAzB,EAAgD;wBACjDZ,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACiF,QAAF,CAAWoO,IAAI,CAAC/P,WAAL,EAAX,EAA+BgQ,IAAI,CAACxP,KAAL,EAA/B,CAAb,EAA2DqI,EAA3D,EAA+D8B,KAA/D,CAAT;sBACH,CAFI,MAGA,IAAGoF,IAAI,CAACpP,KAAL,KAAe3B,IAAf,IAAuB4R,cAAvB,IAAyCZ,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAA5C,EACDZ,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,KAAd,EAAqB,CAACwJ,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAAD,CAArB,CAAT,CADC,KAEA,IAAG2P,IAAI,CAACpP,KAAL,KAAe3B,IAAf,IAAuBgR,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAA1B,EAAiD;wBAClDZ,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACiF,QAAF,CAAWoO,IAAI,CAAC/P,WAAL,EAAX,EAA+BgQ,IAAI,CAACxP,KAAL,EAA/B,CAAb,EAA2DqI,EAA3D,EAA+D8B,KAA/D,CAAT;sBACH,CAFI,MAGA,IAAGoF,IAAI,CAACpP,KAAL,KAAe3C,GAAf,IAAsBgS,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAAzB,EAAgD;wBACjD;wBACAZ,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BuG,IAA9B,EAAoClH,EAApC,EAAwC8B,KAAxC,CAAT;sBACH,CAHI,MAIA,IAAGoF,IAAI,CAACpP,KAAL,KAAe,KAAlB,EAAyB;wBAC1B,IAAGqP,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAlB,CAAH,EAAyB;0BACrB,IAAI4I,EAAE,GAAGlE,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BoG,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAA7B,EAA2CyI,EAA3C,CAAT;0BAAA,IACQmG,EAAE,GAAGtF,EAAE,CAAC,CAAD,CADf;0BAAA,IAEQzB,EAAE,GAAGyB,EAAE,CAAC,CAAD,CAFf;0BAAA,IAGQ3B,GAAG,GAAGgI,IAAI,CAAC3P,IAAL,CAAU,CAAV,EAAaiF,QAAb,EAHd;;0BAIAnF,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,iHAAD,EAAoH0R,EAApH,EAAwH/G,EAAxH,EAA4HF,GAA5H,CAAd,CAAT;wBACH;sBACJ,CARI,MASA;wBACD;wBACA7H,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;sBACH;oBACJ,CAvCI,MAwCA,IAAGvB,EAAE,KAAKvL,EAAP,IAAawL,EAAE,KAAK5L,CAAvB,EAA0B;sBAC3B,IAAIuE,CAAC,GAAGgO,GAAG,KAAKjS,GAAR,GAAcwH,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BoG,IAAI,CAAC3P,IAAL,CAAU,CAAV,CAA7B,EAA2CyI,EAA3C,EAA+C,CAA/C,CAAd,GAAkE,IAA1E;;sBACA,IAAGkH,IAAI,CAAC1D,GAAL,OAAe0D,IAAI,CAAClP,KAAL,CAAWZ,KAAX,KAAqBvC,CAArB,IAA0BqS,IAAI,CAAClP,KAAL,CAAWZ,KAAX,KAAqBpC,EAA9D,KAAqEmS,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAAxE,EAA+F;wBAC3FZ,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,IAAd,EAAoB,CAACwJ,IAAI,CAAClP,KAAL,CAAWL,KAAX,EAAD,CAApB,CAAT;sBACH,CAFD,MAGK,IAAGyP,GAAG,KAAKjS,GAAR,IAAeiE,CAAC,CAACoC,KAAF,KAAY2L,IAAI,CAAC3L,KAAnC,EAA0C;wBAC3CnE,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BuG,IAA9B,EAAoClH,EAApC,EAAwC8B,KAAxC,CAAT;sBACH,CAFI,MAIDzK,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;oBACP,CAVI,MAWA,IAAGvB,EAAE,KAAK1L,EAAP,IAAa2L,EAAE,KAAK5L,CAAvB,EAA0B;sBAC3B;sBACA,IAAGsS,IAAI,CAAC3L,KAAL,KAAe0L,IAAI,CAAC1L,KAApB,IAA6B0L,IAAI,CAAClP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,CAAhC,EAAuD;wBACnD;wBACA,IAAI+P,EAAE,GAAGxC,IAAI,CAACyC,GAAL,CAASC,KAAT,CAAe,IAAf,EAAqBvU,IAAI,CAACO,KAAL,CAAWiU,IAAX,CAAgBjB,IAAI,CAAC/N,OAArB,CAArB,CAAT,CAFmD,CAGnD;;wBACA,IAAIiP,EAAE,GAAG5C,IAAI,CAACyC,GAAL,CAASD,EAAT,EAAab,IAAI,CAACnP,KAAlB,CAAT,CAJmD,CAKnD;;wBACA,IAAI+B,MAAM,GAAGoN,IAAI,CAACxP,KAAL,EAAb;wBACAoC,MAAM,CAAC/B,KAAP,GAAe,IAAIjE,IAAJ,CAASqU,EAAT,CAAf;wBACAjB,IAAI,GAAGtT,CAAC,CAACmG,MAAF,CAASmN,IAAT,EAAepN,MAAM,CAACpC,KAAP,EAAf,CAAP,CARmD,CAQZ;;wBACvC,IAAIiB,CAAC,GAAG,IAAIvE,MAAJ,CAAW,CAAX,CAAR;wBACA6S,IAAI,CAACxO,IAAL,CAAU,UAAUU,CAAV,EAAa;0BACnBR,CAAC,GAAG/E,CAAC,CAACgF,GAAF,CAAMD,CAAN,EAAS/E,CAAC,CAACmG,MAAF,CAASZ,CAAC,CAACzB,KAAF,EAAT,EAAoBoC,MAAM,CAACpC,KAAP,EAApB,CAAT,CAAJ;wBACH,CAFD;wBAGAiB,CAAC,CAACnB,UAAF,GAAeyP,IAAI,CAACzP,UAApB;wBACA6B,MAAM,GAAGzF,CAAC,CAACmG,MAAF,CAASmN,IAAT,EAAevO,CAAf,CAAT;sBACH,CAfD,MAgBK;wBACDU,MAAM,GAAGzF,CAAC,CAAC4E,MAAF,CAASa,MAAT,CAAT;sBACH;;sBACDjC,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAe8B,gBAAf,CAAgCtI,MAAhC,EAAwC0G,EAAxC,EAA4C8B,KAA5C,CAAT;oBACH,CAtBI,MAuBA,IAAGtB,EAAE,KAAKzL,EAAP,IAAa0L,EAAE,KAAK5L,CAAvB,EAA0B;sBAC3B,IAAI0I,CAAC,GAAG2J,IAAI,CAACvP,KAAL,GAAaY,QAAb,EAAR;sBAAA,IACQ8P,WAAW,GAAG1U,IAAI,CAACsG,OAAL,CAAa0L,MAAb,CAAoBpI,CAApB,EAAuB1J,CAAC,CAACkE,KAAF,CAAQiI,EAAR,CAAvB,EAAoC/H,MAApC,CAA2C,CAA3C,CADtB,CAD2B,CAG3B;;sBACA,IAAGiP,IAAI,CAAClP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAD,GAAK,CAAvB,CAAH,EAA8B;wBAC1B,IAAImM,MAAM,GAAGzH,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BoG,IAAI,CAACvP,KAAL,GAAaY,QAAb,EAA7B,EAAsDyH,EAAtD,CAAb;;wBACA,IAAI1I,CAAC,GAAG8M,MAAM,CAAC,CAAD,CAAN,CAAUjM,MAAV,EAAR;wBAAA,IACQiB,CAAC,GAAGgL,MAAM,CAAC,CAAD,CADlB;wBAAA,IAEQnI,CAAC,GAAGmI,MAAM,CAAC,CAAD,CAFlB;wBAAA,IAGQkE,EAAE,GAAGlM,MAAM,CAAC8K,IAAI,CAAClP,KAAN,CAHnB;wBAAA,IAIQuQ,EAAE,GAAGnM,MAAM,CAAC+K,IAAI,CAACnP,KAAN,CAJnB;;wBAKA,IAAGxD,KAAK,CAAC+T,EAAD,CAAL,IAAa5U,IAAI,CAACO,KAAL,CAAWQ,IAAX,CAAgB6T,EAAhB,CAAb,IAAoCnP,CAAC,CAACpB,KAAF,CAAQC,MAAR,CAAe,CAAf,CAAvC,EAA0D;0BACtD;0BACA,IAAIsH,CAAC,GAAG1L,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAACyE,GAAF,CAAM2D,CAAC,CAACtE,KAAF,EAAN,EAAiB,IAAItD,MAAJ,CAAW,CAAX,CAAjB,CAAX,EACTR,CAAC,CAAC6J,WAAF,CAAcpI,IAAd,EAAoB,CAACzB,CAAC,CAACmG,MAAF,CAASiC,CAAC,CAACtE,KAAF,EAAT,EAAoBL,CAAC,CAACK,KAAF,EAApB,CAAD,CAApB,CADS,CAAT,EAEA9D,CAAC,CAACyE,GAAF,CAAMhB,CAAC,CAACK,KAAF,EAAN,EAAiB,IAAItD,MAAJ,CAAW,CAAX,CAAjB,CAFA,CAAR;;0BAGAkL,CAAC,GAAG1L,CAAC,CAACiF,QAAF,CAAWyG,CAAX,EAAc1L,CAAC,CAAC6J,WAAF,CAAcpI,IAAd,EAAoB,CAAC2G,CAAD,CAApB,EAAyBsJ,MAAzB,EAAd,CAAJ;;0BACA,IAAIiD,KAAK,GAAG3U,CAAC,CAACkE,KAAF,CAAQ,QAAR,CAAZ;;0BACAyQ,KAAK,CAACxQ,KAAN,GAAcwQ,KAAK,CAACxQ,KAAN,CAAYc,QAAZ,CAAqBqO,IAAI,CAACnP,KAA1B,CAAd;;0BACA,IAAI8K,QAAQ,GAAGnG,EAAE,CAAC0D,SAAH,CAAamI,KAAb,EAAoB,GAApB,EAAyB1G,KAAzB,CAAf;;0BACA,IAAI2G,KAAK,GAAG5U,CAAC,CAACkE,KAAF,CAAQlC,IAAI,GAAG,GAAP,GAAaP,IAAb,GAAoB,GAApB,GAA0BgC,CAA1B,GAA8B,GAA9B,GAAoC2E,CAApC,GAAwC,IAAxC,GAA+C+D,EAA/C,GAAoD,GAA5D,CAAZ;;0BACA3I,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWyG,CAAX,EAAcuD,QAAQ,CAACvC,GAAT,CAAa,IAAIlM,MAAJ,CAAW,GAAX,CAAb,EAA8BoU,KAA9B,CAAd,CAAT;wBACH,CAXD,MAYK,IAAGH,EAAE,KAAK,CAAC,CAAD,GAAK,CAAf,EAAkB;0BACnB,IAAII,WAAW,GAAG,SAAdA,WAAc,CAAUnL,CAAV,EAAa+C,CAAb,EAAgB;4BAC9B,IAAIwC,QAAQ,GAAGjP,CAAC,CAACkE,KAAF,CAAQ4E,EAAE,CAAC0D,SAAH,CAAa9C,CAAb,EAAgByC,EAAhB,EAAoB8B,KAApB,EAA2BC,GAA3B,EAAgCxB,GAAhC,CAAoCP,EAApC,EAAwCvL,MAAM,CAAC6L,CAAD,EAAIN,EAAJ,CAA9C,CAAR,CAAf;;4BACA,IAAG,CAAC8C,QAAQ,CAAC7L,WAAT,EAAJ,EACI,OAAO6L,QAAP;0BACP,CAJD;;0BAKA,IAAGyF,EAAE,KAAK,CAAC,CAAX,EAAc;4BACVlR,MAAM,GAAGqR,WAAW,CACZ7U,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACyE,GAAF,CAAMzE,CAAC,CAACiF,QAAF,CAAWoO,IAAI,CAAC3B,MAAL,EAAX,EAA0B4B,IAAI,CAAC5B,MAAL,EAA1B,CAAN,EAAgD,IAAIlR,MAAJ,CAAW,CAAX,CAAhD,CAAT,CAAT,EAAmFkR,MAAnF,EADY,EAEZ,mBAFY,CAApB;0BAIH,CALD,MAMK,IAAGgD,EAAE,KAAK,CAAC,CAAX,EAAc;4BACf;4BACAlR,MAAM,GAAGqR,WAAW,CACZ7U,CAAC,CAAC8U,IAAF,CAAO9U,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAACyE,GAAF,CAAMgB,MAAN,EAAc,IAAIjF,MAAJ,CAAW,CAAX,CAAd,EAA6BkR,MAA7B,EAAT,EAAgD1R,CAAC,CAACyE,GAAF,CAAM,IAAIjE,MAAJ,CAAW2L,EAAX,CAAN,EAAsB,IAAI3L,MAAJ,CAAW,CAAX,CAAtB,CAAhD,EAAsF8D,MAAtF,EAAT,CAAP,EAAiHoN,MAAjH,EADY,EAEZ,mBAFY,CAApB;0BAIH;wBACJ;sBACJ,CAvCD,MAwCK,IAAG2B,IAAI,CAAClP,KAAL,CAAWC,MAAX,CAAkB,CAAC,CAAnB,KAAyBkP,IAAI,CAACtP,QAAL,EAAzB,IAA4CwQ,WAA/C,EAA4D;wBAC7DhR,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAe8B,gBAAf,CAAgCtI,MAAhC,EAAwC0G,EAAxC,EAA4C8B,KAA5C,CAAT;sBACH,CAFI,MAGA,IAAG,CAACoF,IAAI,CAAClP,KAAL,CAAWE,QAAX,CAAoB,CAApB,CAAD,IAA2B1D,KAAK,CAAC0S,IAAI,CAAClP,KAAN,CAAnC,EAAiD;wBAClD;wBACA,IAAI4Q,QAAQ,GAAG/U,CAAC,CAAC4E,MAAF,CAASyO,IAAT,CAAf;;wBACA7P,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;wBACAuU,QAAQ,CAAClQ,IAAT,CAAc,UAAUU,CAAV,EAAa;0BACvB,IAAGA,CAAC,CAAChC,KAAF,KAAYtC,EAAf,EAAmB;4BACfsE,CAAC,CAACV,IAAF,CAAO,UAAUmQ,CAAV,EAAa;8BAChBxR,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACiF,QAAF,CAAWqO,IAAI,CAACxP,KAAL,EAAX,EAAyBkR,CAAzB,CAAb,EAA0C7I,EAA1C,EAA8C8B,KAA9C,CAAd,CAAT;4BACH,CAFD;0BAGH,CAJD,MAMIzK,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACiF,QAAF,CAAWqO,IAAI,CAACxP,KAAL,EAAX,EAAyByB,CAAzB,CAAb,EAA0C4G,EAA1C,EAA8C8B,KAA9C,CAAd,CAAT;wBACP,CARD;sBASH,CAbI,MAcA,IAAGoF,IAAI,CAAClP,KAAL,CAAWE,QAAX,CAAoB,CAAC,CAArB,CAAH,EAA4B;wBAC7Bb,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;sBACH,CAFI,MAGA,IAAGmF,IAAI,CAAClP,KAAL,CAAWE,QAAX,CAAoB,CAApB,KAA0BiP,IAAI,CAACnP,KAAL,CAAW2K,WAAX,CAAuB,CAAvB,CAA7B,EAAwD;wBACzD,IAAIyB,MAAM,GAAGzH,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BoG,IAAI,CAACvP,KAAL,GAAaY,QAAb,EAA7B,EAAsDyH,EAAtD,CAAb;wBAAA,IACQ1I,CAAC,GAAG8M,MAAM,CAAC,CAAD,CAAN,CAAUjM,MAAV,EADZ;wBAAA,IAEQiB,CAAC,GAAGgL,MAAM,CAAC,CAAD,CAFlB;wBAAA,IAGQnI,CAAC,GAAGmI,MAAM,CAAC,CAAD,CAHlB;wBAAA,IAIQtH,EAAE,GAAGoK,IAAI,CAACvP,KAAL,GAAaY,QAAb,EAJb;;wBAMA,IAAGa,CAAC,CAAChC,KAAF,KAAYtC,EAAZ,IAAkBsE,CAAC,CAACvB,QAAF,EAArB,EAAmC;0BAC/B,IAAI+I,CAAC,GAAGxE,MAAM,CAAC+K,IAAI,CAACnP,KAAN,CAAd;0BAAA,IACQ6K,EAAE,GAAG,KADb;0BAAA,IAEQvC,CAAC,GAAG,IAAIjM,MAAJ,CAAWwO,EAAX,CAFZ;0BAAA,IAGQ;0BACAiG,CAAC,GAAGjV,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAACyE,GAAF,CAAMzE,CAAC,CAACgL,QAAF,CAAWyB,CAAC,CAAC3I,KAAF,EAAX,EAAsBsE,CAAC,CAACtE,KAAF,EAAtB,CAAN,EAAwC,IAAItD,MAAJ,CAAWuM,CAAX,CAAxC,CAAT,EAAiEN,CAAC,CAAC3I,KAAF,EAAjE,CAAT,CAJZ;0BAAA,IAKQoR,KAAK,GAAG,EALhB,CAD+B,CAQ/B;;;0BACAA,KAAK,CAAClG,EAAD,CAAL,GAAY/F,EAAZ;;0BACA,IAAIkM,EAAE,GAAGnV,CAAC,CAACkE,KAAF,CAAQ+Q,CAAR,EAAWC,KAAX,CAAT;;0BACA1R,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAa2I,EAAb,EAAiBhJ,EAAjB,EAAqB,CAArB,CAAT;wBACH,CAZD,MAaK,IAAGmH,IAAI,CAACnP,KAAL,CAAW2K,WAAX,CAAuBvJ,CAAC,CAACpB,KAAzB,KAAmCmP,IAAI,CAACnP,KAAL,CAAWC,MAAX,CAAkBmB,CAAC,CAACpB,KAApB,CAAtC,EAAkE;0BAEnE;0BACA,IAAIiR,OAAO,GAAG,IAAItV,IAAI,CAACsG,OAAL,CAAaiP,OAAb,CAAqBC,OAAzB,EAAd;0BACAjC,IAAI,GAAGvT,IAAI,CAACsG,OAAL,CAAaoH,MAAb,CAAoB+H,WAApB,CAAgClC,IAAI,CAAC3B,MAAL,EAAhC,EAA+C0D,OAA/C,CAAP;0BACA,IAAII,GAAG,GAAG1V,IAAI,CAACsG,OAAL,CAAaD,MAAb,CAAoBmN,IAApB,EAA0BD,IAA1B,CAAV,CALmE,CAMnE;;0BACA,IAAGmC,GAAG,CAACjS,KAAJ,KAAcpC,EAAjB,EAAqB;4BACjBqC,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;4BACAgV,GAAG,CAAC3Q,IAAJ,CAAS,UAAUE,CAAV,EAAa;8BAClBvB,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcsF,EAAE,CAAC0D,SAAH,CAAazH,CAAb,EAAgBoH,EAAhB,EAAoB8B,KAApB,CAAd,CAAT;4BACH,CAFD,EAFiB,CAKjB;;4BACAmH,OAAO,CAACvQ,IAAR,CAAa,UAAUqB,MAAV,EAAkB;8BAC3B1C,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAAS3C,MAAT,EAAiB0C,MAAjB,CAAT;4BACH,CAFD;4BAIA1C,MAAM,GAAGxD,CAAC,CAAC4E,MAAF,CAASpB,MAAT,CAAT;0BACH,CAXD,MAYK;4BACD;4BACAA,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;0BACH;wBACJ,CAvBI,MAyBD1K,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAe8B,gBAAf,CAAgCtI,MAAhC,EAAwC0G,EAAxC,EAA4C8B,KAA5C,CAAT;sBACP,CA9CI,MA+CA;wBACD;wBACA,IAAGoF,IAAI,CAAClP,KAAL,CAAW8B,GAAX,CAAe7B,MAAf,CAAsB,CAAtB,CAAH,EAA6B;0BACzB;0BACA,IAAI4I,EAAE,GAAGlE,EAAE,CAACmD,WAAH,CAAegB,aAAf,CAA6BoG,IAAI,CAACvP,KAAL,GAAaY,QAAb,EAA7B,EAAsDyH,EAAtD,CAAT;0BAAA,IACQ;0BACA1I,CAAC,GAAGuJ,EAAE,CAAC,CAAD,CAFd;0BAAA,IAEmBzH,CAAC,GAAGyH,EAAE,CAAC,CAAD,CAFzB;0BAAA,IAE8B5E,CAAC,GAAG4E,EAAE,CAAC,CAAD,CAFpC;0BAAA,IAEyCiH,EAAE,GAAGjH,EAAE,CAAC,CAAD,CAFhD;;0BAGA,IAAGzH,CAAC,CAACpB,KAAF,CAAQC,MAAR,CAAe,CAAf,KAAqBgE,CAAC,CAAC/D,QAAF,CAAW,CAAX,CAAxB,EAAuC;4BAAE;4BACrC;4BACA,IAAG,CAACZ,CAAC,CAACW,MAAF,CAAS,CAAT,CAAJ,EAAiB;8BAAE;8BACf;8BACA4O,KAAK,GAAGhT,CAAC,CAACiF,QAAF,CAAW+N,KAAX,EAAkBhT,CAAC,CAACyE,GAAF,CAAMhB,CAAN,EAAS,IAAIjD,MAAJ,CAAW,CAAX,CAAT,CAAlB,CAAR;4BACH;;4BACD,IAAIiM,CAAC,GAAGN,EAAR;;4BACA,IAAIT,CAAC,GAAG1L,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAACyE,GAAF,CAAM2D,CAAC,CAACtE,KAAF,GAAUQ,MAAV,EAAN,EAA0B,IAAI9D,MAAJ,CAAW,IAAI,CAAf,CAA1B,CAAT,EAAuDR,CAAC,CAACyE,GAAF,CAAMhB,CAAN,EAAS,IAAIjD,MAAJ,CAAW,IAAI,CAAf,CAAT,CAAvD,CAAR;4BAAA,IACQwO,EAAE,GAAGhP,CAAC,CAAC6J,WAAF,CAAclI,GAAd,EAAmB,CAAC,IAAInB,MAAJ,CAAWiM,CAAX,CAAD,CAAnB,CADb;4BAAA,IAEQgJ,IAAI,GAAGzV,CAAC,CAACyE,GAAF,CAAMzE,CAAC,CAAC6J,WAAF,CAAclI,GAAd,EAAmB,CAAC,IAAInB,MAAJ,CAAWiM,CAAX,CAAD,CAAnB,CAAN,EAA2C,IAAIjM,MAAJ,CAAW6S,IAAI,CAAClP,KAAL,CAAW4B,GAAtB,CAA3C,CAFf;4BAAA,IAGQ2P,CAAC,GAAG1V,CAAC,CAACyE,GAAF,CAAMzE,CAAC,CAAC6J,WAAF,CAAcnI,GAAd,EAAmB,CAAC,IAAIlB,MAAJ,CAAWiM,CAAX,CAAD,CAAnB,CAAN,EAA2C,IAAIjM,MAAJ,CAAW8S,IAAI,CAACnP,KAAhB,CAA3C,CAHZ;4BAAA,IAIQ0H,GAAG,GAAG7L,CAAC,CAACiF,QAAF,CAAWjF,CAAC,CAACiF,QAAF,CAAWwQ,IAAX,EAAiBzG,EAAjB,CAAX,EAAiC0G,CAAjC,CAJd;4BAAA,IAKQzG,QAAQ,GAAGnG,EAAE,CAAC0D,SAAH,CAAaX,GAAb,EAAkBY,CAAlB,EAAqBwB,KAArB,CALnB,CAPmC,CAanC;;;4BACAzK,MAAM,GAAGyL,QAAQ,CAACvC,GAAT,CAAaD,CAAb,EAAgBzM,CAAC,CAAC6J,WAAF,CAAc7H,IAAd,EAAoB,CAAChC,CAAC,CAACiF,QAAF,CAAW,IAAIzE,MAAJ,CAAW2L,EAAX,CAAX,EAA2BT,CAA3B,CAAD,CAApB,CAAhB,CAAT;0BACH,CAfD,MAgBK;4BACDlI,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAe8B,gBAAf,CAAgCtI,MAAhC,EAAwC0G,EAAxC,EAA4C8B,KAA5C,EAAmDC,GAAnD,CAAT;0BACH;wBACJ,CAxBD,MAyBK,IAAGsG,WAAH,EAAgB;0BACjBhR,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAe8B,gBAAf,CAAgCtI,MAAhC,EAAwC0G,EAAxC,EAA4C8B,KAA5C,CAAT;wBACH;sBACJ;oBAEJ,CA/II,MAgJA,IAAGoF,IAAI,CAAC1N,WAAL,MAAsB2N,IAAI,CAAC3N,WAAL,EAAzB,EAA6C;sBAC9C;sBACAnC,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;;sBACA,IAAG6S,IAAI,CAAClP,KAAL,CAAW2K,WAAX,CAAuB,CAAvB,KAA6BwE,IAAI,CAACnP,KAAL,CAAW2K,WAAX,CAAuB,CAAvB,CAAhC,EAA2D;wBACvD;wBACA,IAAIjL,GAAG,GAAG7D,CAAC,CAAC4E,MAAF,CAASa,MAAT,CAAV;;wBACA5B,GAAG,CAACgB,IAAJ,CAAS,UAAUU,CAAV,EAAa;0BAClB/B,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcsF,EAAE,CAAC0D,SAAH,CAAajH,CAAb,EAAgB4G,EAAhB,EAAoB8B,KAApB,CAAd,CAAT;wBACH,CAFD,EAEG,IAFH;sBAGH,CAND,MAOK;wBACD,IAAIwG,EAAE,GAAGlM,MAAM,CAAC8K,IAAI,CAAClP,KAAN,CAAf;wBAAA,IACQuQ,EAAE,GAAGnM,MAAM,CAAC+K,IAAI,CAACnP,KAAN,CADnB;;wBAEA,IAAGsQ,EAAE,GAAG,CAAL,IAAUC,EAAE,GAAG,CAAlB,EAAqB;0BACjB;0BACA,IAAI3P,CAAC,GAAGsO,IAAR;0BACAA,IAAI,GAAGC,IAAP;0BACAA,IAAI,GAAGvO,CAAP;wBACH;;wBACD,IAAG0P,EAAE,KAAK,CAAC,CAAR,IAAaC,EAAE,KAAK,CAAC,CAAxB,EAA2B;0BACvBlR,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAe8B,gBAAf,CAAgCtI,MAAhC,EAAwC0G,EAAxC,CAAT;wBACH,CAFD,MAGK;0BACDkH,IAAI,CAACxO,IAAL,CAAU,UAAUU,CAAV,EAAa;4BACnB,IAAIyO,CAAC,GAAGhU,CAAC,CAACiF,QAAF,CAAWM,CAAX,EAAc+N,IAAI,CAACxP,KAAL,EAAd,CAAR;;4BACA,IAAImL,QAAQ,GAAGnG,EAAE,CAAC0D,SAAH,CAAawH,CAAb,EAAgB7H,EAAhB,EAAoB8B,KAApB,CAAf;;4BACAzK,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcyL,QAAd,CAAT;0BACH,CAJD;wBAKH;sBACJ;oBACJ,CA9BI,MA+BA,IAAGtC,EAAE,KAAKzL,EAAP,IAAaoE,OAAO,CAAC,CAAD,CAAP,CAAWnB,KAAX,CAAiB2K,WAAjB,CAA6B,CAA7B,CAAhB,EAAiD;sBAClDuE,IAAI,GAAGrT,CAAC,CAAC4E,MAAF,CAASyO,IAAT,CAAP;sBACA7P,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;sBACA6S,IAAI,CAACxO,IAAL,CAAU,UAAUU,CAAV,EAAa;wBACnB/B,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAcsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAACiF,QAAF,CAAWM,CAAX,EAAc+N,IAAI,CAACxP,KAAL,EAAd,CAAb,EAA0CqI,EAA1C,EAA8C8B,KAA9C,CAAd,CAAT;sBACH,CAFD,EAEG,IAFH;oBAGH,CANI,MAOA,IAAGtB,EAAE,KAAKrM,EAAP,IAAasM,EAAE,KAAKxL,EAApB,IAA0BtB,IAAI,CAACO,KAAL,CAAWmG,QAAX,CAAoB6M,IAAI,CAACpP,KAAzB,CAA7B,EAA8D;sBAC/DoP,IAAI,GAAGA,IAAI,CAAC/P,WAAL,EAAP;sBACAE,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACiF,QAAF,CAAWoO,IAAX,EAAiBC,IAAjB,CAAT,CAAb,EAA+CnH,EAA/C,EAAmD8B,KAAnD,CAAT;oBACH,CAHI,MAIA,IAAGtB,EAAE,KAAKrM,EAAP,IAAasM,EAAE,KAAK1L,EAApB,IAA0B0L,EAAE,KAAKtM,EAAP,IAAaqM,EAAE,KAAKzL,EAAjD,EAAqD;sBACtD,IAAG0L,EAAE,KAAKtM,EAAP,IAAaqM,EAAE,KAAKzL,EAAvB,EAA2B;wBACvB,IAAI6D,CAAC,GAAGsO,IAAR;wBACAA,IAAI,GAAGC,IAAP;wBACAA,IAAI,GAAGvO,CAAP,CAHuB,CAGb;sBACb;;sBACD,IAAIiK,EAAJ,EAAQ2G,UAAR,EAAoB5I,CAApB,EAAuBV,CAAvB,EAA0BuJ,EAA1B,EAA8BC,EAA9B;sBACA7G,EAAE,GAAGxO,MAAM,CAACiO,UAAP,CAAkB3F,EAAE,CAACzB,IAAH,CAAQgM,IAAI,CAACvP,KAAL,EAAR,EAAsBqI,EAAtB,CAAlB,EAA6C,IAA7C,CAAL;sBACAwJ,UAAU,GAAGnV,MAAM,CAACiO,UAAP,CAAkB6E,IAAlB,EAAwB,IAAxB,CAAb;;sBACA,IAAGtE,EAAE,CAAC7K,KAAH,CAASC,MAAT,CAAgBuR,UAAU,CAACxR,KAA3B,CAAH,EAAsC;wBAClC4I,CAAC,GAAG,IAAIvM,MAAJ,CAAW8S,IAAI,CAACnP,KAAhB,CAAJ;wBACAyR,EAAE,GAAG5G,EAAE,CAAClL,KAAH,GAAWY,QAAX,EAAL;wBACAmR,EAAE,GAAGvC,IAAI,CAACxP,KAAL,GAAaY,QAAb,EAAL;wBACA2H,CAAC,GAAGvM,IAAI,CAACsG,OAAL,CAAaD,MAAb,CAAoByP,EAAE,CAAClR,QAAH,EAApB,EAAmCmR,EAAnC,CAAJ;;wBACA,IAAGxJ,CAAC,CAAClH,UAAF,EAAH,EAAmB;0BACf,IAAI2Q,EAAE,GAAG9V,CAAC,CAACyE,GAAF,CAAM4H,CAAN,EAASU,CAAC,CAACzI,MAAF,EAAT,CAAT;;0BACAd,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAW6Q,EAAX,EAAehN,EAAE,CAACmD,WAAH,CAAea,cAAf,CAA8BuG,IAAI,CAACvP,KAAL,EAA9B,CAAf,CAAT;wBACH;sBACJ,CATD,MAUK;wBACDN,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;sBACH;oBACJ,CAtBI,MAuBA;sBACD,IAAI6H,IAAI,GAAG1C,IAAI,CAACvP,KAAL,GAAaY,QAAb,EAAX;sBACA,IAAIsR,IAAI,GAAG1C,IAAI,CAACxP,KAAL,GAAaY,QAAb,EAAX;;sBACA,IAAGiI,EAAE,KAAKvL,EAAP,IAAawL,EAAE,KAAKxL,EAApB,IAA0BiS,IAAI,CAAClP,KAAL,CAAW4G,QAAX,CAAoBoB,EAApB,CAA1B,IAAqDmH,IAAI,CAACnP,KAAL,CAAW4G,QAAX,CAAoBoB,EAApB,CAArD,IACQ,CAAC4J,IAAI,CAAChL,QAAL,CAAcoB,EAAd,CADT,IAC8B,CAAC6J,IAAI,CAACjL,QAAL,CAAcoB,EAAd,CADlC,EACqD;wBACjD3I,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,+EAAD,EACfmV,IAAI,CAACpN,QAAL,EADe,EAEfqN,IAAI,CAACrN,QAAL,EAFe,EAGf0K,IAAI,CAAClP,KAAL,CAAWP,UAAX,CAAsB+E,QAAtB,EAHe,EAIf2K,IAAI,CAACnP,KAAL,CAAWP,UAAX,CAAsB+E,QAAtB,EAJe,EAKfwD,EALe,CAAd,CAAT;sBAOH,CATD,MAWI3I,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;oBACP;kBACJ;gBACJ,CA9fD,MA+fK,IAAGpG,CAAC,KAAK,CAAN,KAAYxC,OAAO,CAAC,CAAD,CAAP,CAAW/B,KAAX,KAAqBvC,CAArB,IAA0BsE,OAAO,CAAC,CAAD,CAAP,CAAWnB,KAAX,CAAiBE,QAAjB,CAA0B,CAA1B,CAA1B,IAA0DiB,OAAO,CAAC,CAAD,CAAP,CAAW/B,KAAX,KAAqBrC,EAA3F,CAAH,EAAmG;kBACpG,IAAI+U,KAAK,GAAG3Q,OAAO,CAAC,CAAD,CAAnB;;kBACA,IAAG2Q,KAAK,CAAC1S,KAAN,KAAgBrC,EAAnB,EAAuB;oBAAE;oBACrB,IAAG+U,KAAK,CAAC9R,KAAN,CAAY2K,WAAZ,CAAwB,CAAxB,CAAH,EACImH,KAAK,GAAGjW,CAAC,CAAC4E,MAAF,CAASqR,KAAT,CAAR;;oBACJ,IAAItD,CAAC,GAAG3S,CAAC,CAACiF,QAAF,CAAWK,OAAO,CAAC,CAAD,CAAlB,EAAuBA,OAAO,CAAC,CAAD,CAA9B,CAAR;;oBACA9B,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;oBACAyV,KAAK,CAACpR,IAAN,CAAW,UAAUU,CAAV,EAAa;sBACpB,IAAIR,CAAC,GAAG/E,CAAC,CAACiF,QAAF,CAAWM,CAAX,EAAcoN,CAAC,CAAC7O,KAAF,EAAd,CAAR;;sBACA,IAAIoS,IAAI,GAAGpN,EAAE,CAAC0D,SAAH,CAAazH,CAAb,EAAgBoH,EAAhB,EAAoB8B,KAApB,CAAX;;sBACAzK,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAc0S,IAAd,CAAT;oBACH,CAJD,EAIG,IAJH;kBAKH,CAVD,MAWK;oBACD;oBACA1S,MAAM,GAAGsF,EAAE,CAACmD,WAAH,CAAeoB,QAAf,CAAwB5H,MAAxB,EAAgC0G,EAAhC,EAAoC8B,KAApC,EAA2CC,GAA3C,CAAT;kBACH;gBAEJ,CAlBI,MAmBA,IAAGtG,aAAa,CAACtC,OAAD,CAAhB,EAA2B;kBAC5B,IAAIP,CAAC,GAAG,IAAIvE,MAAJ,CAAW,CAAX,CAAR;;kBACA,KAAI,IAAIwG,CAAC,GAAG,CAAR,EAAWc,CAAC,GAAGxC,OAAO,CAACyC,MAA3B,EAAmCf,CAAC,GAAGc,CAAvC,EAA0Cd,CAAC,EAA3C,EAA+C;oBAC3CjC,CAAC,GAAG/E,CAAC,CAACiF,QAAF,CAAWF,CAAX,EAAcO,OAAO,CAAC0B,CAAD,CAAP,CAAW1D,WAAX,EAAd,CAAJ;kBACH;;kBACDyB,CAAC,GAAG/E,CAAC,CAAC4E,MAAF,CAASG,CAAT,CAAJ;kBACAvB,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAazH,CAAb,EAAgBoH,EAAhB,EAAoB8B,KAApB,CAAT;gBACH,CAPI,MAQA;kBACD;kBACA,IAAItJ,WAAW,GAAG8D,aAAa,CAACnD,OAAD,CAA/B;kBACA9B,MAAM,GAAGsF,EAAE,CAAC0D,SAAH,CAAaxM,CAAC,CAAC4E,MAAF,CAASD,WAAT,CAAb,EAAoCwH,EAApC,EAAwC8B,KAAxC,CAAT;gBACH;cACJ;YAEJ;;YAEDzK,MAAM,GAAGxD,CAAC,CAACiF,QAAF,CAAWzB,MAAX,EAAmBwP,KAAnB,CAAT;UACH,CAxiCD,CAyiCA;;;UACA,IAAGxP,MAAH,EACI,OAAOA,MAAP;QACP,CA5iCD,CA8iCA,OAAM2M,KAAN,EAAa;UACT;UACA,IAAG,EAAEA,KAAK,YAAYpN,eAAjB,IAAoCoN,KAAK,YAAYrQ,IAAI,CAACuJ,UAAL,CAAgB8M,cAAvE,CAAH,EACI,MAAMhG,KAAN;QACP,CA3jC+C,CA6jChD;;;QACA,OAAOnQ,CAAC,CAAC6J,WAAF,CAAc,WAAd,EAA2B,CAACmG,eAAD,EAAkBC,EAAlB,CAA3B,CAAP;MACH,CA/jCM,EA+jCJ,KA/jCI,CAAP;IAgkCH,CAhuDoB;IAiuDrBmG,MAAM,EAAE,gBAAU3Q,MAAV,EAAkB4Q,IAAlB,EAAwBC,EAAxB,EAA4BnK,EAA5B,EAAgC;MACpCA,EAAE,GAAGA,EAAE,IAAI,GAAX,CADoC,CACpB;;MAChB,IAAIoK,SAAS,GAAG,SAAZA,SAAY,CAAUtH,QAAV,EAAoBrI,IAApB,EAA0B4P,KAA1B,EAAiC;QAC7C,IAAI;UACA,OAAOxW,CAAC,CAACkE,KAAF,CAAQ+K,QAAR,EAAkBrI,IAAlB,CAAP;QACH,CAFD,CAGA,OAAMO,CAAN,EAAS;UACL;UACA,IAAIsP,GAAG,GAAG3N,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAe1H,QAAf,EAAyB9C,EAAzB,EAA6BqK,KAA7B,CAAV;;UACA,OAAOC,GAAP;QACH;MACJ,CATD;;MAWA,IAAI7P,IAAI,GAAG9G,IAAI,CAACO,KAAL,CAAWsK,SAAX,CAAqBlF,MAArB,CAAX;MAAA,IACQP,OAAO,GAAGO,MAAM,CAACP,OAAP,EADlB;MAEA,IAAI1B,MAAJ,EAAYyL,QAAZ,CAfoC,CAiBpC;;MACA,IAAGrI,IAAI,CAACmB,MAAL,KAAgB,CAAhB,IAAqB,CAACoE,EAAzB,EACIA,EAAE,GAAGvF,IAAI,CAAC,CAAD,CAAT;;MAEJ,IAAG,CAAC1B,OAAJ,EAAa;QACT+J,QAAQ,GAAGnG,EAAE,CAAC0D,SAAH,CAAa/G,MAAb,EAAqB0G,EAArB,CAAX;MACH;;MAED,IAAG,CAACjH,OAAD,IAAY,CAAC+J,QAAQ,CAAC7L,WAAT,EAAhB,EAAwC;QACpC,IAAIwT,KAAK,GAAG,EAAZ;QAAA,IACQC,KAAK,GAAG,EADhB;QAAA,IAEQpT,CAFR;QAAA,IAEW2E,CAFX;QAGAwO,KAAK,CAACzK,EAAD,CAAL,GAAYmK,EAAZ;QACAO,KAAK,CAAC1K,EAAD,CAAL,GAAYkK,IAAZ;QAEA5S,CAAC,GAAG8S,SAAS,CAACtH,QAAD,EAAW2H,KAAX,EAAkBN,EAAlB,EAAsBnK,EAAtB,CAAb;QACA/D,CAAC,GAAGmO,SAAS,CAACtH,QAAD,EAAW4H,KAAX,EAAkBR,IAAlB,EAAwBlK,EAAxB,CAAb;QACA3I,MAAM,GAAGxD,CAAC,CAACgL,QAAF,CAAWvH,CAAX,EAAc2E,CAAd,CAAT;MACH,CAVD,MAWK,IAAGxB,IAAI,CAACmB,MAAL,KAAgB,CAAhB,IAAqBsO,IAAI,CAAClR,UAAL,EAArB,IAA0CmR,EAAE,CAACnR,UAAH,EAA7C,EAA8D;QAE/D,IAAIuE,CAAC,GAAG5J,IAAI,CAACO,KAAL,CAAWyW,KAAX,CAAiBrR,MAAjB,CAAR;QACAjC,MAAM,GAAG,IAAIhD,MAAJ,CAAWV,IAAI,CAACiX,KAAL,CAAWC,aAAX,CAAyBtN,CAAzB,EAA4BnB,MAAM,CAAC8N,IAAD,CAAlC,EAA0C9N,MAAM,CAAC+N,EAAD,CAAhD,CAAX,CAAT;MACH,CAJI,MAMD9S,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,QAAd,EAAwB,CAACpE,MAAD,EAAS4Q,IAAT,EAAeC,EAAf,EAAmBnK,EAAnB,CAAxB,CAAT;;MACJ,OAAO3I,MAAP;IACH,CA7wDoB;IA+wDrBkT,KAAK,EAAE;MACHO,QAAQ,EAAE,kBAAU9N,KAAV,EAAiBC,GAAjB,EAAsB;QAC5B,OAAOpJ,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,YAAD,EAAeuI,KAAf,EAAsBC,GAAtB,CAAd,CAAP;MACH,CAHE;MAIH8N,QAAQ,EAAE,oBAAY;QAClB,OAAOpO,EAAE,CAAC4N,KAAH,CAASO,QAAT,CAAkB,WAAlB,EAA+B,UAA/B,CAAP;MACH,CANE;MAOH9Q,MAAM,EAAE,gBAAUuD,CAAV,EAAauB,CAAb,EAAgB1F,CAAhB,EAAmBkR,GAAnB,EAAwBxI,KAAxB,EAA+B;QACnC,IAAGA,KAAK,KAAK9N,QAAQ,CAAC0I,aAAtB,EAAqC;UACjC;QACH;;QAED,IAAIsO,GAAG,GAAGzN,CAAC,CAAC5F,KAAF,EAAV;QAAA,IAAqBsT,GAAG,GAAGnM,CAAC,CAACnH,KAAF,EAA3B,CALmC,CAOnC;QACA;QACA;QACA;;QACA,IAAGmH,CAAC,CAAChH,KAAF,KAAYzC,GAAf,EAAoB;UAChB,IAAIuS,IAAI,GAAGrK,CAAC,CAACqK,IAAF,EAAX;UACA,IAAIsD,QAAQ,GAAGZ,GAAG,CAAC1C,IAAJ,EAAf;UAEA,IAAG0C,GAAG,CAACa,UAAP,EACI,OAAOtX,CAAC,CAACiF,QAAF,CAAW,IAAIzE,MAAJ,CAAWuT,IAAX,CAAX,EAA6B,IAAIvT,MAAJ,CAAW6W,QAAX,CAA7B,CAAP,CADJ,KAGK,IAAGZ,GAAG,CAACrS,MAAJ,CAAW,CAAX,CAAH,EAAkB;YACnB,IAAImT,EAAE,GAAGvX,CAAC,CAACkE,KAAF,CAAQwF,CAAC,CAAC9F,UAAV,CAAT;;YACA,IAAI4T,EAAE,GAAGxX,CAAC,CAACkE,KAAF,CAAQ+G,CAAC,CAACrH,UAAV,CAAT;;YACA,OAAO5D,CAAC,CAACmG,MAAF,CAASnG,CAAC,CAACiF,QAAF,CAAWsS,EAAX,EAAezO,EAAE,CAAC4N,KAAH,CAASO,QAAT,CAAkB,IAAlB,EAAwB,GAAxB,CAAf,CAAT,EAAuDO,EAAvD,CAAP;UACH,CAJI,MAKA;YACD;YACA1O,EAAE,CAAC4N,KAAH,CAASQ,QAAT;UACH;QACJ;;QAED,IAAII,UAAU,GAAG,SAAbA,UAAa,CAAUG,CAAV,EAAa;UAC1B,IAAG3X,IAAI,CAACO,KAAL,CAAW6J,QAAX,CAAoBuN,CAApB,CAAH,EAA2B;YACvB,KAAI,IAAIzQ,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGyQ,CAAC,CAACpN,QAAF,CAAWtC,MAA9B,EAAsCf,CAAC,EAAvC;cACI,IAAG,CAACyQ,CAAC,CAACpN,QAAF,CAAWrD,CAAX,EAAcsQ,UAAlB,EACI,OAAO,KAAP;YAFR;;YAGA,OAAO,IAAP;UACH;;UACD,OAAOG,CAAC,CAACH,UAAT;QACH,CARD;;QAUA,IAAIlT,MAAM,GAAG,SAATA,MAAS,CAAUqT,CAAV,EAAa1Q,CAAb,EAAgB;UACzB,IAAGjH,IAAI,CAACO,KAAL,CAAW6J,QAAX,CAAoBuN,CAApB,CAAH,EAA2B;YACvB,OAAO,KAAP;UACH;;UACD,OAAOA,CAAC,CAACrT,MAAF,CAAS2C,CAAT,CAAP;QACH,CALD;;QAOA,IAAIvD,MAAJ;;QACA,GAAG;UACC,IAAIkU,IAAI,GAAG5W,QAAQ,CAACgI,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAejN,CAAC,CAAC5F,KAAF,EAAf,EAA0ByB,CAA1B,EAA6BkR,GAA7B,EAAkCxI,KAAlC,CAAD,CAAnB;UACA,IAAI0J,IAAI,GAAG7W,QAAQ,CAACgI,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAe1L,CAAC,CAACnH,KAAF,EAAf,EAA0ByB,CAA1B,EAA6BkR,GAA7B,EAAkCxI,KAAlC,CAAD,CAAnB,CAFD,CAIC;;UACA,IAAI2J,aAAa,GAAGN,UAAU,CAACI,IAAD,CAAV,IAAoBJ,UAAU,CAACK,IAAD,CAA9B,IAAwCvT,MAAM,CAACsT,IAAD,EAAO,CAAP,CAAN,IAAmBtT,MAAM,CAACuT,IAAD,EAAO,CAAP,CAArF,CALD,CAMC;;UACA,IAAGC,aAAH,EAAkB;YACd,IAAIC,EAAE,GAAG/O,EAAE,CAACzB,IAAH,CAAQqC,CAAC,CAAC5F,KAAF,EAAR,EAAmByB,CAAnB,CAAT;;YACA,IAAIkC,EAAE,GAAGqB,EAAE,CAACzB,IAAH,CAAQ4D,CAAC,CAACnH,KAAF,EAAR,EAAmByB,CAAnB,CAAT;;YAEA,IAAIuS,QAAQ,GAAG9X,CAAC,CAAC4E,MAAF,CAAS5E,CAAC,CAACmG,MAAF,CAAS0R,EAAT,EAAapQ,EAAb,CAAT,CAAf;;YACAiC,CAAC,GAAGoO,QAAQ,CAAC9R,MAAT,EAAJ;YACAiF,CAAC,GAAG6M,QAAQ,CAAChS,QAAT,EAAJ;UAEH;QACJ,CAhBD,QAiBM8R,aAjBN,EA/CmC,CAkEnC;QACA;QACA;;;QACA,IAAIG,WAAW,GAAGJ,IAAI,CAACvT,MAAL,CAAY,CAAZ,CAAlB;QACA,IAAI2I,CAAC,GAAGxE,MAAM,CAAC6O,GAAG,CAACjT,KAAL,CAAd;;QAEA,IAAGsS,GAAG,CAACtR,UAAJ,CAAe,IAAf,KAAwB4S,WAA3B,EAAwC;UACpCvU,MAAM,GAAGhD,MAAM,CAACwX,QAAP,CAAgBlY,IAAI,CAACO,KAAL,CAAWQ,IAAX,CAAgBkM,CAAhB,KAAsB2K,IAAI,CAACrT,QAAL,CAAc,CAAd,CAAtB,GAAyC,CAAC,CAA1C,GAA8CqG,SAA9D,CAAT;QACH,CAFD,MAGK,IAAGqN,WAAH,EAAgB;UACjBvU,MAAM,GAAGsF,EAAE,CAAC4N,KAAH,CAASQ,QAAT,EAAT;QACH,CAFI,MAGA;UACD1T,MAAM,GAAGxD,CAAC,CAACmG,MAAF,CAASuR,IAAT,EAAeC,IAAf,CAAT;QACH;;QAED,OAAOnU,MAAP;MACH,CA1FE;MA2FHyU,YAAY,EAAE,sBAAUxS,MAAV,EAAkB;QAC5B,IAAIsH,CAAC,GAAGtH,MAAM,CAACtB,KAAP,CAAaL,KAAb,EAAR;QACA2B,MAAM,CAACf,QAAP;QACA,OAAO1E,CAAC,CAACyE,GAAF,CAAM,IAAIjE,MAAJ,CAAW,GAAX,CAAN,EAAuBR,CAAC,CAACiF,QAAF,CAAW8H,CAAX,EAAc/M,CAAC,CAAC6J,WAAF,CAAc1J,QAAQ,CAACmB,GAAT,GAAe,EAA7B,EAAiC,CAACmE,MAAD,CAAjC,CAAd,CAAvB,CAAP;MACH,CA/FE;MAgGHyS,SAAS,EAAE,mBAAUxO,CAAV,EAAanE,CAAb,EAAgBkR,GAAhB,EAAqB;QAC5B,IAAIjT,MAAJ,CAD4B,CAE5B;;QACA,IAAGkG,CAAC,CAACnG,KAAF,KAAYnC,EAAf,EAAmB;UACfsI,CAAC,GAAGZ,EAAE,CAACmP,YAAH,CAAgBvO,CAAhB,CAAJ;QACH,CAL2B,CAM5B;;;QACA,IAAI;UACAlG,MAAM,GAAGkG,CAAC,CAACgD,GAAF,CAAMnH,CAAN,EAASkR,GAAT,CAAT;QACH,CAFD,CAGA,OAAMtP,CAAN,EAAS;UACL;UACA3D,MAAM,GAAGkG,CAAT;QACH;;QAED,OAAOlG,MAAP;MACH,CAhHE;MAiHH2U,UAAU,EAAE,oBAAUxB,KAAV,EAAiB;QACzB,OAAO7W,IAAI,CAACO,KAAL,CAAW6J,QAAX,CAAoByM,KAApB,CAAP;MACH,CAnHE;MAoHHyB,YAAY,EAAE,sBAAUzB,KAAV,EAAiB;QAC3B;QACA,KACQ;QACA7N,EAAE,CAAC4N,KAAH,CAASyB,UAAT,CAAoBxB,KAApB,KAA8BA,KAAK,CAACtM,QAAN,CAAe,CAAf,EAAkBiN,UAAhD,IAA8DX,KAAK,CAACtM,QAAN,CAAe,CAAf,EAAkBiN,UAAhF,IACA;QACAX,KAAK,CAACtT,gBAAN,CAAuB,OAAvB,CAJR,EAKU;UACN,OAAO,KAAP,CADM,CACQ;QACjB;;QACD,OAAO,IAAP,CAV2B,CAUd;MAChB,CA/HE;MAgIHsT,KAAK,EAAE,eAAUlR,MAAV,EAAkBF,CAAlB,EAAqBkR,GAArB,EAA0BxI,KAA1B,EAAiC;QACpC;QACA,IAAGxI,MAAM,CAACzB,QAAP,MAAqByB,MAAM,CAACE,WAAP,EAAxB,EAA8C;UAE1C;UACA,IAAIgR,KAAK,GAAG,IAAInW,MAAJ,CAAW,CAAX,CAAZ;UACAiF,MAAM,CAACZ,IAAP,CAAY,UAAUC,CAAV,EAAa;YACrB6R,KAAK,GAAG3W,CAAC,CAACgF,GAAF,CAAM2R,KAAN,EAAa7N,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAe7R,CAAf,EAAkBS,CAAlB,EAAqBkR,GAArB,EAA0BxI,KAA1B,CAAb,CAAR;UACH,CAFD,EAEG,IAFH;UAIA,OAAO0I,KAAP;QACH;;QACD;QAEAlR,MAAM,GAAG3F,IAAI,CAACsG,OAAL,CAAaiS,QAAb,CAAsBC,QAAtB,CAA+B7S,MAA/B,CAAT;QAEAwI,KAAK,GAAGA,KAAK,IAAI,CAAjB;;QAEA,IAAGA,KAAK,KAAK9N,QAAQ,CAAC0I,aAAtB,EAAqC;UACjC;QACH,CApBmC,CAsBpC;;;QACA,IAAIlF,CAAC,GAAG3D,CAAC,CAACkE,KAAF,CAAQuB,MAAM,CAAC7B,UAAf,CAAR,CAvBoC,CAwBpC;;;QACA6B,MAAM,CAAC1B,gBAAP;;QACA,IAAI;UACA;UACA,IAAIP,MAAJ,CAFA,CAGA;UACA;;UACA,IAAGiC,MAAM,CAACN,UAAP,CAAkB,IAAlB,CAAH,EAA4B;YACxB3B,MAAM,GAAGiC,MAAT;UACH,CAFD,MAGK;YACD,IAAI+Q,KAAK,GAAG,EAAZ;YACAA,KAAK,CAACjR,CAAD,CAAL,GAAWkR,GAAX,CAFC,CAGD;;YAEA,IAAI;cAEA;cACA,IAAI1R,CAAC,GAAG/E,CAAC,CAACkE,KAAF,CAAQuB,MAAM,CAACiH,GAAP,CAAWnH,CAAX,EAAckR,GAAd,CAAR,EAA4BD,KAA5B,CAAR,CAHA,CAKA;;;cACA,IAAGzR,CAAC,CAACI,UAAF,CAAa,IAAb,KAAsBJ,CAAC,CAACuS,UAA3B,EACI9T,MAAM,GAAGuB,CAAT;YAEP,CATD,CAUA,OAAMoC,CAAN,EAAS;cAAE;YACV;;YACD;;YAEA,IAAG,CAAC3D,MAAJ,EAAY;cACR;cACA,IAAIuC,GAAG,GAAGN,MAAM,CAACO,MAAP,EAAV;cACA,IAAIC,GAAG,GAAGR,MAAM,CAACK,QAAP,EAAV;;cAEA,IAAGG,GAAG,CAACd,UAAJ,CAAe,IAAf,CAAH,EAAyB;gBACrB;gBACA,IAAGM,MAAM,CAAClC,KAAP,KAAiBnC,EAApB,EAAwB;kBACpB;kBACA;kBACA,IAAIsI,CAAC,GAAGjE,MAAM,CAAC3B,KAAP,GAAeY,QAAf,EAAR;kBACA,IAAIqI,CAAC,GAAGtH,MAAM,CAACtB,KAAP,CAAaL,KAAb,EAAR;;kBACA,IAAIyU,IAAI,GAAG7O,CAAC,CAAC1D,MAAF,EAAX;;kBACA,IAAIwS,IAAI,GAAG9O,CAAC,CAAC5D,QAAF,EAAX;;kBACA,IAAImD,EAAE,GAAGnJ,IAAI,CAACO,KAAL,CAAW0P,YAAX,CAAwByI,IAAxB,EAA8BjT,CAA9B,EAAiC,IAAjC,CAAT,CAPoB,CAQpB;;kBACA,IAAGgT,IAAI,CAAChV,KAAL,KAAevC,CAAf,IAAoBuX,IAAI,CAAC3U,UAAL,CAAgB6U,KAAhB,EAApB,IAA+CxP,EAAE,CAAC4F,EAAH,CAAMtL,KAAN,KAAgBvC,CAA/D,IAAoEiI,EAAE,CAACb,CAAH,CAAKjD,UAAL,CAAgB,IAAhB,CAApE,IAA6F8D,EAAE,CAACxF,CAAH,CAAKgV,KAAL,EAA7F,IAA6GxP,EAAE,CAACb,CAAH,CAAKjD,UAAL,CAAgB,IAAhB,CAAhH,EAAuI;oBACnI3B,MAAM,GAAGxD,CAAC,CAACkE,KAAF,CAAQtD,MAAM,CAAC,aAAD,EAAgBqI,EAAE,CAACb,CAAnB,CAAd,CAAT;kBACH,CAFD,MAGK;oBACD,IAAIsQ,OAAO,GAAG5P,EAAE,CAAC4N,KAAH,CAASuB,YAAT,CAAsBxS,MAAM,CAAC3B,KAAP,EAAtB,CAAd,CADC,CAED;;;oBACA,IAAIW,GAAG,GAAGiU,OAAO,CAACvU,KAAR,CAAcL,KAAd,EAAV;oBACA,IAAI6U,IAAI,GAAGD,OAAO,CAAC5U,KAAR,GAAgBY,QAAhB,EAAX;;oBACA,IAAIkU,QAAQ,GAAG9P,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAegC,IAAf,EAAqBpT,CAArB,EAAwBkR,GAAxB,EAA6BxI,KAA7B,CAAf;;oBACA,IAAI4K,OAAO,GAAG/P,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAelS,GAAf,EAAoBc,CAApB,EAAuBkR,GAAvB,EAA4BxI,KAA5B,CAAd;;oBACAzK,MAAM,GAAGxD,CAAC,CAACyE,GAAF,CAAMmU,QAAN,EAAgBC,OAAhB,CAAT;kBACH;gBACJ,CArBD,MAsBK,IAAGpT,MAAM,CAAClC,KAAP,KAAiBjD,EAAjB,IAAuBmF,MAAM,CAAC/B,IAAP,CAAYqE,MAAZ,KAAuB,CAAjD,EAAoD;kBACrD,IAAI+Q,SAAJ,CADqD,CAErD;;kBACA,IAAIzN,GAAG,GAAGvC,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAelR,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAf,EAA+B6B,CAA/B,EAAkCkR,GAAlC,EAAuCxI,KAAvC,CAAV;;kBACA,IAAGnO,IAAI,CAACO,KAAL,CAAW6J,QAAX,CAAoBmB,GAApB,CAAH,EAA6B;oBACzB;oBACA7H,MAAM,GAAG6H,GAAG,CAAC3C,GAAJ,CAAQ,UAAUvB,CAAV,EAAa;sBAC1B,IAAIrD,KAAK,GAAG2B,MAAM,CAAC3B,KAAP,EAAZ;sBACAA,KAAK,CAACJ,IAAN,CAAW,CAAX,IAAgByD,CAAhB;sBACA,OAAO2B,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAe3W,CAAC,CAAC6J,WAAF,CAAcpE,MAAM,CAACxB,KAArB,EAA4B,CAACkD,CAAD,CAA5B,CAAf,EAAiD5B,CAAjD,EAAoDkR,GAApD,EAAyDxI,KAAzD,CAAP;oBACH,CAJQ,CAAT;oBAMA,OAAOjO,CAAC,CAACiF,QAAF,CAAWtB,CAAX,EAAcH,MAAd,CAAP;kBACH,CATD,CAUA;kBAVA,KAWK,IAAG6H,GAAG,CAAClG,UAAJ,CAAe,IAAf,CAAH,EAAyB;oBAE1B;oBACA,IAAI4T,KAAK,GAAG/Y,CAAC,CAAC6J,WAAF,CAAcpE,MAAM,CAACxB,KAArB,EAA4B,CAACoH,GAAD,CAA5B,CAAZ,CAH0B,CAI1B;;;oBACA,IAAI;sBACAvK,QAAQ,CAACiY,KAAD,CAAR;sBACAD,SAAS,GAAG,IAAZ;oBACH,CAHD,CAIA,OAAM3R,CAAN,EAAS;sBAEL2R,SAAS,GAAG,KAAZ;oBACH;kBACJ;;kBACD,IAAGA,SAAH,EAAc;oBACVtV,MAAM,GAAGuV,KAAT;kBACH,CAFD,MAGK;oBACD;oBACA,IAAGjQ,EAAE,CAAC4N,KAAH,CAAS0B,YAAT,CAAsB/M,GAAtB,CAAH,EAA+B;sBAC3B,IAAG5F,MAAM,CAACxB,KAAP,KAAiB3C,GAApB,EAAyB;wBACrB,QAAO+J,GAAG,CAAC1C,QAAJ,EAAP;0BACI;0BACA,KAAK,GAAL;4BACInF,MAAM,GAAGhD,MAAM,CAACwX,QAAP,GAAkB1T,MAAlB,EAAT;4BACA;;0BACJ,KAAK,UAAL;4BACId,MAAM,GAAGhD,MAAM,CAACwX,QAAP,EAAT;4BACA;;0BACJ,KAAK,WAAL;4BACIxU,MAAM,GAAGhD,MAAM,CAACwX,QAAP,EAAT;4BACA;wBAVR;sBAYH,CAbD,MAcK,IAAG,CAACvS,MAAM,CAACxB,KAAP,KAAiBtC,GAAjB,IAAwB8D,MAAM,CAACxB,KAAP,KAAiBvC,GAA1C,KAAkD+U,GAAG,CAACa,UAAzD,EAAqE;wBACtE9T,MAAM,GAAGsF,EAAE,CAAC4N,KAAH,CAASO,QAAT,CAAkB,CAAC,CAAnB,EAAsB,CAAtB,CAAT;sBACH,CAFI,MAGA,IAAIxR,MAAM,CAACxB,KAAP,KAAiBrC,GAArB,EAA2B;wBAC5B,IAAIoX,KAAK,GAAGvT,MAAM,CAAC/B,IAAP,CAAY,CAAZ,CAAZ;wBACA,IAAIa,CAAC,GAAGyU,KAAK,CAAChT,MAAN,EAAR;wBACA,IAAIyE,CAAC,GAAGuO,KAAK,CAAClT,QAAN,EAAR;wBACA,IAAImT,EAAE,GAAG1U,CAAC,CAACR,gBAAF,EAAT;;wBACA,IAAG0S,GAAG,CAACa,UAAJ,IAAkB2B,EAAE,CAAC7U,MAAH,CAAU,IAAV,KAAmBqG,CAAC,CAACrG,MAAF,CAAS,CAAT,CAAxC,EAAqD;0BACjDZ,MAAM,GAAG0V,SAAS,EAAlB;wBACH;sBACJ,CARI,MASA,IAAGzT,MAAM,CAACxB,KAAP,KAAiB9D,QAAQ,CAACgZ,SAA7B,EAAwC;wBACzC,IAAG9N,GAAG,CAACiM,UAAP,EACI,OAAO9W,MAAM,CAACwX,QAAP,EAAP;sBACP;oBACJ;kBACJ;gBACJ,CAnEI,MAoEA,IAAGvS,MAAM,CAAClC,KAAP,KAAiBvC,CAApB,EAAuB;kBACxB,IAAGyE,MAAM,CAACtB,KAAP,GAAe,CAAlB,EACI;oBACA,OAAOnE,CAAC,CAACkE,KAAF,CAAQuB,MAAR,EAAgB+Q,KAAhB,CAAP,CAFJ,KAGK;oBACD;oBACA;oBACA,IAAG1W,IAAI,CAACO,KAAL,CAAWQ,IAAX,CAAgB4E,MAAM,CAACtB,KAAvB,CAAH,EAAkC;sBAC9B;sBACAX,MAAM,GAAGhD,MAAM,CAACwX,QAAP,EAAT;oBACH,CAHD,MAIK;sBACD;sBACAxU,MAAM,GAAGsF,EAAE,CAAC4N,KAAH,CAASQ,QAAT,EAAT;oBACH;kBACJ;gBACJ,CAhBI,MAiBA,IAAGzR,MAAM,CAAClC,KAAP,KAAiBpC,EAApB,EAAwB;kBAEzB,IAAIuW,IAAJ,EAAUC,IAAV,CAFyB,CAGzB;kBACA;kBACA;;kBACA,IAAIrS,OAAO,GAAGG,MAAM,CAACsG,cAAP,GAAwBoH,IAAxB,CAA6B,UAAU1P,CAAV,EAAa2E,CAAb,EAAgB;oBACvD,OAAO3E,CAAC,CAACF,KAAF,GAAU6E,CAAC,CAAC7E,KAAnB;kBACH,CAFa,CAAd;kBAIA,IAAImG,CAAC,GAAGpE,OAAO,CAACuK,GAAR,EAAR,CAVyB,CAWzB;;kBACA6H,IAAI,GAAG5W,QAAQ,CAACgI,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAejN,CAAf,EAAkBnE,CAAlB,EAAqBkR,GAArB,EAA0BxI,KAA1B,CAAD,CAAf,CAZyB,CAczB;;kBACA,OAAM3I,OAAO,CAACyC,MAAd,EAAsB;oBAClB;oBACA,IAAIkD,CAAC,GAAG3F,OAAO,CAACuK,GAAR,EAAR,CAFkB,CAGlB;;oBACA8H,IAAI,GAAG7W,QAAQ,CAACgI,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAe1L,CAAf,EAAkB1F,CAAlB,EAAqBkR,GAArB,EAA0BxI,KAA1B,CAAD,CAAf,CAJkB,CAMlB;;oBACA,IAAIyJ,IAAI,CAACJ,UAAL,IAAmB,CAACxO,EAAE,CAAC4N,KAAH,CAAS0B,YAAT,CAAsBV,IAAtB,CAAD,IAAgCC,IAAI,CAACvT,MAAL,CAAY,CAAZ,CAAnD,IAAqEsT,IAAI,CAACtT,MAAL,CAAY,CAAZ,KAAkB0E,EAAE,CAAC4N,KAAH,CAAS0B,YAAT,CAAsBT,IAAtB,CAA3F,EAAyH;sBACrH,IAAG1M,CAAC,CAAC5H,gBAAF,CAAmB/B,GAAnB,CAAH,EAA4B;wBACxB;wBACA2J,CAAC,GAAG,CAACvB,CAAD,EAAIA,CAAC,GAAGuB,CAAR,EAAW,CAAX,CAAJ;sBACH,CAJoH,CAKrH;;;sBACAA,CAAC,CAACyG,MAAF,GANqH,CAQrH;;sBACA,IAAGgG,IAAI,CAACJ,UAAL,IAAmBK,IAAI,CAACL,UAA3B,EAAuC;wBACnCI,IAAI,GAAGlX,MAAM,CAACwX,QAAP,EAAP;sBACH,CAFD,MAGK;wBACDN,IAAI,GAAG5O,EAAE,CAAC4N,KAAH,CAASvQ,MAAT,CAAgBuD,CAAhB,EAAmBuB,CAAnB,EAAsB1F,CAAtB,EAAyBkR,GAAzB,EAA8BxI,KAA9B,CAAP;sBACH;oBACJ,CAfD,MAgBK;sBACD;sBACAyJ,IAAI,GAAG1X,CAAC,CAACiF,QAAF,CAAWyS,IAAX,EAAiBC,IAAjB,CAAP,CAFC,CAGD;;sBACAjO,CAAC,GAAG1J,CAAC,CAACiF,QAAF,CAAWyE,CAAX,EAAcuB,CAAd,CAAJ;oBACH;kBACJ,CA5CwB,CA8CzB;;;kBACAzH,MAAM,GAAGkU,IAAT;gBACH,CAhDI,MAiDA,IAAGjS,MAAM,CAACE,WAAP,EAAH,EAAyB;kBAC1B,IAAIyT,IAAJ;;kBACA,IAAG,CAAC3T,MAAM,CAACzB,QAAP,EAAJ,EACIyB,MAAM,GAAGzF,CAAC,CAAC4E,MAAF,CAASa,MAAT,CAAT,CAHsB,CAI1B;;kBACAjC,MAAM,GAAG,IAAIhD,MAAJ,CAAW,CAAX,CAAT;kBAEA,IAAI8E,OAAO,GAAGG,MAAM,CAACsG,cAAP,GAAwBoH,IAAxB,CAA6B,UAAU1P,CAAV,EAAa2E,CAAb,EAAgB;oBACvD,OAAOA,CAAC,CAAC7E,KAAF,GAAUE,CAAC,CAACF,KAAnB;kBACH,CAFa,CAAd;kBAIA,IAAI8V,QAAQ,GAAG,EAAf,CAX0B,CAY1B;;kBACA,IAAIC,GAAG,GAAG,IAAI9Y,MAAJ,CAAW,CAAX,CAAV;;kBACA,KAAI,IAAIwG,CAAC,GAAG,CAAR,EAAWc,CAAC,GAAGxC,OAAO,CAACyC,MAA3B,EAAmCf,CAAC,GAAGc,CAAvC,EAA0Cd,CAAC,EAA3C,EAA+C;oBAC3C,IAAInD,GAAG,GAAGyB,OAAO,CAAC0B,CAAD,CAAP,CAAWlD,KAAX,EAAV;;oBACA,IAAGD,GAAG,CAACN,KAAJ,KAAcjD,EAAd,IAAoBuD,GAAG,CAACN,KAAJ,KAAcpC,EAAd,IAAoB0C,GAAG,CAACwO,OAAJ,EAA3C,EAA0D;sBACtDiH,GAAG,GAAGtZ,CAAC,CAACgF,GAAF,CAAMsU,GAAN,EAAWzV,GAAX,CAAN;oBACH,CAFD,MAIIwV,QAAQ,CAAC/O,IAAT,CAAczG,GAAd;kBACP;;kBACDwV,QAAQ,CAACE,OAAT,CAAiBD,GAAjB,EAtB0B,CAwB1B;;;kBACA,IAAGD,QAAQ,CAACtR,MAAT,KAAoB,CAAvB,EAA0B;oBACtBzC,OAAO,GAAG+T,QAAV;kBACH;;kBAED,KAAI,IAAIrS,CAAC,GAAG,CAAR,EAAWc,CAAC,GAAGxC,OAAO,CAACyC,MAA3B,EAAmCf,CAAC,GAAGc,CAAvC,EAA0Cd,CAAC,EAA3C,EAA+C;oBAC3C,IAAInD,GAAG,GAAGyB,OAAO,CAAC0B,CAAD,CAAjB,CAD2C,CAE3C;;oBACA,IAAI;sBACAoS,IAAI,GAAGtQ,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAe9S,GAAf,EAAoB0B,CAApB,EAAuBkR,GAAvB,EAA4BxI,KAA5B,CAAP;oBACH,CAFD,CAGA,OAAM9G,CAAN,EAAS;sBACLiS,IAAI,GAAGtQ,EAAE,CAAC4N,KAAH,CAASQ,QAAT,EAAP;oBACH;;oBAED,IAAI;sBACA1T,MAAM,GAAGxD,CAAC,CAACgF,GAAF,CAAMxB,MAAN,EAAc4V,IAAd,CAAT;oBACH,CAFD,CAGA,OAAMjS,CAAN,EAAS;sBACL,IAAG8G,KAAK,KAAK9N,QAAQ,CAAC0I,aAAtB,EAAqC;wBACjC;sBACH;;sBACD;sBACArF,MAAM,GAAGsF,EAAE,CAAC4N,KAAH,CAASC,KAAT,CAAe7N,EAAE,CAACzB,IAAH,CAAQ5B,MAAR,EAAgBF,CAAhB,CAAf,EAAmCA,CAAnC,EAAsCkR,GAAtC,EAA2CxI,KAA3C,CAAT;oBACH;kBACJ;gBACJ;cACJ,CAjND,MAkNK;gBACDzK,MAAM,GAAGsF,EAAE,CAAC4N,KAAH,CAASvQ,MAAT,CAAgBJ,GAAhB,EAAqBE,GAArB,EAA0BV,CAA1B,EAA6BkR,GAA7B,EAAkCxI,KAAlC,CAAT;cACH;YACJ;UACJ,CAtPD,CAwPA;;;UACA,IAAG,CAACzK,MAAJ,EACI;YACAA,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,OAAd,EAAuB,CAACpE,MAAD,EAASF,CAAT,EAAYkR,GAAZ,CAAvB,CAAT;QACP,CA5PD,CA6PA,OAAMtP,CAAN,EAAS;UACL;UACA3D,MAAM,GAAGxD,CAAC,CAAC6J,WAAF,CAAc,OAAd,EAAuB,CAACpE,MAAD,EAASF,CAAT,EAAYkR,GAAZ,CAAvB,CAAT;QACH;;QAED,OAAOzW,CAAC,CAACiF,QAAF,CAAWtB,CAAX,EAAcH,MAAd,CAAP;MACH;IA7ZE,CA/wDc;IA8qErBgW,OAAO,EAAE;MACLxY,CAAC,EAAE,WAAUuE,CAAV,EAAa;QACZ,IAAGA,CAAC,CAACJ,UAAF,CAAa,IAAb,CAAH,EAAuB;UACnB,OAAO2D,EAAE,CAACsN,MAAH,CAAUpW,CAAC,CAACkE,KAAF,CAAQ,eAAR,CAAV,EAAoC1D,MAAM,CAAC,CAAD,CAA1C,EAA+C+E,CAA/C,EAAkD,GAAlD,CAAP;QACH;;QACD,OAAOvF,CAAC,CAAC6J,WAAF,CAAc,GAAd,EAAmBC,SAAnB,CAAP;MACH,CANI;MAOL4G,CAAC,EAAE,WAAUnL,CAAV,EAAa;QACZ,IAAGA,CAAC,CAACJ,UAAF,CAAa,IAAb,CAAH,EAAuB;UACnB,OAAO2D,EAAE,CAACsN,MAAH,CAAUpW,CAAC,CAACkE,KAAF,CAAQ,eAAR,CAAV,EAAoC1D,MAAM,CAAC,CAAD,CAA1C,EAA+C+E,CAA/C,EAAkD,GAAlD,CAAP;QACH;;QACD,OAAOvF,CAAC,CAAC6J,WAAF,CAAc,GAAd,EAAmBC,SAAnB,CAAP;MACH;IAZI;EA9qEY,CAAzB;;EA8rEAlK,QAAQ,CAAC6Z,QAAT,CAAkB,CACd;IACIC,IAAI,EAAE,MADV;IAEIC,OAAO,EAAE,IAFb;IAGIC,OAAO,EAAE,CAAC,CAAD,EAAI,CAAJ,CAHb;IAII9C,KAAK,EAAE,iBAAY;MACf,OAAOhO,EAAE,CAACzB,IAAV;IACH;EANL,CADc,EASd;IACIqS,IAAI,EAAE,KADV;IAEIC,OAAO,EAAE,IAFb;IAGIC,OAAO,EAAE,CAHb;IAII9C,KAAK,EAAE,iBAAY;MACf,OAAOhO,EAAE,CAACE,GAAV;IACH;EANL,CATc,EAiBd;IACI0Q,IAAI,EAAE,SADV;IAEIC,OAAO,EAAE,IAFb;IAGIC,OAAO,EAAE,CAHb;IAII9C,KAAK,EAAE,iBAAY;MACf,OAAOhO,EAAE,CAACiB,OAAV;IACH;EANL,CAjBc,EAyBd;IACI2P,IAAI,EAAE,WADV;IAEIC,OAAO,EAAE,IAFb;IAGIC,OAAO,EAAE,CAAC,CAAD,EAAI,CAAJ,CAHb;IAII9C,KAAK,EAAE,iBAAY;MACf,OAAOhO,EAAE,CAAC0D,SAAV;IACH;EANL,CAzBc,EAiCd;IACIkN,IAAI,EAAE,QADV;IAEIC,OAAO,EAAE,IAFb;IAGIC,OAAO,EAAE,CAAC,CAAD,EAAI,CAAJ,CAHb;IAII9C,KAAK,EAAE,iBAAY;MACf,OAAOhO,EAAE,CAACsN,MAAV;IACH;EANL,CAjCc,EAyCd;IACIsD,IAAI,EAAE,GADV;IAEIC,OAAO,EAAE,IAFb;IAGIC,OAAO,EAAE,CAHb;IAII9C,KAAK,EAAE,iBAAY;MACf,OAAOhO,EAAE,CAAC0Q,OAAH,CAAWxY,CAAlB;IACH;EANL,CAzCc,EAiDd;IACI0Y,IAAI,EAAE,GADV;IAEIC,OAAO,EAAE,IAFb;IAGIC,OAAO,EAAE,CAHb;IAII9C,KAAK,EAAE,iBAAY;MACf,OAAOhO,EAAE,CAAC0Q,OAAH,CAAW9I,CAAlB;IACH;EANL,CAjDc,EAyDd;IACIgJ,IAAI,EAAE,OADV;IAEIC,OAAO,EAAE,IAFb;IAGIC,OAAO,EAAE,CAAC,CAAD,EAAI,CAAJ,CAHb;IAII9C,KAAK,EAAE,iBAAY;MACf,OAAOhO,EAAE,CAAC4N,KAAH,CAASC,KAAhB;IACH;EANL,CAzDc,CAAlB,EA/hFS,CAimFT;;EACA/W,QAAQ,CAACia,SAAT;AAEH,CApmFD"},"metadata":{},"sourceType":"script"}