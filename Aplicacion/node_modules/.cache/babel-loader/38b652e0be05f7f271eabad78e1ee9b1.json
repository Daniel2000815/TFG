{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitFieldClass = exports.BitField = void 0;\n\nvar BitField = function () {\n  function BitField() {\n    this.bits = 0;\n  }\n\n  BitField.allocate = function () {\n    var e_1, _a;\n\n    var names = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      names[_i] = arguments[_i];\n    }\n\n    try {\n      for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {\n        var name_1 = names_1_1.value;\n\n        if (this.has(name_1)) {\n          throw new Error('Bit already allocated for ' + name_1);\n        }\n\n        if (this.next === BitField.MAXBIT) {\n          throw new Error('Maximum number of bits already allocated');\n        }\n\n        this.names.set(name_1, this.next);\n        this.next <<= 1;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  BitField.has = function (name) {\n    return this.names.has(name);\n  };\n\n  BitField.prototype.set = function (name) {\n    this.bits |= this.getBit(name);\n  };\n\n  BitField.prototype.clear = function (name) {\n    this.bits &= ~this.getBit(name);\n  };\n\n  BitField.prototype.isSet = function (name) {\n    return !!(this.bits & this.getBit(name));\n  };\n\n  BitField.prototype.reset = function () {\n    this.bits = 0;\n  };\n\n  BitField.prototype.getBit = function (name) {\n    var bit = this.constructor.names.get(name);\n\n    if (!bit) {\n      throw new Error('Unknown bit-field name: ' + name);\n    }\n\n    return bit;\n  };\n\n  BitField.MAXBIT = 1 << 31;\n  BitField.next = 1;\n  BitField.names = new Map();\n  return BitField;\n}();\n\nexports.BitField = BitField;\n\nfunction BitFieldClass() {\n  var names = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    names[_i] = arguments[_i];\n  }\n\n  var Bits = function (_super) {\n    __extends(Bits, _super);\n\n    function Bits() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    return Bits;\n  }(BitField);\n\n  Bits.allocate.apply(Bits, __spreadArray([], __read(names), false));\n  return Bits;\n}\n\nexports.BitFieldClass = BitFieldClass;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;EAAA;IAoBY,YAAe,CAAf;EAmEX;;EA9DeA,oBAAd;;;IAAuB;;SAAA,yCAAkB;MAAlBC;;;;MACrB,KAAmB,+BAAKC,0BAAxB,EAAwB,eAAxB,EAAwBA,0BAAxB,EAA0B;QAArB,IAAMC,MAAI,kBAAV;;QACH,IAAI,KAAKC,GAAL,CAASD,MAAT,CAAJ,EAAoB;UAClB,MAAM,IAAIE,KAAJ,CAAU,+BAA+BF,MAAzC,CAAN;QACD;;QACD,IAAI,KAAKG,IAAL,KAAcN,QAAQ,CAACO,MAA3B,EAAmC;UACjC,MAAM,IAAIF,KAAJ,CAAU,0CAAV,CAAN;QACD;;QACD,KAAKJ,KAAL,CAAWO,GAAX,CAAeL,MAAf,EAAqB,KAAKG,IAA1B;QACA,KAAKA,IAAL,KAAc,CAAd;MACD;;;;;;;;;;;;EACF,CAXa;;EAiBAN,eAAd,UAAkBS,IAAlB,EAA8B;IAC5B,OAAO,KAAKR,KAAL,CAAWG,GAAX,CAAeK,IAAf,CAAP;EACD,CAFa;;EAOPT,yBAAP,UAAWS,IAAX,EAAuB;IACrB,KAAKC,IAAL,IAAa,KAAKC,MAAL,CAAYF,IAAZ,CAAb;EACD,CAFM;;EAOAT,2BAAP,UAAaS,IAAb,EAAyB;IACvB,KAAKC,IAAL,IAAa,CAAC,KAAKC,MAAL,CAAYF,IAAZ,CAAd;EACD,CAFM;;EAQAT,2BAAP,UAAaS,IAAb,EAAyB;IACvB,OAAO,CAAC,EAAE,KAAKC,IAAL,GAAY,KAAKC,MAAL,CAAYF,IAAZ,CAAd,CAAR;EACD,CAFM;;EAOAT,2BAAP;IACE,KAAKU,IAAL,GAAY,CAAZ;EACD,CAFM;;EAQGV,4BAAV,UAAiBS,IAAjB,EAA6B;IAC3B,IAAMG,GAAG,GAAI,KAAKC,WAAL,CAAqCZ,KAArC,CAA2Ca,GAA3C,CAA+CL,IAA/C,CAAb;;IACA,IAAI,CAACG,GAAL,EAAU;MACR,MAAM,IAAIP,KAAJ,CAAU,6BAA6BI,IAAvC,CAAN;IACD;;IACD,OAAOG,GAAP;EACD,CANS;;EA1EOZ,kBAAS,KAAK,EAAd;EAKAA,gBAAe,CAAf;EAKAA,iBAA6B,IAAIe,GAAJ,EAA7B;EAwEnB;AAAC,CAvFD;;AAAaC;;AA6Fb,SAAgBC,aAAhB,GAA6B;EAAC;;OAAA,yCAAkB;IAAlBhB;;;EAC5B,IAAMiB,IAAI;IAAiBC;;IAAd;;IAAyB;;IAAD;EAAC,CAA5B,CAAiBnB,QAAjB,CAAV;;EACAkB,IAAI,CAACE,QAAL,CAAaC,KAAb,OAAIC,yBAAarB,KAAb,GAAkB,KAAlB,CAAJ;EACA,OAAOiB,IAAP;AACD;;AAJDF","names":["BitField","names","names_1_1","name_1","has","Error","next","MAXBIT","set","name","bits","getBit","bit","constructor","get","Map","exports","BitFieldClass","Bits","__extends","allocate","apply","__spreadArray"],"sourceRoot":"","sources":["../../ts/util/BitField.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}