{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RPN = void 0;\n\nvar Token_1 = require(\"./Token\");\n\nvar Settings_1 = require(\"../Settings\");\n\nvar Symbol_1 = require(\"../Types/Symbol\");\n\nvar Collection_1 = require(\"./Collection\");\n\nvar Slice_1 = require(\"./Slice\");\n\nvar Vector_1 = require(\"../Types/Vector\");\n\nvar Set_1 = require(\"../Types/Set\");\n\nvar Errors_1 = require(\"../Core/Errors\");\n\nvar Utils_1 = require(\"../Core/Utils\");\n\nvar Parser_1 = require(\"./Parser\");\n\nvar RPN = /*#__PURE__*/function () {\n  function RPN(deps, variables, peekers) {\n    _classCallCheck(this, RPN);\n\n    this.deps = deps;\n    this.peekers = peekers;\n    this.variables = variables;\n  }\n  /**\n   * Puts token array in Reverse Polish Notation\n   * @param {Token[] | Token} tokens\n   * @returns {Token[]}\n   */\n\n\n  _createClass(RPN, [{\n    key: \"parseRPN\",\n    value:\n    /*\n    * Parses the tokens\n    * @param {Tokens[]} rpn\n    * @param {object} substitutions\n    * @returns {Symbol}\n    */\n    function parseRPN(rpn) {\n      var substitutions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var deps = this.deps; // try {\n      //prepare the substitutions.\n\n      substitutions = substitutions || {}; //we first parse them out as-is\n\n      for (var x in substitutions) {\n        substitutions[x] = (0, Parser_1.parse)(substitutions[x], {});\n      } //Although technically constants,\n      //pi and e are only available when evaluating the expression so add to the subs.\n      //Doing this avoids rounding errors\n      //link e and pi\n\n\n      if (Settings_1.Settings.PARSE2NUMBER) {\n        //use the value provided if the individual for some strange reason prefers this.\n        //one reason could be to sub e but not pi or vice versa\n        if (!('e' in substitutions)) substitutions.e = new Symbol_1.Symbol(Settings_1.Settings.E);\n        if (!('pi' in substitutions)) substitutions.pi = new Symbol_1.Symbol(Settings_1.Settings.PI);\n      }\n\n      var Q = [];\n\n      for (var i = 0, l = rpn.length; i < l; i++) {\n        var e = rpn[i]; //Arrays indicate a new scope so parse that out\n\n        if (Array.isArray(e)) {\n          e = this.parseRPN(e, substitutions);\n        }\n\n        if (e) {\n          if (e.type === Token_1.Token.OPERATOR) {\n            if (e.is_prefix || e.postfix) {\n              //resolve the operation assocated with the prefix\n              Q.push(e.operation(Q.pop()));\n            } else {\n              var b = Q.pop();\n              var a = Q.pop(); //Throw an error if the RH value is empty. This cannot be a postfix since we already checked\n\n              if (typeof a === 'undefined') throw new Errors_1.OperatorError(e + ' is not a valid postfix operator at ' + e.column);\n              var is_comma = e.action === 'comma'; //convert Sets to Vectors on all operations at this point. Sets are only recognized functions or individually\n\n              if (a instanceof Set_1.Set && !is_comma) a = Vector_1.Vector.fromSet(a);\n              if (b instanceof Set_1.Set && !is_comma) b = Vector_1.Vector.fromSet(b); //call all the pre-operators\n\n              this.callPeekers('pre_operator', a, b, e);\n              var action = deps.getAction(e.action);\n              var ans = action(a, b); //call all the pre-operators\n\n              this.callPeekers('post_operator', ans, a, b, e);\n              Q.push(ans);\n            }\n          } else if (e.type === Token_1.Token.FUNCTION) {\n            var args = Q.pop();\n            var parent = args.parent; //make a note of the parent\n\n            if (!(args instanceof Collection_1.Collection)) args = Collection_1.Collection.create(args); //the return value may be a vector. If it is then we check\n            //Q to see if there's another vector on the stack. If it is then\n            //we check if has elements. If it does then we know that we're dealing\n            //with an \"getter\" object and return the requested values\n            //call the function. This is the _.callfunction method in nerdamer\n            //call the function. This is the _.callfunction method in nerdamer\n\n            var fn_name = e.value;\n            var fn_args = args.getItems(); //call the pre-function peekers\n\n            this.callPeekers('pre_function', fn_name, fn_args);\n            var ret = deps.callfunction(fn_name, fn_args); //call the post-function peekers\n\n            this.callPeekers('post_function', ret, fn_name, fn_args);\n            var last = Q[Q.length - 1];\n            var next = rpn[i + 1];\n            var next_is_comma = next && next.type === Token_1.Token.OPERATOR && next.value === ',';\n\n            if (!next_is_comma && ret instanceof Vector_1.Vector && last && last.elements && !(last instanceof Collection_1.Collection)) {\n              //remove the item from the queue\n              var item = Q.pop();\n              var getter = ret.elements[0]; //check if it's symbolic. If so put it back and add the item to the stack\n\n              if (!getter.isConstant()) {\n                item.getter = getter;\n                Q.push(item);\n                Q.push(ret);\n              } else if (getter instanceof Slice_1.Slice) {\n                //if it's a Slice return the slice\n                Q.push(Vector_1.Vector.fromArray(item.elements.slice(getter.start, getter.end)));\n              } else {\n                var index = Number(getter);\n                var il = item.elements.length; //support for negative indices\n\n                if (index < 0) index = il + index; //it it's still out of bounds\n\n                if (index < 0 || index >= il) //index should no longer be negative since it's been reset above\n                  //range error\n                  throw new Errors_1.OutOfRangeError('Index out of range ' + (e.column + 1));\n                var element = item.elements[index]; //cyclic but we need to mark this for future reference\n\n                item.getter = index;\n                element.parent = item;\n                Q.push(element);\n              }\n            } else {\n              //extend the parent reference\n              if (parent) ret.parent = parent;\n              Q.push(ret);\n            }\n          } else {\n            var subbed = void 0;\n            var v = e.value;\n            if (v in Settings_1.Settings.ALIASES) e = (0, Parser_1.parse)(Settings_1.Settings.ALIASES[e]); //wrap it in a symbol if need be\n            else if (e.type === Token_1.Token.VARIABLE_OR_LITERAL) e = new Symbol_1.Symbol(v);else if (e.type === Token_1.Token.UNIT) {\n              e = new Symbol_1.Symbol(v);\n              e.isUnit = true;\n            } //make substitutions\n            //Always constants first. This avoids the being overridden\n\n            if (this.variables.isConstant(v)) {\n              subbed = e;\n              e = new Symbol_1.Symbol(this.variables.getConstant(v));\n            } //next substitutions. This allows declared variable to be overridden\n            //check if the values match to avoid erasing the multiplier.\n            //Example:/e = 3*a. substutiting a for a will wipe out the multiplier.\n            else if (v in substitutions && v !== substitutions[v].toString()) {\n              subbed = e;\n              e = substitutions[v].clone();\n            } //next declare variables\n            else if (this.variables.isVar(v)) {\n              subbed = e;\n              e = this.variables.getVar(v).clone();\n            } //make notation of what it was before\n\n\n            if (subbed) e.subbed = subbed;\n            Q.push(e);\n          }\n        }\n      }\n\n      var retval = Q[0];\n\n      if (['undefined', 'string', 'number'].indexOf(typeof retval) !== -1) {\n        throw new Errors_1.UnexpectedTokenError(\"Unexpected token: \".concat(typeof retval, \", \").concat(retval));\n      }\n\n      return retval; // }\n      // catch(error) {\n      //     throw error;\n      //     // let rethrowErrors = [OutOfFunctionDomainError];\n      //     // // Rethrow certain errors in the same class to preserve them\n      //     // rethrowErrors.forEach(function (E) {\n      //     //     if (error instanceof E) {\n      //     //         throw new E(error.message + ': ' + e.column);\n      //     //     }\n      //     // });\n      //     //\n      //     // throw new ParseError(error.message + ': ' + e.column);\n      // }\n    }\n  }, {\n    key: \"callPeekers\",\n    value: function callPeekers(name) {\n      if (Settings_1.Settings.callPeekers) {\n        var peekers = this.peekers[name]; //remove the first items and stringify\n\n        var args = (0, Utils_1.arguments2Array)(arguments).slice(1).map(function (o) {\n          return o ? String(o) : o;\n        }); //call each one of the peekers\n\n        for (var i = 0; i < peekers.length; i++) {\n          peekers[i].apply(null, args);\n        }\n      }\n    }\n  }], [{\n    key: \"TokensToRPN\",\n    value: function TokensToRPN(tokens) {\n      var fn = tokens.type;\n      var l = tokens.length;\n      var output = [];\n      var stack = [];\n      var prefixes = [];\n\n      var collapse = function collapse(target, destination) {\n        while (target.length) {\n          destination.push(target.pop());\n        }\n      };\n\n      var i; //mark all the prefixes and add them to the stack\n\n      for (i = 0; i < l; i++) {\n        var token = tokens[i];\n        if (token.type !== Token_1.Token.OPERATOR) break;\n        if (!token.prefix) throw new Errors_1.OperatorError('Not a prefix operator');\n        token.is_prefix = true;\n        stack.push(token);\n      } //begin with remaining tokens\n\n\n      for (; i < l; i++) {\n        var e = tokens[i];\n\n        if (e.type === Token_1.Token.OPERATOR) {\n          var operator = e; //create the option for the operator being overloaded\n\n          if (operator.overloaded) {\n            var next = tokens[i + 1]; //if it's followed by a number or variable then we assume it's not a postfix operator\n\n            if (next && next.type === Token_1.Token.VARIABLE_OR_LITERAL) {\n              operator.postfix = false; //override the original function with the overload function\n\n              operator.action = operator.overloadAction;\n              operator.leftAssoc = operator.overloadLeftAssoc;\n            }\n          } //if the stack is not empty\n\n\n          while (stack.length) {\n            var last = stack[stack.length - 1]; //if (there is an operator at the top of the operator stack with greater precedence)\n            //or (the operator at the top of the operator stack has equal precedence and is left associative)) ~ wikipedia\n            //the !prefixes.length makes sure that the operator on stack isn't prematurely taken from the stack.\n\n            if (!(last.precedence > operator.precedence || !operator.leftAssoc && last.precedence === operator.precedence)) break;\n            output.push(stack.pop());\n          } //change the behavior of the operator if it's a vector and we've been asked to do so\n\n\n          if ((fn === 'vector' || fn === 'set') && 'vectorFn' in operator) operator.action = operator.vectorFn; //if the operator is a postfix operator then we're ready to go since it belongs\n          //to the preceding token. However the output cannot be empty. It must have either\n          //an operator or a variable/literal\n\n          if (operator.postfix) {\n            var previous = tokens[i - 1];\n            if (!previous) throw new Errors_1.OperatorError(\"Unexpected prefix operator '\" + e.value + \"'! at \" + e.column);else if (previous.type === Token_1.Token.OPERATOR) {\n              //a postfix can only be followed by a postfix\n              if (!previous.postfix) throw new Errors_1.OperatorError(\"Unexpected prefix operator '\" + previous.value + \"'! at \" + previous.column);\n            }\n          } else {\n            var next_is_operator = void 0; //we must be at an infix so point the operator this\n\n            do {\n              //the first one is an infix operator all others have to be prefix operators so jump to the end\n              var _next = tokens[i + 1]; //take a look ahead\n\n              next_is_operator = _next ? _next.type === Token_1.Token.OPERATOR : false; //check if it's an operator\n\n              if (next_is_operator) {\n                //if it's not a prefix operator then it not in the right place\n                if (!_next.prefix) {\n                  throw new Errors_1.OperatorError('A prefix operator was expected at ' + _next.column);\n                } //mark it as a confirmed prefix\n\n\n                _next.is_prefix = true; //add it to the prefixes\n\n                prefixes.push(_next);\n                i++;\n              }\n            } while (next_is_operator);\n          } //if it's a prefix it should be on a special stack called prefixes\n          //we do this to hold on to prefixes because of left associative operators.\n          //they belong to the variable/literal but if placed on either the stack\n          //or output there's no way of knowing this. I might be wrong so I welcome\n          //any discussion about this.\n\n\n          if (operator.is_prefix) //ADD ALL EXCEPTIONS FOR ADDING TO PREFIX STACK HERE. !!!\n            prefixes.push(operator);else stack.push(operator); //move the prefixes to the stack\n\n          while (prefixes.length) {\n            if (operator.leftAssoc || !operator.leftAssoc && prefixes[prefixes.length - 1].precedence >= operator.precedence) //revisit for commas\n              stack.push(prefixes.pop());else break;\n          }\n        } else if (e.type === Token_1.Token.VARIABLE_OR_LITERAL) {\n          //move prefixes to stack at beginning of scope\n          if (output.length === 0) collapse(prefixes, stack); //done with token\n\n          output.push(e);\n          var last_on_stack = stack[stack.length - 1]; //then move all the prefixes to the output\n\n          if (!last_on_stack || !last_on_stack.leftAssoc) collapse(prefixes, output);\n        } else if (e.type === Token_1.Token.FUNCTION) {\n          stack.push(e);\n        } else if (e.type === Token_1.Token.UNIT) {\n          //if it's a unit it belongs on the stack since it's tied to the previous token\n          output.push(e);\n        } //if it's an additional scope then put that into RPN form\n\n\n        if (Array.isArray(e)) {\n          output.push(RPN.TokensToRPN(e));\n          if (e.type) output.push(new Token_1.Token(e.type, Token_1.Token.FUNCTION, e.column)); //since it's hidden it needs no column\n        }\n      } //collapse the remainder of the stack and prefixes to output\n\n\n      collapse(stack, output);\n      collapse(prefixes, output);\n      return output;\n    }\n  }]);\n\n  return RPN;\n}();\n\nexports.RPN = RPN;","map":{"version":3,"mappings":"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","names":["RPN","deps","variables","peekers","rpn","substitutions","x","Settings_1","PARSE2NUMBER","e","Symbol_1","E","pi","PI","Q","i","l","length","Array","isArray","parseRPN","type","Token_1","OPERATOR","is_prefix","postfix","push","operation","pop","b","a","Errors_1","column","is_comma","action","Set_1","Vector_1","fromSet","callPeekers","getAction","ans","FUNCTION","args","parent","Collection_1","create","fn_name","value","fn_args","getItems","ret","callfunction","last","next","next_is_comma","elements","item","getter","isConstant","Slice_1","fromArray","slice","start","end","index","Number","il","element","subbed","v","ALIASES","VARIABLE_OR_LITERAL","UNIT","isUnit","getConstant","toString","clone","isVar","getVar","retval","indexOf","name","arguments","map","o","String","apply","tokens","fn","output","stack","prefixes","collapse","target","destination","token","prefix","operator","overloaded","overloadAction","leftAssoc","overloadLeftAssoc","precedence","vectorFn","previous","next_is_operator","last_on_stack","TokensToRPN","exports"],"sourceRoot":"","sources":["../../src/Parser/RPN.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}