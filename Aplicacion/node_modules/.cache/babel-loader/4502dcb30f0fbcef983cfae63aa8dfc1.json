{"ast":null,"code":"export var fs = function fs(sdf) {\n  return \"\\n  // https://thebookofshaders.com/03/?lan=es\\n// https://thebookofshaders.com/03/\\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\\n// https://www.shadertoy.com/view/llt3R4\\n\\n// camera\\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\\n// http://www.codinglabs.net/article_world_view_projection_matrix.aspx\\n// https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\\n// https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\\n\\n#ifdef GL_ES\\nprecision mediump float;\\n#endif\\n\\nconst int AA = 3;\\nconst int MAX_MARCHING_STEPS = 255;\\nconst float EPSILON = 0.0001;\\nconst float MIN_DIST = 0.0;\\nconst float MAX_DIST = 100.0;\\n\\n\\nstruct Material\\n{\\n    vec3 specular;\\n    vec3 diffuse;\\n    vec3 ambient;\\n    float smoothness;\\n};\\n\\nfloat map( in vec3 pos )\\n{\\n    return  length(p)-1.0;\\n}\\n\\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\\n    const float fov = 45.0;\\n\\n    vec2 xy = fragCoord - size / 2.0;\\n    float z = size.y / tan(radians(fov) / 2.0);\\n\\n    return normalize(vec3(xy, -z));\\n}\\n\\nvec3 normal(vec3 p) {\\n    return normalize(vec3(\\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\\n    ));\\n}\\n\\nvec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\\n    vec3 ambient = vec3(0.5);\\n\\n    vec3 lights_pos[2];\\n    lights_pos[0] = vec3(4.0, 2.0, 2.0);\\n    lights_pos[1] = vec3(-4.0, -2.0, -2.0);\\n\\n    vec3 lights_color[2];\\n    lights_color[0] = vec3(1.0, 1.0, 1.0);\\n    lights_color[1] = vec3(1.0, 1.0, 1.0);\\n\\n    vec3 Ip = mat.ambient * ambient;\\n\\n    for(int i=0; i<2; i++){\\n        vec3 Lm = normalize(lights_pos[i] - p);\\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\\n        vec3 V  = normalize(eye - p);\\n\\n        float LN = dot(Lm, n);\\n        float RV = dot(Rm, V);\\n\\n        if (LN < 0.0)   // Light not visible\\n            Ip += vec3(0.0, 0.0, 0.0);\\n        else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\\n            Ip += lights_color[i] * (mat.diffuse * LN);\\n        else\\n            Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\\n    }\\n\\n    return Ip;\\n}\\n\\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\\n    // Based on gluLookAt man page\\n    vec3 f = normalize(center - eye);\\n    vec3 s = normalize(cross(f, up));\\n    vec3 u = cross(s, f);\\n    return mat4(\\n        vec4(s, 0.0),\\n        vec4(u, 0.0),\\n        vec4(-f, 0.0),\\n        vec4(0.0, 0.0, 0.0, 1)\\n    );\\n}\\n\\nvoid main() {\\n    Material mat_red = Material(\\n        vec3(1.0, 1.0, 1.0),    // specular\\n        vec3(color.xyz),        // diffuse\\n        vec3(0.2),              // ambient\\n        10.0                    // shiness\\n    );\\n    vec3 eye                    = vec3(10.0*cos(iTime), 1.0, 10.0*sin(iTime));\\n    const vec3 backGroundColor  = vec3(0.7);\\n\\n    for( int m=0; m<AA; m++ ){\\n        for( int n=0; n<AA; n++ ){\\n            float depth = MIN_DIST;\\n\\n            // create view ray\\n            vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\\n            mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\\n            vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\\n\\n            // raytracing\\n            for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\\n                float dist = map(eye + depth * worldDir);\\n                if (dist < EPSILON) {\\n                    vec3 p = eye + depth * worldDir;\\n                    vec3 n = normal(p);\\n\\n                    gl_FragColor = vec4(lighting(p, n, eye, mat_red), 1.0);\\n                    return;\\n                }\\n\\n                depth += dist;\\n\\n                if (depth >= MAX_DIST) {\\n                    gl_FragColor = vec4(backGroundColor.xyz, 1.0);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n\";\n};","map":{"version":3,"names":["fs","sdf"],"sources":["C:/Users/daniz/TFG/Aplicacion/src/fragmentShader.js"],"sourcesContent":["export const fs = (sdf) => {\r\n  return `\r\n  // https://thebookofshaders.com/03/?lan=es\r\n// https://thebookofshaders.com/03/\r\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\r\n// https://www.shadertoy.com/view/llt3R4\r\n\r\n// camera\r\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\r\n// http://www.codinglabs.net/article_world_view_projection_matrix.aspx\r\n// https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\r\n// https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nconst int AA = 3;\r\nconst int MAX_MARCHING_STEPS = 255;\r\nconst float EPSILON = 0.0001;\r\nconst float MIN_DIST = 0.0;\r\nconst float MAX_DIST = 100.0;\r\n\r\n\r\nstruct Material\r\n{\r\n    vec3 specular;\r\n    vec3 diffuse;\r\n    vec3 ambient;\r\n    float smoothness;\r\n};\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    return  length(p)-1.0;\r\n}\r\n\r\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\r\n    const float fov = 45.0;\r\n\r\n    vec2 xy = fragCoord - size / 2.0;\r\n    float z = size.y / tan(radians(fov) / 2.0);\r\n\r\n    return normalize(vec3(xy, -z));\r\n}\r\n\r\nvec3 normal(vec3 p) {\r\n    return normalize(vec3(\r\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\r\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\r\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\r\n    ));\r\n}\r\n\r\nvec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\r\n    vec3 ambient = vec3(0.5);\r\n\r\n    vec3 lights_pos[2];\r\n    lights_pos[0] = vec3(4.0, 2.0, 2.0);\r\n    lights_pos[1] = vec3(-4.0, -2.0, -2.0);\r\n\r\n    vec3 lights_color[2];\r\n    lights_color[0] = vec3(1.0, 1.0, 1.0);\r\n    lights_color[1] = vec3(1.0, 1.0, 1.0);\r\n\r\n    vec3 Ip = mat.ambient * ambient;\r\n\r\n    for(int i=0; i<2; i++){\r\n        vec3 Lm = normalize(lights_pos[i] - p);\r\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\r\n        vec3 V  = normalize(eye - p);\r\n\r\n        float LN = dot(Lm, n);\r\n        float RV = dot(Rm, V);\r\n\r\n        if (LN < 0.0)   // Light not visible\r\n            Ip += vec3(0.0, 0.0, 0.0);\r\n        else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\r\n            Ip += lights_color[i] * (mat.diffuse * LN);\r\n        else\r\n            Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\r\n    }\r\n\r\n    return Ip;\r\n}\r\n\r\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\r\n    // Based on gluLookAt man page\r\n    vec3 f = normalize(center - eye);\r\n    vec3 s = normalize(cross(f, up));\r\n    vec3 u = cross(s, f);\r\n    return mat4(\r\n        vec4(s, 0.0),\r\n        vec4(u, 0.0),\r\n        vec4(-f, 0.0),\r\n        vec4(0.0, 0.0, 0.0, 1)\r\n    );\r\n}\r\n\r\nvoid main() {\r\n    Material mat_red = Material(\r\n        vec3(1.0, 1.0, 1.0),    // specular\r\n        vec3(color.xyz),        // diffuse\r\n        vec3(0.2),              // ambient\r\n        10.0                    // shiness\r\n    );\r\n    vec3 eye                    = vec3(10.0*cos(iTime), 1.0, 10.0*sin(iTime));\r\n    const vec3 backGroundColor  = vec3(0.7);\r\n\r\n    for( int m=0; m<AA; m++ ){\r\n        for( int n=0; n<AA; n++ ){\r\n            float depth = MIN_DIST;\r\n\r\n            // create view ray\r\n            vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\r\n            mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\r\n            vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\r\n\r\n            // raytracing\r\n            for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\r\n                float dist = map(eye + depth * worldDir);\r\n                if (dist < EPSILON) {\r\n                    vec3 p = eye + depth * worldDir;\r\n                    vec3 n = normal(p);\r\n\r\n                    gl_FragColor = vec4(lighting(p, n, eye, mat_red), 1.0);\r\n                    return;\r\n                }\r\n\r\n                depth += dist;\r\n\r\n                if (depth >= MAX_DIST) {\r\n                    gl_FragColor = vec4(backGroundColor.xyz, 1.0);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n`;\r\n};\r\n"],"mappings":"AAAA,OAAO,IAAMA,EAAE,GAAG,SAALA,EAAK,CAACC,GAAD,EAAS;EACzB;AA4ID,CA7IM"},"metadata":{},"sourceType":"module"}