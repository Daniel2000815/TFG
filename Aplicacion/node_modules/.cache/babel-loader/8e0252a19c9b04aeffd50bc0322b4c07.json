{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _toConsumableArray from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { deepStrictEqual } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nimport { createMap } from '../../utils/map.js';\nvar name = 'Node';\nvar dependencies = ['mathWithTransform'];\nexport var createNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var mathWithTransform = _ref.mathWithTransform;\n  /**\r\n   * Validate the symbol names of a scope.\r\n   * Throws an error when the scope contains an illegal symbol.\r\n   * @param {Object} scope\r\n   */\n\n  function _validateScope(scope) {\n    for (var _i = 0, _arr = _toConsumableArray(keywords); _i < _arr.length; _i++) {\n      var symbol = _arr[_i];\n\n      if (scope.has(symbol)) {\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\n      }\n    }\n  }\n\n  var Node = /*#__PURE__*/function () {\n    function Node() {\n      _classCallCheck(this, Node);\n    }\n\n    _createClass(Node, [{\n      key: \"type\",\n      get: function get() {\n        return 'Node';\n      }\n    }, {\n      key: \"isNode\",\n      get: function get() {\n        return true;\n      }\n      /**\r\n       * Evaluate the node\r\n       * @param {Object} [scope]  Scope to read/write variables\r\n       * @return {*}              Returns the result\r\n       */\n\n    }, {\n      key: \"evaluate\",\n      value: function evaluate(scope) {\n        return this.compile().evaluate(scope);\n      }\n      /**\r\n       * Compile the node into an optimized, evauatable JavaScript function\r\n       * @return {{evaluate: function([Object])}} object\r\n       *                Returns an object with a function 'evaluate',\r\n       *                which can be invoked as expr.evaluate([scope: Object]),\r\n       *                where scope is an optional object with\r\n       *                variables.\r\n       */\n\n    }, {\n      key: \"compile\",\n      value: function compile() {\n        var expr = this._compile(mathWithTransform, {});\n\n        var args = {};\n        var context = null;\n\n        function evaluate(scope) {\n          var s = createMap(scope);\n\n          _validateScope(s);\n\n          return expr(s, args, context);\n        }\n\n        return {\n          evaluate: evaluate\n        };\n      }\n      /**\r\n       * Compile a node into a JavaScript function.\r\n       * This basically pre-calculates as much as possible and only leaves open\r\n       * calculations which depend on a dynamic scope with variables.\r\n       * @param {Object} math     Math.js namespace with functions and constants.\r\n       * @param {Object} argNames An object with argument names as key and `true`\r\n       *                          as value. Used in the SymbolNode to optimize\r\n       *                          for arguments from user assigned functions\r\n       *                          (see FunctionAssignmentNode) or special symbols\r\n       *                          like `end` (see IndexNode).\r\n       * @return {function} Returns a function which can be called like:\r\n       *                        evalNode(scope: Object, args: Object, context: *)\r\n       */\n\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        throw new Error('Method _compile must be implemented by type ' + this.type);\n      }\n      /**\r\n       * Execute a callback for each of the child nodes of this node\r\n       * @param {function(child: Node, path: string, parent: Node)} callback\r\n       */\n\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot run forEach on a Node interface');\n      }\n      /**\r\n       * Create a new Node whose children are the results of calling the\r\n       * provided callback function for each child of the original node.\r\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n       * @returns {OperatorNode} Returns a transformed copy of the node\r\n       */\n\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot run map on a Node interface');\n      }\n      /**\r\n       * Validate whether an object is a Node, for use with map\r\n       * @param {Node} node\r\n       * @returns {Node} Returns the input if it's a node, else throws an Error\r\n       * @protected\r\n       */\n\n    }, {\n      key: \"_ifNode\",\n      value: function _ifNode(node) {\n        if (!isNode(node)) {\n          throw new TypeError('Callback function must return a Node');\n        }\n\n        return node;\n      }\n      /**\r\n       * Recursively traverse all nodes in a node tree. Executes given callback for\r\n       * this node and each of its child nodes.\r\n       * @param {function(node: Node, path: string, parent: Node)} callback\r\n       *          A callback called for every node in the node tree.\r\n       */\n\n    }, {\n      key: \"traverse\",\n      value: function traverse(callback) {\n        // execute callback for itself\n        // eslint-disable-next-line\n        callback(this, null, null); // recursively traverse over all children of a node\n\n        function _traverse(node, callback) {\n          node.forEach(function (child, path, parent) {\n            callback(child, path, parent);\n\n            _traverse(child, callback);\n          });\n        }\n\n        _traverse(this, callback);\n      }\n      /**\r\n       * Recursively transform a node tree via a transform function.\r\n       *\r\n       * For example, to replace all nodes of type SymbolNode having name 'x' with\r\n       * a ConstantNode with value 2:\r\n       *\r\n       *     const res = Node.transform(function (node, path, parent) {\r\n       *       if (node && node.isSymbolNode) && (node.name === 'x')) {\r\n       *         return new ConstantNode(2)\r\n       *       }\r\n       *       else {\r\n       *         return node\r\n       *       }\r\n       *     })\r\n       *\r\n       * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n       *          A mapping function accepting a node, and returning\r\n       *          a replacement for the node or the original node. The \"signature\"\r\n       *          of the callback must be:\r\n       *          callback(node: Node, index: string, parent: Node) : Node\r\n       * @return {Node} Returns the original node or its replacement\r\n       */\n\n    }, {\n      key: \"transform\",\n      value: function transform(callback) {\n        function _transform(child, path, parent) {\n          var replacement = callback(child, path, parent);\n\n          if (replacement !== child) {\n            // stop iterating when the node is replaced\n            return replacement;\n          }\n\n          return child.map(_transform);\n        }\n\n        return _transform(this, null, null);\n      }\n      /**\r\n       * Find any node in the node tree matching given filter function. For\r\n       * example, to find all nodes of type SymbolNode having name 'x':\r\n       *\r\n       *     const results = Node.filter(function (node) {\r\n       *       return (node && node.isSymbolNode) && (node.name === 'x')\r\n       *     })\r\n       *\r\n       * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n       *            A test function returning true when a node matches, and false\r\n       *            otherwise. Function signature:\r\n       *            callback(node: Node, index: string, parent: Node) : boolean\r\n       * @return {Node[]} nodes\r\n       *            An array with nodes matching given filter criteria\r\n       */\n\n    }, {\n      key: \"filter\",\n      value: function filter(callback) {\n        var nodes = [];\n        this.traverse(function (node, path, parent) {\n          if (callback(node, path, parent)) {\n            nodes.push(node);\n          }\n        });\n        return nodes;\n      }\n      /**\r\n       * Create a shallow clone of this node\r\n       * @return {Node}\r\n       */\n\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        // must be implemented by each of the Node implementations\n        throw new Error('Cannot clone a Node interface');\n      }\n      /**\r\n       * Create a deep clone of this node\r\n       * @return {Node}\r\n       */\n\n    }, {\n      key: \"cloneDeep\",\n      value: function cloneDeep() {\n        return this.map(function (node) {\n          return node.cloneDeep();\n        });\n      }\n      /**\r\n       * Deep compare this node with another node.\r\n       * @param {Node} other\r\n       * @return {boolean} Returns true when both nodes are of the same type and\r\n       *                   contain the same values (as do their childs)\r\n       */\n\n    }, {\n      key: \"equals\",\n      value: function equals(other) {\n        return other ? this.type === other.type && deepStrictEqual(this, other) : false;\n      }\n      /**\r\n       * Get string representation. (wrapper function)\r\n       *\r\n       * This function can get an object of the following form:\r\n       * {\r\n       *    handler: //This can be a callback function of the form\r\n       *             // \"function callback(node, options)\"or\r\n       *             // a map that maps function names (used in FunctionNodes)\r\n       *             // to callbacks\r\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n       * }\r\n       *\r\n       * @param {Object} [options]\r\n       * @return {string}\r\n       */\n\n    }, {\n      key: \"toString\",\n      value: function toString(options) {\n        var customString = this._getCustomString(options);\n\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n\n        return this._toString(options);\n      }\n      /**\r\n       * Get a JSON representation of the node\r\n       * Both .toJSON() and the static .fromJSON(json) should be implemented by all\r\n       * implementations of Node\r\n       * @returns {Object}\r\n       */\n\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\n      }\n      /**\r\n       * Get HTML representation. (wrapper function)\r\n       *\r\n       * This function can get an object of the following form:\r\n       * {\r\n       *    handler: //This can be a callback function of the form\r\n       *             // \"function callback(node, options)\" or\r\n       *             // a map that maps function names (used in FunctionNodes)\r\n       *             // to callbacks\r\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n       * }\r\n       *\r\n       * @param {Object} [options]\r\n       * @return {string}\r\n       */\n\n    }, {\n      key: \"toHTML\",\n      value: function toHTML(options) {\n        var customString = this._getCustomString(options);\n\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n\n        return this.toHTML(options);\n      }\n      /**\r\n       * Internal function to generate the string output.\r\n       * This has to be implemented by every Node\r\n       *\r\n       * @throws {Error}\r\n       */\n\n    }, {\n      key: \"_toString\",\n      value: function _toString() {\n        // must be implemented by each of the Node implementations\n        throw new Error('_toString not implemented for ' + this.type);\n      }\n      /**\r\n       * Get LaTeX representation. (wrapper function)\r\n       *\r\n       * This function can get an object of the following form:\r\n       * {\r\n       *    handler: //This can be a callback function of the form\r\n       *             // \"function callback(node, options)\"or\r\n       *             // a map that maps function names (used in FunctionNodes)\r\n       *             // to callbacks\r\n       *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n       * }\r\n       *\r\n       * @param {Object} [options]\r\n       * @return {string}\r\n       */\n\n    }, {\n      key: \"toTex\",\n      value: function toTex(options) {\n        var customString = this._getCustomString(options);\n\n        if (typeof customString !== 'undefined') {\n          return customString;\n        }\n\n        return this._toTex(options);\n      }\n      /**\r\n       * Internal function to generate the LaTeX output.\r\n       * This has to be implemented by every Node\r\n       *\r\n       * @param {Object} [options]\r\n       * @throws {Error}\r\n       */\n\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        // must be implemented by each of the Node implementations\n        throw new Error('_toTex not implemented for ' + this.type);\n      }\n      /**\r\n       * Helper used by `to...` functions.\r\n       */\n\n    }, {\n      key: \"_getCustomString\",\n      value: function _getCustomString(options) {\n        if (options && typeof options === 'object') {\n          switch (typeof options.handler) {\n            case 'object':\n            case 'undefined':\n              return;\n\n            case 'function':\n              return options.handler(this, options);\n\n            default:\n              throw new TypeError('Object or function expected as callback');\n          }\n        }\n      }\n      /**\r\n       * Get identifier.\r\n       * @return {string}\r\n       */\n\n    }, {\n      key: \"getIdentifier\",\n      value: function getIdentifier() {\n        return this.type;\n      }\n      /**\r\n       * Get the content of the current Node.\r\n       * @return {Node} node\r\n       **/\n\n    }, {\n      key: \"getContent\",\n      value: function getContent() {\n        return this;\n      }\n    }]);\n\n    return Node;\n  }();\n\n  return Node;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["isNode","keywords","deepStrictEqual","factory","createMap","name","dependencies","createNode","_ref","mathWithTransform","_validateScope","scope","symbol","has","Error","Node","compile","evaluate","expr","_compile","args","context","s","math","argNames","type","callback","node","TypeError","_traverse","forEach","child","path","parent","_transform","replacement","map","nodes","traverse","push","cloneDeep","other","options","customString","_getCustomString","_toString","toHTML","_toTex","handler","isClass"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/mathjs/lib/esm/expression/node/Node.js"],"sourcesContent":["import { isNode } from '../../utils/is.js';\r\nimport { keywords } from '../keywords.js';\r\nimport { deepStrictEqual } from '../../utils/object.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { createMap } from '../../utils/map.js';\r\nvar name = 'Node';\r\nvar dependencies = ['mathWithTransform'];\r\nexport var createNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    mathWithTransform\r\n  } = _ref;\r\n\r\n  /**\r\n   * Validate the symbol names of a scope.\r\n   * Throws an error when the scope contains an illegal symbol.\r\n   * @param {Object} scope\r\n   */\r\n  function _validateScope(scope) {\r\n    for (var symbol of [...keywords]) {\r\n      if (scope.has(symbol)) {\r\n        throw new Error('Scope contains an illegal symbol, \"' + symbol + '\" is a reserved keyword');\r\n      }\r\n    }\r\n  }\r\n\r\n  class Node {\r\n    get type() {\r\n      return 'Node';\r\n    }\r\n\r\n    get isNode() {\r\n      return true;\r\n    }\r\n    /**\r\n     * Evaluate the node\r\n     * @param {Object} [scope]  Scope to read/write variables\r\n     * @return {*}              Returns the result\r\n     */\r\n\r\n\r\n    evaluate(scope) {\r\n      return this.compile().evaluate(scope);\r\n    }\r\n    /**\r\n     * Compile the node into an optimized, evauatable JavaScript function\r\n     * @return {{evaluate: function([Object])}} object\r\n     *                Returns an object with a function 'evaluate',\r\n     *                which can be invoked as expr.evaluate([scope: Object]),\r\n     *                where scope is an optional object with\r\n     *                variables.\r\n     */\r\n\r\n\r\n    compile() {\r\n      var expr = this._compile(mathWithTransform, {});\r\n\r\n      var args = {};\r\n      var context = null;\r\n\r\n      function evaluate(scope) {\r\n        var s = createMap(scope);\r\n\r\n        _validateScope(s);\r\n\r\n        return expr(s, args, context);\r\n      }\r\n\r\n      return {\r\n        evaluate\r\n      };\r\n    }\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n\r\n\r\n    _compile(math, argNames) {\r\n      throw new Error('Method _compile must be implemented by type ' + this.type);\r\n    }\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n\r\n\r\n    forEach(callback) {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('Cannot run forEach on a Node interface');\r\n    }\r\n    /**\r\n     * Create a new Node whose children are the results of calling the\r\n     * provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {OperatorNode} Returns a transformed copy of the node\r\n     */\r\n\r\n\r\n    map(callback) {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('Cannot run map on a Node interface');\r\n    }\r\n    /**\r\n     * Validate whether an object is a Node, for use with map\r\n     * @param {Node} node\r\n     * @returns {Node} Returns the input if it's a node, else throws an Error\r\n     * @protected\r\n     */\r\n\r\n\r\n    _ifNode(node) {\r\n      if (!isNode(node)) {\r\n        throw new TypeError('Callback function must return a Node');\r\n      }\r\n\r\n      return node;\r\n    }\r\n    /**\r\n     * Recursively traverse all nodes in a node tree. Executes given callback for\r\n     * this node and each of its child nodes.\r\n     * @param {function(node: Node, path: string, parent: Node)} callback\r\n     *          A callback called for every node in the node tree.\r\n     */\r\n\r\n\r\n    traverse(callback) {\r\n      // execute callback for itself\r\n      // eslint-disable-next-line\r\n      callback(this, null, null); // recursively traverse over all children of a node\r\n\r\n      function _traverse(node, callback) {\r\n        node.forEach(function (child, path, parent) {\r\n          callback(child, path, parent);\r\n\r\n          _traverse(child, callback);\r\n        });\r\n      }\r\n\r\n      _traverse(this, callback);\r\n    }\r\n    /**\r\n     * Recursively transform a node tree via a transform function.\r\n     *\r\n     * For example, to replace all nodes of type SymbolNode having name 'x' with\r\n     * a ConstantNode with value 2:\r\n     *\r\n     *     const res = Node.transform(function (node, path, parent) {\r\n     *       if (node && node.isSymbolNode) && (node.name === 'x')) {\r\n     *         return new ConstantNode(2)\r\n     *       }\r\n     *       else {\r\n     *         return node\r\n     *       }\r\n     *     })\r\n     *\r\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n     *          A mapping function accepting a node, and returning\r\n     *          a replacement for the node or the original node. The \"signature\"\r\n     *          of the callback must be:\r\n     *          callback(node: Node, index: string, parent: Node) : Node\r\n     * @return {Node} Returns the original node or its replacement\r\n     */\r\n\r\n\r\n    transform(callback) {\r\n      function _transform(child, path, parent) {\r\n        var replacement = callback(child, path, parent);\r\n\r\n        if (replacement !== child) {\r\n          // stop iterating when the node is replaced\r\n          return replacement;\r\n        }\r\n\r\n        return child.map(_transform);\r\n      }\r\n\r\n      return _transform(this, null, null);\r\n    }\r\n    /**\r\n     * Find any node in the node tree matching given filter function. For\r\n     * example, to find all nodes of type SymbolNode having name 'x':\r\n     *\r\n     *     const results = Node.filter(function (node) {\r\n     *       return (node && node.isSymbolNode) && (node.name === 'x')\r\n     *     })\r\n     *\r\n     * @param {function(node: Node, path: string, parent: Node) : Node} callback\r\n     *            A test function returning true when a node matches, and false\r\n     *            otherwise. Function signature:\r\n     *            callback(node: Node, index: string, parent: Node) : boolean\r\n     * @return {Node[]} nodes\r\n     *            An array with nodes matching given filter criteria\r\n     */\r\n\r\n\r\n    filter(callback) {\r\n      var nodes = [];\r\n      this.traverse(function (node, path, parent) {\r\n        if (callback(node, path, parent)) {\r\n          nodes.push(node);\r\n        }\r\n      });\r\n      return nodes;\r\n    }\r\n    /**\r\n     * Create a shallow clone of this node\r\n     * @return {Node}\r\n     */\r\n\r\n\r\n    clone() {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('Cannot clone a Node interface');\r\n    }\r\n    /**\r\n     * Create a deep clone of this node\r\n     * @return {Node}\r\n     */\r\n\r\n\r\n    cloneDeep() {\r\n      return this.map(function (node) {\r\n        return node.cloneDeep();\r\n      });\r\n    }\r\n    /**\r\n     * Deep compare this node with another node.\r\n     * @param {Node} other\r\n     * @return {boolean} Returns true when both nodes are of the same type and\r\n     *                   contain the same values (as do their childs)\r\n     */\r\n\r\n\r\n    equals(other) {\r\n      return other ? this.type === other.type && deepStrictEqual(this, other) : false;\r\n    }\r\n    /**\r\n     * Get string representation. (wrapper function)\r\n     *\r\n     * This function can get an object of the following form:\r\n     * {\r\n     *    handler: //This can be a callback function of the form\r\n     *             // \"function callback(node, options)\"or\r\n     *             // a map that maps function names (used in FunctionNodes)\r\n     *             // to callbacks\r\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n     * }\r\n     *\r\n     * @param {Object} [options]\r\n     * @return {string}\r\n     */\r\n\r\n\r\n    toString(options) {\r\n      var customString = this._getCustomString(options);\r\n\r\n      if (typeof customString !== 'undefined') {\r\n        return customString;\r\n      }\r\n\r\n      return this._toString(options);\r\n    }\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * Both .toJSON() and the static .fromJSON(json) should be implemented by all\r\n     * implementations of Node\r\n     * @returns {Object}\r\n     */\r\n\r\n\r\n    toJSON() {\r\n      throw new Error('Cannot serialize object: toJSON not implemented by ' + this.type);\r\n    }\r\n    /**\r\n     * Get HTML representation. (wrapper function)\r\n     *\r\n     * This function can get an object of the following form:\r\n     * {\r\n     *    handler: //This can be a callback function of the form\r\n     *             // \"function callback(node, options)\" or\r\n     *             // a map that maps function names (used in FunctionNodes)\r\n     *             // to callbacks\r\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n     * }\r\n     *\r\n     * @param {Object} [options]\r\n     * @return {string}\r\n     */\r\n\r\n\r\n    toHTML(options) {\r\n      var customString = this._getCustomString(options);\r\n\r\n      if (typeof customString !== 'undefined') {\r\n        return customString;\r\n      }\r\n\r\n      return this.toHTML(options);\r\n    }\r\n    /**\r\n     * Internal function to generate the string output.\r\n     * This has to be implemented by every Node\r\n     *\r\n     * @throws {Error}\r\n     */\r\n\r\n\r\n    _toString() {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('_toString not implemented for ' + this.type);\r\n    }\r\n    /**\r\n     * Get LaTeX representation. (wrapper function)\r\n     *\r\n     * This function can get an object of the following form:\r\n     * {\r\n     *    handler: //This can be a callback function of the form\r\n     *             // \"function callback(node, options)\"or\r\n     *             // a map that maps function names (used in FunctionNodes)\r\n     *             // to callbacks\r\n     *    parenthesis: \"keep\" //the parenthesis option (This is optional)\r\n     * }\r\n     *\r\n     * @param {Object} [options]\r\n     * @return {string}\r\n     */\r\n\r\n\r\n    toTex(options) {\r\n      var customString = this._getCustomString(options);\r\n\r\n      if (typeof customString !== 'undefined') {\r\n        return customString;\r\n      }\r\n\r\n      return this._toTex(options);\r\n    }\r\n    /**\r\n     * Internal function to generate the LaTeX output.\r\n     * This has to be implemented by every Node\r\n     *\r\n     * @param {Object} [options]\r\n     * @throws {Error}\r\n     */\r\n\r\n\r\n    _toTex(options) {\r\n      // must be implemented by each of the Node implementations\r\n      throw new Error('_toTex not implemented for ' + this.type);\r\n    }\r\n    /**\r\n     * Helper used by `to...` functions.\r\n     */\r\n\r\n\r\n    _getCustomString(options) {\r\n      if (options && typeof options === 'object') {\r\n        switch (typeof options.handler) {\r\n          case 'object':\r\n          case 'undefined':\r\n            return;\r\n\r\n          case 'function':\r\n            return options.handler(this, options);\r\n\r\n          default:\r\n            throw new TypeError('Object or function expected as callback');\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Get identifier.\r\n     * @return {string}\r\n     */\r\n\r\n\r\n    getIdentifier() {\r\n      return this.type;\r\n    }\r\n    /**\r\n     * Get the content of the current Node.\r\n     * @return {Node} node\r\n     **/\r\n\r\n\r\n    getContent() {\r\n      return this;\r\n    }\r\n\r\n  }\r\n\r\n  return Node;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}