{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.expandall = exports.expand = void 0;\nvar Utils_1 = require(\"../../../Core/Utils\");\nvar Symbol_1 = require(\"../../../Types/Symbol\");\nvar Groups_1 = require(\"../../../Types/Groups\");\nvar index_1 = require(\"../index\");\nvar Parser_1 = require(\"../../../Parser/Parser\");\n/**\n * Expands a symbol\n * @param symbol\n */\n// Old expand\nfunction expand(symbol) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  if (Array.isArray(symbol)) {\n    return symbol.map(function (x) {\n      return expand(x, opt);\n    });\n  }\n  opt = opt || {};\n  //deal with parenthesis\n  if (symbol.group === Groups_1.Groups.FN && symbol.fname === '') {\n    var f = expand(symbol.args[0], opt);\n    var x = expand((0, index_1.pow)(f, (0, Parser_1.parse)(symbol.power)), opt);\n    return (0, index_1.multiply)((0, Parser_1.parse)(symbol.multiplier), x).distributeMultiplier();\n  }\n  // We can expand these groups so no need to waste time. Just return and be done.\n  if ([Groups_1.Groups.N, Groups_1.Groups.P, Groups_1.Groups.S].indexOf(symbol.group) !== -1) {\n    return symbol; //nothing to do\n  }\n\n  var original = symbol.clone();\n  // Set up a try-catch block. If anything goes wrong then we simply return the original symbol\n  try {\n    // Store the power and multiplier\n    var m = symbol.multiplier.toString();\n    var p = Number(symbol.power);\n    var retval = symbol;\n    // Handle (a+b)^2 | (x+x^2)^2\n    if (symbol.isComposite() && (0, Utils_1.isInt)(symbol.power) && symbol.power > 0) {\n      var n = p - 1;\n      // Strip the expression of it's multiplier and power. We'll call it f. The power will be p and the multiplier m.\n      var f = new Symbol_1.Symbol(0);\n      symbol.each(function (x) {\n        f = (0, index_1.add)(f, expand((0, Parser_1.parse)(x), opt));\n      });\n      var expanded = (0, Parser_1.parse)(f);\n      for (var i = 0; i < n; i++) {\n        expanded = mix(expanded, f, opt);\n      }\n      retval = (0, index_1.multiply)((0, Parser_1.parse)(m), expanded).distributeMultiplier();\n    } else if (symbol.group === Groups_1.Groups.FN && opt.expand_functions === true) {\n      var args = [];\n      // Expand function the arguments\n      symbol.args.forEach(function (x) {\n        args.push(expand(x, opt));\n      });\n      // Put back the power and multiplier\n      retval = (0, index_1.pow)((0, Symbol_1.symfunction)(symbol.fname, args), (0, Parser_1.parse)(symbol.power));\n      retval = (0, index_1.multiply)(retval, (0, Parser_1.parse)(symbol.multiplier));\n    } else if (symbol.isComposite() && (0, Utils_1.isInt)(symbol.power) && symbol.power < 0 && opt.expand_denominator === true) {\n      // Invert it. Expand it and then re-invert it.\n      symbol = symbol.invert();\n      retval = expand(symbol, opt);\n      retval.invert();\n    } else if (symbol.group === Groups_1.Groups.CB) {\n      var rank = function rank(s) {\n        switch (s.group) {\n          case Groups_1.Groups.CP:\n            return 0;\n          case Groups_1.Groups.PL:\n            return 1;\n          case Groups_1.Groups.CB:\n            return 2;\n          case Groups_1.Groups.FN:\n            return 3;\n          default:\n            return 4;\n        }\n      };\n      // Consider (a+b)(c+d). The result will be (a*c+a*d)+(b*c+b*d).\n      // We start by moving collecting the symbols. We want others>FN>CB>PL>CP\n      var symbols = symbol.collectSymbols().sort(function (a, b) {\n        return rank(b) - rank(a);\n      })\n      // Distribute the power to each symbol and expand\n      .map(function (s) {\n        var x = (0, index_1.pow)(s, (0, Parser_1.parse)(p));\n        var e = expand(x, opt);\n        return e;\n      });\n      var f = symbols.pop();\n      // If the first symbols isn't a composite then we're done\n      if (f.isComposite() && f.isLinear()) {\n        symbols.forEach(function (s) {\n          f = mix(f, s, opt);\n        });\n        // If f is of group PL or CP then we can expand some more\n        if (f.isComposite()) {\n          if (f.power > 1) {\n            f = expand((0, index_1.pow)(f, (0, Parser_1.parse)(f.power)), opt);\n          }\n          // Put back the multiplier\n          retval = (0, index_1.multiply)((0, Parser_1.parse)(m), f).distributeMultiplier();\n        } else {\n          // Everything is expanded at this point so if it's still a CB\n          // then just return the symbol\n          retval = f;\n        }\n      } else {\n        // Just multiply back in the expanded form of each\n        retval = f;\n        symbols.forEach(function (s) {\n          retval = (0, index_1.multiply)(retval, s);\n        });\n        // Put back the multiplier\n        retval = (0, index_1.multiply)(retval, (0, Parser_1.parse)(m)).distributeMultiplier();\n      }\n      // TODO: This exists solely as a quick fix for sqrt(11)*sqrt(33) not simplifying.\n      if (retval.group === Groups_1.Groups.CB) {\n        retval = (0, Parser_1.parse)(retval);\n      }\n    } else {\n      // Otherwise just return the expression\n      retval = symbol;\n    }\n    // Final cleanup and return\n    return retval;\n  } catch (e) {\n    return original;\n  }\n}\nexports.expand = expand;\n/**\n * A wrapper for the expand function\n * @param {Symbol} symbol\n * @returns {Symbol}\n */\nfunction expandall(symbol, opt) {\n  opt = opt || {\n    expand_denominator: true,\n    expand_functions: true\n  };\n  return expand(symbol, opt);\n}\nexports.expandall = expandall;\n/**\n * Used to multiply two expression in expanded form\n * @param {Symbol} a\n * @param {Symbol} b\n */\nfunction mix(a, b, opt) {\n  // Flip them if b is a CP or PL and a is not\n  if (b.isComposite() && !a.isComposite() || b.isLinear() && !a.isLinear()) {\n    var _ref = [b, a];\n    a = _ref[0];\n    b = _ref[1];\n  }\n  // A temporary variable to hold the expanded terms\n  var t = new Symbol_1.Symbol(0);\n  if (a.isLinear()) {\n    a.each(function (x) {\n      // If b is not a PL or a CP then simply multiply it\n      if (!b.isComposite()) {\n        var term = (0, index_1.multiply)((0, Parser_1.parse)(x), (0, Parser_1.parse)(b));\n        t = (0, index_1.add)(t, expand(term, opt));\n      }\n      // Otherwise multiply out each term.\n      else if (b.isLinear()) {\n        b.each(function (y) {\n          var term = (0, index_1.multiply)((0, Parser_1.parse)(x), (0, Parser_1.parse)(y));\n          var expanded = expand((0, Parser_1.parse)(term), opt);\n          t = (0, index_1.add)(t, expanded);\n        }, true);\n      } else {\n        t = (0, index_1.add)(t, (0, index_1.multiply)(x, (0, Parser_1.parse)(b)));\n      }\n    }, true);\n  } else {\n    // Just multiply them together\n    t = (0, index_1.multiply)(a, b);\n  }\n  // The expanded function is now t\n  return t;\n}","map":{"version":3,"mappings":"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","names":["expand","symbol","opt","undefined","Array","isArray","map","x","group","Groups_1","FN","fname","f","args","power","multiplier","distributeMultiplier","N","P","S","indexOf","original","clone","m","toString","p","Number","retval","isComposite","n","Symbol_1","each","expanded","i","mix","expand_functions","forEach","push","expand_denominator","invert","CB","rank","s","CP","PL","symbols","collectSymbols","sort","a","b","e","pop","isLinear","exports","expandall","t","term","y"],"sourceRoot":"","sources":["../../../../src/Functions/Core/math/expand.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}