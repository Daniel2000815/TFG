{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport Node from \"./Node\";\nimport Token from \"./Token\";\nimport arities from \"./util/arities\";\nimport { fact } from \"./util/localFunctions\"; // Parser\n// ======\n// The parser takes a list of Token objects and tries to construct a syntax\n// tree that represents the math to be evaluated, taking into account the\n// correct order of operations.\n// This is a simple recursive-descent parser based on [Wikipedia's example](https://en.wikipedia.org/wiki/Recursive_descent_parser).\n\nexport default function parser(tokens) {\n  var p = new Parser(tokens);\n  return p.parse();\n}\n;\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser() {\n    var tokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, Parser);\n\n    this.cursor = 0;\n    this.tokens = tokens;\n  }\n\n  _createClass(Parser, [{\n    key: \"currentToken\",\n    get: function get() {\n      return this.tokens[this.cursor];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.cursor - 1];\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      //this.preprocess();\n      var ast = this.sum();\n      ast = ast.simplify(); // Throw an exception if there are still tokens remaining after parsing\n\n      if (this.currentToken !== undefined) {\n        console.log(ast.printTree());\n        throw \"Parsing error: Expected end of input, but got \" + this.currentToken.type + \" \" + this.currentToken.value;\n      }\n\n      return ast;\n    } //preprocess() {\n    // This function used to contain procedures to remove whitespace\n    // tokens and replace symbol tokens with functions, but that work\n    // has been moved to the lexer in order to keep the parser more\n    // lightweight.\n    //}\n\n    /**\n     * Accepts the current token if it matches the given type.\n     * If it does, the cursor is incremented and this method returns true.\n     * If it doesn't, the cursor stays where it is and this method returns false.\n     * @param type Type of token to accept.\n     * @returns {boolean} True if the token was accepted.\n     */\n\n  }, {\n    key: \"accept\",\n    value: function accept(type) {\n      if (this.currentToken && this.currentToken.type === type) {\n        this.cursor++;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Accepts the current token if it matches the given type.\n     * If it does, the cursor is incremented.\n     * If it doesn't, an exception is raised.\n     * @param type\n     */\n\n  }, {\n    key: \"expect\",\n    value: function expect(type) {\n      if (!this.accept(type)) {\n        throw \"Expected \" + type + \" but got \" + (this.currentToken ? this.currentToken.toString() : \"end of input.\");\n      }\n    } // Rules\n    // -----\n\n    /**\n     * Parses a math expression with\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum() {\n      var node = new Node(Node.TYPE_SUM);\n      node.addChild(this.product());\n\n      while (true) {\n        // Continue to accept chained addends\n        if (this.accept(Token.TYPE_PLUS)) {\n          node.addChild(this.product());\n        } else if (this.accept(Token.TYPE_MINUS)) {\n          node.addChild(new Node(Node.TYPE_NEGATE).addChild(this.product()));\n        } else {\n          break;\n        }\n      }\n\n      return node;\n    }\n  }, {\n    key: \"product\",\n    value: function product() {\n      var node = new Node(Node.TYPE_PRODUCT);\n      node.addChild(this.power());\n\n      while (true) {\n        // Continue to accept chained multiplicands\n        if (this.accept(Token.TYPE_TIMES)) {\n          node.addChild(this.power());\n        } else if (this.accept(Token.TYPE_DIVIDE)) {\n          node.addChild(new Node(Node.TYPE_INVERSE).addChild(this.power()));\n        } else if (this.accept(Token.TYPE_LPAREN)) {\n          this.cursor--;\n          node.addChild(this.power());\n        } else if (this.accept(Token.TYPE_SYMBOL) || this.accept(Token.TYPE_NUMBER) || this.accept(Token.TYPE_FUNCTION)) {\n          this.cursor--;\n          node.addChild(this.power());\n        } else {\n          break;\n        }\n      }\n\n      return node;\n    }\n  }, {\n    key: \"power\",\n    value: function power() {\n      var node = new Node(Node.TYPE_POWER);\n      node.addChild(this.val()); // If a chained power is encountered (e.g. a ^ b ^ c), treat it like\n      // a ^ (b ^ c)\n\n      if (this.accept(Token.TYPE_POWER)) {\n        node.addChild(this.power());\n      }\n\n      return node;\n    }\n  }, {\n    key: \"val\",\n    value: function val() {\n      // Don't create a new node immediately, since we need to parse postfix\n      // operators like factorials, which come after a value.\n      var node = {};\n\n      if (this.accept(Token.TYPE_SYMBOL)) {\n        node = new Node(Node.TYPE_SYMBOL, this.prevToken.value);\n      } else if (this.accept(Token.TYPE_NUMBER)) {\n        node = new Node(Node.TYPE_NUMBER, parseFloat(this.prevToken.value));\n      } else if (this.accept(Token.TYPE_COMMAND)) {\n        var cmdToken = this.prevToken;\n        node = new Node(Node.TYPE_FUNCTION, cmdToken.value);\n        node.name = cmdToken.name;\n\n        for (var i = 0; i < arities[cmdToken.name]; i++) {\n          node.addChild(this.val());\n        }\n      } else if (this.accept(Token.TYPE_FUNCTION)) {\n        node = new Node(Node.TYPE_FUNCTION, this.prevToken.value);\n        node.name = this.prevToken.name; // Multi-param functions require parens and have commas\n\n        if (this.accept(Token.TYPE_LPAREN)) {\n          node.addChild(this.sum());\n\n          while (this.accept(Token.TYPE_COMMA)) {\n            node.addChild(this.sum());\n          }\n\n          this.expect(Token.TYPE_RPAREN);\n        } // Single-parameter functions don't need parens\n        else {\n          node.addChild(this.power());\n        }\n      } else if (this.accept(Token.TYPE_MINUS)) {\n        node = new Node(Node.TYPE_NEGATE).addChild(this.power());\n      } else if (this.accept(Token.TYPE_LPAREN)) {\n        node = this.sum();\n        this.expect(Token.TYPE_RPAREN);\n      } else if (this.accept(Token.TYPE_ABS)) {\n        node = new Node(Node.TYPE_FUNCTION, Math.abs);\n        node.addChild(this.sum());\n        this.expect(Token.TYPE_ABS);\n      } else {\n        throw \"Unexpected \" + this.currentToken.toString() + \" at token \" + this.cursor;\n      }\n\n      if (this.accept(Token.TYPE_BANG)) {\n        var factNode = new Node(Node.TYPE_FUNCTION, fact);\n        factNode.addChild(node);\n        return factNode;\n      }\n\n      return node;\n    }\n  }]);\n\n  return Parser;\n}();\n/*\n// Non-terminal rules\n// ------------------\n\n// The following parser functions match certain motifs that are called\n// \"non-terminals\" in parsing lingo.\n// Essentially, they implement a sort of finite state automaton.\n// You should read the [Wikipedia article](https://en.wikipedia.org/wiki/Recursive_descent_parser) on recursive-descent parsing if you want to know more about how these work.\n\n// ### Grammar:\n// ```\n// orderExpression : sum\n// sum : product { ('+'|'-') product }\n// product : power { ('*'|'/') power }\n//         | power '(' orderExpression ')'\n// power : TODO power\n// val : SYMBOL\n//     | NUMBER\n//     | FUNCTION '(' orderExpression { ',' orderExpression } ')'\n//     | '-' val\n//     | '(' orderExpression ')'\n//     | '{' orderExpression '}'\n//     | '|' orderExpression '|'\n//     | val '!'\n// ```\n*/\n// Parses values or nested expressions.\n//Parser.prototype.val = function() {\n// Don't return new nodes immediately, since we need to parse\n// factorials, which come at the END of values.\n//var node = {};\n// Parse negative values like -42.\n// The lexer can't differentiate between a difference and a negative,\n// so that distinction is done here.\n// Notice the `power()` rule that comes after a negative sign so that\n// expressions like `-4^2` return -16 instead of 16.\n// Parse nested expression with parentheses.\n// Notice that the parser expects an RPAREN token after the expression.\n// Parse absolute value.\n// Absolute values are contained in pipes (`|`) and are treated quite\n// like parens.\n// All parsing rules should have terminated or recursed by now.\n// Throw an exception if this is not the case.\n// Process postfix operations like factorials.\n// Parse factorial.\n//return node;\n//};","map":{"version":3,"names":["Node","Token","arities","fact","parser","tokens","p","Parser","parse","cursor","ast","sum","simplify","currentToken","undefined","console","log","printTree","type","value","accept","toString","node","TYPE_SUM","addChild","product","TYPE_PLUS","TYPE_MINUS","TYPE_NEGATE","TYPE_PRODUCT","power","TYPE_TIMES","TYPE_DIVIDE","TYPE_INVERSE","TYPE_LPAREN","TYPE_SYMBOL","TYPE_NUMBER","TYPE_FUNCTION","TYPE_POWER","val","prevToken","parseFloat","TYPE_COMMAND","cmdToken","name","i","TYPE_COMMA","expect","TYPE_RPAREN","TYPE_ABS","Math","abs","TYPE_BANG","factNode"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/evaluatex/src/parser.js"],"sourcesContent":["import Node from \"./Node\";\nimport Token from \"./Token\";\nimport arities from \"./util/arities\";\nimport { fact } from \"./util/localFunctions\";\n\n// Parser\n// ======\n\n// The parser takes a list of Token objects and tries to construct a syntax\n// tree that represents the math to be evaluated, taking into account the\n// correct order of operations.\n// This is a simple recursive-descent parser based on [Wikipedia's example](https://en.wikipedia.org/wiki/Recursive_descent_parser).\n\nexport default function parser(tokens) {\n    let p = new Parser(tokens);\n    return p.parse();\n};\n\nclass Parser {\n    constructor(tokens = []) {\n        this.cursor = 0;\n        this.tokens = tokens;\n    }\n\n    get currentToken() {\n        return this.tokens[this.cursor];\n    }\n\n    get prevToken() {\n        return this.tokens[this.cursor - 1];\n    }\n\n    parse() {\n        //this.preprocess();\n        let ast = this.sum();\n        ast = ast.simplify();\n\n        // Throw an exception if there are still tokens remaining after parsing\n        if (this.currentToken !== undefined) {\n            console.log(ast.printTree());\n            throw \"Parsing error: Expected end of input, but got \" + this.currentToken.type +\n            \" \" + this.currentToken.value;\n        }\n\n        return ast;\n    }\n\n    //preprocess() {\n    // This function used to contain procedures to remove whitespace\n    // tokens and replace symbol tokens with functions, but that work\n    // has been moved to the lexer in order to keep the parser more\n    // lightweight.\n    //}\n\n    /**\n     * Accepts the current token if it matches the given type.\n     * If it does, the cursor is incremented and this method returns true.\n     * If it doesn't, the cursor stays where it is and this method returns false.\n     * @param type Type of token to accept.\n     * @returns {boolean} True if the token was accepted.\n     */\n    accept(type) {\n        if (this.currentToken && this.currentToken.type === type) {\n            this.cursor++;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Accepts the current token if it matches the given type.\n     * If it does, the cursor is incremented.\n     * If it doesn't, an exception is raised.\n     * @param type\n     */\n    expect(type) {\n        if (!this.accept(type)) {\n            throw \"Expected \" + type + \" but got \" +\n            (this.currentToken ? this.currentToken.toString() : \"end of input.\");\n        }\n    }\n\n    // Rules\n    // -----\n\n    /**\n     * Parses a math expression with\n     */\n    sum() {\n        let node = new Node(Node.TYPE_SUM);\n        node.addChild(this.product());\n\n        while (true) {\n            // Continue to accept chained addends\n            if (this.accept(Token.TYPE_PLUS)) {\n                node.addChild(this.product());\n            }\n            else if (this.accept(Token.TYPE_MINUS)) {\n                node.addChild(new Node(Node.TYPE_NEGATE).addChild(this.product()));\n            }\n            else {\n                break;\n            }\n        }\n\n        return node;\n    }\n\n    product() {\n        let node = new Node(Node.TYPE_PRODUCT);\n        node.addChild(this.power());\n\n        while (true) {\n            // Continue to accept chained multiplicands\n\n            if (this.accept(Token.TYPE_TIMES)) {\n                node.addChild(this.power());\n            }\n            else if (this.accept(Token.TYPE_DIVIDE)) {\n                node.addChild(new Node(Node.TYPE_INVERSE).addChild(this.power()));\n            }\n            else if (this.accept(Token.TYPE_LPAREN)) {\n                this.cursor--;\n                node.addChild(this.power());\n            }\n            else if (this.accept(Token.TYPE_SYMBOL) ||\n                this.accept(Token.TYPE_NUMBER) ||\n                this.accept(Token.TYPE_FUNCTION)) {\n                this.cursor--;\n                node.addChild(this.power());\n            }\n            else {\n                break;\n            }\n        }\n\n        return node;\n    }\n\n    power() {\n        let node = new Node(Node.TYPE_POWER);\n        node.addChild(this.val());\n\n        // If a chained power is encountered (e.g. a ^ b ^ c), treat it like\n        // a ^ (b ^ c)\n        if (this.accept(Token.TYPE_POWER)) {\n            node.addChild(this.power());\n        }\n\n        return node;\n    }\n\n    val() {\n        // Don't create a new node immediately, since we need to parse postfix\n        // operators like factorials, which come after a value.\n        let node = {};\n\n        if (this.accept(Token.TYPE_SYMBOL)) {\n            node = new Node(Node.TYPE_SYMBOL, this.prevToken.value);\n        }\n        else if (this.accept(Token.TYPE_NUMBER)) {\n            node = new Node(Node.TYPE_NUMBER, parseFloat(this.prevToken.value));\n        }\n        else if (this.accept(Token.TYPE_COMMAND)) {\n            const cmdToken = this.prevToken;\n            node = new Node(Node.TYPE_FUNCTION, cmdToken.value);\n            node.name = cmdToken.name;\n\n            for (let i = 0; i < arities[cmdToken.name]; i++) {\n                node.addChild(this.val());\n            }\n        }\n        else if (this.accept(Token.TYPE_FUNCTION)) {\n            node = new Node(Node.TYPE_FUNCTION, this.prevToken.value);\n            node.name = this.prevToken.name;\n\n            // Multi-param functions require parens and have commas\n            if (this.accept(Token.TYPE_LPAREN)) {\n                node.addChild(this.sum());\n\n                while (this.accept(Token.TYPE_COMMA)) {\n                    node.addChild(this.sum());\n                }\n\n                this.expect(Token.TYPE_RPAREN);\n            }\n\n            // Single-parameter functions don't need parens\n            else {\n                node.addChild(this.power());\n            }\n        }\n        else if (this.accept(Token.TYPE_MINUS)) {\n            node = new Node(Node.TYPE_NEGATE).addChild(this.power());\n        }\n        else if (this.accept(Token.TYPE_LPAREN)) {\n            node = this.sum();\n            this.expect(Token.TYPE_RPAREN);\n        }\n        else if (this.accept(Token.TYPE_ABS)) {\n            node = new Node(Node.TYPE_FUNCTION, Math.abs);\n            node.addChild(this.sum());\n            this.expect(Token.TYPE_ABS);\n        }\n        else {\n            throw \"Unexpected \" + this.currentToken.toString() + \" at token \" + this.cursor;\n        }\n\n        if (this.accept(Token.TYPE_BANG)) {\n            let factNode = new Node(Node.TYPE_FUNCTION, fact);\n            factNode.addChild(node);\n            return factNode;\n        }\n\n        return node;\n    }\n}\n\n/*\n// Non-terminal rules\n// ------------------\n\n// The following parser functions match certain motifs that are called\n// \"non-terminals\" in parsing lingo.\n// Essentially, they implement a sort of finite state automaton.\n// You should read the [Wikipedia article](https://en.wikipedia.org/wiki/Recursive_descent_parser) on recursive-descent parsing if you want to know more about how these work.\n\n// ### Grammar:\n// ```\n// orderExpression : sum\n// sum : product { ('+'|'-') product }\n// product : power { ('*'|'/') power }\n//         | power '(' orderExpression ')'\n// power : TODO power\n// val : SYMBOL\n//     | NUMBER\n//     | FUNCTION '(' orderExpression { ',' orderExpression } ')'\n//     | '-' val\n//     | '(' orderExpression ')'\n//     | '{' orderExpression '}'\n//     | '|' orderExpression '|'\n//     | val '!'\n// ```\n*/\n\n// Parses values or nested expressions.\n//Parser.prototype.val = function() {\n// Don't return new nodes immediately, since we need to parse\n// factorials, which come at the END of values.\n//var node = {};\n\n\n// Parse negative values like -42.\n// The lexer can't differentiate between a difference and a negative,\n// so that distinction is done here.\n// Notice the `power()` rule that comes after a negative sign so that\n// expressions like `-4^2` return -16 instead of 16.\n\n\n// Parse nested expression with parentheses.\n// Notice that the parser expects an RPAREN token after the expression.\n\n\n// Parse absolute value.\n// Absolute values are contained in pipes (`|`) and are treated quite\n// like parens.\n\n\n// All parsing rules should have terminated or recursed by now.\n// Throw an exception if this is not the case.\n\n\n// Process postfix operations like factorials.\n\n// Parse factorial.\n\n\n//return node;\n//};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}