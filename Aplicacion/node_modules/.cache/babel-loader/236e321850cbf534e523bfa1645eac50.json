{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nimport { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is.js';\nimport { arraySize, getArrayDataType, processSizesWildcard, reshape, resize, unsqueeze, validate, validateIndex } from '../../utils/array.js';\nimport { format } from '../../utils/string.js';\nimport { isInteger } from '../../utils/number.js';\nimport { clone, deepStrictEqual } from '../../utils/object.js';\nimport { DimensionError } from '../../error/DimensionError.js';\nimport { factory } from '../../utils/factory.js';\nimport { maxArgumentCount } from '../../utils/function.js';\nvar name = 'DenseMatrix';\nvar dependencies = ['Matrix'];\nexport var createDenseMatrixClass = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Matrix = _ref.Matrix;\n  /**\r\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\r\n   * @class DenseMatrix\r\n   * @enum {{ value, index: number[] }}\r\n   */\n\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n\n    if (isMatrix(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = clone(data._data);\n        this._size = clone(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && isArray(data.data) && isArray(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size; // verify the dimensions of the array\n\n      validate(this._data, this._size);\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data); // get the dimensions of the array\n\n      this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array\n\n      validate(this._data, this._size); // data type unknown\n\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n\n  DenseMatrix.prototype = new Matrix();\n  /**\r\n   * Create a new DenseMatrix\r\n   */\n\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\r\n   * Attach type information\r\n   */\n\n\n  Object.defineProperty(DenseMatrix, 'name', {\n    value: 'DenseMatrix'\n  });\n  DenseMatrix.prototype.constructor = DenseMatrix;\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n  /**\r\n   * Get the matrix type\r\n   *\r\n   * Usage:\r\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\r\n   *\r\n   * @memberOf DenseMatrix\r\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\r\n   */\n\n  DenseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._data, typeOf);\n  };\n  /**\r\n   * Get the storage format used by the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.storage()  // retrieve storage format\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @return {string}           The storage format.\r\n   */\n\n\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n  /**\r\n   * Get the datatype of the data stored in the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.datatype()   // retrieve matrix datatype\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @return {string}           The datatype.\r\n   */\n\n\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n  /**\r\n   * Create a new DenseMatrix\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {string} [datatype]\r\n   */\n\n\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n  /**\r\n   * Get a subset of the matrix, or replace a subset of the matrix.\r\n   *\r\n   * Usage:\r\n   *     const subset = matrix.subset(index)               // retrieve subset\r\n   *     const value = matrix.subset(index, replacement)   // replace subset\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {Index} index\r\n   * @param {Array | Matrix | *} [replacement]\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be filled with zeros.\r\n   */\n\n\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n      // intentional fall through\n\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n  /**\r\n   * Get a single element from the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @return {*} value\r\n   */\n\n\n  DenseMatrix.prototype.get = function (index) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length !== this._size.length) {\n      throw new DimensionError(index.length, this._size.length);\n    } // check index\n\n\n    for (var x = 0; x < index.length; x++) {\n      validateIndex(index[x], this._size[x]);\n    }\n\n    var data = this._data;\n\n    for (var i = 0, ii = index.length; i < ii; i++) {\n      var indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    }\n\n    return data;\n  };\n  /**\r\n   * Replace a single element in the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @param {*} value\r\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be left undefined.\r\n   * @return {DenseMatrix} self\r\n   */\n\n\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n\n    if (index.length < this._size.length) {\n      throw new DimensionError(index.length, this._size.length, '<');\n    }\n\n    var i, ii, indexI; // enlarge matrix when needed\n\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n\n    _fit(this, size, defaultValue); // traverse over the dimensions\n\n\n    var data = this._data;\n\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    } // set new value\n\n\n    indexI = index[index.length - 1];\n    validateIndex(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n  /**\r\n   * Get a submatrix of this matrix\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix\r\n   * @param {Index} index   Zero-based index\r\n   * @private\r\n   */\n\n\n  function _get(matrix, index) {\n    if (!isIndex(index)) {\n      throw new TypeError('Invalid index');\n    }\n\n    var isScalar = index.isScalar();\n\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n\n      if (size.length !== matrix._size.length) {\n        throw new DimensionError(size.length, matrix._size.length);\n      } // validate if any of the ranges in the index is out of range\n\n\n      var min = index.min();\n      var max = index.max();\n\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        validateIndex(min[i], matrix._size[i]);\n        validateIndex(max[i], matrix._size[i]);\n      } // retrieve submatrix\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\n\n\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\n    }\n  }\n  /**\r\n   * Recursively get a submatrix of a multi dimensional matrix.\r\n   * Index is not checked for correct number or length of dimensions.\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {Index} index\r\n   * @param {number} dims   Total number of dimensions\r\n   * @param {number} dim    Current dimension\r\n   * @return {Array} submatrix\r\n   * @private\r\n   */\n\n\n  function _getSubmatrix(data, index, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        return data[i];\n      }).valueOf();\n    } else {\n      return range.map(function (i) {\n        validateIndex(i, data.length);\n        var child = data[i];\n        return _getSubmatrix(child, index, dims, dim + 1);\n      }).valueOf();\n    }\n  }\n  /**\r\n   * Replace a submatrix in this matrix\r\n   * Indexes are zero-based.\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix\r\n   * @param {Index} index\r\n   * @param {DenseMatrix | Array | *} submatrix\r\n   * @param {*} defaultValue          Default value, filled in on new entries when\r\n   *                                  the matrix is resized.\r\n   * @return {DenseMatrix} matrix\r\n   * @private\r\n   */\n\n\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    } // get index size and check whether the index contains a single value\n\n\n    var iSize = index.size();\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\n\n    var sSize;\n\n    if (isMatrix(submatrix)) {\n      sSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      sSize = arraySize(submatrix);\n    }\n\n    if (isScalar) {\n      // set a scalar\n      // check whether submatrix is a scalar\n      if (sSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      }\n\n      if (sSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n\n        while (iSize[i] === 1 && sSize[i] === 1) {\n          i++;\n        }\n\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        } // unsqueeze both outer and inner dimensions\n\n\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\n      } // check whether the size of the submatrix matches the index size\n\n\n      if (!deepStrictEqual(iSize, sSize)) {\n        throw new DimensionError(iSize, sSize, '>');\n      } // enlarge matrix when needed\n\n\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n\n      _fit(matrix, size, defaultValue); // insert the sub matrix\n\n\n      var dims = iSize.length;\n      var dim = 0;\n\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\n    }\n\n    return matrix;\n  }\n  /**\r\n   * Replace a submatrix of a multi dimensional matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {Index} index\r\n   * @param {Array} submatrix\r\n   * @param {number} dims   Total number of dimensions\r\n   * @param {number} dim\r\n   * @private\r\n   */\n\n\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\n    var last = dim === dims - 1;\n    var range = index.dimension(dim);\n\n    if (last) {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n        data[dataIndex] = submatrix[subIndex[0]];\n      });\n    } else {\n      range.forEach(function (dataIndex, subIndex) {\n        validateIndex(dataIndex);\n\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\n      });\n    }\n  }\n  /**\r\n   * Resize the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (resize in place).\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number[] || Matrix} size The new size the matrix should have.\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\r\n   *                                  If not provided, the matrix elements will\r\n   *                                  be filled with zeros.\r\n   * @param {boolean} [copy]          Return a resized copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The resized matrix\r\n   */\n\n\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isCollection(size)) {\n      throw new TypeError('Array or Matrix expected');\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n\n\n    var sizeArray = size.valueOf().map(function (value) {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    }); // matrix to resize\n\n    var m = copy ? this.clone() : this; // resize matrix\n\n    return _resize(m, sizeArray, defaultValue);\n  };\n\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data; // go deep\n\n      while (isArray(v)) {\n        v = v[0];\n      }\n\n      return v;\n    } // resize matrix\n\n\n    matrix._size = size.slice(0); // copy the array\n\n    matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix\n\n    return matrix;\n  }\n  /**\r\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\r\n   *\r\n   * NOTE: This might be better suited to copy by default, instead of modifying\r\n   *       in place. For now, it operates in place to remain consistent with\r\n   *       resize().\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} size           The new size the matrix should have.\r\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The reshaped matrix\r\n   */\n\n\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = reshape(m._data, size);\n\n    var currentLength = m._size.reduce(function (length, size) {\n      return length * size;\n    });\n\n    m._size = processSizesWildcard(size, currentLength);\n    return m;\n  };\n  /**\r\n   * Enlarge the matrix when it is smaller than given size.\r\n   * If the matrix is larger or equal sized, nothing is done.\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix           The matrix to be resized\r\n   * @param {number[]} size\r\n   * @param {*} defaultValue          Default value, filled in on new entries.\r\n   * @private\r\n   */\n\n\n  function _fit(matrix, size, defaultValue) {\n    var // copy the array\n    newSize = matrix._size.slice(0);\n\n    var changed = false; // add dimensions when needed\n\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    } // enlarge size when needed\n\n\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n  /**\r\n   * Create a clone of the matrix\r\n   * @memberof DenseMatrix\r\n   * @return {DenseMatrix} clone\r\n   */\n\n\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: clone(this._data),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n  /**\r\n   * Retrieve the size of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @returns {number[]} size\r\n   */\n\n\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n  /**\r\n   * Create a new matrix with the results of the callback function executed on\r\n   * each entry of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   *\r\n   * @return {DenseMatrix} matrix\r\n   */\n\n\n  DenseMatrix.prototype.map = function (callback) {\n    // matrix instance\n    var me = this;\n    var args = maxArgumentCount(callback);\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        return value.map(function (child, i) {\n          return recurse(child, index.concat(i));\n        });\n      } else {\n        // invoke the callback function with the right number of arguments\n        if (args === 1) {\n          return callback(value);\n        } else if (args === 2) {\n          return callback(value, index);\n        } else {\n          // 3 or -1\n          return callback(value, index, me);\n        }\n      }\n    }; // determine the new datatype when the original matrix has datatype defined\n    // TODO: should be done in matrix constructor instead\n\n\n    var data = recurse(this._data, []);\n    var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;\n    return new DenseMatrix(data, datatype);\n  };\n  /**\r\n   * Execute a callback function on each entry of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   */\n\n\n  DenseMatrix.prototype.forEach = function (callback) {\n    // matrix instance\n    var me = this;\n\n    var recurse = function recurse(value, index) {\n      if (isArray(value)) {\n        value.forEach(function (child, i) {\n          recurse(child, index.concat(i));\n        });\n      } else {\n        callback(value, index, me);\n      }\n    };\n\n    recurse(this._data, []);\n  };\n  /**\r\n   * Iterate over the matrix elements\r\n   * @return {Iterable<{ value, index: number[] }>}\r\n   */\n\n\n  DenseMatrix.prototype[Symbol.iterator] = /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var recurse;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            recurse = /*#__PURE__*/_regeneratorRuntime().mark(function recurse(value, index) {\n              var i;\n              return _regeneratorRuntime().wrap(function recurse$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!isArray(value)) {\n                        _context.next = 9;\n                        break;\n                      }\n\n                      i = 0;\n\n                    case 2:\n                      if (!(i < value.length)) {\n                        _context.next = 7;\n                        break;\n                      }\n\n                      return _context.delegateYield(recurse(value[i], index.concat(i)), \"t0\", 4);\n\n                    case 4:\n                      i++;\n                      _context.next = 2;\n                      break;\n\n                    case 7:\n                      _context.next = 11;\n                      break;\n\n                    case 9:\n                      _context.next = 11;\n                      return {\n                        value: value,\n                        index: index\n                      };\n\n                    case 11:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, recurse);\n            });\n            return _context2.delegateYield(recurse(this._data, []), \"t0\", 2);\n\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, this);\n  });\n  /**\r\n   * Returns an array containing the rows of a 2D matrix\r\n   * @returns {Array<Matrix>}\r\n   */\n\n  DenseMatrix.prototype.rows = function () {\n    var result = [];\n    var s = this.size();\n\n    if (s.length !== 2) {\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\n    }\n\n    var data = this._data;\n\n    var _iterator = _createForOfIteratorHelper(data),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var row = _step.value;\n        result.push(new DenseMatrix([row], this._datatype));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns an array containing the columns of a 2D matrix\r\n   * @returns {Array<Matrix>}\r\n   */\n\n\n  DenseMatrix.prototype.columns = function () {\n    var _this = this;\n\n    var result = [];\n    var s = this.size();\n\n    if (s.length !== 2) {\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\n    }\n\n    var data = this._data;\n\n    var _loop = function _loop(i) {\n      var col = data.map(function (row) {\n        return [row[i]];\n      });\n      result.push(new DenseMatrix(col, _this._datatype));\n    };\n\n    for (var i = 0; i < s[1]; i++) {\n      _loop(i);\n    }\n\n    return result;\n  };\n  /**\r\n   * Create an Array with a copy of the data of the DenseMatrix\r\n   * @memberof DenseMatrix\r\n   * @returns {Array} array\r\n   */\n\n\n  DenseMatrix.prototype.toArray = function () {\n    return clone(this._data);\n  };\n  /**\r\n   * Get the primitive value of the DenseMatrix: a multidimensional array\r\n   * @memberof DenseMatrix\r\n   * @returns {Array} array\r\n   */\n\n\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n  /**\r\n   * Get a string representation of the matrix, with optional formatting options.\r\n   * @memberof DenseMatrix\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @returns {string} str\r\n   */\n\n\n  DenseMatrix.prototype.format = function (options) {\n    return format(this._data, options);\n  };\n  /**\r\n   * Get a string representation of the matrix\r\n   * @memberof DenseMatrix\r\n   * @returns {string} str\r\n   */\n\n\n  DenseMatrix.prototype.toString = function () {\n    return format(this._data);\n  };\n  /**\r\n   * Get a JSON representation of the matrix\r\n   * @memberof DenseMatrix\r\n   * @returns {Object}\r\n   */\n\n\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n  /**\r\n   * Get the kth Matrix diagonal.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\r\n   *\r\n   * @returns {Matrix}                     The matrix with the diagonal values.\r\n   */\n\n\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows & columns\n\n    var rows = this._size[0];\n    var columns = this._size[1]; // number diagonal values\n\n    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix\n\n    var data = []; // loop rows\n\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n  /**\r\n   * Create a diagonal matrix.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {Array} size                     The matrix size.\r\n   * @param {number | Matrix | Array } value The values for the diagonal.\r\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\r\n   * @param {number} [defaultValue]          The default value for non-diagonal\r\n   * @param {string} [datatype]              The datatype for the diagonal\r\n   *\r\n   * @returns {DenseMatrix}\r\n   */\n\n\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    } // map size & validate\n\n\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      } // validate arguments\n\n\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n\n      return s;\n    }); // validate k if any\n\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      } // is must be an integer\n\n\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // rows and columns\n\n    var rows = size[0];\n    var columns = size[1]; // number of non-zero items\n\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\n\n    var _value; // check value\n\n\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size(); // validate matrix\n\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      } // define function\n\n\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    } // discover default value if needed\n\n\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\n      : 0;\n    } // empty array\n\n\n    var data = []; // check we need to resize array\n\n    if (size.length > 0) {\n      // resize array\n      data = resize(data, size, defaultValue); // fill diagonal\n\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    } // create DenseMatrix\n\n\n    return new DenseMatrix({\n      data: data,\n      size: [rows, columns]\n    });\n  };\n  /**\r\n   * Generate a matrix from a JSON object\r\n   * @memberof DenseMatrix\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\r\n   *                       where mathjs is optional\r\n   * @returns {DenseMatrix}\r\n   */\n\n\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n  /**\r\n   * Swap rows i and j in Matrix.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   *\r\n   * @return {Matrix}        The matrix reference\r\n   */\n\n\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    } // check dimensions\n\n\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    } // validate index\n\n\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]); // swap rows\n\n    DenseMatrix._swapRows(i, j, this._data); // return current instance\n\n\n    return this;\n  };\n  /**\r\n   * Swap rows i and j in Dense Matrix data structure.\r\n   *\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   * @param {Array} data     Matrix data\r\n   */\n\n\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n  /**\r\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\r\n   * Matrices. Replaces all nested Matrices with Arrays\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @return {Array} data\r\n   */\n\n\n  function preprocess(data) {\n    for (var i = 0, ii = data.length; i < ii; i++) {\n      var elem = data[i];\n\n      if (isArray(elem)) {\n        data[i] = preprocess(elem);\n      } else if (elem && elem.isMatrix === true) {\n        data[i] = preprocess(elem.valueOf());\n      }\n    }\n\n    return data;\n  }\n\n  return DenseMatrix;\n}, {\n  isClass: true\n});","map":{"version":3,"names":["isArray","isBigNumber","isCollection","isIndex","isMatrix","isNumber","isString","typeOf","arraySize","getArrayDataType","processSizesWildcard","reshape","resize","unsqueeze","validate","validateIndex","format","isInteger","clone","deepStrictEqual","DimensionError","factory","maxArgumentCount","name","dependencies","createDenseMatrixClass","_ref","Matrix","DenseMatrix","data","datatype","SyntaxError","Error","type","_data","_size","_datatype","toArray","size","preprocess","TypeError","prototype","createDenseMatrix","Object","defineProperty","value","constructor","isDenseMatrix","getDataType","storage","create","subset","index","replacement","defaultValue","arguments","length","_get","_set","get","x","i","ii","indexI","set","map","_fit","matrix","isScalar","min","max","_getSubmatrix","dims","dim","last","range","dimension","valueOf","child","submatrix","iSize","sSize","outer","_setSubmatrix","forEach","dataIndex","subIndex","copy","sizeArray","Array","m","_resize","v","slice","currentLength","reduce","newSize","changed","push","callback","me","args","recurse","concat","undefined","Symbol","iterator","rows","result","s","row","columns","_this","_loop","col","options","toString","toJSON","mathjs","diagonal","k","toNumber","kSuper","kSub","n","Math","_value","ms","mul","d","fromJSON","json","swapRows","j","_swapRows","vi","elem","isClass"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js"],"sourcesContent":["import { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is.js';\r\nimport { arraySize, getArrayDataType, processSizesWildcard, reshape, resize, unsqueeze, validate, validateIndex } from '../../utils/array.js';\r\nimport { format } from '../../utils/string.js';\r\nimport { isInteger } from '../../utils/number.js';\r\nimport { clone, deepStrictEqual } from '../../utils/object.js';\r\nimport { DimensionError } from '../../error/DimensionError.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { maxArgumentCount } from '../../utils/function.js';\r\nvar name = 'DenseMatrix';\r\nvar dependencies = ['Matrix'];\r\nexport var createDenseMatrixClass = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Matrix\r\n  } = _ref;\r\n\r\n  /**\r\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\r\n   * @class DenseMatrix\r\n   * @enum {{ value, index: number[] }}\r\n   */\r\n  function DenseMatrix(data, datatype) {\r\n    if (!(this instanceof DenseMatrix)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n\r\n    if (datatype && !isString(datatype)) {\r\n      throw new Error('Invalid datatype: ' + datatype);\r\n    }\r\n\r\n    if (isMatrix(data)) {\r\n      // check data is a DenseMatrix\r\n      if (data.type === 'DenseMatrix') {\r\n        // clone data & size\r\n        this._data = clone(data._data);\r\n        this._size = clone(data._size);\r\n        this._datatype = datatype || data._datatype;\r\n      } else {\r\n        // build data from existing matrix\r\n        this._data = data.toArray();\r\n        this._size = data.size();\r\n        this._datatype = datatype || data._datatype;\r\n      }\r\n    } else if (data && isArray(data.data) && isArray(data.size)) {\r\n      // initialize fields from JSON representation\r\n      this._data = data.data;\r\n      this._size = data.size; // verify the dimensions of the array\r\n\r\n      validate(this._data, this._size);\r\n      this._datatype = datatype || data.datatype;\r\n    } else if (isArray(data)) {\r\n      // replace nested Matrices with Arrays\r\n      this._data = preprocess(data); // get the dimensions of the array\r\n\r\n      this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array\r\n\r\n      validate(this._data, this._size); // data type unknown\r\n\r\n      this._datatype = datatype;\r\n    } else if (data) {\r\n      // unsupported type\r\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\r\n    } else {\r\n      // nothing provided\r\n      this._data = [];\r\n      this._size = [0];\r\n      this._datatype = datatype;\r\n    }\r\n  }\r\n\r\n  DenseMatrix.prototype = new Matrix();\r\n  /**\r\n   * Create a new DenseMatrix\r\n   */\r\n\r\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\r\n    return new DenseMatrix(data, datatype);\r\n  };\r\n  /**\r\n   * Attach type information\r\n   */\r\n\r\n\r\n  Object.defineProperty(DenseMatrix, 'name', {\r\n    value: 'DenseMatrix'\r\n  });\r\n  DenseMatrix.prototype.constructor = DenseMatrix;\r\n  DenseMatrix.prototype.type = 'DenseMatrix';\r\n  DenseMatrix.prototype.isDenseMatrix = true;\r\n  /**\r\n   * Get the matrix type\r\n   *\r\n   * Usage:\r\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\r\n   *\r\n   * @memberOf DenseMatrix\r\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\r\n   */\r\n\r\n  DenseMatrix.prototype.getDataType = function () {\r\n    return getArrayDataType(this._data, typeOf);\r\n  };\r\n  /**\r\n   * Get the storage format used by the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.storage()  // retrieve storage format\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @return {string}           The storage format.\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.storage = function () {\r\n    return 'dense';\r\n  };\r\n  /**\r\n   * Get the datatype of the data stored in the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.datatype()   // retrieve matrix datatype\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @return {string}           The datatype.\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.datatype = function () {\r\n    return this._datatype;\r\n  };\r\n  /**\r\n   * Create a new DenseMatrix\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {string} [datatype]\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.create = function (data, datatype) {\r\n    return new DenseMatrix(data, datatype);\r\n  };\r\n  /**\r\n   * Get a subset of the matrix, or replace a subset of the matrix.\r\n   *\r\n   * Usage:\r\n   *     const subset = matrix.subset(index)               // retrieve subset\r\n   *     const value = matrix.subset(index, replacement)   // replace subset\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {Index} index\r\n   * @param {Array | Matrix | *} [replacement]\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be filled with zeros.\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\r\n    switch (arguments.length) {\r\n      case 1:\r\n        return _get(this, index);\r\n      // intentional fall through\r\n\r\n      case 2:\r\n      case 3:\r\n        return _set(this, index, replacement, defaultValue);\r\n\r\n      default:\r\n        throw new SyntaxError('Wrong number of arguments');\r\n    }\r\n  };\r\n  /**\r\n   * Get a single element from the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @return {*} value\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.get = function (index) {\r\n    if (!isArray(index)) {\r\n      throw new TypeError('Array expected');\r\n    }\r\n\r\n    if (index.length !== this._size.length) {\r\n      throw new DimensionError(index.length, this._size.length);\r\n    } // check index\r\n\r\n\r\n    for (var x = 0; x < index.length; x++) {\r\n      validateIndex(index[x], this._size[x]);\r\n    }\r\n\r\n    var data = this._data;\r\n\r\n    for (var i = 0, ii = index.length; i < ii; i++) {\r\n      var indexI = index[i];\r\n      validateIndex(indexI, data.length);\r\n      data = data[indexI];\r\n    }\r\n\r\n    return data;\r\n  };\r\n  /**\r\n   * Replace a single element in the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @param {*} value\r\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be left undefined.\r\n   * @return {DenseMatrix} self\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\r\n    if (!isArray(index)) {\r\n      throw new TypeError('Array expected');\r\n    }\r\n\r\n    if (index.length < this._size.length) {\r\n      throw new DimensionError(index.length, this._size.length, '<');\r\n    }\r\n\r\n    var i, ii, indexI; // enlarge matrix when needed\r\n\r\n    var size = index.map(function (i) {\r\n      return i + 1;\r\n    });\r\n\r\n    _fit(this, size, defaultValue); // traverse over the dimensions\r\n\r\n\r\n    var data = this._data;\r\n\r\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\r\n      indexI = index[i];\r\n      validateIndex(indexI, data.length);\r\n      data = data[indexI];\r\n    } // set new value\r\n\r\n\r\n    indexI = index[index.length - 1];\r\n    validateIndex(indexI, data.length);\r\n    data[indexI] = value;\r\n    return this;\r\n  };\r\n  /**\r\n   * Get a submatrix of this matrix\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix\r\n   * @param {Index} index   Zero-based index\r\n   * @private\r\n   */\r\n\r\n\r\n  function _get(matrix, index) {\r\n    if (!isIndex(index)) {\r\n      throw new TypeError('Invalid index');\r\n    }\r\n\r\n    var isScalar = index.isScalar();\r\n\r\n    if (isScalar) {\r\n      // return a scalar\r\n      return matrix.get(index.min());\r\n    } else {\r\n      // validate dimensions\r\n      var size = index.size();\r\n\r\n      if (size.length !== matrix._size.length) {\r\n        throw new DimensionError(size.length, matrix._size.length);\r\n      } // validate if any of the ranges in the index is out of range\r\n\r\n\r\n      var min = index.min();\r\n      var max = index.max();\r\n\r\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\r\n        validateIndex(min[i], matrix._size[i]);\r\n        validateIndex(max[i], matrix._size[i]);\r\n      } // retrieve submatrix\r\n      // TODO: more efficient when creating an empty matrix and setting _data and _size manually\r\n\r\n\r\n      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);\r\n    }\r\n  }\r\n  /**\r\n   * Recursively get a submatrix of a multi dimensional matrix.\r\n   * Index is not checked for correct number or length of dimensions.\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {Index} index\r\n   * @param {number} dims   Total number of dimensions\r\n   * @param {number} dim    Current dimension\r\n   * @return {Array} submatrix\r\n   * @private\r\n   */\r\n\r\n\r\n  function _getSubmatrix(data, index, dims, dim) {\r\n    var last = dim === dims - 1;\r\n    var range = index.dimension(dim);\r\n\r\n    if (last) {\r\n      return range.map(function (i) {\r\n        validateIndex(i, data.length);\r\n        return data[i];\r\n      }).valueOf();\r\n    } else {\r\n      return range.map(function (i) {\r\n        validateIndex(i, data.length);\r\n        var child = data[i];\r\n        return _getSubmatrix(child, index, dims, dim + 1);\r\n      }).valueOf();\r\n    }\r\n  }\r\n  /**\r\n   * Replace a submatrix in this matrix\r\n   * Indexes are zero-based.\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix\r\n   * @param {Index} index\r\n   * @param {DenseMatrix | Array | *} submatrix\r\n   * @param {*} defaultValue          Default value, filled in on new entries when\r\n   *                                  the matrix is resized.\r\n   * @return {DenseMatrix} matrix\r\n   * @private\r\n   */\r\n\r\n\r\n  function _set(matrix, index, submatrix, defaultValue) {\r\n    if (!index || index.isIndex !== true) {\r\n      throw new TypeError('Invalid index');\r\n    } // get index size and check whether the index contains a single value\r\n\r\n\r\n    var iSize = index.size();\r\n    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed\r\n\r\n    var sSize;\r\n\r\n    if (isMatrix(submatrix)) {\r\n      sSize = submatrix.size();\r\n      submatrix = submatrix.valueOf();\r\n    } else {\r\n      sSize = arraySize(submatrix);\r\n    }\r\n\r\n    if (isScalar) {\r\n      // set a scalar\r\n      // check whether submatrix is a scalar\r\n      if (sSize.length !== 0) {\r\n        throw new TypeError('Scalar expected');\r\n      }\r\n\r\n      matrix.set(index.min(), submatrix, defaultValue);\r\n    } else {\r\n      // set a submatrix\r\n      // validate dimensions\r\n      if (iSize.length < matrix._size.length) {\r\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\r\n      }\r\n\r\n      if (sSize.length < iSize.length) {\r\n        // calculate number of missing outer dimensions\r\n        var i = 0;\r\n        var outer = 0;\r\n\r\n        while (iSize[i] === 1 && sSize[i] === 1) {\r\n          i++;\r\n        }\r\n\r\n        while (iSize[i] === 1) {\r\n          outer++;\r\n          i++;\r\n        } // unsqueeze both outer and inner dimensions\r\n\r\n\r\n        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);\r\n      } // check whether the size of the submatrix matches the index size\r\n\r\n\r\n      if (!deepStrictEqual(iSize, sSize)) {\r\n        throw new DimensionError(iSize, sSize, '>');\r\n      } // enlarge matrix when needed\r\n\r\n\r\n      var size = index.max().map(function (i) {\r\n        return i + 1;\r\n      });\r\n\r\n      _fit(matrix, size, defaultValue); // insert the sub matrix\r\n\r\n\r\n      var dims = iSize.length;\r\n      var dim = 0;\r\n\r\n      _setSubmatrix(matrix._data, index, submatrix, dims, dim);\r\n    }\r\n\r\n    return matrix;\r\n  }\r\n  /**\r\n   * Replace a submatrix of a multi dimensional matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {Index} index\r\n   * @param {Array} submatrix\r\n   * @param {number} dims   Total number of dimensions\r\n   * @param {number} dim\r\n   * @private\r\n   */\r\n\r\n\r\n  function _setSubmatrix(data, index, submatrix, dims, dim) {\r\n    var last = dim === dims - 1;\r\n    var range = index.dimension(dim);\r\n\r\n    if (last) {\r\n      range.forEach(function (dataIndex, subIndex) {\r\n        validateIndex(dataIndex);\r\n        data[dataIndex] = submatrix[subIndex[0]];\r\n      });\r\n    } else {\r\n      range.forEach(function (dataIndex, subIndex) {\r\n        validateIndex(dataIndex);\r\n\r\n        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);\r\n      });\r\n    }\r\n  }\r\n  /**\r\n   * Resize the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (resize in place).\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number[] || Matrix} size The new size the matrix should have.\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\r\n   *                                  If not provided, the matrix elements will\r\n   *                                  be filled with zeros.\r\n   * @param {boolean} [copy]          Return a resized copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The resized matrix\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\r\n    // validate arguments\r\n    if (!isCollection(size)) {\r\n      throw new TypeError('Array or Matrix expected');\r\n    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\r\n\r\n\r\n    var sizeArray = size.valueOf().map(value => {\r\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\r\n    }); // matrix to resize\r\n\r\n    var m = copy ? this.clone() : this; // resize matrix\r\n\r\n    return _resize(m, sizeArray, defaultValue);\r\n  };\r\n\r\n  function _resize(matrix, size, defaultValue) {\r\n    // check size\r\n    if (size.length === 0) {\r\n      // first value in matrix\r\n      var v = matrix._data; // go deep\r\n\r\n      while (isArray(v)) {\r\n        v = v[0];\r\n      }\r\n\r\n      return v;\r\n    } // resize matrix\r\n\r\n\r\n    matrix._size = size.slice(0); // copy the array\r\n\r\n    matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix\r\n\r\n    return matrix;\r\n  }\r\n  /**\r\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\r\n   *\r\n   * NOTE: This might be better suited to copy by default, instead of modifying\r\n   *       in place. For now, it operates in place to remain consistent with\r\n   *       resize().\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} size           The new size the matrix should have.\r\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The reshaped matrix\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.reshape = function (size, copy) {\r\n    var m = copy ? this.clone() : this;\r\n    m._data = reshape(m._data, size);\r\n\r\n    var currentLength = m._size.reduce((length, size) => length * size);\r\n\r\n    m._size = processSizesWildcard(size, currentLength);\r\n    return m;\r\n  };\r\n  /**\r\n   * Enlarge the matrix when it is smaller than given size.\r\n   * If the matrix is larger or equal sized, nothing is done.\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix           The matrix to be resized\r\n   * @param {number[]} size\r\n   * @param {*} defaultValue          Default value, filled in on new entries.\r\n   * @private\r\n   */\r\n\r\n\r\n  function _fit(matrix, size, defaultValue) {\r\n    var // copy the array\r\n    newSize = matrix._size.slice(0);\r\n\r\n    var changed = false; // add dimensions when needed\r\n\r\n    while (newSize.length < size.length) {\r\n      newSize.push(0);\r\n      changed = true;\r\n    } // enlarge size when needed\r\n\r\n\r\n    for (var i = 0, ii = size.length; i < ii; i++) {\r\n      if (size[i] > newSize[i]) {\r\n        newSize[i] = size[i];\r\n        changed = true;\r\n      }\r\n    }\r\n\r\n    if (changed) {\r\n      // resize only when size is changed\r\n      _resize(matrix, newSize, defaultValue);\r\n    }\r\n  }\r\n  /**\r\n   * Create a clone of the matrix\r\n   * @memberof DenseMatrix\r\n   * @return {DenseMatrix} clone\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.clone = function () {\r\n    var m = new DenseMatrix({\r\n      data: clone(this._data),\r\n      size: clone(this._size),\r\n      datatype: this._datatype\r\n    });\r\n    return m;\r\n  };\r\n  /**\r\n   * Retrieve the size of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @returns {number[]} size\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.size = function () {\r\n    return this._size.slice(0); // return a clone of _size\r\n  };\r\n  /**\r\n   * Create a new matrix with the results of the callback function executed on\r\n   * each entry of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   *\r\n   * @return {DenseMatrix} matrix\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.map = function (callback) {\r\n    // matrix instance\r\n    var me = this;\r\n    var args = maxArgumentCount(callback);\r\n\r\n    var recurse = function recurse(value, index) {\r\n      if (isArray(value)) {\r\n        return value.map(function (child, i) {\r\n          return recurse(child, index.concat(i));\r\n        });\r\n      } else {\r\n        // invoke the callback function with the right number of arguments\r\n        if (args === 1) {\r\n          return callback(value);\r\n        } else if (args === 2) {\r\n          return callback(value, index);\r\n        } else {\r\n          // 3 or -1\r\n          return callback(value, index, me);\r\n        }\r\n      }\r\n    }; // determine the new datatype when the original matrix has datatype defined\r\n    // TODO: should be done in matrix constructor instead\r\n\r\n\r\n    var data = recurse(this._data, []);\r\n    var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;\r\n    return new DenseMatrix(data, datatype);\r\n  };\r\n  /**\r\n   * Execute a callback function on each entry of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.forEach = function (callback) {\r\n    // matrix instance\r\n    var me = this;\r\n\r\n    var recurse = function recurse(value, index) {\r\n      if (isArray(value)) {\r\n        value.forEach(function (child, i) {\r\n          recurse(child, index.concat(i));\r\n        });\r\n      } else {\r\n        callback(value, index, me);\r\n      }\r\n    };\r\n\r\n    recurse(this._data, []);\r\n  };\r\n  /**\r\n   * Iterate over the matrix elements\r\n   * @return {Iterable<{ value, index: number[] }>}\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype[Symbol.iterator] = function* () {\r\n    var recurse = function* recurse(value, index) {\r\n      if (isArray(value)) {\r\n        for (var i = 0; i < value.length; i++) {\r\n          yield* recurse(value[i], index.concat(i));\r\n        }\r\n      } else {\r\n        yield {\r\n          value,\r\n          index\r\n        };\r\n      }\r\n    };\r\n\r\n    yield* recurse(this._data, []);\r\n  };\r\n  /**\r\n   * Returns an array containing the rows of a 2D matrix\r\n   * @returns {Array<Matrix>}\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.rows = function () {\r\n    var result = [];\r\n    var s = this.size();\r\n\r\n    if (s.length !== 2) {\r\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\r\n    }\r\n\r\n    var data = this._data;\r\n\r\n    for (var row of data) {\r\n      result.push(new DenseMatrix([row], this._datatype));\r\n    }\r\n\r\n    return result;\r\n  };\r\n  /**\r\n   * Returns an array containing the columns of a 2D matrix\r\n   * @returns {Array<Matrix>}\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.columns = function () {\r\n    var _this = this;\r\n\r\n    var result = [];\r\n    var s = this.size();\r\n\r\n    if (s.length !== 2) {\r\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\r\n    }\r\n\r\n    var data = this._data;\r\n\r\n    var _loop = function _loop(i) {\r\n      var col = data.map(row => [row[i]]);\r\n      result.push(new DenseMatrix(col, _this._datatype));\r\n    };\r\n\r\n    for (var i = 0; i < s[1]; i++) {\r\n      _loop(i);\r\n    }\r\n\r\n    return result;\r\n  };\r\n  /**\r\n   * Create an Array with a copy of the data of the DenseMatrix\r\n   * @memberof DenseMatrix\r\n   * @returns {Array} array\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.toArray = function () {\r\n    return clone(this._data);\r\n  };\r\n  /**\r\n   * Get the primitive value of the DenseMatrix: a multidimensional array\r\n   * @memberof DenseMatrix\r\n   * @returns {Array} array\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.valueOf = function () {\r\n    return this._data;\r\n  };\r\n  /**\r\n   * Get a string representation of the matrix, with optional formatting options.\r\n   * @memberof DenseMatrix\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @returns {string} str\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.format = function (options) {\r\n    return format(this._data, options);\r\n  };\r\n  /**\r\n   * Get a string representation of the matrix\r\n   * @memberof DenseMatrix\r\n   * @returns {string} str\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.toString = function () {\r\n    return format(this._data);\r\n  };\r\n  /**\r\n   * Get a JSON representation of the matrix\r\n   * @memberof DenseMatrix\r\n   * @returns {Object}\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'DenseMatrix',\r\n      data: this._data,\r\n      size: this._size,\r\n      datatype: this._datatype\r\n    };\r\n  };\r\n  /**\r\n   * Get the kth Matrix diagonal.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\r\n   *\r\n   * @returns {Matrix}                     The matrix with the diagonal values.\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.diagonal = function (k) {\r\n    // validate k if any\r\n    if (k) {\r\n      // convert BigNumber to a number\r\n      if (isBigNumber(k)) {\r\n        k = k.toNumber();\r\n      } // is must be an integer\r\n\r\n\r\n      if (!isNumber(k) || !isInteger(k)) {\r\n        throw new TypeError('The parameter k must be an integer number');\r\n      }\r\n    } else {\r\n      // default value\r\n      k = 0;\r\n    }\r\n\r\n    var kSuper = k > 0 ? k : 0;\r\n    var kSub = k < 0 ? -k : 0; // rows & columns\r\n\r\n    var rows = this._size[0];\r\n    var columns = this._size[1]; // number diagonal values\r\n\r\n    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix\r\n\r\n    var data = []; // loop rows\r\n\r\n    for (var i = 0; i < n; i++) {\r\n      data[i] = this._data[i + kSub][i + kSuper];\r\n    } // create DenseMatrix\r\n\r\n\r\n    return new DenseMatrix({\r\n      data,\r\n      size: [n],\r\n      datatype: this._datatype\r\n    });\r\n  };\r\n  /**\r\n   * Create a diagonal matrix.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {Array} size                     The matrix size.\r\n   * @param {number | Matrix | Array } value The values for the diagonal.\r\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\r\n   * @param {number} [defaultValue]          The default value for non-diagonal\r\n   * @param {string} [datatype]              The datatype for the diagonal\r\n   *\r\n   * @returns {DenseMatrix}\r\n   */\r\n\r\n\r\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\r\n    if (!isArray(size)) {\r\n      throw new TypeError('Array expected, size parameter');\r\n    }\r\n\r\n    if (size.length !== 2) {\r\n      throw new Error('Only two dimensions matrix are supported');\r\n    } // map size & validate\r\n\r\n\r\n    size = size.map(function (s) {\r\n      // check it is a big number\r\n      if (isBigNumber(s)) {\r\n        // convert it\r\n        s = s.toNumber();\r\n      } // validate arguments\r\n\r\n\r\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\r\n        throw new Error('Size values must be positive integers');\r\n      }\r\n\r\n      return s;\r\n    }); // validate k if any\r\n\r\n    if (k) {\r\n      // convert BigNumber to a number\r\n      if (isBigNumber(k)) {\r\n        k = k.toNumber();\r\n      } // is must be an integer\r\n\r\n\r\n      if (!isNumber(k) || !isInteger(k)) {\r\n        throw new TypeError('The parameter k must be an integer number');\r\n      }\r\n    } else {\r\n      // default value\r\n      k = 0;\r\n    }\r\n\r\n    var kSuper = k > 0 ? k : 0;\r\n    var kSub = k < 0 ? -k : 0; // rows and columns\r\n\r\n    var rows = size[0];\r\n    var columns = size[1]; // number of non-zero items\r\n\r\n    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function\r\n\r\n    var _value; // check value\r\n\r\n\r\n    if (isArray(value)) {\r\n      // validate array\r\n      if (value.length !== n) {\r\n        // number of values in array must be n\r\n        throw new Error('Invalid value array length');\r\n      } // define function\r\n\r\n\r\n      _value = function _value(i) {\r\n        // return value @ i\r\n        return value[i];\r\n      };\r\n    } else if (isMatrix(value)) {\r\n      // matrix size\r\n      var ms = value.size(); // validate matrix\r\n\r\n      if (ms.length !== 1 || ms[0] !== n) {\r\n        // number of values in array must be n\r\n        throw new Error('Invalid matrix length');\r\n      } // define function\r\n\r\n\r\n      _value = function _value(i) {\r\n        // return value @ i\r\n        return value.get([i]);\r\n      };\r\n    } else {\r\n      // define function\r\n      _value = function _value() {\r\n        // return value\r\n        return value;\r\n      };\r\n    } // discover default value if needed\r\n\r\n\r\n    if (!defaultValue) {\r\n      // check first value in array\r\n      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\r\n      : 0;\r\n    } // empty array\r\n\r\n\r\n    var data = []; // check we need to resize array\r\n\r\n    if (size.length > 0) {\r\n      // resize array\r\n      data = resize(data, size, defaultValue); // fill diagonal\r\n\r\n      for (var d = 0; d < n; d++) {\r\n        data[d + kSub][d + kSuper] = _value(d);\r\n      }\r\n    } // create DenseMatrix\r\n\r\n\r\n    return new DenseMatrix({\r\n      data,\r\n      size: [rows, columns]\r\n    });\r\n  };\r\n  /**\r\n   * Generate a matrix from a JSON object\r\n   * @memberof DenseMatrix\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\r\n   *                       where mathjs is optional\r\n   * @returns {DenseMatrix}\r\n   */\r\n\r\n\r\n  DenseMatrix.fromJSON = function (json) {\r\n    return new DenseMatrix(json);\r\n  };\r\n  /**\r\n   * Swap rows i and j in Matrix.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   *\r\n   * @return {Matrix}        The matrix reference\r\n   */\r\n\r\n\r\n  DenseMatrix.prototype.swapRows = function (i, j) {\r\n    // check index\r\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\r\n      throw new Error('Row index must be positive integers');\r\n    } // check dimensions\r\n\r\n\r\n    if (this._size.length !== 2) {\r\n      throw new Error('Only two dimensional matrix is supported');\r\n    } // validate index\r\n\r\n\r\n    validateIndex(i, this._size[0]);\r\n    validateIndex(j, this._size[0]); // swap rows\r\n\r\n    DenseMatrix._swapRows(i, j, this._data); // return current instance\r\n\r\n\r\n    return this;\r\n  };\r\n  /**\r\n   * Swap rows i and j in Dense Matrix data structure.\r\n   *\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   * @param {Array} data     Matrix data\r\n   */\r\n\r\n\r\n  DenseMatrix._swapRows = function (i, j, data) {\r\n    // swap values i <-> j\r\n    var vi = data[i];\r\n    data[i] = data[j];\r\n    data[j] = vi;\r\n  };\r\n  /**\r\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\r\n   * Matrices. Replaces all nested Matrices with Arrays\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @return {Array} data\r\n   */\r\n\r\n\r\n  function preprocess(data) {\r\n    for (var i = 0, ii = data.length; i < ii; i++) {\r\n      var elem = data[i];\r\n\r\n      if (isArray(elem)) {\r\n        data[i] = preprocess(elem);\r\n      } else if (elem && elem.isMatrix === true) {\r\n        data[i] = preprocess(elem.valueOf());\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  return DenseMatrix;\r\n}, {\r\n  isClass: true\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}