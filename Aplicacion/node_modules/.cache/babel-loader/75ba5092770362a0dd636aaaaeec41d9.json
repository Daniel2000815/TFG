{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Expression = void 0;\nvar Settings_1 = require(\"../Settings\");\nvar Build_1 = require(\"./Build\");\nvar Text_1 = require(\"../Core/Text\");\nvar LaTeX_1 = require(\"../LaTeX/LaTeX\");\nvar Utils_1 = require(\"../Core/Utils\");\nvar Core_1 = require(\"../Functions/Core\");\nvar expand_1 = require(\"../Functions/Core/math/expand\");\nvar Parser_1 = require(\"./Parser\");\n/**\n * This is what nerdamer returns. It's sort of a wrapper around the symbol class and\n * provides the user with some useful functions. If you want to provide the user with extra\n * library functions then add them to this class's prototype.\n * @param {Symbol} symbol\n */\nvar Expression = /*#__PURE__*/function () {\n  function Expression(symbol) {\n    _classCallCheck(this, Expression);\n    //we don't want arrays wrapped\n    this.symbol = symbol;\n  }\n  /**\n   * Returns stored expression at index. For first index use 1 not 0.\n   * @param {number | string} expression_number\n   * @param {boolean} asType\n   */\n  _createClass(Expression, [{\n    key: \"text\",\n    value:\n    /**\n     * Returns the text representation of the expression\n     * @param {String} opt - option of formatting numbers\n     * @param {Number} n The number of significant figures\n     * @returns {String}\n     */\n    function text() {\n      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'decimals';\n      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      n = n || 19;\n      opt = opt || 'decimals';\n      if (this.symbol.text_) return this.symbol.text_(opt);\n      return (0, Text_1.text)(this.symbol, opt, undefined, n);\n    }\n    /**\n     * Returns the latex representation of the expression\n     * @param {String} option - option for formatting numbers\n     * @returns {String}\n     */\n  }, {\n    key: \"latex\",\n    value: function latex(option) {\n      if (this.symbol.latex) return this.symbol.latex(option);\n      return LaTeX_1.LaTeX.latex(this.symbol, option);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.symbol.valueOf();\n    }\n    /**\n     * Evaluates the expression and tries to reduce it to a number if possible.\n     * If an argument is given in the form of %{integer} it will evaluate that expression.\n     * Other than that it will just use it's own text and reparse\n     * @returns {Expression}\n     */\n  }, {\n    key: \"evaluate\",\n    value: function evaluate() {\n      // Don't evaluate an empty vector\n      if ((0, Utils_1.isVector)(this.symbol) && this.symbol.dimensions() === 0) {\n        return this;\n      }\n      var first_arg = arguments[0],\n        expression,\n        idx = 1;\n      //Enable getting of expressions using the % so for example %1 should get the first expression\n      if (typeof first_arg === 'string') {\n        expression = first_arg.charAt(0) === '%' ? Expression.getExpression(first_arg.substr(1)).text() : first_arg;\n      } else if (first_arg instanceof Expression || (0, Utils_1.isSymbol)(first_arg)) {\n        expression = first_arg.text();\n      } else {\n        expression = this.symbol.text();\n        idx--;\n      }\n      var subs = arguments[idx] || {};\n      return new Expression((0, Utils_1.block)('PARSE2NUMBER', function () {\n        return (0, Parser_1.parse)(expression, subs);\n      }, true, this));\n    }\n    /**\n     * Converts a symbol to a JS function. Pass in an array of variables to use that order instead of\n     * the default alphabetical order\n     * @param vars {Array}\n     */\n  }, {\n    key: \"buildFunction\",\n    value: function buildFunction(vars) {\n      return Build_1.Build.build(this.symbol, vars);\n    }\n    /**\n     * Checks to see if the expression is just a plain old number\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isNumber\",\n    value: function isNumber() {\n      return (0, Utils_1.isNumericSymbol)(this.symbol);\n    }\n    /**\n     * Checks to see if the expression is infinity\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isInfinity\",\n    value: function isInfinity() {\n      return Math.abs(this.symbol.multiplier) === Infinity;\n    }\n    /**\n     * Checks to see if the expression contains imaginary numbers\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isImaginary\",\n    value: function isImaginary() {\n      return (0, Parser_1.evaluate)((0, Parser_1.parse)(this.symbol)).isImaginary();\n    }\n    /**\n     * Returns all the variables in the expression\n     * @returns {Array}\n     */\n  }, {\n    key: \"variables\",\n    value: function variables() {\n      if (!(0, Utils_1.isSymbol)(this.symbol)) {\n        return [];\n      }\n      return this.symbol.variables();\n    }\n    /**\n     *\n     * @return {string}\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      try {\n        if (Array.isArray(this.symbol)) return '[' + this.symbol.toString() + ']';\n        return this.symbol.toString();\n      } catch (e) {\n        return '';\n      }\n    }\n    //forces the symbol to be returned as a decimal\n  }, {\n    key: \"toDecimal\",\n    value: function toDecimal(prec) {\n      Settings_1.Settings.precision = prec;\n      var dec = (0, Text_1.text)(this.symbol, 'decimals');\n      Settings_1.Settings.precision = undefined;\n      return dec;\n    }\n    //checks to see if the expression is a fraction\n  }, {\n    key: \"isFraction\",\n    value: function isFraction() {\n      return (0, Utils_1.isFraction)(this.symbol);\n    }\n    //checks to see if the symbol is a multivariate polynomial\n  }, {\n    key: \"isPolynomial\",\n    value: function isPolynomial() {\n      return this.symbol.isPoly();\n    }\n    //performs a substitution\n  }, {\n    key: \"sub\",\n    value: function sub(symbol, for_symbol) {\n      return new Expression(this.symbol.sub((0, Parser_1.parse)(symbol), (0, Parser_1.parse)(for_symbol)));\n    }\n  }, {\n    key: \"operation\",\n    value: function operation(otype, symbol) {\n      if (isExpression(symbol)) {\n        symbol = symbol.symbol;\n      } else if (!(0, Utils_1.isSymbol)(symbol)) {\n        symbol = (0, Parser_1.parse)(symbol);\n      }\n      return new Expression(Parser_1.ParseDeps.parser.getAction(otype)(this.symbol.clone(), symbol.clone()));\n    }\n  }, {\n    key: \"add\",\n    value: function add(symbol) {\n      return this.operation('add', symbol);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(symbol) {\n      return this.operation('subtract', symbol);\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(symbol) {\n      return this.operation('multiply', symbol);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(symbol) {\n      return this.operation('divide', symbol);\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(symbol) {\n      return this.operation('pow', symbol);\n    }\n  }, {\n    key: \"expand\",\n    value: function expand() {\n      return new Expression((0, expand_1.expand)(this.symbol));\n    }\n  }, {\n    key: \"each\",\n    value: function each(callback, i) {\n      if (this.symbol.each) this.symbol.each(callback, i);else if (Array.isArray(this.symbol)) {\n        for (var _i = 0; _i < this.symbol.length; _i++) {\n          callback.call(this.symbol, this.symbol[_i], _i);\n        }\n      } else callback.call(this.symbol);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(value) {\n      if (!(0, Utils_1.isSymbol)(value)) value = (0, Parser_1.parse)(value);\n      try {\n        var d = (0, Core_1.subtract)(this.symbol.clone(), value);\n        return d.equals(0);\n      } catch (e) {\n        return false;\n      }\n    }\n  }, {\n    key: \"lt\",\n    value: function lt(value) {\n      if (!(0, Utils_1.isSymbol)(value)) value = (0, Parser_1.parse)(value);\n      try {\n        var d = (0, Parser_1.evaluate)((0, Core_1.subtract)(this.symbol.clone(), value));\n        return d.lessThan(0);\n      } catch (e) {\n        return false;\n      }\n    }\n  }, {\n    key: \"gt\",\n    value: function gt(value) {\n      if (!(0, Utils_1.isSymbol)(value)) value = (0, Parser_1.parse)(value);\n      try {\n        var d = (0, Parser_1.evaluate)((0, Core_1.subtract)(this.symbol.clone(), value));\n        return d.greaterThan(0);\n      } catch (e) {\n        return false;\n      }\n    }\n  }, {\n    key: \"gte\",\n    value: function gte(value) {\n      return this.gt(value) || this.eq(value);\n    }\n  }, {\n    key: \"lte\",\n    value: function lte(value) {\n      return this.lt(value) || this.eq(value);\n    }\n  }, {\n    key: \"numerator\",\n    value: function numerator() {\n      return new Expression(this.symbol.getNum());\n    }\n  }, {\n    key: \"denominator\",\n    value: function denominator() {\n      return new Expression(this.symbol.getDenom());\n    }\n  }, {\n    key: \"hasFunction\",\n    value: function hasFunction(f) {\n      return this.symbol.containsFunction(f);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(variable) {\n      return this.symbol.contains(variable);\n    }\n  }, {\n    key: \"toTeX\",\n    value: function toTeX(option) {\n      return this.latex(option);\n    }\n  }], [{\n    key: \"getExpression\",\n    value: function getExpression(expression_number) {\n      var asType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (expression_number === 'last' || !expression_number) expression_number = Expression.$EXPRESSIONS.length;\n      if (expression_number === 'first') expression_number = 1;\n      var index = expression_number - 1,\n        expression = Expression.$EXPRESSIONS[index];\n      return expression ? new Expression(expression) : expression;\n    }\n  }]);\n  return Expression;\n}();\nexports.Expression = Expression;","map":{"version":3,"mappings":"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","names":["Expression","symbol","opt","n","text_","undefined","option","latex","LaTeX_1","valueOf","dimensions","first_arg","arguments","expression","idx","charAt","getExpression","substr","text","subs","vars","Build_1","build","Math","abs","multiplier","Infinity","isImaginary","variables","Array","isArray","toString","e","prec","Settings_1","precision","dec","isPoly","for_symbol","sub","otype","isExpression","Parser_1","parser","getAction","clone","operation","callback","i","each","length","call","value","d","equals","lessThan","greaterThan","gt","eq","lt","getNum","getDenom","f","containsFunction","variable","contains","expression_number","asType","$EXPRESSIONS","index","exports"],"sourceRoot":"","sources":["../../src/Parser/Expression.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}