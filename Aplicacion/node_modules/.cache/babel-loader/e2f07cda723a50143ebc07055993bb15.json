{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.default = parser;\n\nvar _Node = require(\"./Node\");\n\nvar _Node2 = _interopRequireDefault(_Node);\n\nvar _Token = require(\"./Token\");\n\nvar _Token2 = _interopRequireDefault(_Token);\n\nvar _arities = require(\"./util/arities\");\n\nvar _arities2 = _interopRequireDefault(_arities);\n\nvar _localFunctions = require(\"./util/localFunctions\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Parser\n// ======\n// The parser takes a list of Token objects and tries to construct a syntax\n// tree that represents the math to be evaluated, taking into account the\n// correct order of operations.\n// This is a simple recursive-descent parser based on [Wikipedia's example](https://en.wikipedia.org/wiki/Recursive_descent_parser).\n\n\nfunction parser(tokens) {\n  var p = new Parser(tokens);\n  return p.parse();\n}\n\n;\n\nvar Parser = function () {\n  function Parser() {\n    var tokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, Parser);\n\n    this.cursor = 0;\n    this.tokens = tokens;\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse() {\n      //this.preprocess();\n      var ast = this.sum();\n      ast = ast.simplify(); // Throw an exception if there are still tokens remaining after parsing\n\n      if (this.currentToken !== undefined) {\n        console.log(ast.printTree());\n        throw \"Parsing error: Expected end of input, but got \" + this.currentToken.type + \" \" + this.currentToken.value;\n      }\n\n      return ast;\n    } //preprocess() {\n    // This function used to contain procedures to remove whitespace\n    // tokens and replace symbol tokens with functions, but that work\n    // has been moved to the lexer in order to keep the parser more\n    // lightweight.\n    //}\n\n    /**\n     * Accepts the current token if it matches the given type.\n     * If it does, the cursor is incremented and this method returns true.\n     * If it doesn't, the cursor stays where it is and this method returns false.\n     * @param type Type of token to accept.\n     * @returns {boolean} True if the token was accepted.\n     */\n\n  }, {\n    key: \"accept\",\n    value: function accept(type) {\n      if (this.currentToken && this.currentToken.type === type) {\n        this.cursor++;\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Accepts the current token if it matches the given type.\n     * If it does, the cursor is incremented.\n     * If it doesn't, an exception is raised.\n     * @param type\n     */\n\n  }, {\n    key: \"expect\",\n    value: function expect(type) {\n      if (!this.accept(type)) {\n        throw \"Expected \" + type + \" but got \" + (this.currentToken ? this.currentToken.toString() : \"end of input.\");\n      }\n    } // Rules\n    // -----\n\n    /**\n     * Parses a math expression with\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum() {\n      var node = new _Node2.default(_Node2.default.TYPE_SUM);\n      node.addChild(this.product());\n\n      while (true) {\n        // Continue to accept chained addends\n        if (this.accept(_Token2.default.TYPE_PLUS)) {\n          node.addChild(this.product());\n        } else if (this.accept(_Token2.default.TYPE_MINUS)) {\n          node.addChild(new _Node2.default(_Node2.default.TYPE_NEGATE).addChild(this.product()));\n        } else {\n          break;\n        }\n      }\n\n      return node;\n    }\n  }, {\n    key: \"product\",\n    value: function product() {\n      var node = new _Node2.default(_Node2.default.TYPE_PRODUCT);\n      node.addChild(this.power());\n\n      while (true) {\n        // Continue to accept chained multiplicands\n        if (this.accept(_Token2.default.TYPE_TIMES)) {\n          node.addChild(this.power());\n        } else if (this.accept(_Token2.default.TYPE_DIVIDE)) {\n          node.addChild(new _Node2.default(_Node2.default.TYPE_INVERSE).addChild(this.power()));\n        } else if (this.accept(_Token2.default.TYPE_LPAREN)) {\n          this.cursor--;\n          node.addChild(this.power());\n        } else if (this.accept(_Token2.default.TYPE_SYMBOL) || this.accept(_Token2.default.TYPE_NUMBER) || this.accept(_Token2.default.TYPE_FUNCTION)) {\n          this.cursor--;\n          node.addChild(this.power());\n        } else {\n          break;\n        }\n      }\n\n      return node;\n    }\n  }, {\n    key: \"power\",\n    value: function power() {\n      var node = new _Node2.default(_Node2.default.TYPE_POWER);\n      node.addChild(this.val()); // If a chained power is encountered (e.g. a ^ b ^ c), treat it like\n      // a ^ (b ^ c)\n\n      if (this.accept(_Token2.default.TYPE_POWER)) {\n        node.addChild(this.power());\n      }\n\n      return node;\n    }\n  }, {\n    key: \"val\",\n    value: function val() {\n      // Don't create a new node immediately, since we need to parse postfix\n      // operators like factorials, which come after a value.\n      var node = {};\n\n      if (this.accept(_Token2.default.TYPE_SYMBOL)) {\n        node = new _Node2.default(_Node2.default.TYPE_SYMBOL, this.prevToken.value);\n      } else if (this.accept(_Token2.default.TYPE_NUMBER)) {\n        node = new _Node2.default(_Node2.default.TYPE_NUMBER, parseFloat(this.prevToken.value));\n      } else if (this.accept(_Token2.default.TYPE_COMMAND)) {\n        var cmdToken = this.prevToken;\n        node = new _Node2.default(_Node2.default.TYPE_FUNCTION, cmdToken.value);\n        node.name = cmdToken.name;\n\n        for (var i = 0; i < _arities2.default[cmdToken.name]; i++) {\n          node.addChild(this.val());\n        }\n      } else if (this.accept(_Token2.default.TYPE_FUNCTION)) {\n        node = new _Node2.default(_Node2.default.TYPE_FUNCTION, this.prevToken.value);\n        node.name = this.prevToken.name; // Multi-param functions require parens and have commas\n\n        if (this.accept(_Token2.default.TYPE_LPAREN)) {\n          node.addChild(this.sum());\n\n          while (this.accept(_Token2.default.TYPE_COMMA)) {\n            node.addChild(this.sum());\n          }\n\n          this.expect(_Token2.default.TYPE_RPAREN);\n        } // Single-parameter functions don't need parens\n        else {\n          node.addChild(this.power());\n        }\n      } else if (this.accept(_Token2.default.TYPE_MINUS)) {\n        node = new _Node2.default(_Node2.default.TYPE_NEGATE).addChild(this.power());\n      } else if (this.accept(_Token2.default.TYPE_LPAREN)) {\n        node = this.sum();\n        this.expect(_Token2.default.TYPE_RPAREN);\n      } else if (this.accept(_Token2.default.TYPE_ABS)) {\n        node = new _Node2.default(_Node2.default.TYPE_FUNCTION, Math.abs);\n        node.addChild(this.sum());\n        this.expect(_Token2.default.TYPE_ABS);\n      } else {\n        throw \"Unexpected \" + this.currentToken.toString() + \" at token \" + this.cursor;\n      }\n\n      if (this.accept(_Token2.default.TYPE_BANG)) {\n        var factNode = new _Node2.default(_Node2.default.TYPE_FUNCTION, _localFunctions.fact);\n        factNode.addChild(node);\n        return factNode;\n      }\n\n      return node;\n    }\n  }, {\n    key: \"currentToken\",\n    get: function get() {\n      return this.tokens[this.cursor];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.cursor - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n/*\n// Non-terminal rules\n// ------------------\n\n// The following parser functions match certain motifs that are called\n// \"non-terminals\" in parsing lingo.\n// Essentially, they implement a sort of finite state automaton.\n// You should read the [Wikipedia article](https://en.wikipedia.org/wiki/Recursive_descent_parser) on recursive-descent parsing if you want to know more about how these work.\n\n// ### Grammar:\n// ```\n// orderExpression : sum\n// sum : product { ('+'|'-') product }\n// product : power { ('*'|'/') power }\n//         | power '(' orderExpression ')'\n// power : TODO power\n// val : SYMBOL\n//     | NUMBER\n//     | FUNCTION '(' orderExpression { ',' orderExpression } ')'\n//     | '-' val\n//     | '(' orderExpression ')'\n//     | '{' orderExpression '}'\n//     | '|' orderExpression '|'\n//     | val '!'\n// ```\n*/\n// Parses values or nested expressions.\n//Parser.prototype.val = function() {\n// Don't return new nodes immediately, since we need to parse\n// factorials, which come at the END of values.\n//var node = {};\n// Parse negative values like -42.\n// The lexer can't differentiate between a difference and a negative,\n// so that distinction is done here.\n// Notice the `power()` rule that comes after a negative sign so that\n// expressions like `-4^2` return -16 instead of 16.\n// Parse nested expression with parentheses.\n// Notice that the parser expects an RPAREN token after the expression.\n// Parse absolute value.\n// Absolute values are contained in pipes (`|`) and are treated quite\n// like parens.\n// All parsing rules should have terminated or recursed by now.\n// Throw an exception if this is not the case.\n// Process postfix operations like factorials.\n// Parse factorial.\n//return node;\n//};","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","default","parser","_Node","require","_Node2","_interopRequireDefault","_Token","_Token2","_arities","_arities2","_localFunctions","obj","__esModule","_classCallCheck","instance","TypeError","tokens","p","Parser","parse","arguments","undefined","cursor","ast","sum","simplify","currentToken","console","log","printTree","type","accept","expect","toString","node","TYPE_SUM","addChild","product","TYPE_PLUS","TYPE_MINUS","TYPE_NEGATE","TYPE_PRODUCT","power","TYPE_TIMES","TYPE_DIVIDE","TYPE_INVERSE","TYPE_LPAREN","TYPE_SYMBOL","TYPE_NUMBER","TYPE_FUNCTION","TYPE_POWER","val","prevToken","parseFloat","TYPE_COMMAND","cmdToken","name","TYPE_COMMA","TYPE_RPAREN","TYPE_ABS","Math","abs","TYPE_BANG","factNode","fact","get"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/evaluatex/dist/parser.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.default = parser;\n\nvar _Node = require(\"./Node\");\n\nvar _Node2 = _interopRequireDefault(_Node);\n\nvar _Token = require(\"./Token\");\n\nvar _Token2 = _interopRequireDefault(_Token);\n\nvar _arities = require(\"./util/arities\");\n\nvar _arities2 = _interopRequireDefault(_arities);\n\nvar _localFunctions = require(\"./util/localFunctions\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Parser\n// ======\n\n// The parser takes a list of Token objects and tries to construct a syntax\n// tree that represents the math to be evaluated, taking into account the\n// correct order of operations.\n// This is a simple recursive-descent parser based on [Wikipedia's example](https://en.wikipedia.org/wiki/Recursive_descent_parser).\n\nfunction parser(tokens) {\n    var p = new Parser(tokens);\n    return p.parse();\n};\n\nvar Parser = function () {\n    function Parser() {\n        var tokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n        _classCallCheck(this, Parser);\n\n        this.cursor = 0;\n        this.tokens = tokens;\n    }\n\n    _createClass(Parser, [{\n        key: \"parse\",\n        value: function parse() {\n            //this.preprocess();\n            var ast = this.sum();\n            ast = ast.simplify();\n\n            // Throw an exception if there are still tokens remaining after parsing\n            if (this.currentToken !== undefined) {\n                console.log(ast.printTree());\n                throw \"Parsing error: Expected end of input, but got \" + this.currentToken.type + \" \" + this.currentToken.value;\n            }\n\n            return ast;\n        }\n\n        //preprocess() {\n        // This function used to contain procedures to remove whitespace\n        // tokens and replace symbol tokens with functions, but that work\n        // has been moved to the lexer in order to keep the parser more\n        // lightweight.\n        //}\n\n        /**\n         * Accepts the current token if it matches the given type.\n         * If it does, the cursor is incremented and this method returns true.\n         * If it doesn't, the cursor stays where it is and this method returns false.\n         * @param type Type of token to accept.\n         * @returns {boolean} True if the token was accepted.\n         */\n\n    }, {\n        key: \"accept\",\n        value: function accept(type) {\n            if (this.currentToken && this.currentToken.type === type) {\n                this.cursor++;\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * Accepts the current token if it matches the given type.\n         * If it does, the cursor is incremented.\n         * If it doesn't, an exception is raised.\n         * @param type\n         */\n\n    }, {\n        key: \"expect\",\n        value: function expect(type) {\n            if (!this.accept(type)) {\n                throw \"Expected \" + type + \" but got \" + (this.currentToken ? this.currentToken.toString() : \"end of input.\");\n            }\n        }\n\n        // Rules\n        // -----\n\n        /**\n         * Parses a math expression with\n         */\n\n    }, {\n        key: \"sum\",\n        value: function sum() {\n            var node = new _Node2.default(_Node2.default.TYPE_SUM);\n            node.addChild(this.product());\n\n            while (true) {\n                // Continue to accept chained addends\n                if (this.accept(_Token2.default.TYPE_PLUS)) {\n                    node.addChild(this.product());\n                } else if (this.accept(_Token2.default.TYPE_MINUS)) {\n                    node.addChild(new _Node2.default(_Node2.default.TYPE_NEGATE).addChild(this.product()));\n                } else {\n                    break;\n                }\n            }\n\n            return node;\n        }\n    }, {\n        key: \"product\",\n        value: function product() {\n            var node = new _Node2.default(_Node2.default.TYPE_PRODUCT);\n            node.addChild(this.power());\n\n            while (true) {\n                // Continue to accept chained multiplicands\n\n                if (this.accept(_Token2.default.TYPE_TIMES)) {\n                    node.addChild(this.power());\n                } else if (this.accept(_Token2.default.TYPE_DIVIDE)) {\n                    node.addChild(new _Node2.default(_Node2.default.TYPE_INVERSE).addChild(this.power()));\n                } else if (this.accept(_Token2.default.TYPE_LPAREN)) {\n                    this.cursor--;\n                    node.addChild(this.power());\n                } else if (this.accept(_Token2.default.TYPE_SYMBOL) || this.accept(_Token2.default.TYPE_NUMBER) || this.accept(_Token2.default.TYPE_FUNCTION)) {\n                    this.cursor--;\n                    node.addChild(this.power());\n                } else {\n                    break;\n                }\n            }\n\n            return node;\n        }\n    }, {\n        key: \"power\",\n        value: function power() {\n            var node = new _Node2.default(_Node2.default.TYPE_POWER);\n            node.addChild(this.val());\n\n            // If a chained power is encountered (e.g. a ^ b ^ c), treat it like\n            // a ^ (b ^ c)\n            if (this.accept(_Token2.default.TYPE_POWER)) {\n                node.addChild(this.power());\n            }\n\n            return node;\n        }\n    }, {\n        key: \"val\",\n        value: function val() {\n            // Don't create a new node immediately, since we need to parse postfix\n            // operators like factorials, which come after a value.\n            var node = {};\n\n            if (this.accept(_Token2.default.TYPE_SYMBOL)) {\n                node = new _Node2.default(_Node2.default.TYPE_SYMBOL, this.prevToken.value);\n            } else if (this.accept(_Token2.default.TYPE_NUMBER)) {\n                node = new _Node2.default(_Node2.default.TYPE_NUMBER, parseFloat(this.prevToken.value));\n            } else if (this.accept(_Token2.default.TYPE_COMMAND)) {\n                var cmdToken = this.prevToken;\n                node = new _Node2.default(_Node2.default.TYPE_FUNCTION, cmdToken.value);\n                node.name = cmdToken.name;\n\n                for (var i = 0; i < _arities2.default[cmdToken.name]; i++) {\n                    node.addChild(this.val());\n                }\n            } else if (this.accept(_Token2.default.TYPE_FUNCTION)) {\n                node = new _Node2.default(_Node2.default.TYPE_FUNCTION, this.prevToken.value);\n                node.name = this.prevToken.name;\n\n                // Multi-param functions require parens and have commas\n                if (this.accept(_Token2.default.TYPE_LPAREN)) {\n                    node.addChild(this.sum());\n\n                    while (this.accept(_Token2.default.TYPE_COMMA)) {\n                        node.addChild(this.sum());\n                    }\n\n                    this.expect(_Token2.default.TYPE_RPAREN);\n                }\n\n                // Single-parameter functions don't need parens\n                else {\n                        node.addChild(this.power());\n                    }\n            } else if (this.accept(_Token2.default.TYPE_MINUS)) {\n                node = new _Node2.default(_Node2.default.TYPE_NEGATE).addChild(this.power());\n            } else if (this.accept(_Token2.default.TYPE_LPAREN)) {\n                node = this.sum();\n                this.expect(_Token2.default.TYPE_RPAREN);\n            } else if (this.accept(_Token2.default.TYPE_ABS)) {\n                node = new _Node2.default(_Node2.default.TYPE_FUNCTION, Math.abs);\n                node.addChild(this.sum());\n                this.expect(_Token2.default.TYPE_ABS);\n            } else {\n                throw \"Unexpected \" + this.currentToken.toString() + \" at token \" + this.cursor;\n            }\n\n            if (this.accept(_Token2.default.TYPE_BANG)) {\n                var factNode = new _Node2.default(_Node2.default.TYPE_FUNCTION, _localFunctions.fact);\n                factNode.addChild(node);\n                return factNode;\n            }\n\n            return node;\n        }\n    }, {\n        key: \"currentToken\",\n        get: function get() {\n            return this.tokens[this.cursor];\n        }\n    }, {\n        key: \"prevToken\",\n        get: function get() {\n            return this.tokens[this.cursor - 1];\n        }\n    }]);\n\n    return Parser;\n}();\n\n/*\n// Non-terminal rules\n// ------------------\n\n// The following parser functions match certain motifs that are called\n// \"non-terminals\" in parsing lingo.\n// Essentially, they implement a sort of finite state automaton.\n// You should read the [Wikipedia article](https://en.wikipedia.org/wiki/Recursive_descent_parser) on recursive-descent parsing if you want to know more about how these work.\n\n// ### Grammar:\n// ```\n// orderExpression : sum\n// sum : product { ('+'|'-') product }\n// product : power { ('*'|'/') power }\n//         | power '(' orderExpression ')'\n// power : TODO power\n// val : SYMBOL\n//     | NUMBER\n//     | FUNCTION '(' orderExpression { ',' orderExpression } ')'\n//     | '-' val\n//     | '(' orderExpression ')'\n//     | '{' orderExpression '}'\n//     | '|' orderExpression '|'\n//     | val '!'\n// ```\n*/\n\n// Parses values or nested expressions.\n//Parser.prototype.val = function() {\n// Don't return new nodes immediately, since we need to parse\n// factorials, which come at the END of values.\n//var node = {};\n\n\n// Parse negative values like -42.\n// The lexer can't differentiate between a difference and a negative,\n// so that distinction is done here.\n// Notice the `power()` rule that comes after a negative sign so that\n// expressions like `-4^2` return -16 instead of 16.\n\n\n// Parse nested expression with parentheses.\n// Notice that the parser expects an RPAREN token after the expression.\n\n\n// Parse absolute value.\n// Absolute values are contained in pipes (`|`) and are treated quite\n// like parens.\n\n\n// All parsing rules should have terminated or recursed by now.\n// Throw an exception if this is not the case.\n\n\n// Process postfix operations like factorials.\n\n// Parse factorial.\n\n\n//return node;\n//};"],"mappings":"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"},"metadata":{},"sourceType":"script"}