{"ast":null,"code":"export var defaultShader = function defaultShader() {\n  return \"\\n#define AA 2\\n\\nfloat sdPlane(vec3 p, vec4 n) {\\n    return dot(p, n.xyz) + n.w;\\n}\\n\\nfloat shrepe(in vec3 p) {\\n    return length(p) - 1.0;\\n}\\n\\nfloat sdRoundBox(vec3 p, vec3 b, float r)\\n{\\n    vec3 d = abs(p) - b;\\n    return length(max(d, 0.0)) - r\\n    + min(max(d.x, max(d.y, d.z)), 0.0);// remove this line for an only partially signed sdf\\n}\\n\\nfloat easeSmoothStep(float x) {\\n    return -2.0 * x * x * x + 3.0 * x * x;\\n}\\n\\nfloat map(in vec3 p0, out vec4 oTrap, in vec4 c) {\\n    oTrap = vec4(1, 1, 1, 0.5);\\n    vec3 p = p0;\\n\\n    vec3 scale = vec3(0.5, 0.5, 0.8);\\n    float s1 = shrepe(p / scale) * min(scale.x, min(scale.y, scale.z));\\n    float t1 = sdRoundBox(p, vec3(0.5 - 0.1, 0.5 - 0.1, 0.8 - 0.1), 0.1);\\n    float ll = 2.0 * (clamp(sin(iTime), -0.25, 0.25) + 0.25);\\n\\n    s1 = mix(s1, t1, easeSmoothStep(ll));\\n\\n    float s2 = shrepe(p / 0.25 +  vec3(4.0 * cos(iTime * 4.0), 4.0 * sin(iTime * 4.0), 0)) * 0.25;\\n\\n    float spheres = min(s1, s2);\\n    float plane = sdPlane(p, vec4(0, 1, 0, 1.5));\\n    if (plane < spheres) {\\n        oTrap.x = -0.5;\\n        oTrap.w = 0.0;\\n    }\\n    return min(plane, spheres);\\n}\\n\\nvec3 calcNormal(in vec3 pos, in vec4 c) {\\n    vec4 kk;\\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.001;\\n    return normalize(e.xyy*map(pos + e.xyy, kk, c) +\\n                        e.yyx*map(pos + e.yyx, kk, c) +\\n                        e.yxy*map(pos + e.yxy, kk, c) +\\n                        e.xxx*map(pos + e.xxx, kk, c));\\n}\\n\\nfloat intersect(in vec3 ro, in vec3 rd, out vec4 res, in vec4 c) {\\n    vec4 tmp;\\n    float resT = -1.0;\\n    float maxd = 20.0;\\n    float h = 1.0;\\n    float t = 0.0;\\n    for (int i=0; i<64; i++)\\n    {\\n        h = map(ro+rd*t, tmp, c);\\n        if (h<0.001||t>maxd) break;\\n        t += h;\\n    }\\n    if (t<maxd) { resT=t; res = tmp; }\\n\\n    return resT;\\n}\\n\\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float k, in vec4 c)\\n{\\n    float res = 1.0;\\n    float t = mint;\\n    for (int i=0; i<64; i++)\\n    {\\n        vec4 kk;\\n        float h = map(ro + rd*t, kk, c);\\n        res = min(res, k*h/t);\\n        if (res<0.001) break;\\n        t += clamp(h, 0.01, 0.5);\\n    }\\n    return clamp(res, 0.0, 1.0);\\n}\\n\\n    #define MISS_BOTTOM vec3(1.0, 0.0, 0.0)\\n    #define MISS_TOP vec3(0.0, 0.0, 1.0)\\n\\n    #define MATE_COLOR vec3(0.9, 0.5, 0.5) * 0.3\\n\\nvec3 applyFog(in vec3  rgb, in vec3 skyColor, in float distance) {\\n    float startDist = 8.0;\\n    float fogAmount = 2.0 * (1.0 - exp(-(distance-startDist) * (1.0/startDist)));\\n    return mix(rgb, skyColor, clamp(fogAmount, 0.0, 1.0));\\n}\\n\\n// https://iquilezles.org/articles/checkerfiltering\\nfloat checkersGradBox(vec2 p) {\\n    vec2 w = fwidth(p) + 0.001;\\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\\n    return 0.5 - 0.5*i.x*i.y;\\n}\\n\\nvec3 render(in vec3 ro, in vec3 rd, in vec4 c)\\n{\\n    const vec3 sun = vec3(0.6, 0.6, 0.6);\\n    vec4 tra;\\n    float t = intersect(ro, rd, tra, c);\\n\\n    vec3 skybox = mix(MISS_BOTTOM, MISS_TOP, rd.y);\\n    vec3 col = skybox;\\n    if (t > 0.0) {\\n        vec3 pos = ro + t*rd;\\n        vec3 nor = calcNormal(pos, c);\\n\\n        vec3 mate = MATE_COLOR;\\n        //        mate.x = 1.0-10.0*tra.x;\\n        if (tra.x <= -0.5) {\\n            float grid = checkersGradBox(pos.xz*0.4) * 0.2 + 0.1;\\n            mate = vec3(grid, grid, grid);\\n        }\\n\\n        float occ = clamp(2.5*tra.w-0.15, 0.0, 1.0);\\n        //        float occ = 0.5;\\n\\n        col = vec3(0.0, 0.0, 0.0);\\n\\n        // sky\\n        {\\n            float co = clamp(dot(-rd, nor), 0.0, 1.0);\\n            vec3 ref = reflect(rd, nor);\\n            float shadow = softshadow(pos+0.0005*nor, ref, 0.001, 4.0, c);\\n            //            float sha = occ;\\n            shadow *= smoothstep(-0.1, 0.1, ref.y);\\n            vec3 shadowc = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\\n            float fre = 0.1 + 0.9*pow(1.0-co, 5.0);\\n\\n            vec3 sky_color = vec3(0.8, 0.9, 1.0);\\n            col  = mate*0.3*sky_color*(0.6+0.4*nor.y)*occ;\\n            col +=  2.0*0.3*sky_color*(0.6+0.4*nor.y)*shadowc*fre;\\n        }\\n\\n        // sun\\n        {\\n            const vec3 lig = sun;\\n            float dif = clamp(dot(lig, nor), 0.0, 1.0);\\n            float shadow = softshadow(pos, lig, 0.001, 64.0, c);\\n            vec3 shadowc = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\\n            //            vec3 shadowc = vec3(shadow);\\n            vec3 hal = normalize(-rd+lig);\\n            float co = clamp(dot(hal, lig), 0.0, 1.0);\\n            float fre = 0.04 + 0.96*pow(1.0-co, 5.0);\\n            float spe = pow(clamp(dot(hal, nor), 0.0, 1.0), 32.0);\\n\\n            vec3 sun_color = vec3(1, 0.9, 0.7);\\n            vec3 sun_color2 = vec3(1, 0.9, 0.7);\\n            //vec3(1.00,0.90,0.70)\\n\\n            col += mate*3.5*sun_color*dif*shadowc;\\n            col +=  7.0*3.5*sun_color2*spe*dif*shadowc*fre;\\n        }\\n\\n        // extra fill\\n        {\\n            const vec3 lig = vec3(-0.707, 0.000, -0.707);\\n            float dif = clamp(0.5+0.5*dot(lig, nor), 0.0, 1.0);\\n            mate = vec3(0, 1, 0);\\n            col += mate* 1.5*vec3(0.14, 0.14, 0.14)*dif*occ;\\n        }\\n\\n        // fake SSS\\n        {\\n            float fre = clamp(1.+dot(rd, nor), 0.0, 1.0);\\n            mate = skybox;\\n            col += mate* mate*0.6*fre*fre*(0.2+0.8*occ);\\n        }\\n\\n        col = applyFog(col, skybox, t);\\n    }\\n    return col;\\n}\\n\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec2 screenCoord = fragCoord.xy;\\n    float t = iTime;\\n    vec4 c = 0.45*cos(vec4(0.5, 3.9, 1.4, 1.1) + t*vec4(1.2, 1.7, 1.3, 2.5)) - vec4(0.3, 0.0, 0.0, 0.0);\\n\\n    // camera\\n\\n    float camTrackRadius = 3.0 + sin(t);\\n    vec3 camTarget = vec3(0, 0, 0);\\n    vec3 camPos = vec3(camTrackRadius * cos(t), 1.0 + 0.5 * sin(t * 0.5), camTrackRadius * sin(t));\\n    vec3 camForward = normalize(camTarget - camPos);\\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\\n    vec3 camUp = normalize(cross(camForward, camRight));\\n\\n    float fPersp = 2.0;\\n\\n    // render\\n    vec3 col = vec3(0.0);\\n    for (int j=0; j<AA; j++) {\\n        for (int i=0; i<AA; i++) {\\n            vec2 offf = vec2(float(i), float(j))/float(AA);\\n            vec2 result = 2.0 * ((screenCoord + offf) / iResolution.xy - 0.5);\\n            result.x *= iResolution.x/iResolution.y;// Correct for aspect ratio\\n            vec2 p = result;\\n            vec3 vDir = normalize(p.x * camRight + p.y * camUp + camForward * fPersp);\\n            col += render(camPos, vDir, c);\\n        }\\n    }\\n    col /= float(AA*AA);\\n    col = pow(col, vec3(1.0 / 2.2));\\n\\n    vec2 uv = screenCoord.xy / iResolution.xy;\\n    col *= 0.2 + 0.8*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.25);\\n\\n    fragColor = vec4(col, 1.0);\\n}\\n\";\n};","map":{"version":3,"names":["defaultShader"],"sources":["C:/Users/daniz/TFG/Aplicacion/src/defaultShader.js"],"sourcesContent":["export const defaultShader = () => `\r\n#define AA 2\r\n\r\nfloat sdPlane(vec3 p, vec4 n) {\r\n    return dot(p, n.xyz) + n.w;\r\n}\r\n\r\nfloat shrepe(in vec3 p) {\r\n    return length(p) - 1.0;\r\n}\r\n\r\nfloat sdRoundBox(vec3 p, vec3 b, float r)\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return length(max(d, 0.0)) - r\r\n    + min(max(d.x, max(d.y, d.z)), 0.0);// remove this line for an only partially signed sdf\r\n}\r\n\r\nfloat easeSmoothStep(float x) {\r\n    return -2.0 * x * x * x + 3.0 * x * x;\r\n}\r\n\r\nfloat map(in vec3 p0, out vec4 oTrap, in vec4 c) {\r\n    oTrap = vec4(1, 1, 1, 0.5);\r\n    vec3 p = p0;\r\n\r\n    vec3 scale = vec3(0.5, 0.5, 0.8);\r\n    float s1 = shrepe(p / scale) * min(scale.x, min(scale.y, scale.z));\r\n    float t1 = sdRoundBox(p, vec3(0.5 - 0.1, 0.5 - 0.1, 0.8 - 0.1), 0.1);\r\n    float ll = 2.0 * (clamp(sin(iTime), -0.25, 0.25) + 0.25);\r\n\r\n    s1 = mix(s1, t1, easeSmoothStep(ll));\r\n\r\n    float s2 = shrepe(p / 0.25 +  vec3(4.0 * cos(iTime * 4.0), 4.0 * sin(iTime * 4.0), 0)) * 0.25;\r\n\r\n    float spheres = min(s1, s2);\r\n    float plane = sdPlane(p, vec4(0, 1, 0, 1.5));\r\n    if (plane < spheres) {\r\n        oTrap.x = -0.5;\r\n        oTrap.w = 0.0;\r\n    }\r\n    return min(plane, spheres);\r\n}\r\n\r\nvec3 calcNormal(in vec3 pos, in vec4 c) {\r\n    vec4 kk;\r\n    vec2 e = vec2(1.0, -1.0)*0.5773*0.001;\r\n    return normalize(e.xyy*map(pos + e.xyy, kk, c) +\r\n                        e.yyx*map(pos + e.yyx, kk, c) +\r\n                        e.yxy*map(pos + e.yxy, kk, c) +\r\n                        e.xxx*map(pos + e.xxx, kk, c));\r\n}\r\n\r\nfloat intersect(in vec3 ro, in vec3 rd, out vec4 res, in vec4 c) {\r\n    vec4 tmp;\r\n    float resT = -1.0;\r\n    float maxd = 20.0;\r\n    float h = 1.0;\r\n    float t = 0.0;\r\n    for (int i=0; i<64; i++)\r\n    {\r\n        h = map(ro+rd*t, tmp, c);\r\n        if (h<0.001||t>maxd) break;\r\n        t += h;\r\n    }\r\n    if (t<maxd) { resT=t; res = tmp; }\r\n\r\n    return resT;\r\n}\r\n\r\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float k, in vec4 c)\r\n{\r\n    float res = 1.0;\r\n    float t = mint;\r\n    for (int i=0; i<64; i++)\r\n    {\r\n        vec4 kk;\r\n        float h = map(ro + rd*t, kk, c);\r\n        res = min(res, k*h/t);\r\n        if (res<0.001) break;\r\n        t += clamp(h, 0.01, 0.5);\r\n    }\r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n    #define MISS_BOTTOM vec3(1.0, 0.0, 0.0)\r\n    #define MISS_TOP vec3(0.0, 0.0, 1.0)\r\n\r\n    #define MATE_COLOR vec3(0.9, 0.5, 0.5) * 0.3\r\n\r\nvec3 applyFog(in vec3  rgb, in vec3 skyColor, in float distance) {\r\n    float startDist = 8.0;\r\n    float fogAmount = 2.0 * (1.0 - exp(-(distance-startDist) * (1.0/startDist)));\r\n    return mix(rgb, skyColor, clamp(fogAmount, 0.0, 1.0));\r\n}\r\n\r\n// https://iquilezles.org/articles/checkerfiltering\r\nfloat checkersGradBox(vec2 p) {\r\n    vec2 w = fwidth(p) + 0.001;\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nvec3 render(in vec3 ro, in vec3 rd, in vec4 c)\r\n{\r\n    const vec3 sun = vec3(0.6, 0.6, 0.6);\r\n    vec4 tra;\r\n    float t = intersect(ro, rd, tra, c);\r\n\r\n    vec3 skybox = mix(MISS_BOTTOM, MISS_TOP, rd.y);\r\n    vec3 col = skybox;\r\n    if (t > 0.0) {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal(pos, c);\r\n\r\n        vec3 mate = MATE_COLOR;\r\n        //        mate.x = 1.0-10.0*tra.x;\r\n        if (tra.x <= -0.5) {\r\n            float grid = checkersGradBox(pos.xz*0.4) * 0.2 + 0.1;\r\n            mate = vec3(grid, grid, grid);\r\n        }\r\n\r\n        float occ = clamp(2.5*tra.w-0.15, 0.0, 1.0);\r\n        //        float occ = 0.5;\r\n\r\n        col = vec3(0.0, 0.0, 0.0);\r\n\r\n        // sky\r\n        {\r\n            float co = clamp(dot(-rd, nor), 0.0, 1.0);\r\n            vec3 ref = reflect(rd, nor);\r\n            float shadow = softshadow(pos+0.0005*nor, ref, 0.001, 4.0, c);\r\n            //            float sha = occ;\r\n            shadow *= smoothstep(-0.1, 0.1, ref.y);\r\n            vec3 shadowc = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\r\n            float fre = 0.1 + 0.9*pow(1.0-co, 5.0);\r\n\r\n            vec3 sky_color = vec3(0.8, 0.9, 1.0);\r\n            col  = mate*0.3*sky_color*(0.6+0.4*nor.y)*occ;\r\n            col +=  2.0*0.3*sky_color*(0.6+0.4*nor.y)*shadowc*fre;\r\n        }\r\n\r\n        // sun\r\n        {\r\n            const vec3 lig = sun;\r\n            float dif = clamp(dot(lig, nor), 0.0, 1.0);\r\n            float shadow = softshadow(pos, lig, 0.001, 64.0, c);\r\n            vec3 shadowc = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));\r\n            //            vec3 shadowc = vec3(shadow);\r\n            vec3 hal = normalize(-rd+lig);\r\n            float co = clamp(dot(hal, lig), 0.0, 1.0);\r\n            float fre = 0.04 + 0.96*pow(1.0-co, 5.0);\r\n            float spe = pow(clamp(dot(hal, nor), 0.0, 1.0), 32.0);\r\n\r\n            vec3 sun_color = vec3(1, 0.9, 0.7);\r\n            vec3 sun_color2 = vec3(1, 0.9, 0.7);\r\n            //vec3(1.00,0.90,0.70)\r\n\r\n            col += mate*3.5*sun_color*dif*shadowc;\r\n            col +=  7.0*3.5*sun_color2*spe*dif*shadowc*fre;\r\n        }\r\n\r\n        // extra fill\r\n        {\r\n            const vec3 lig = vec3(-0.707, 0.000, -0.707);\r\n            float dif = clamp(0.5+0.5*dot(lig, nor), 0.0, 1.0);\r\n            mate = vec3(0, 1, 0);\r\n            col += mate* 1.5*vec3(0.14, 0.14, 0.14)*dif*occ;\r\n        }\r\n\r\n        // fake SSS\r\n        {\r\n            float fre = clamp(1.+dot(rd, nor), 0.0, 1.0);\r\n            mate = skybox;\r\n            col += mate* mate*0.6*fre*fre*(0.2+0.8*occ);\r\n        }\r\n\r\n        col = applyFog(col, skybox, t);\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 screenCoord = fragCoord.xy;\r\n    float t = iTime;\r\n    vec4 c = 0.45*cos(vec4(0.5, 3.9, 1.4, 1.1) + t*vec4(1.2, 1.7, 1.3, 2.5)) - vec4(0.3, 0.0, 0.0, 0.0);\r\n\r\n    // camera\r\n\r\n    float camTrackRadius = 3.0 + sin(t);\r\n    vec3 camTarget = vec3(0, 0, 0);\r\n    vec3 camPos = vec3(camTrackRadius * cos(t), 1.0 + 0.5 * sin(t * 0.5), camTrackRadius * sin(t));\r\n    vec3 camForward = normalize(camTarget - camPos);\r\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\r\n    vec3 camUp = normalize(cross(camForward, camRight));\r\n\r\n    float fPersp = 2.0;\r\n\r\n    // render\r\n    vec3 col = vec3(0.0);\r\n    for (int j=0; j<AA; j++) {\r\n        for (int i=0; i<AA; i++) {\r\n            vec2 offf = vec2(float(i), float(j))/float(AA);\r\n            vec2 result = 2.0 * ((screenCoord + offf) / iResolution.xy - 0.5);\r\n            result.x *= iResolution.x/iResolution.y;// Correct for aspect ratio\r\n            vec2 p = result;\r\n            vec3 vDir = normalize(p.x * camRight + p.y * camUp + camForward * fPersp);\r\n            col += render(camPos, vDir, c);\r\n        }\r\n    }\r\n    col /= float(AA*AA);\r\n    col = pow(col, vec3(1.0 / 2.2));\r\n\r\n    vec2 uv = screenCoord.xy / iResolution.xy;\r\n    col *= 0.2 + 0.8*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.25);\r\n\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n`;\r\n"],"mappings":"AAAA,OAAO,IAAMA,aAAa,GAAG,SAAhBA,aAAgB;EAAA;AAAA,CAAtB"},"metadata":{},"sourceType":"module"}