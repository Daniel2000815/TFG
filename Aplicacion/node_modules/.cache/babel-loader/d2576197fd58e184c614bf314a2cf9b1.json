{"ast":null,"code":"/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\n\n/* global module, Function */\nif (typeof module !== 'undefined') {\n  var nerdamer = require('./nerdamer.core.js');\n\n  require('./Calculus.js');\n}\n\n(function () {\n  \"use strict\";\n  /*shortcuts*/\n\n  var core = nerdamer.getCore(),\n      _ = core.PARSER,\n      N = core.groups.N,\n      P = core.groups.P,\n      S = core.groups.S,\n      EX = core.groups.EX,\n      FN = core.groups.FN,\n      PL = core.groups.PL,\n      CP = core.groups.CP,\n      CB = core.groups.CB,\n      keys = core.Utils.keys,\n      even = core.Utils.even,\n      variables = core.Utils.variables,\n      format = core.Utils.format,\n      round = core.Utils.round,\n      Frac = core.Frac,\n      isInt = core.Utils.isInt,\n      Symbol = core.Symbol,\n      CONST_HASH = core.Settings.CONST_HASH,\n      math = core.Utils.importFunctions(),\n      evaluate = core.Utils.evaluate; //*************** CLASSES ***************//\n\n  /**\r\n   * Converts a symbol into an equivalent polynomial arrays of \r\n   * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n   * Univariate polymials only. \r\n   * @param {Symbol|Number} symbol\r\n   * @param {String} variable The variable name of the polynomial\r\n   * @param {int} order\r\n   */\n\n  function Polynomial(symbol, variable, order) {\n    if (core.Utils.isSymbol(symbol)) {\n      this.parse(symbol);\n      this.variable = this.variable || variable;\n    } else if (!isNaN(symbol)) {\n      order = order || 0;\n      if (variable === undefined) throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\n      this.coeffs = [];\n      this.coeffs[order] = symbol;\n      this.fill(symbol);\n    } else if (typeof symbol === 'string') {\n      this.parse(_.parse(symbol));\n    }\n  }\n  /**\r\n   * Creates a Polynomial given an array of coefficients\r\n   * @param {int[]} arr\r\n   * @param {String} variable\r\n   * @returns {Polynomial}\r\n   */\n\n\n  Polynomial.fromArray = function (arr, variable) {\n    if (typeof variable === 'undefined') throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\n    var p = new Polynomial();\n    p.coeffs = arr;\n    p.variable = variable;\n    return p;\n  };\n\n  Polynomial.fit = function (c1, c2, n, base, p, variable) {\n    //after having looped through and mod 10 the number to get the matching factor\n    var terms = new Array(p + 1),\n        t = n - c2;\n    terms[0] = c2; //the constants is assumed to be correct\n    //constant for x^p is also assumed know so add\n\n    terms[p] = c1;\n    t -= c1 * Math.pow(base, p); //start fitting\n\n    for (var i = p - 1; i > 0; i--) {\n      var b = Math.pow(base, i),\n          //we want as many wholes as possible\n      q = t / b,\n          sign = Math.sign(q);\n      var c = sign * Math.floor(Math.abs(q));\n      t -= c * b;\n      terms[i] = c;\n    }\n\n    if (t !== 0) return null;\n\n    for (var i = 0; i < terms.length; i++) {\n      terms[i] = new Frac(terms[i]);\n    }\n\n    return Polynomial.fromArray(terms, variable);\n  };\n\n  Polynomial.prototype = {\n    /**\r\n     * Converts Symbol to Polynomial\r\n     * @param {Symbol} symbol\r\n     * @param {Array} c - a collector array\r\n     * @returns {Polynomial}\r\n     */\n    parse: function parse(symbol, c) {\n      this.variable = variables(symbol)[0];\n      if (!symbol.isPoly()) throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\n      c = c || [];\n      if (!symbol.power.absEquals(1)) symbol = _.expand(symbol);\n\n      if (symbol.group === core.groups.N) {\n        c[0] = symbol.multiplier;\n      } else if (symbol.group === core.groups.S) {\n        c[symbol.power.toDecimal()] = symbol.multiplier;\n      } else {\n        for (var x in symbol.symbols) {\n          var sub = symbol.symbols[x],\n              p = sub.power;\n          if (core.Utils.isSymbol(p)) throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\n          p = sub.group === N ? 0 : p.toDecimal();\n\n          if (sub.symbols) {\n            this.parse(sub, c);\n          } else {\n            c[p] = sub.multiplier;\n          }\n        }\n      }\n\n      this.coeffs = c;\n      this.fill();\n    },\n\n    /**\r\n     * Fills in the holes in a polynomial with zeroes\r\n     * @param {Number} x - The number to fill the holes with\r\n     */\n    fill: function fill(x) {\n      x = Number(x) || 0;\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        if (this.coeffs[i] === undefined) {\n          this.coeffs[i] = new Frac(x);\n        }\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Removes higher order zeros or a specific coefficient\r\n     * @returns {Array}\r\n     */\n    trim: function trim() {\n      var l = this.coeffs.length;\n\n      while (l--) {\n        var c = this.coeffs[l];\n        var equalsZero = c.equals(0);\n\n        if (c && equalsZero) {\n          if (l === 0) break;\n          this.coeffs.pop();\n        } else break;\n      }\n\n      return this;\n    },\n\n    /*\r\n     * Returns polynomial mod p **currently fails**\r\n     * @param {Number} p\r\n     * @returns {Polynomial}\r\n     */\n    modP: function modP(p) {\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var c = this.coeffs[i];\n\n        if (c < 0) {\n          //go borrow\n          var b; //a coefficient > 0\n\n          for (var j = i; j < l; j++) {\n            //starting from where we left off\n            if (this.coeffs[j] > 0) {\n              b = this.coeffs[j];\n              break;\n            }\n          }\n\n          if (b) {\n            //if such a coefficient exists\n            for (j; j > i; j--) {\n              //go down the line and adjust using p\n              this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\n              this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\n            }\n\n            c = this.coeffs[i]; //reset c\n          }\n        }\n\n        var d = c.mod(p);\n        var w = c.subtract(d).divide(p);\n\n        if (!w.equals(0)) {\n          var up_one = i + 1;\n          var next = this.coeffs[up_one] || new Frac(0);\n          next = next.add(w);\n          this.coeffs[up_one] = new Frac(next);\n          this.coeffs[i] = new Frac(d);\n        }\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Adds together 2 polynomials\r\n     * @param {Polynomial} poly\r\n     */\n    add: function add(poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n            b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.add(b);\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Adds together 2 polynomials\r\n     * @param {Polynomial} poly\r\n     */\n    subtract: function subtract(poly) {\n      var l = Math.max(this.coeffs.length, poly.coeffs.length);\n\n      for (var i = 0; i < l; i++) {\n        var a = this.coeffs[i] || new Frac(0),\n            b = poly.coeffs[i] || new Frac(0);\n        this.coeffs[i] = a.subtract(b);\n      }\n\n      return this;\n    },\n    divide: function divide(poly) {\n      var variable = this.variable,\n          dividend = core.Utils.arrayClone(this.coeffs),\n          divisor = core.Utils.arrayClone(poly.coeffs),\n          n = dividend.length,\n          mp = divisor.length - 1,\n          quotient = []; //loop through the dividend\n\n      for (var i = 0; i < n; i++) {\n        var p = n - (i + 1); //get the difference of the powers\n\n        var d = p - mp; //get the quotient of the coefficients\n\n        var q = dividend[p].divide(divisor[mp]);\n        if (d < 0) break; //the divisor is not greater than the dividend\n        //place it in the quotient\n\n        quotient[d] = q;\n\n        for (var j = 0; j <= mp; j++) {\n          //reduce the dividend\n          dividend[j + d] = dividend[j + d].subtract(divisor[j].multiply(q));\n        }\n      } //clean up\n\n\n      var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(),\n          //pass in x for safety\n      p2 = Polynomial.fromArray(quotient, variable || 'x');\n      return [p2, p1];\n    },\n    multiply: function multiply(poly) {\n      var l1 = this.coeffs.length,\n          l2 = poly.coeffs.length,\n          c = []; //array to be returned\n\n      for (var i = 0; i < l1; i++) {\n        var x1 = this.coeffs[i];\n\n        for (var j = 0; j < l2; j++) {\n          var k = i + j,\n              //add the powers together\n          x2 = poly.coeffs[j],\n              e = c[k] || new Frac(0); //get the existing term from the new array\n\n          c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\n        }\n      }\n\n      this.coeffs = c;\n      return this;\n    },\n\n    /**\r\n     * Checks if a polynomial is zero\r\n     * @returns {Boolean}\r\n     */\n    isZero: function isZero() {\n      var l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var e = this.coeffs[i];\n        if (!e.equals(0)) return false;\n      }\n\n      return true;\n    },\n\n    /** \r\n     * Substitutes in a number n into the polynomial p(n)\r\n     * @param {Number} n\r\n     * @returns {Frac}\r\n     */\n    sub: function sub(n) {\n      var sum = new Frac(0),\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var t = this.coeffs[i];\n        if (!t.equals(0)) sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\n      }\n\n      return sum;\n    },\n\n    /**\r\n     * Returns a clone of the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    clone: function clone() {\n      var p = new Polynomial();\n      p.coeffs = this.coeffs;\n      p.variable = this.variable;\n      return p;\n    },\n\n    /**\r\n     * Gets the degree of the polynomial\r\n     * @returns {Number}\r\n     */\n    deg: function deg() {\n      this.trim();\n      return this.coeffs.length - 1;\n    },\n\n    /**\r\n     * Returns a lead coefficient\r\n     * @returns {Frac}\r\n     */\n    lc: function lc() {\n      return this.coeffs[this.deg()].clone();\n    },\n\n    /**\r\n     * Converts polynomial into a monic polynomial\r\n     * @returns {Polynomial}\r\n     */\n    monic: function monic() {\n      var lc = this.lc(),\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        this.coeffs[i] = this.coeffs[i].divide(lc);\n      }\n\n      return this;\n    },\n\n    /**\r\n     * Returns the GCD of two polynomials\r\n     * @param {Polynomial} poly\r\n     * @returns {Polynomial}\r\n     */\n    gcd: function gcd(poly) {\n      //get the maximum power of each\n      var mp1 = this.coeffs.length - 1,\n          mp2 = poly.coeffs.length - 1,\n          T; //swap so we always have the greater power first\n\n      if (mp1 < mp2) {\n        return poly.gcd(this);\n      }\n\n      var a = this;\n\n      while (!poly.isZero()) {\n        var t = poly.clone();\n        a = a.clone();\n        T = a.divide(t);\n        poly = T[1];\n        a = t;\n      }\n\n      var gcd = core.Math2.QGCD.apply(null, a.coeffs);\n\n      if (!gcd.equals(1)) {\n        var l = a.coeffs.length;\n\n        for (var i = 0; i < l; i++) {\n          a.coeffs[i] = a.coeffs[i].divide(gcd);\n        }\n      }\n\n      return a;\n    },\n\n    /**\r\n     * Differentiates the polynomial\r\n     * @returns {Polynomial}\r\n     */\n    diff: function diff() {\n      var new_array = [],\n          l = this.coeffs.length;\n\n      for (var i = 1; i < l; i++) {\n        new_array.push(this.coeffs[i].multiply(new Frac(i)));\n      }\n\n      this.coeffs = new_array;\n      return this;\n    },\n\n    /**\r\n     * Integrates the polynomial\r\n     * @returns {Polynomial} \r\n     */\n    integrate: function integrate() {\n      var new_array = [0],\n          l = this.coeffs.length;\n\n      for (var i = 0; i < l; i++) {\n        var c = new Frac(i + 1);\n        new_array[c] = this.coeffs[i].divide(c);\n      }\n\n      this.coeffs = new_array;\n      return this;\n    },\n\n    /**\r\n     * Returns the Greatest common factor of the polynomial\r\n     * @param {bool} toPolynomial - true if a polynomial is wanted\r\n     * @returns {Frac|Polynomial}\r\n     */\n    gcf: function gcf(toPolynomial) {\n      //get the first nozero coefficient and returns its power\n      var fnz = function fnz(a) {\n        for (var i = 0; i < a.length; i++) {\n          if (!a[i].equals(0)) return i;\n        }\n      },\n          ca = [];\n\n      for (var i = 0; i < this.coeffs.length; i++) {\n        var c = this.coeffs[i];\n        if (!c.equals(0) && ca.indexOf(c) === -1) ca.push(c);\n      }\n\n      var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\n\n      if (toPolynomial) {\n        var parr = [];\n        parr[p[1] - 1] = p[0];\n        p = Polynomial.fromArray(parr, this.variable).fill();\n      }\n\n      return p;\n    },\n\n    /**\r\n     * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n     * @param {bool} incl_img - Include imaginary numbers \r\n     */\n    quad: function quad(incl_img) {\n      var roots = [];\n      if (this.coeffs.length > 3) throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\n      if (this.coeffs.length === 0) throw new Error('Polynomial array has no terms');\n      var a = this.coeffs[2] || 0,\n          b = this.coeffs[1] || 0,\n          c = this.coeffs[0];\n      var dsc = b * b - 4 * a * c;\n      if (dsc < 0 && !incl_img) return roots;else {\n        roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\n        roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\n      }\n      return roots;\n    },\n\n    /**\r\n     * Makes polynomial square free\r\n     * @returns {Array}\r\n     */\n    squareFree: function squareFree() {\n      var a = this.clone(),\n          i = 1,\n          b = a.clone().diff(),\n          c = a.clone().gcd(b),\n          w = a.divide(c)[0];\n      var output = Polynomial.fromArray([new Frac(1)], a.variable);\n\n      while (!c.equalsNumber(1)) {\n        var y = w.gcd(c);\n        var z = w.divide(y)[0]; //one of the factors may have shown up since it's square but smaller than the \n        //one where finding\n\n        if (!z.equalsNumber(1) && i > 1) {\n          var t = z.clone();\n\n          for (var j = 1; j < i; j++) {\n            t.multiply(z.clone());\n          }\n\n          z = t;\n        }\n\n        output = output.multiply(z);\n        i++;\n        w = y;\n        c = c.divide(y)[0];\n      }\n\n      return [output, w, i];\n    },\n\n    /**\r\n     * Converts polynomial to Symbol\r\n     * @returns {Symbol}\r\n     */\n    toSymbol: function toSymbol() {\n      var l = this.coeffs.length,\n          variable = this.variable;\n      if (l === 0) return new core.Symbol(0);\n      var end = l - 1,\n          str = '';\n\n      for (var i = 0; i < l; i++) {\n        //place the plus sign for all but the last one\n        var plus = i === end ? '' : '+',\n            e = this.coeffs[i];\n        if (!e.equals(0)) str += e + '*' + variable + '^' + i + plus;\n      }\n\n      return _.parse(str);\n    },\n\n    /**\r\n     * Checks if polynomial is equal to a number\r\n     * @param {Number} x\r\n     * @returns {Boolean}\r\n     */\n    equalsNumber: function equalsNumber(x) {\n      this.trim();\n      return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\n    },\n    toString: function toString() {\n      return this.toSymbol().toString();\n    }\n  };\n  /**\r\n   * TODO\r\n   * ===================================================================================\r\n   * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n   * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n   * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n   * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n   * ===================================================================================\r\n   * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n   * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n   * so the symbol multiplier carries the coefficients for all contained symbols.\r\n   * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n   * @param {Array} c The coefficient array\r\n   * @param {boolean} with_order \r\n   * @return {Array}\r\n   */\n\n  Symbol.prototype.coeffs = function (c, with_order) {\n    if (with_order && !this.isPoly(true)) _.error('Polynomial expected when requesting coefficients with order');\n    c = c || [];\n    var s = this.clone().distributeMultiplier();\n\n    if (s.isComposite()) {\n      for (var x in s.symbols) {\n        var sub = s.symbols[x];\n\n        if (sub.isComposite()) {\n          sub.clone().distributeMultiplier().coeffs(c, with_order);\n        } else {\n          if (with_order) c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;else {\n            c.push(sub.multiplier);\n          }\n        }\n      }\n    } else {\n      if (with_order) c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;else {\n        if (s.group === CB && s.isImaginary()) {\n          var m = new Symbol(s.multiplier);\n          s.each(function (x) {\n            //add the imaginary part\n            if (x.isConstant(true) || x.imaginary) m = _.multiply(m, x);\n          });\n          c.push(m);\n        } else c.push(s.multiplier);\n      }\n    } //fill the holes\n\n\n    if (with_order) {\n      for (var i = 0; i < c.length; i++) {\n        if (c[i] === undefined) c[i] = new Symbol(0);\n      }\n    }\n\n    return c;\n  };\n\n  Symbol.prototype.tBase = function (map) {\n    if (typeof map === 'undefined') throw new Error('Symbol.tBase requires a map object!');\n    var terms = [];\n    var symbols = this.collectSymbols(null, null, null, true),\n        l = symbols.length;\n\n    for (var i = 0; i < l; i++) {\n      var symbol = symbols[i],\n          g = symbol.group,\n          nterm = new MVTerm(symbol.multiplier, [], map);\n\n      if (g === CB) {\n        for (var x in symbol.symbols) {\n          var sym = symbol.symbols[x];\n          nterm.terms[map[x]] = sym.power;\n        }\n      } else {\n        nterm.terms[map[symbol.value]] = symbol.power;\n      }\n\n      terms.push(nterm.fill());\n      nterm.updateCount();\n    }\n\n    return terms;\n  };\n\n  Symbol.prototype.altVar = function (x) {\n    var m = this.multiplier.toString(),\n        p = this.power.toString();\n    return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\n  };\n  /**\r\n   * Checks to see if the symbols contain the same variables\r\n   * @param {Symbol} symbol\r\n   * @returns {Boolean}\r\n   */\n\n\n  Symbol.prototype.sameVars = function (symbol) {\n    if (!(this.symbols || this.group === symbol.group)) return false;\n\n    for (var x in this.symbols) {\n      var a = this.symbols[x],\n          b = symbol.symbols[x];\n      if (!b) return false;\n      if (a.value !== b.value) return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Groups the terms in a symbol with respect to a variable\r\n   * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n   * @returns {Factors}\r\n   */\n\n\n  Symbol.prototype.groupTerms = function (x) {\n    x = String(x);\n    var f, p, egrouped;\n    var grouped = [];\n    this.each(function (e) {\n      if (e.group === PL) {\n        egrouped = e.groupTerms(x);\n\n        for (var i = 0; i < egrouped.length; i++) {\n          var el = egrouped[i];\n          if (el) grouped[i] = el;\n        }\n      } else {\n        f = core.Utils.decompose_fn(e, x, true);\n        p = f.x.value === x ? Number(f.x.power) : 0; //check if there's an existing value\n\n        grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\n      }\n    });\n    return grouped;\n  };\n  /**\r\n   * Use this to collect Factors\r\n   * @returns {Symbol[]}\r\n   */\n\n\n  Symbol.prototype.collectFactors = function () {\n    var factors = [];\n    if (this.group === CB) this.each(function (x) {\n      factors.push(x.clone());\n    });else factors.push(this.clone());\n    return factors;\n  };\n  /**\r\n   * A container class for factors\r\n   * @returns {Factors}\r\n   */\n\n\n  function Factors() {\n    this.factors = {};\n    this.length = 0;\n  }\n\n  ;\n\n  Factors.prototype.getNumberSymbolics = function () {\n    var n = 0;\n    this.each(function (x) {\n      if (!x.isConstant(true)) n++;\n    });\n    return n;\n  };\n  /**\r\n   * Adds the factors to the factor object\r\n   * @param {Symbo} s\r\n   * @returns {Factors}\r\n   */\n\n\n  Factors.prototype.add = function (s) {\n    if (s.equals(0)) return this; //nothing to add\n    //we don't want to carry -1 as a factor. If a factor already exists,\n    //then add the minus one to that factor and return.\n\n    if (s.equals(-1) && this.length > 0) {\n      var fo = core.Utils.firstObject(this.factors, null, true);\n      this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\n      delete this.factors[fo.key];\n      this.length--;\n      return this;\n    }\n\n    if (s.group === CB) {\n      var factors = this;\n      if (!s.multiplier.equals(1)) factors.add(new Symbol(s.multiplier));\n      s.each(function (x) {\n        factors.add(x);\n      });\n    } else {\n      if (this.preAdd) //if a preAdd function was defined call it to do prep\n        s = this.preAdd(s);\n      if (this.pFactor) //if the symbol isn't linear add back the power\n        s = _.pow(s, new Symbol(this.pFactor));\n      var is_constant = s.isConstant();\n      if (is_constant && s.equals(1)) return this; //don't add 1\n\n      var v = is_constant ? s.value : s.text();\n\n      if (v in this.factors) {\n        this.factors[v] = _.multiply(this.factors[v], s); //did the addition cancel out the existing factor? If so remove it and decrement the length\n\n        if (this.factors[v].equals(1)) {\n          delete this.factors[v];\n          this.length--;\n        }\n      } else {\n        this.factors[v] = s;\n        this.length++;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Converts the factor object to a Symbol\r\n   * @returns {Symbol}\r\n   */\n\n\n  Factors.prototype.toSymbol = function () {\n    var factored = new Symbol(1);\n    var factors = Object.values(this.factors).sort(function (a, b) {\n      return a.group > b.group;\n    });\n\n    for (var i = 0, l = factors.length; i < l; i++) {\n      var f = factors[i]; //don't wrap group S or FN\n\n      var factor = f.power.equals(1) && f.fname !== ''\n      /* don't wrap it twice */\n      ? _.symfunction(core.PARENTHESIS, [f]) : f;\n      factored = _.multiply(factored, factor);\n    }\n\n    if (factored.fname === '') factored = Symbol.unwrapPARENS(factored);\n    return factored;\n  };\n  /**\r\n   * Merges 2 factor objects into one\r\n   * @param {Factor} o\r\n   * @returns {Factors}\r\n   */\n\n\n  Factors.prototype.merge = function (o) {\n    for (var x in o) {\n      if (x in this.factors) this.factors[x] = _.multiply(this.factors[x], o[x]);else this.factors[x] = o[x];\n    }\n\n    return this;\n  };\n  /**\r\n   * The iterator for the factor object\r\n   * @param {Function} f - callback\r\n   * @returns {Factor}\r\n   */\n\n\n  Factors.prototype.each = function (f) {\n    for (var x in this.factors) {\n      var factor = this.factors[x];\n      if (factor.fname === core.PARENTHESIS && factor.isLinear()) factor = factor.args[0];\n      f.call(this, factor, x);\n    }\n\n    return this;\n  };\n  /**\r\n   * Return the number of factors contained in the factor object\r\n   * @returns {int}\r\n   */\n\n\n  Factors.prototype.count = function () {\n    return keys(this.factors).length;\n  };\n  /**\r\n   * Cleans up factors from -1\r\n   * @returns {undefined}\r\n   */\n\n\n  Factors.prototype.clean = function () {\n    try {\n      var h = core.Settings.CONST_HASH;\n\n      if (this.factors[h].lessThan(0)) {\n        if (this.factors[h].equals(-1)) delete this.factors[h];else this.factors[h].negate();\n        this.each(function (x) {\n          x.negate();\n        });\n      }\n    } catch (e) {}\n\n    ;\n  };\n\n  Factors.prototype.toString = function () {\n    return this.toSymbol().toString();\n  }; //a wrapper for performing multivariate division\n\n\n  function MVTerm(coeff, terms, map) {\n    this.terms = terms || [];\n    this.coeff = coeff;\n    this.map = map; //careful! all maps are the same object\n\n    this.sum = new core.Frac(0);\n    this.image = undefined;\n  }\n\n  ;\n\n  MVTerm.prototype.updateCount = function () {\n    this.count = this.count || 0;\n\n    for (var i = 0; i < this.terms.length; i++) {\n      if (!this.terms[i].equals(0)) this.count++;\n    }\n\n    return this;\n  };\n\n  MVTerm.prototype.getVars = function () {\n    var vars = [];\n\n    for (var i = 0; i < this.terms.length; i++) {\n      var term = this.terms[i],\n          rev_map = this.getRevMap();\n      if (!term.equals(0)) vars.push(this.rev_map[i]);\n    }\n\n    return vars.join(' ');\n  };\n\n  MVTerm.prototype.len = function () {\n    if (typeof this.count === 'undefined') {\n      this.updateCount();\n    }\n\n    return this.count;\n  };\n\n  MVTerm.prototype.toSymbol = function (rev_map) {\n    rev_map = rev_map || this.getRevMap();\n    var symbol = new Symbol(this.coeff);\n\n    for (var i = 0; i < this.terms.length; i++) {\n      var v = rev_map[i],\n          t = this.terms[i];\n      if (t.equals(0) || v === CONST_HASH) continue;\n      var mapped = new Symbol(v);\n      mapped.power = t;\n      symbol = _.multiply(symbol, mapped);\n    }\n\n    return symbol;\n  };\n\n  MVTerm.prototype.getRevMap = function () {\n    if (this.rev_map) return this.rev_map;\n    var o = {};\n\n    for (var x in this.map) {\n      o[this.map[x]] = x;\n    }\n\n    this.rev_map = o;\n    return o;\n  };\n\n  MVTerm.prototype.generateImage = function () {\n    this.image = this.terms.join(' ');\n    return this;\n  }, MVTerm.prototype.getImg = function () {\n    if (!this.image) this.generateImage();\n    return this.image;\n  }, MVTerm.prototype.fill = function () {\n    var l = this.map.length;\n\n    for (var i = 0; i < l; i++) {\n      if (typeof this.terms[i] === 'undefined') this.terms[i] = new core.Frac(0);else {\n        this.sum = this.sum.add(this.terms[i]);\n      }\n    }\n\n    return this;\n  };\n\n  MVTerm.prototype.divide = function (mvterm) {\n    var c = this.coeff.divide(mvterm.coeff),\n        l = this.terms.length,\n        new_mvterm = new MVTerm(c, [], this.map);\n\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n\n    return new_mvterm;\n  };\n\n  MVTerm.prototype.multiply = function (mvterm) {\n    var c = this.coeff.multiply(mvterm.coeff),\n        l = this.terms.length,\n        new_mvterm = new MVTerm(c, [], this.map);\n\n    for (var i = 0; i < l; i++) {\n      new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\n      new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\n    }\n\n    return new_mvterm;\n  };\n\n  MVTerm.prototype.isZero = function () {\n    return this.coeff.equals(0);\n  };\n\n  MVTerm.prototype.toString = function () {\n    return '{ coeff: ' + this.coeff.toString() + ', terms: [' + this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\n  };\n\n  core.Utils.toMapObj = function (arr) {\n    var c = 0,\n        o = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      var v = arr[i];\n\n      if (typeof o[v] === 'undefined') {\n        o[v] = c;\n        c++;\n      }\n    }\n\n    o.length = c;\n    return o;\n  };\n\n  core.Utils.filledArray = function (v, n, clss) {\n    var a = [];\n\n    while (n--) {\n      a[n] = clss ? new clss(v) : v;\n    }\n\n    return a;\n  };\n\n  core.Utils.arrSum = function (arr) {\n    var sum = 0,\n        l = arr.length;\n\n    for (var i = 0; i < l; i++) {\n      sum += arr[i];\n    }\n\n    return sum;\n  };\n  /**\r\n   * Determines if 2 arrays have intersecting elements.\r\n   * @param {Array} a\r\n   * @param {Array} b\r\n   * @returns {Boolean} True if a and b have intersecting elements.\r\n   */\n\n\n  core.Utils.haveIntersection = function (a, b) {\n    var t;\n    if (b.length > a.length) t = b, b = a, a = t; // indexOf to loop over shorter\n\n    return a.some(function (e) {\n      return b.indexOf(e) > -1;\n    });\n  };\n  /**\r\n   * Substitutes out functions as variables so they can be used in regular algorithms\r\n   * @param {Symbol} symbol\r\n   * @param {Object} map\r\n   * @returns {String} The expression string\r\n   */\n\n\n  core.Utils.subFunctions = function (symbol, map) {\n    map = map || {};\n    var subbed = [];\n    symbol.each(function (x) {\n      if (x.group === FN || x.previousGroup === FN) {\n        //we need a new variable name so why not use one of the existing\n        var val = core.Utils.text(x, 'hash'),\n            tvar = map[val];\n\n        if (!tvar) {\n          //generate a unique enough name\n          var t = x.fname + keys(map).length;\n          map[val] = t;\n          subbed.push(x.altVar(t));\n        } else subbed.push(x.altVar(tvar));\n      } else if (x.group === CB || x.group === PL || x.group === CP) {\n        subbed.push(core.Utils.subFunctions(x, map));\n      } else subbed.push(x.text());\n    });\n    if (symbol.group === CP || symbol.group === PL) return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\n    ;\n    if (symbol.group === CB) return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\n    return symbol.text();\n  };\n\n  core.Utils.getFunctionsSubs = function (map) {\n    var subs = {}; //prepare substitutions\n\n    for (var x in map) {\n      subs[map[x]] = _.parse(x);\n    }\n\n    return subs;\n  };\n\n  var __ = core.Algebra = {\n    version: '1.4.6',\n    proots: function proots(symbol, decp) {\n      //the roots will be rounded up to 7 decimal places.\n      //if this causes trouble you can explicitly pass in a different number of places\n      //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\n      decp = decp || 7;\n      var zeros = 0;\n      var known_roots = [];\n\n      var get_roots = function get_roots(rarr, powers, max) {\n        var roots = calcroots(rarr, powers, max).concat(known_roots);\n\n        for (var i = 0; i < zeros; i++) {\n          roots.unshift(0);\n        }\n\n        return roots;\n      };\n\n      if (symbol instanceof Symbol && symbol.isPoly()) {\n        symbol.distributeMultiplier(); //make it so the symbol has a constants as the lowest term\n\n        if (symbol.group === PL) {\n          var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\n          var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\n          symbol = _.expand(_.divide(symbol, lowest_symbol));\n          known_roots.push(0); //add zero since this is a known root\n        }\n\n        if (symbol.group === core.groups.S) {\n          return [0];\n        } else if (symbol.group === core.groups.PL) {\n          var powers = keys(symbol.symbols),\n              minpower = core.Utils.arrayMin(powers),\n              symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\n        }\n\n        var variable = keys(symbol.symbols).sort().pop(),\n            sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\n            g = sym.group,\n            powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\n            rarr = [],\n            max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\n        // Prepare the data\n\n        for (var i = 1; i <= max; i++) {\n          var c = 0; //if there is no power then the hole must be filled with a zero\n\n          if (powers.indexOf(i + '') !== -1) {\n            if (g === S) {\n              c = sym.multiplier;\n            } else {\n              c = sym.symbols[i].multiplier;\n            }\n          } // Insert the coeffient but from the front\n\n\n          rarr.unshift(c);\n        }\n\n        rarr.push(symbol.symbols[CONST_HASH].multiplier);\n        if (sym.group === S) rarr[0] = sym.multiplier; //the symbol maybe of group CP with one variable\n\n        return get_roots(rarr, powers, max);\n      } else if (core.Utils.isArray(symbol)) {\n        var parr = symbol;\n        var rarr = [],\n            powers = [],\n            last_power = 0;\n\n        for (var i = 0; i < parr.length; i++) {\n          var coeff = parr[i][0],\n              pow = parr[i][1],\n              d = pow - last_power - 1; //insert the zeros\n\n          for (var j = 0; j < d; j++) {\n            rarr.unshift(0);\n          }\n\n          rarr.unshift(coeff);\n          if (pow !== 0) powers.push(pow);\n          last_power = pow;\n        }\n\n        var max = Math.max.apply(undefined, powers);\n        return get_roots(rarr, powers, max);\n      } else {\n        throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\n      }\n\n      function calcroots(rarr, powers, max) {\n        var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\n        // Make a clone of the coefficients before appending the max power\n\n        var p = rarr.slice(0); // Divide the string up into its individual entries, which--presumably--are separated by whitespace\n\n        rarr.unshift(max);\n\n        if (max > MAXDEGREE) {\n          throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\n        }\n\n        var zeroi = [],\n            // Vector of imaginary components of roots\n        degreePar = {}; // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\n\n        degreePar.Degree = max;\n\n        for (i = 0; i < max; i++) {\n          zeroi.push(0);\n        }\n\n        var zeror = zeroi.slice(0); // Vector of real components of roots\n        // Find the roots\n        //--> Begin Jenkins-Traub\n\n        /*\r\n         * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n         */\n\n        function QuadSD_ak1(NN, u, v, p, q, iPar) {\n          // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\n          // iPar is a dummy variable for passing in the two parameters--a and b--by reference\n          q[0] = iPar.b = p[0];\n          q[1] = iPar.a = -(u * iPar.b) + p[1];\n\n          for (var i = 2; i < NN; i++) {\n            q[i] = -(u * iPar.a + v * iPar.b) + p[i];\n            iPar.b = iPar.a;\n            iPar.a = q[i];\n          }\n\n          return;\n        }\n\n        function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\n          // This routine calculates scalar quantities used to compute the next K polynomial and\n          // new estimates of the quadratic coefficients.\n          // calcSC -\tinteger variable set here indicating how the calculations are normalized\n          // to avoid overflow.\n          // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\n          // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\n          var sdPar = new Object(),\n              // TYPE = 3 indicates the quadratic is almost a factor of K\n          dumFlag = 3; // Synthetic division of K by the quadratic 1, u, v\n\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(N, u, v, K, qk, sdPar);\n          iPar.c = sdPar.a;\n          iPar.d = sdPar.b;\n\n          if (Math.abs(iPar.c) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 1])) {\n            if (Math.abs(iPar.d) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 2])) return dumFlag;\n          }\n\n          iPar.h = v * b;\n\n          if (Math.abs(iPar.d) >= Math.abs(iPar.c)) {\n            // TYPE = 2 indicates that all formulas are divided by d\n            dumFlag = 2;\n            iPar.e = a / iPar.d;\n            iPar.f = iPar.c / iPar.d;\n            iPar.g = u * b;\n            iPar.a3 = iPar.e * (iPar.g + a) + iPar.h * (b / iPar.d);\n            iPar.a1 = -a + iPar.f * b;\n            iPar.a7 = iPar.h + (iPar.f + u) * a;\n          } else {\n            // TYPE = 1 indicates that all formulas are divided by c;\n            dumFlag = 1;\n            iPar.e = a / iPar.c;\n            iPar.f = iPar.d / iPar.c;\n            iPar.g = iPar.e * u;\n            iPar.a3 = iPar.e * a + (iPar.g + iPar.h / iPar.c) * b;\n            iPar.a1 = -(a * (iPar.d / iPar.c)) + b;\n            iPar.a7 = iPar.g * iPar.d + iPar.h * iPar.f + a;\n          }\n\n          return dumFlag;\n        }\n\n        function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\n          // Computes the next K polynomials using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\n          var temp;\n\n          if (tFlag == 3) {\n            // Use unscaled form of the recurrence\n            K[1] = K[0] = 0.0;\n\n            for (var i = 2; i < N; i++) {\n              K[i] = qk[i - 2];\n            }\n\n            return;\n          }\n\n          temp = tFlag == 1 ? b : a;\n\n          if (Math.abs(iPar.a1) > 10.0 * DBL_EPSILON * Math.abs(temp)) {\n            // Use scaled form of the recurrence\n            iPar.a7 /= iPar.a1;\n            iPar.a3 /= iPar.a1;\n            K[0] = qp[0];\n            K[1] = -(qp[0] * iPar.a7) + qp[1];\n\n            for (var i = 2; i < N; i++) {\n              K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\n            }\n          } else {\n            // If a1 is nearly zero, then use a special form of the recurrence\n            K[0] = 0.0;\n            K[1] = -(qp[0] * iPar.a7);\n\n            for (var i = 2; i < N; i++) {\n              K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\n            }\n          }\n\n          return;\n        }\n\n        function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\n          // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\n          // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\n          // iPar.a = uu, iPar.b = vv\n          var a4, a5, b1, b2, c1, c2, c3, c4, temp;\n          iPar.b = iPar.a = 0.0; // The quadratic is zeroed\n\n          if (tFlag != 3) {\n            if (tFlag != 2) {\n              a4 = a + u * b + h * f;\n              a5 = c + (u + v * f) * d;\n            } else {\n              a4 = (a + g) * f + h;\n              a5 = (f + u) * c + v * d;\n            } // Evaluate new quadratic coefficients\n\n\n            b1 = -(K[N - 1] / p[N]);\n            b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\n            c1 = v * b2 * a1;\n            c2 = b1 * a7;\n            c3 = b1 * b1 * a3;\n            c4 = -(c2 + c3) + c1;\n            temp = -c4 + a5 + b1 * a4;\n\n            if (temp != 0.0) {\n              iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\n              iPar.b = v * (1.0 + c4 / temp);\n            }\n          }\n\n          return;\n        }\n\n        function Quad_ak1(a, b1, c, iPar) {\n          // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\n          // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\n          // zeros are real and both zeros are complex. The smaller real zero is found directly from\n          // the product of the zeros c/a.\n          // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\n          var b, d, e;\n          iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\n\n          if (a == 0) {\n            iPar.sr = b1 != 0 ? -(c / b1) : iPar.sr;\n            return;\n          }\n\n          if (c == 0) {\n            iPar.lr = -(b1 / a);\n            return;\n          } // Compute discriminant avoiding overflow\n\n\n          b = b1 / 2.0;\n\n          if (Math.abs(b) < Math.abs(c)) {\n            e = c >= 0 ? a : -a;\n            e = -e + b * (b / Math.abs(c));\n            d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\n          } else {\n            e = -(a / b * (c / b)) + 1.0;\n            d = Math.sqrt(Math.abs(e)) * Math.abs(b);\n          }\n\n          if (e >= 0) {\n            // Real zeros\n            d = b >= 0 ? -d : d;\n            iPar.lr = (-b + d) / a;\n            iPar.sr = iPar.lr != 0 ? c / iPar.lr / a : iPar.sr;\n          } else {\n            // Complex conjugate zeros\n            iPar.lr = iPar.sr = -(b / a);\n            iPar.si = Math.abs(d / a);\n            iPar.li = -iPar.si;\n          }\n\n          return;\n        }\n\n        function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\n          // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\n          // zeros are equimodular or nearly so.\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\n          // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\n          // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\n          var qPar = new Object(),\n              ee,\n              mp,\n              omp,\n              relstp,\n              t,\n              u,\n              ui,\n              v,\n              vi,\n              zm,\n              i,\n              j = 0,\n              tFlag,\n              triedFlag = 0; // Integer variables\n\n          iPar.NZ = 0; // Number of zeros found\n\n          u = uu; // uu and vv are coefficients of the starting quadratic\n\n          v = vv;\n\n          do {\n            qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n            Quad_ak1(1.0, u, v, qPar);\n            iPar.szr = qPar.sr;\n            iPar.szi = qPar.si;\n            iPar.lzr = qPar.lr;\n            iPar.lzi = qPar.li; // Return if roots of the quadratic are real and not close to multiple or nearly\n            // equal and of opposite sign.\n\n            if (Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr)) break; // Evaluate polynomial by quadratic synthetic division\n\n            QuadSD_ak1(NN, u, v, p, qp, sdPar);\n            mp = Math.abs(-(iPar.szr * sdPar.b) + sdPar.a) + Math.abs(iPar.szi * sdPar.b); // Compute a rigorous bound on the rounding error in evaluating p\n\n            zm = Math.sqrt(Math.abs(v));\n            ee = 2.0 * Math.abs(qp[0]);\n            t = -(iPar.szr * sdPar.b);\n\n            for (i = 1; i < N; i++) {\n              ee = ee * zm + Math.abs(qp[i]);\n            }\n\n            ee = ee * zm + Math.abs(t + sdPar.a);\n            ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs(sdPar.a + t) + zm * Math.abs(sdPar.b))) * DBL_EPSILON; // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\n\n            if (mp <= 20.0 * ee) {\n              iPar.NZ = 2;\n              break;\n            }\n\n            j++; // Stop iteration after 20 steps\n\n            if (j > 20) break;\n\n            if (j >= 2) {\n              if (relstp <= 0.01 && mp >= omp && !triedFlag) {\n                // A cluster appears to be stalling the convergence. Five fixed shift\n                // steps are taken with a u, v close to the cluster.\n                relstp = relstp < DBL_EPSILON ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp);\n                u -= u * relstp;\n                v += v * relstp;\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n\n                for (i = 0; i < 5; i++) {\n                  tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n                  nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n                }\n\n                triedFlag = 1;\n                j = 0;\n              }\n            }\n\n            omp = mp; // Calculate next K polynomial and new u and v\n\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\n            newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vi = sdPar.b; // If vi is zero, the iteration is not converging\n\n            if (vi != 0) {\n              relstp = Math.abs((-v + vi) / vi);\n              u = ui;\n              v = vi;\n            }\n          } while (vi != 0);\n\n          return;\n        }\n\n        function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\n          // Variable-shift H-polynomial iteration for a real zero\n          // sss\t- starting iterate = sdPar.a\n          // NZ\t\t- number of zeros found = iPar.NZ\n          // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\n          var ee,\n              kv,\n              mp,\n              ms,\n              omp,\n              pv,\n              s,\n              t,\n              dumFlag,\n              i,\n              j,\n              nm1 = N - 1; // Integer variables\n\n          iPar.NZ = j = dumFlag = 0;\n          s = sdPar.a;\n\n          for (;;) {\n            pv = p[0]; // Evaluate p at s\n\n            qp[0] = pv;\n\n            for (i = 1; i < NN; i++) {\n              qp[i] = pv = pv * s + p[i];\n            }\n\n            mp = Math.abs(pv); // Compute a rigorous bound on the error in evaluating p\n\n            ms = Math.abs(s);\n            ee = 0.5 * Math.abs(qp[0]);\n\n            for (i = 1; i < NN; i++) {\n              ee = ee * ms + Math.abs(qp[i]);\n            } // Iteration has converged sufficiently if the polynomial value is less than\n            // 20 times this bound\n\n\n            if (mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\n              iPar.NZ = 1;\n              iPar.szr = s;\n              iPar.szi = 0.0;\n              break;\n            }\n\n            j++; // Stop iteration after 10 steps\n\n            if (j > 10) break;\n\n            if (j >= 2) {\n              if (Math.abs(t) <= 0.001 * Math.abs(-t + s) && mp > omp) {\n                // A cluster of zeros near the real axis has been encountered.\n                // Return with iFlag set to initiate a quadratic iteration.\n                dumFlag = 1;\n                iPar.a = s;\n                break;\n              } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\n\n            } //End if (j >= 2)\n            // Return if the polynomial value has increased significantly\n\n\n            omp = mp; // Compute t, the next polynomial and the new iterate\n\n            qk[0] = kv = K[0];\n\n            for (i = 1; i < N; i++) {\n              qk[i] = kv = kv * s + K[i];\n            }\n\n            if (Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\n              // Use the scaled form of the recurrence if the value of K at s is non-zero\n              t = -(pv / kv);\n              K[0] = qp[0];\n\n              for (i = 1; i < N; i++) {\n                K[i] = t * qk[i - 1] + qp[i];\n              }\n            } else {\n              // Use unscaled form\n              K[0] = 0.0;\n\n              for (i = 1; i < N; i++) {\n                K[i] = qk[i - 1];\n              }\n            }\n\n            kv = K[0];\n\n            for (i = 1; i < N; i++) {\n              kv = kv * s + K[i];\n            }\n\n            t = Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON ? -(pv / kv) : 0.0;\n            s += t;\n          }\n\n          return dumFlag;\n        }\n\n        function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\n          // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\n          // quadratic case. Initiates one of the variable shift iterations and returns with the\n          // number of zeros found.\n          // L2\tlimit of fixed shift steps\n          // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\n          // NZ\tnumber of zeros found\n          var sdPar = new Object(),\n              // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\n          calcPar = new Object(),\n              // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\n          qk = new Array(MDP1),\n              svk = new Array(MDP1),\n              a,\n              b,\n              betas,\n              betav,\n              oss,\n              ots,\n              otv,\n              ovv,\n              s,\n              ss,\n              ts,\n              tss,\n              tv,\n              tvv,\n              ui,\n              vi,\n              vv,\n              fflag,\n              i,\n              iFlag = 1,\n              j,\n              spass,\n              stry,\n              tFlag,\n              vpass,\n              vtry; // Integer variables\n\n          iPar.NZ = 0;\n          betav = betas = 0.25;\n          oss = sr;\n          ovv = v; //Evaluate polynomial by synthetic division\n\n          sdPar.b = sdPar.a = 0.0;\n          QuadSD_ak1(NN, u, v, p, qp, sdPar);\n          a = sdPar.a;\n          b = sdPar.b;\n          calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\n          tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n\n          for (j = 0; j < L2; j++) {\n            fflag = 1; // Calculate next K polynomial and estimate v\n\n            nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\n            tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk); // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\n            // sdPar.a = ui, sdPar.b = vi\n\n            newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\n            ui = sdPar.a;\n            vv = vi = sdPar.b; // Estimate s\n\n            ss = K[N - 1] != 0.0 ? -(p[N] / K[N - 1]) : 0.0;\n            ts = tv = 1.0;\n\n            if (j != 0 && tFlag != 3) {\n              // Compute relative measures of convergence of s and v sequences\n              tv = vv != 0.0 ? Math.abs((vv - ovv) / vv) : tv;\n              ts = ss != 0.0 ? Math.abs((ss - oss) / ss) : ts; // If decreasing, multiply the two most recent convergence measures\n\n              tvv = tv < otv ? tv * otv : 1.0;\n              tss = ts < ots ? ts * ots : 1.0; // Compare with convergence criteria\n\n              vpass = tvv < betav ? 1 : 0;\n              spass = tss < betas ? 1 : 0;\n\n              if (spass || vpass) {\n                // At least one sequence has passed the convergence test.\n                // Store variables before iterating\n                for (i = 0; i < N; i++) {\n                  svk[i] = K[i];\n                }\n\n                s = ss; // Choose iteration according to the fastest converging sequence\n\n                stry = vtry = 0;\n\n                for (;;) {\n                  if (fflag && (fflag = 0) == 0 && spass && (!vpass || tss < tvv)) {\n                    ; // Do nothing. Provides a quick \"short circuit\".\n                  } else {\n                    QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\n                    a = sdPar.a;\n                    b = sdPar.b;\n                    if (iPar.NZ > 0) return; // Quadratic iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n\n                    iFlag = vtry = 1;\n                    betav *= 0.25; // Try linear iteration if it has not been tried and the s sequence is converging\n\n                    if (stry || !spass) {\n                      iFlag = 0;\n                    } else {\n                      for (i = 0; i < N; i++) {\n                        K[i] = svk[i];\n                      }\n                    }\n                  } //fflag = 0;\n\n\n                  if (iFlag != 0) {\n                    // Use sdPar for passing in s instead of defining a brand-new variable.\n                    // sdPar.a = s\n                    sdPar.a = s;\n                    iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\n                    s = sdPar.a;\n                    if (iPar.NZ > 0) return; // Linear iteration has failed. Flag that it has been tried and decrease the\n                    // convergence criterion\n\n                    stry = 1;\n                    betas *= 0.25;\n\n                    if (iFlag != 0) {\n                      // If linear iteration signals an almost double real zero, attempt quadratic iteration\n                      ui = -(s + s);\n                      vi = s * s;\n                      continue;\n                    }\n                  } // Restore variables\n\n\n                  for (i = 0; i < N; i++) {\n                    K[i] = svk[i];\n                  } // Try quadratic iteration if it has not been tried and the v sequence is converging\n\n\n                  if (!vpass || vtry) break; // Break out of infinite for loop\n                } // Re-compute qp and scalar values to continue the second stage\n\n\n                QuadSD_ak1(NN, u, v, p, qp, sdPar);\n                a = sdPar.a;\n                b = sdPar.b;\n                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\n              }\n            }\n\n            ovv = vv;\n            oss = ss;\n            otv = tv;\n            ots = ts;\n          }\n\n          return;\n        }\n\n        function rpSolve(degPar, p, zeror, zeroi) {\n          var N = degPar.Degree,\n              RADFAC = 3.14159265358979323846 / 180,\n              // Degrees-to-radians conversion factor = PI/180\n          LB2 = Math.LN2,\n              // Dummy variable to avoid re-calculating this value in loop below\n          MDP1 = degPar.Degree + 1,\n              K = new Array(MDP1),\n              pt = new Array(MDP1),\n              qp = new Array(MDP1),\n              temp = new Array(MDP1),\n              // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\n          qPar = new Object(),\n              // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\n          Fxshfr_Par = new Object(),\n              bnd,\n              DBL_EPSILON,\n              df,\n              dx,\n              factor,\n              ff,\n              moduli_max,\n              moduli_min,\n              sc,\n              x,\n              xm,\n              aa,\n              bb,\n              cc,\n              sr,\n              t,\n              u,\n              xxx,\n              j,\n              jj,\n              l,\n              NM1,\n              NN,\n              zerok; // Integer variables\n          // Calculate the machine epsilon and store in the variable DBL_EPSILON.\n          // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\n\n          aa = 1.0;\n\n          do {\n            DBL_EPSILON = aa;\n            aa /= 2;\n            bb = 1.0 + aa;\n          } while (bb > 1.0);\n\n          var LO = Number.MIN_VALUE / DBL_EPSILON,\n              cosr = Math.cos(94.0 * RADFAC),\n              // = -0.069756474\n          sinr = Math.sin(94.0 * RADFAC),\n              // = 0.99756405\n          xx = Math.sqrt(0.5),\n              // = 0.70710678\n          yy = -xx;\n          Fxshfr_Par.NZ = j = 0;\n          Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0; // Remove zeros at the origin, if any\n\n          while (p[N] == 0) {\n            zeror[j] = zeroi[j] = 0;\n            N--;\n            j++;\n          }\n\n          NN = N + 1; // >>>>> Begin Main Loop <<<<<\n\n          while (N >= 1) {\n            // Main loop\n            // Start the algorithm for one zero\n            if (N <= 2) {\n              // Calculate the final zero or pair of zeros\n              if (N < 2) {\n                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\n                zeroi[degPar.Degree - 1] = 0;\n              } else {\n                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\n                Quad_ak1(p[0], p[1], p[2], qPar);\n                zeror[degPar.Degree - 2] = qPar.sr;\n                zeroi[degPar.Degree - 2] = qPar.si;\n                zeror[degPar.Degree - 1] = qPar.lr;\n                zeroi[degPar.Degree - 1] = qPar.li;\n              }\n\n              break;\n            } // Find the largest and smallest moduli of the coefficients\n\n\n            moduli_max = 0.0;\n            moduli_min = Number.MAX_VALUE;\n\n            for (i = 0; i < NN; i++) {\n              x = Math.abs(p[i]);\n              if (x > moduli_max) moduli_max = x;\n              if (x != 0 && x < moduli_min) moduli_min = x;\n            } // Scale if there are large or very small coefficients\n            // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\n            // is done to avoid overflow and to avoid undetected underflow interfering with the\n            // convergence criterion.\n            // The factor is a power of the base.\n\n\n            sc = LO / moduli_min;\n\n            if (sc <= 1.0 && moduli_max >= 10 || sc > 1.0 && Number.MAX_VALUE / sc >= moduli_max) {\n              sc = sc == 0 ? Number.MIN_VALUE : sc;\n              l = Math.floor(Math.log(sc) / LB2 + 0.5);\n              factor = Math.pow(2.0, l);\n\n              if (factor != 1.0) {\n                for (i = 0; i < NN; i++) {\n                  p[i] *= factor;\n                }\n              }\n            } // Compute lower bound on moduli of zeros\n\n\n            for (var i = 0; i < NN; i++) {\n              pt[i] = Math.abs(p[i]);\n            }\n\n            pt[N] = -pt[N];\n            NM1 = N - 1; // Compute upper estimate of bound\n\n            x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\n\n            if (pt[NM1] != 0) {\n              // If Newton step at the origin is better, use it\n              xm = -pt[N] / pt[NM1];\n              x = xm < x ? xm : x;\n            } // Chop the interval (0, x) until ff <= 0\n\n\n            xm = x;\n\n            do {\n              x = xm;\n              xm = 0.1 * x;\n              ff = pt[0];\n\n              for (var i = 1; i < NN; i++) {\n                ff = ff * xm + pt[i];\n              }\n            } while (ff > 0); // End do-while loop\n\n\n            dx = x; // Do Newton iteration until x converges to two decimal places\n\n            do {\n              df = ff = pt[0];\n\n              for (var i = 1; i < N; i++) {\n                ff = x * ff + pt[i];\n                df = x * df + ff;\n              } // End for i\n\n\n              ff = x * ff + pt[N];\n              dx = ff / df;\n              x -= dx;\n            } while (Math.abs(dx / x) > 0.005); // End do-while loop\n\n\n            bnd = x; // Compute the derivative as the initial K polynomial and do 5 steps with no shift\n\n            for (var i = 1; i < N; i++) {\n              K[i] = (N - i) * p[i] / N;\n            }\n\n            K[0] = p[0];\n            aa = p[N];\n            bb = p[NM1];\n            zerok = K[NM1] == 0 ? 1 : 0;\n\n            for (jj = 0; jj < 5; jj++) {\n              cc = K[NM1];\n\n              if (zerok) {\n                // Use unscaled form of recurrence\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = K[j - 1];\n                } // End for i\n\n\n                K[0] = 0;\n                zerok = K[NM1] == 0 ? 1 : 0;\n              } else {\n                // Used scaled form of recurrence if value of K at 0 is nonzero\n                t = -aa / cc;\n\n                for (var i = 0; i < NM1; i++) {\n                  j = NM1 - i;\n                  K[j] = t * K[j - 1] + p[j];\n                } // End for i\n\n\n                K[0] = p[0];\n                zerok = Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0 ? 1 : 0;\n              }\n            } // Save K for restarts with new shifts\n\n\n            for (var i = 0; i < N; i++) {\n              temp[i] = K[i];\n            } // Loop to select the quadratic corresponding to each new shift\n\n\n            for (jj = 1; jj <= 20; jj++) {\n              // Quadratic corresponds to a double shift to a non-real point and its\n              // complex conjugate. The point has modulus BND and amplitude rotated\n              // by 94 degrees from the previous shift.\n              xxx = -(sinr * yy) + cosr * xx;\n              yy = sinr * xx + cosr * yy;\n              xx = xxx;\n              sr = bnd * xx;\n              u = -(2.0 * sr); // Second stage calculation, fixed quadratic\n\n              Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\n\n              if (Fxshfr_Par.NZ != 0) {\n                // The second stage jumps directly to one of the third stage iterations and\n                // returns here if successful. Deflate the polynomial, store the zero or\n                // zeros, and return to the main algorithm.\n                j = degPar.Degree - N;\n                zeror[j] = Fxshfr_Par.szr;\n                zeroi[j] = Fxshfr_Par.szi;\n                NN = NN - Fxshfr_Par.NZ;\n                N = NN - 1;\n\n                for (var i = 0; i < NN; i++) {\n                  p[i] = qp[i];\n                }\n\n                if (Fxshfr_Par.NZ != 1) {\n                  zeror[j + 1] = Fxshfr_Par.lzr;\n                  zeroi[j + 1] = Fxshfr_Par.lzi;\n                }\n\n                break;\n              } else {\n                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\n                for (var i = 0; i < N; i++) {\n                  K[i] = temp[i];\n                }\n              }\n            } // Return with failure if no convergence with 20 shifts\n\n\n            if (jj > 20) {\n              degPar.Degree -= N;\n              break;\n            }\n          } // >>>>> End Main Loop <<<<<\n\n\n          return;\n        } //--> End Jenkins-Traub\n\n\n        rpSolve(degreePar, p, zeror, zeroi);\n        var l = zeroi.length; //format the output\n\n        for (i = 0; i < l; i++) {\n          // We round the imaginary part to avoid having something crazy like 5.67e-16.\n          var img = round(zeroi[i], decp + 8),\n              real = round(zeror[i], decp + 8); // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\n          // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \n          // the original otherwise the rounding was worth it.\n\n          real = decp - String(real).length > 2 ? real : zeror[i];\n          var sign = img < 0 ? '-' : ''; // Remove the zeroes\n\n          if (real === 0) {\n            real = '';\n          }\n\n          if (img === 0) {\n            img = '';\n          } // Remove 1 as the multiplier and discard imaginary part if there isn't one.\n\n\n          img = Math.abs(img) === 1 ? sign + 'i' : img ? img + '*i' : '';\n          var num = real && img ? real + '+' + img : real + img;\n          zeror[i] = num.replace(/\\+\\-/g, '-');\n        }\n\n        return zeror;\n      }\n    },\n    roots: function roots(symbol) {\n      if (symbol.isConstant(true, true)) {\n        return core.Utils.nroots(symbol);\n      }\n\n      var roots = __.proots(symbol).map(function (x) {\n        return _.parse(x);\n      });\n\n      return core.Vector.fromArray(roots);\n    },\n    froot: function froot(f, guess, dx) {\n      var newtonraph = function newtonraph(xn) {\n        var mesh = 1e-12,\n            // If the derivative was already provided then don't recalculate.\n        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\n            // If the function was passed in as a function then don't recalculate.\n        fn = f instanceof Function ? f : core.Utils.build(f),\n            max = 10000,\n            done = false,\n            safety = 0;\n\n        while (!done) {\n          var x = xn - fn(xn) / df(xn); //absolute values for both x & xn ensures that we indeed have the radius    \n\n          var r = Math.abs(x) - Math.abs(xn),\n              delta = Math.abs(r);\n          xn = x;\n          if (delta < mesh) done = true;else if (safety > max) {\n            xn = null;\n            done = true;\n          }\n          safety++;\n        }\n\n        return xn;\n      };\n\n      return newtonraph(Number(guess));\n    },\n    quad: function quad(a, b, c) {\n      var q = function q(a, b, c, sign) {\n        return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\n      };\n\n      return [q(a, b, c, 1), q(a, b, c, -1)];\n    },\n    sumProd: function sumProd(a, b) {\n      return __.quad(-b, a, -1).map(function (x) {\n        return x.invert();\n      });\n    },\n    coeffs: function coeffs(symbol, wrt, _coeffs) {\n      wrt = String(wrt);\n      symbol = _.expand(symbol);\n      _coeffs = _coeffs || [new Symbol(0)]; //we cannot get coeffs for group EX\n\n      if (symbol.group === EX && symbol.contains(wrt, true)) _.error('Unable to get coefficients using expression ' + symbol.toString());\n      var vars = variables(symbol);\n\n      if (vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\n        var a = new Polynomial(symbol).coeffs.map(function (x) {\n          return new Symbol(x);\n        });\n\n        for (var i = 0, l = a.length; i < l; i++) {\n          var coeff = a[i],\n              e = _coeffs[i];\n          if (e) coeff = _.add(e, coeff);\n          _coeffs[i] = coeff; //transfer it all over\n        }\n      } else {\n        if (!wrt) _.error('Polynomial contains more than one variable. Please specify which variable is to be used!'); //if the variable isn't part of this polynomial then we're looking at x^0\n\n        if (vars.indexOf(wrt) === -1) {\n          _coeffs[0] = _.add(symbol, _coeffs[0]);\n        } else {\n          _coeffs = _coeffs || [new Symbol(0)];\n\n          if (symbol.group === CB) {\n            var s = symbol.symbols[wrt];\n            if (!s) _.error('Expression is not a polynomial!');\n            var p = Number(s.power);\n            coeff = _.divide(symbol.clone(), s.clone());\n            if (coeff.contains(wrt, true) || p < 0 || !isInt(p)) _.error('Expression is not a polynomial!');\n            var e = _coeffs[p];\n            if (e) coeff = _.add(e, coeff);\n            _coeffs[p] = coeff;\n          } else if (symbol.group === CP) {\n            symbol.each(function (x) {\n              __.coeffs(x.clone(), wrt, _coeffs);\n            }, true);\n          }\n        }\n      } //fill holes\n\n\n      for (var i = 0, l = _coeffs.length; i < l; i++) {\n        if (typeof _coeffs[i] === 'undefined') _coeffs[i] = new Symbol(0);\n      }\n\n      return _coeffs;\n    },\n\n    /**\r\n     * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n     * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n     * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n     * @param {Symbol} e\r\n     * @param {String} for_variable\r\n     * @param {Array} powers\r\n     * @returns {Array} An array of the powers\r\n     */\n    //assumes you've already verified that it's a polynomial\n    polyPowers: function polyPowers(e, for_variable, powers) {\n      powers = powers || [];\n      var g = g = e.group;\n\n      if (g === PL && for_variable === e.value) {\n        powers = powers.concat(keys(e.symbols));\n      } else if (g === CP) {\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s];\n          var g = symbol.group,\n              v = symbol.value;\n          if (g === S && for_variable === v) powers.push(symbol.power);else if (g === PL || g === CP) powers = __.polyPowers(symbol, for_variable, powers);else if (g === CB && symbol.contains(for_variable)) {\n            var t = symbol.symbols[for_variable];\n            if (t) powers.push(t.power);\n          } else if (g === N || for_variable !== v) powers.push(0);\n        }\n      } else if (g === CB && e.contains(for_variable)) {\n        powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\n      }\n\n      return core.Utils.arrayUnique(powers).sort();\n    },\n    //The factor object\n    Factor: {\n      //splits the symbol in symbol and constant\n      split: function split(symbol) {\n        var c = new Symbol(1); //the constants part\n\n        var s = new Symbol(1); //the symbolic part\n\n        __.Factor.factor(symbol, new Factors()).each(function (x) {\n          var t = _.parse(x);\n\n          if (x.isConstant(true)) {\n            c = _.multiply(c, t);\n          } else {\n            s = _.multiply(s, t);\n          }\n        });\n\n        return [c, s];\n      },\n      mix: function mix(o, include_negatives) {\n        var factors = keys(o);\n        var l = factors.length;\n        var m = []; //create a row which we'r going to be mixing\n\n        for (var i = 0; i < l; i++) {\n          var factor = factors[i],\n              p = o[factor];\n          var ll = m.length;\n\n          for (var j = 0; j < ll; j++) {\n            var t = m[j] * factor;\n            m.push(t);\n            if (include_negatives) m.push(-t);\n          }\n\n          for (var j = 1; j <= p; j++) {\n            m.push(Math.pow(factor, j));\n          }\n        }\n\n        return m;\n      },\n      //TODO: this method is to replace common factoring\n      common: function common(symbol, factors) {\n        try {\n          if (symbol.group === CP) {\n            //this may have the unfortunate side effect of expanding and factoring again\n            //to only end up with the same result. \n            //TODO: try to avoid this\n            //collect the symbols and sort to have the longest first. Thinking is that the longest terms \n            //has to contain the variable in order for it to be factorable\n            var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\n              return (b.length || 1) - (a.length || 1);\n            });\n\n            var map = {}; //create a map of common factors\n\n            var coeffs = [];\n\n            for (var i = 0; i < symbols.length; i++) {\n              var sym = symbols[i];\n              coeffs.push(sym.multiplier.clone());\n              sym.each(function (x) {\n                var p = Number(x.power); //This check exits since we have a symbolic power.\n                //For the future... think about removing this check and modify for symbolic powers\n\n                if (isNaN(p)) throw new Error('exiting'); //loop through the symbols and lump together common terms\n\n                if (x.value in map) {\n                  if (p < map[x.value][0]) map[x.value][0] = p;\n                  map[x.value][1].push(x);\n                } else map[x.value] = [p, [x]];\n              });\n            } //the factor\n\n\n            var factor = new Symbol(1);\n\n            for (var x in map) {\n              //if this factor is found in all terms since the length of \n              //matching variable terms matches the number of original terms\n              if (map[x][1].length === symbols.length) {\n                //generate a symbol and multiply into the factor\n                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\n              }\n            } //get coefficient factor\n\n\n            var c = core.Math2.QGCD.apply(null, coeffs);\n\n            if (!c.equals(1)) {\n              factors.add(new Symbol(c));\n\n              for (var i = 0; i < symbols.length; i++) {\n                symbols[i].multiplier = symbols[i].multiplier.divide(c);\n              }\n            } //if we actuall found any factors\n\n\n            if (!factor.equals(1)) {\n              factors.add(factor);\n              symbol = new Symbol(0);\n\n              for (var i = 0; i < symbols.length; i++) {\n                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n\n        return symbol;\n      },\n      zeroes: function zeroes(symbol, factors) {\n        var exit = function exit() {\n          throw new core.exceptions.ValueLimitExceededError('Exiting');\n        };\n\n        try {\n          var vars, term, sum, p, e;\n          symbol = _.expand(symbol.clone());\n          e = symbol.toString();\n          vars = variables(symbol);\n          sum = new Symbol(0);\n          var terms = [];\n          var powers = []; //start setting each variable to zero\n\n          for (var i = 0, l = vars.length; i < vars.length; i++) {\n            var subs = {}; //we want to create a subs object with all but the current variable set to zero\n\n            for (var j = 0; j < l; j++) {\n              if (i !== j) //make sure we're not looking at the same variable\n                subs[vars[j]] = 0;\n            }\n\n            term = _.parse(e, subs);\n            var tp = term.power; //the temporary power has to be an integer as well\n\n            if (!isInt(tp)) exit();\n            terms.push(term);\n            powers.push(term.power);\n          } //get the gcd. This will be the p in (a^n+b^m)^p\n          //if the gcd equals 1 meaning n = m then we need a tie breakder\n\n\n          if (core.Utils.allSame(powers)) {\n            //get p given x number of terms\n            var n_terms = symbol.length; //the number of zeroes determines\n\n            var n_zeroes = terms.length;\n\n            if (n_zeroes === 2) {\n              p = new Frac(powers[0] / (n_terms - 1));\n            }\n\n            if (n_zeroes === 3) {\n              p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\n            }\n            /*\r\n             //get the lowest possible power\r\n             //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n             symbol.each(function(x) {\r\n             if(x.group === CB)\r\n             x.each(function(y) {\r\n             if(!p || y.power.lessThan(p))\r\n             //p = Number(y.power);\r\n             p = y.power;\r\n             });\r\n             else if(!p || x.power.lessThan(p))\r\n             //p = Number(x.power);\r\n             p = x.power;\r\n             });\r\n             */\n\n          } else //p is just the gcd of the powers\n            p = core.Math2.QGCD.apply(null, powers); //if we don't have an integer then exit\n\n\n          if (!isInt(p)) exit(); //build the factor\n\n          for (var i = 0; i < terms.length; i++) {\n            var t = terms[i];\n            var n = t.power.clone().divide(p);\n            t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\n            t.power = p.clone();\n            sum = _.add(sum, t);\n          } //by now we have the factor of zeroes. We'll know if we got it right because \n          //we'll get a remainder of zero each time we divide by it\n\n\n          if (sum.group !== CP) return symbol; //nothing to do\n\n          while (true) {\n            var d = __.div(symbol.clone(), sum.clone());\n\n            if (d[1].equals(0)) {\n              symbol = d[0];\n              factors.add(sum.clone());\n              if (symbol.equals(1)) //we've reached 1 so done.\n                break;\n            } else break;\n          }\n        } catch (e) {}\n\n        ;\n        return symbol;\n      },\n      factor: function factor(symbol, factors) {\n        // Don't try to factor constants\n        if (symbol.isConstant()) {\n          return core.Math2.factor(symbol);\n        }\n\n        var _symbol = _.parse(symbol);\n\n        var retval = __.Factor._factor(_symbol, factors);\n\n        if (retval.equals(symbol)) {\n          return retval;\n        }\n\n        if (retval.group === CB) {\n          var t = new Symbol(1);\n\n          var p = _.parse(retval.power); //store the multiplier and strip it\n\n\n          var m = _.parse(retval.multiplier);\n\n          retval.toUnitMultiplier();\n          /* \r\n           * NOTE: for sign issues with factor START DEBUGGING HERE\r\n           */\n          //move the sign to t\n\n          if (retval.multiplier.lessThan(0)) {\n            t.negate();\n            retval.negate();\n          }\n\n          retval.each(function (x) {\n            // Related to #566. Since the symbol's group may not have been properly\n            // updated, it's easier to just parse the symbol and have the parser \n            // do the update for us.\n            var factored = _.parse(__.Factor._factor(x));\n\n            if (factored.group === CB) {\n              // Include the multiplier\n              m = _.multiply(m, Symbol.create(factored.multiplier));\n              factored.each(function (y) {\n                var _factored = _.parse(__.Factor._factor(y));\n\n                t = _.multiply(t, _factored);\n\n                if (_factored.group === CB) {\n                  m = _.multiply(m, Symbol.create(_factored.multiplier));\n                }\n              });\n            } else {\n              t = _.multiply(t, factored);\n            }\n          }); //put back the multiplier and power\n\n          retval = _.pow(_.multiply(m, t), p);\n        }\n\n        return retval;\n      },\n      quadFactor: function quadFactor(symbol, factors) {\n        if (symbol.isPoly() && __.degree(symbol.equals(2))) {\n          //We've  already checked that we're dealing with a polynomial\n          var v = core.Utils.variables(symbol)[0]; //get the variable\n\n          var coeffs = __.coeffs(symbol, v); //factor the lead coefficient\n\n\n          var cf = __.Factor._factor(coeffs[2].clone()); //check if we have factors\n\n\n          if (cf.group === CB) {\n            var symbols = cf.collectSymbols(); //if the factors are greater than 2 we're done so exit\n\n            if (symbols.length > 2) return symbol; //if we have two factors then attempt to factor the polynomial\n            //let the factors be f1 and f1\n            //let the factors be (ax+b)(cx+d)\n            //let the coefficients be c1x^2+c2x+c3\n            //then a(x1)+c(x2)=c2 and x1*x2=c3\n            //we can solve for x1 and x2\n\n            var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\n\n            var b = _.parse(coeffs[1]).negate();\n\n            var a = _.parse(symbols[1]); //solve the system\n\n\n            var root = __.quad(a, b, c).filter(function (x) {\n              if (core.Utils.isInt(x)) return x;\n            }); //if we have one root then find the other one by dividing the constant\n\n\n            if (root.length === 1) {\n              var root1 = root[0];\n\n              var root2 = _.divide(coeffs[0], _.parse(root1));\n\n              if (core.Utils.isInt(root2)) {\n                //we found them both\n                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\n                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\n                symbol = new Symbol(1);\n              }\n            }\n          }\n        }\n\n        return symbol;\n      },\n      cubeFactor: function cubeFactor(symbol, factors) {\n        if (symbol.isComposite()) {\n          var symbols = symbol.collectSymbols(); // The symbol should be in the form of a^3+-b^3. The length\n          // should therefore only be two. If it's any different from this\n          // then we're done\n\n          if (symbols.length === 2) {\n            // Store the signs and then strip them from the symbols\n            var sign_a = symbols[0].sign();\n            var a = symbols[0].clone().abs();\n            var sign_b = symbols[1].sign();\n            var b = symbols[1].clone().abs(); // Check if they're cube\n\n            if (a.isCube() && b.isCube()) {\n              // Keep the negative sign on the right, meaning b is always negative.\n              if (sign_a < sign_b) {\n                // Swap the signs and then the values\n                var _ref = [sign_b, sign_a];\n                sign_a = _ref[0];\n                sign_b = _ref[1];\n                var _ref2 = [b, a];\n                a = _ref2[0];\n                b = _ref2[1];\n              } // Get teh roots\n\n\n              var m_root_a = _.parse(a.getNth(3));\n\n              var m_root_b = _.parse(b.getNth(3)); // Remove the cube for both\n\n\n              var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\n\n              var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\n\n              if (sign_a === 1 && sign_b === -1) {\n                // Apply difference of cubes rule\n                factors.add(_.parse(format('(({0})-({1}))', x, y)));\n                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\n                symbol = Symbol(1);\n              } else if (sign_a === 1 && sign_b === 1) {\n                // Apply sum of cubes rule\n                factors.add(_.parse(format('(({0})+({1}))', x, y)));\n                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\n                symbol = Symbol(1);\n              }\n            }\n          }\n        }\n\n        return symbol;\n      },\n      _factor: function _factor(symbol, factors) {\n        var g = symbol.group; //some items cannot be factored any further so return those right away\n\n        if (symbol.group === FN) {\n          var arg = symbol.args[0];\n\n          if (arg.group === S && arg.isSimple()) {\n            return symbol;\n          }\n        } else if (symbol.group === S && symbol.isSimple()) {\n          return symbol;\n        } // Expand the symbol to get it in a predictable form. If this step\n        // is skipped some factors are missed.\n        //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\n\n\n        if (symbol.group === CP) {\n          symbol.distributeMultiplier(true);\n          var t = new Symbol(0);\n          symbol.each(function (x) {\n            if (x.group === CP && x.power.greaterThan(1) || x.group === CB) x = _.expand(x);\n            t = _.add(t, x);\n          });\n          t.power = symbol.power;\n          symbol = t;\n        }\n\n        if (symbol.group === FN && symbol.fname !== 'sqrt') {\n          symbol = core.Utils.evaluate(symbol);\n        } //make a copy of the symbol to return if something goes wrong\n\n\n        var untouched = symbol.clone();\n\n        try {\n          if (symbol.group === CB) {\n            var p = _.parse(symbol.power);\n\n            var den_array, num_array, den, num, dfact, nfact; //grab the denominator and strip the multiplier and power. Store them in an array\n\n            den_array = __.Simplify.strip(symbol.getDenom());\n            num_array = __.Simplify.strip(symbol.getNum());\n            den = den_array.pop();\n            num = num_array.pop(); //if the numerator equals the symbol then we've hit the simplest form and then we're done\n\n            if (num.equals(symbol)) {\n              return symbol;\n            }\n\n            nfact = __.Factor.factor(num);\n            dfact = __.Factor.factor(den);\n\n            var n = __.Simplify.unstrip(num_array, nfact);\n\n            var d = __.Simplify.unstrip(den_array, dfact);\n\n            var retval = _.divide(n, d);\n\n            return retval;\n          }\n\n          if (symbol.group === S) {\n            return symbol; //absolutely nothing to do\n          }\n\n          if (symbol.isConstant()) {\n            if (symbol.equals(1)) return symbol.clone();\n            var ret = core.Math2.factor(symbol);\n            return ret;\n          }\n\n          var p = symbol.power.clone();\n\n          if (isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\n            var sign = p.sign();\n            symbol.toLinear();\n            factors = factors || new Factors();\n            var map = {};\n            symbol = _.parse(core.Utils.subFunctions(symbol, map));\n\n            if (keys(map).length > 0) {\n              //it might have functions\n              factors.preAdd = function (factor) {\n                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\n\n                return ret;\n              };\n            } //strip the power\n\n\n            if (!symbol.isLinear()) {\n              factors.pFactor = symbol.power.toString();\n              symbol.toLinear();\n            }\n\n            var vars = variables(symbol); //bypass for imaginary. TODO: find a better solution\n\n            if (symbol.isImaginary()) {\n              vars.push(core.Settings.IMAGINARY);\n            }\n\n            var multiVar = vars.length > 1; //minor optimization. Seems to cut factor time by half in some cases.\n\n            if (multiVar) {\n              var all_S = true,\n                  all_unit = true;\n              symbol.each(function (x) {\n                if (x.group !== S) all_S = false;\n                if (!x.multiplier.equals(1)) all_unit = false;\n              });\n\n              if (all_S && all_unit) {\n                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\n              }\n            } //factor the coefficients\n\n\n            var coeff_factors = new Factors();\n            symbol = __.Factor.coeffFactor(symbol, coeff_factors);\n            coeff_factors.each(function (x) {\n              // If the factor was negative but was within a square then it becomes positive\n              if (even(p) && x.lessThan(0)) {\n                x.negate();\n              }\n\n              if (sign < 0) x.invert();\n              factors.add(x);\n            }); //factor the power\n\n            var power_factors = new Factors();\n            symbol = __.Factor.powerFactor(symbol, power_factors);\n            power_factors.each(function (x) {\n              if (sign < 0) x.invert();\n              factors.add(x);\n            });\n\n            if (!multiVar) {\n              //pass in vars[0] for safety\n              var v = vars[0];\n              symbol = __.Factor.squareFree(symbol, factors, v);\n              var t_factors = new Factors();\n              symbol = __.Factor.trialAndError(symbol, t_factors, v); //generate a symbol based off the last factors\n\n              var tf_symbol = t_factors.toSymbol(); //if nothing was factored then return the factors\n\n              if (tf_symbol.equals(untouched)) {\n                return tf_symbol;\n              }\n\n              for (var x in t_factors.factors) {\n                //store the current factor in t_factor\n                var t_factor = t_factors.factors[x];\n                factors.add(_.pow(t_factor, _.parse(p)));\n              } //if we still don't have a factor and it's quadratic then let's just do a quad factor\n\n\n              if (symbol.equals(untouched)) {\n                symbol = __.Factor.quadFactor(symbol, factors);\n              }\n            } else {\n              // Try sum and difference of cubes\n              symbol = __.Factor.cubeFactor(symbol, factors);\n              symbol = __.Factor.mfactor(symbol, factors); //put back the sign of power\n\n              factors.each(function (x) {\n                if (sign < 0) x.power.negate();\n              });\n            } //last minute clean up\n\n\n            symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\n            var addPower = factors.length === 1;\n            factors.add(_.pow(symbol, _.parse(p)));\n            var retval = factors.toSymbol(); // We may have only factored out the symbol itself so we end up with a factor of one \n            // where the power needs to be placed back\n            // e.g. factor((2*y+p)^2). Here we end up having a factor of 1 remaining and a p of 2.\n\n            if (addPower && symbol.equals(1) && retval.isLinear()) {\n              retval = _.pow(retval, _.parse(p));\n            }\n\n            return retval;\n          }\n\n          return symbol;\n        } catch (e) {\n          //no need to stop the show because something went wrong :). Just return the unfactored.\n          return untouched;\n        }\n      },\n      reduce: function reduce(symbol, factors) {\n        if (symbol.group === CP && symbol.length === 2) {\n          var symbols = symbol.collectSymbols().sort(function (a, b) {\n            return b.multiplier - a.multiplier;\n          });\n\n          if (symbols[0].power.equals(symbols[1].power)) {\n            //x^n-a^n\n            var n = _.parse(symbols[0].power),\n                a = symbols[0].clone().toLinear(),\n                b = symbols[1].clone().toLinear(); //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\n\n\n            factors.add(_.add(a.clone(), b.clone())); //flip the sign\n\n            b.negate(); //turn n into a number\n\n            var nn = Number(n); //the remainder\n\n            var result = new Symbol(0);\n\n            for (var i = 1; i <= nn; i++) {\n              var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\n                  bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\n\n              result = _.add(result, _.multiply(aa, bb));\n            }\n\n            return result;\n          }\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * Makes Symbol square free\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @@param {String} variable The variable which is being factored \r\n       * @returns {[Symbol, Factor]}\r\n       */\n      squareFree: function squareFree(symbol, factors, variable) {\n        if (symbol.isConstant() || symbol.group === S) return symbol;\n        var poly = new Polynomial(symbol, variable);\n        var sqfr = poly.squareFree();\n        var p = sqfr[2]; //if we found a square then the p entry in the array will be non-unit\n\n        if (p !== 1) {\n          //make sure the remainder doesn't have factors\n          var t = sqfr[1].toSymbol();\n          t.power = t.power.multiply(new Frac(p)); //send the factor to be fatored to be sure it's completely factored\n\n          factors.add(__.Factor.factor(t));\n\n          var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\n\n          return retval;\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * Factors the powers such that the lowest power is a constant\r\n       * @param {Symbol} symbol\r\n       * @param {Factors} factors\r\n       * @returns {[Symbol, Factor]}\r\n       */\n      powerFactor: function powerFactor(symbol, factors) {\n        //only PL need apply\n        if (symbol.group !== PL || symbol.previousGroup === EX) return symbol;\n        var k = keys(symbol.symbols); //we expect only numeric powers so return all else\n\n        if (!core.Utils.allNumeric(k)) return symbol;\n        var d = core.Utils.arrayMin(k);\n        var retval = new Symbol(0);\n\n        var q = _.parse(symbol.value + '^' + d);\n\n        symbol.each(function (x) {\n          x = _.divide(x, q.clone());\n          retval = _.add(retval, x);\n        });\n        factors.add(q);\n        return retval;\n      },\n\n      /**\r\n       * Removes GCD from coefficients\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @returns {Symbol}\r\n       */\n      coeffFactor: function coeffFactor(symbol, factors) {\n        if (symbol.isComposite()) {\n          var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\n\n          if (!gcd.equals(1)) {\n            symbol.each(function (x) {\n              if (x.isComposite()) {\n                x.each(function (y) {\n                  y.multiplier = y.multiplier.divide(gcd);\n                });\n              } else x.multiplier = x.multiplier.divide(gcd);\n            });\n            symbol.updateHash();\n          } else {\n            // TODO: This should probably go to the prototype\n            var power = function power(symbol) {\n              var p;\n\n              if (symbol.group === CB) {\n                p = 0;\n                symbol.each(function (x) {\n                  p += x.power;\n                });\n              } else {\n                p = Number(symbol.power);\n              }\n\n              return p;\n            }; // Factor out negatives from the lead term\n\n\n            var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\n              // Push constants to the back\n              if (a.isConstant(true)) return 1;\n              return b.power - a.power;\n            });\n            var LT = terms[0]; // Check if the LT is indeed the greatest\n\n            if (power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\n              if (LT.multiplier.lessThan(0)) {\n                // Although the symbol should always be linear at this point, remove the negative for squares\n                // to be safe.\n                factors.add(new Symbol(-1));\n                symbol.each(function (x) {\n                  x.negate();\n                }, true);\n              }\n            }\n          }\n\n          if (factors) {\n            factors.add(new Symbol(gcd));\n          }\n        }\n\n        return symbol;\n      },\n\n      /**\r\n       * The name says it all :)\r\n       * @param {Symbol} symbol\r\n       * @param {Factor} factors\r\n       * @@param {String} variable \r\n       * @returns {Symbol}\r\n       */\n      trialAndError: function trialAndError(symbol, factors, variable) {\n        var untouched = symbol.clone();\n\n        try {\n          // At temp holder for the factors. If all goes well then\n          // they'll be moved to the actual factors.\n          var factor_array = [];\n          if (symbol.isConstant() || symbol.group === S) return symbol;\n\n          var poly = new Polynomial(symbol, variable),\n              cnst = poly.coeffs[0],\n              cfactors = core.Math2.ifactor(cnst),\n              roots = __.proots(symbol);\n\n          for (var i = 0; i < roots.length; i++) {\n            var r = roots[i],\n                p = 1;\n\n            if (!isNaN(r)) {\n              //if it's a number\n              for (var x in cfactors) {\n                //check it's raised to a power\n                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\n\n                if (isInt(n)) {\n                  r = x; //x must be the root since n gave us a whole\n\n                  p = n;\n                  break;\n                }\n              }\n\n              var root = new Frac(r),\n                  terms = [new Frac(root.num).negate()];\n              terms[p] = new Frac(root.den); //convert to Frac. The den is coeff of LT and the num is coeff of constant\n\n              var div = Polynomial.fromArray(terms, poly.variable).fill(),\n                  t = poly.divide(div);\n\n              if (t[1].equalsNumber(0)) {\n                //if it's zero we have a root and divide it out\n                poly = t[0]; // factors.add(div.toSymbol());\n\n                factor_array.push(div.toSymbol());\n              }\n            }\n          }\n\n          if (!poly.equalsNumber(1)) {\n            poly = __.Factor.search(poly, factors);\n          } // Move the factors over since all went well.\n\n\n          factor_array.forEach(function (x) {\n            factors.add(x);\n          });\n          return poly.toSymbol();\n        } catch (e) {\n          return untouched;\n        }\n      },\n      search: function search(poly, factors, base) {\n        base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\n\n        var v = poly.variable; //the polynmial variable name\n\n        /**\r\n         * Attempt to remove a root by division given a number by first creating\r\n         * a polynomial fromt he given information\r\n         * @param {int} c1 - coeffient for the constant\r\n         * @param {int} c2 - coefficient for the LT\r\n         * @param {int} n - the number to be used to construct the polynomial\r\n         * @param {int} p - the power at which to create the polynomial\r\n         * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n         */\n\n        var check = function check(c1, c2, n, p) {\n          var candidate = Polynomial.fit(c1, c2, n, base, p, v);\n\n          if (candidate && candidate.coeffs.length > 1) {\n            var t = poly.divide(candidate);\n\n            if (t[1].equalsNumber(0)) {\n              factors.add(candidate.toSymbol());\n              return [t[0], candidate];\n            }\n          }\n\n          return null;\n        };\n\n        var cnst = poly.coeffs[0];\n        var cfactors = core.Math2.ifactor(cnst);\n        var lc = poly.lc();\n        var ltfactors = core.Math2.ifactor(lc);\n        var subbed = poly.sub(base);\n        var isubbed = core.Math2.ifactor(subbed);\n\n        var nfactors = __.Factor.mix(isubbed, subbed < 0);\n\n        var cp = Math.ceil(poly.coeffs.length / 2);\n        var lc_is_neg = lc.lessThan(0);\n        var cnst_is_neg = cnst.lessThan(0);\n        ltfactors['1'] = 1;\n        cfactors['1'] = 1;\n\n        while (cp--) {\n          for (var x in ltfactors) {\n            for (var y in cfactors) {\n              for (var i = 0; i < nfactors.length; i++) {\n                var factor_found = check(x, y, nfactors[i], cp);\n\n                if (factor_found) {\n                  poly = factor_found[0];\n                  if (!core.Utils.isPrime(poly.sub(base))) poly = __.Factor.search(poly, factors);\n                  return poly;\n                } else if (!factor_found) {\n                  if (lc_is_neg && cnst_is_neg) factor_found = check(-x, -y, nfactors[i], cp);else if (lc_is_neg) factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\n                  else if (cnst_is_neg) factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\n                }\n              }\n            }\n          }\n        }\n\n        return poly;\n      },\n\n      /**\r\n       * Equivalent of square free factor for multivariate polynomials\r\n       * @param {type} symbol\r\n       * @param {type} factors\r\n       * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n       */\n      mSqfrFactor: function mSqfrFactor(symbol, factors) {\n        if (symbol.group !== FN) {\n          var vars = variables(symbol).reverse(); // Loop through all the variable and remove the partial derivatives\n\n          for (var i = 0; i < vars.length; i++) {\n            do {\n              if (vars[i] === symbol.value) {\n                //the derivative tells us nothing since this symbol is already the factor\n                factors.add(symbol);\n                symbol = new Symbol(1);\n                continue;\n              }\n\n              var diff = core.Calculus.diff(symbol, vars[i]);\n\n              var d = __.Factor.coeffFactor(diff);\n\n              if (d.equals(0)) break; //trial division to see if factors have whole numbers. \n              //This can be optimized by stopping as soon as can_divide is false\n              //this will also need utilize big number at some point\n\n              var can_divide = true;\n\n              if (d.isConstant() && symbol.isComposite()) {\n                //check the coefficients\n                symbol.each(function (x) {\n                  if (x.multiplier % d !== 0) can_divide = false;\n                }, true);\n              } //if we can divide then do so\n\n\n              if (can_divide) {\n                var div = __.div(symbol, d.clone()),\n                    is_factor = div[1].equals(0); // Break infinite loop for factoring e^t*x-1\n\n\n                if (symbol.equals(div[0]) && div[1].equals(0)) {\n                  break;\n                }\n\n                if (div[0].isConstant()) {\n                  factors.add(div[0]);\n                  break;\n                }\n              } else is_factor = false;\n\n              if (is_factor) {\n                factors.add(div[0]);\n                symbol = d;\n              }\n            } while (is_factor);\n          }\n        }\n\n        return symbol;\n      },\n      //difference of squares factorization\n      sqdiff: function sqdiff(symbol, factors) {\n        if (symbol.isConstant('all')) {\n          // Nothing to do\n          return symbol;\n        }\n\n        try {\n          var remove_square = function remove_square(x) {\n            return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\n              return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\n            }, true);\n          };\n\n          var separated = core.Utils.separate(symbol.clone());\n          var obj_array = []; //get the unique variables\n\n          for (var x in separated) {\n            if (x !== 'constants') {\n              obj_array.push(separated[x]);\n            }\n          }\n\n          obj_array.sort(function (a, b) {\n            return b.power - a.power;\n          }); //if we have the same number of variables as unique variables then we can apply the difference of squares\n\n          if (obj_array.length === 2) {\n            var a, b;\n            a = obj_array.pop();\n            b = obj_array.pop();\n\n            if (even(a.power) && even(b.power) && a.sign() === b.sign() && a.group === S && b.group === S) {\n              throw new Error('Unable to factor');\n            }\n\n            ;\n\n            if (a.isComposite() && b.power.equals(2)) {\n              //remove the square from b\n              b = remove_square(b);\n\n              var f = __.Factor.factor(_.add(a, separated.constants));\n\n              if (f.power.equals(2)) {\n                f.toLinear();\n                factors.add(_.subtract(f.clone(), b.clone()));\n                factors.add(_.add(f, b));\n                symbol = new Symbol(1);\n              }\n            } else {\n              a = a.powSimp();\n              b = b.powSimp();\n\n              if ((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\n                if (a.multiplier.lessThan(0)) {\n                  var t = b;\n                  b = a;\n                  a = t;\n                }\n\n                if (a.multiplier.greaterThan(0)) {\n                  a = remove_square(a);\n                  b = remove_square(b);\n                }\n\n                factors.add(_.subtract(a.clone(), b.clone()));\n                factors.add(_.add(a, b));\n                symbol = new Symbol(1);\n              }\n            }\n          }\n        } catch (e) {\n          ;\n        }\n\n        return symbol;\n      },\n      //factoring for multivariate\n      mfactor: function mfactor(symbol, factors) {\n        if (symbol.group === FN) {\n          if (symbol.fname === 'sqrt') {\n            var factors2 = new Factors(),\n                arg = __.Factor.common(symbol.args[0].clone(), factors2);\n\n            arg = __.Factor.coeffFactor(arg, factors2);\n            symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\n            factors2.each(function (x) {\n              symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\n            });\n          } else factors.add(symbol);\n        } else {\n          //square free factorization\n          symbol = __.Factor.mSqfrFactor(symbol, factors); //try factor out common factors\n          //symbol = __.Factor.common(symbol, factors);\n\n          var vars = variables(symbol),\n              symbols = symbol.collectSymbols().map(function (x) {\n            return Symbol.unwrapSQRT(x);\n          }),\n              sorted = {},\n              maxes = {},\n              l = vars.length,\n              n = symbols.length; //take all the variables in the symbol and organize by variable name\n          //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\n\n          for (var i = 0; i < l; i++) {\n            var v = vars[i];\n            sorted[v] = new Symbol(0);\n\n            for (var j = 0; j < n; j++) {\n              var s = symbols[j];\n\n              if (s.contains(v)) {\n                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\n                if (!maxes[v] || p < maxes[v]) maxes[v] = p;\n                sorted[v] = _.add(sorted[v], s.clone());\n              }\n            }\n          }\n\n          for (var x in sorted) {\n            var r = _.parse(x + '^' + maxes[x]);\n\n            var div = _.divide(sorted[x], r);\n\n            var new_factor = _.expand(div);\n\n            if (new_factor.equals(1)) break; //why divide by one. Just move \n\n            var divided = __.div(symbol.clone(), new_factor);\n\n            if (divided[0].equals(0)) {\n              //cant factor anymore\n              break;\n            } // We potentially ended up with fractional coefficients when the\n            // trial division was performed. We need to remove \n            // This check will more then likely become superfluous with improvements\n            // to polynomial division\n\n\n            if (divided[1].equals(0)) {\n              var has_fractions = false;\n              divided[0].each(function (x) {\n                if (!isInt(x.multiplier)) {\n                  has_fractions = true;\n                }\n              }); // The factor isn't really a factor and needs to be put back\n\n              if (has_fractions) {\n                divided[1] = _.expand(_.multiply(divided[1], new_factor)); // Since the new factor is not just one, we exit.\n\n                break;\n              }\n            }\n\n            var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\n\n            if (divided[1].equals(0) && !neg_numeric_factor) {\n              //we found at least one factor\n              //factors.add(new_factor);\n              var d = __.div(symbol.clone(), divided[0].clone());\n\n              var r = d[0]; // Nothing left to do since we didn't get a reduction\n\n              if (r.equals(0)) {\n                return symbol;\n              }\n\n              symbol = d[1]; //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\n              //and we just return the symbol;\n              //If r equals zero then there's nothing left to do so we're done\n\n              if (r.equals(-1) && !symbol.equals(0)) return symbol;\n              var factor = divided[0];\n\n              if (symbol.equals(factor)) {\n                var rem = __.Factor.reduce(factor, factors);\n\n                if (!symbol.equals(rem)) return __.Factor.mfactor(rem, factors);\n                return rem;\n              } else {\n                factors.add(factor); //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\n\n                if (symbol.equals(0)) return r;\n              }\n\n              if (r.isConstant('all')) {\n                factors.add(r);\n                return r;\n              }\n\n              return __.Factor.mfactor(r, factors);\n            }\n          }\n        } //difference of squares factorization\n\n\n        symbol = __.Factor.sqdiff(symbol, factors); //factors by fishing for zeroes\n\n        symbol = __.Factor.zeroes(symbol, factors);\n        return symbol;\n      }\n    },\n\n    /**\r\n     * Checks to see if a set of \"equations\" is linear. \r\n     * @param {type} set\r\n     * @returns {Boolean}\r\n     */\n    allLinear: function allLinear(set) {\n      var l = set.length;\n\n      for (var i = 0; i < l; i++) {\n        if (!__.isLinear(set[i])) return false;\n      }\n\n      return true;\n    },\n\n    /*\r\n     * Checks to see if the \"equation\" is linear\r\n     * @param {Symbol} e\r\n     * @returns {boolean}\r\n     */\n    isLinear: function isLinear(e) {\n      var status = false,\n          g = e.group;\n\n      if (g === PL || g === CP) {\n        status = true;\n\n        for (var s in e.symbols) {\n          var symbol = e.symbols[s],\n              sg = symbol.group;\n\n          if (sg === FN || sg === EX) {\n            status = false;\n          }\n\n          if (sg === CB) {\n            //needs further checking since it might be imaginary\n            status = variables(symbol).length === 1;\n          } else {\n            if (sg === PL || sg === CP) status = __.isLinear(symbol);else {\n              if (symbol.group !== N && symbol.power.toString() !== '1') {\n                status = false;\n                break;\n              }\n            }\n          }\n        }\n      } else if (g === S && e.power === 1) status = true;\n\n      return status;\n    },\n    gcd: function gcd() {\n      var args;\n      if (arguments.length === 1 && arguments[0] instanceof core.Vector) args = arguments[0].elements;else args = core.Utils.arguments2Array(arguments); //short-circuit early\n\n      if (args.length === 0) return new Symbol(1);else if (args.length === 1) return args[0];\n      var appeared = [],\n          evaluate = false;\n\n      for (var i = 0; i < args.length; i++) {\n        if (args[i].group === FN && args[i].fname === 'gcd') {\n          //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\n          args = args.concat(arguments[i].args); //do not keep gcd in args\n\n          args.splice(i, 1);\n        } else {\n          //Look if there are any common variables such that\n          //gcd(a,b) => gcd(a,b); gcd(a,a) => a\n          var vars = variables(args[i]);\n\n          if (core.Utils.haveIntersection(vars, appeared)) {\n            //Ok, there are common variables\n            evaluate = true;\n            break;\n          } else appeared = appeared.concat(vars);\n        }\n      } //appeared.length is 0 when all arguments are group N\n\n\n      if (evaluate || appeared.length === 0) {\n        //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\n        if (args.every(function (symbol) {\n          return symbol.getDenom().equals(1);\n        })) {\n          var aggregate = args[0];\n\n          for (var i = 1; i < args.length; i++) {\n            aggregate = __.gcd_(args[i], aggregate);\n          }\n\n          return aggregate;\n        } else {\n          //gcd_ cannot handle denominators correctly\n          return _.divide(__.gcd.apply(null, args.map(function (symbol) {\n            return symbol.getNum();\n          })), __.lcm.apply(null, args.map(function (symbol) {\n            return symbol.getDenom();\n          })));\n        }\n      } else return _.symfunction('gcd', args);\n    },\n    gcd_: function gcd_(a, b) {\n      if (a.group === FN || a.group === P) a = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(a);\n      });\n      if (b.group === FN) b = core.Utils.block('PARSE2NUMBER', function () {\n        return _.parse(b);\n      });\n\n      if (a.isConstant() && b.isConstant()) {\n        // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\n        return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\n      }\n\n      var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\n\n      a = _.multiply(a.clone(), den.clone());\n      b = _.multiply(b.clone(), den.clone()); //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\n\n      a = _.expand(a);\n      b = _.expand(b);\n\n      if (a.group === CB || b.group === CB) {\n        var q = _.divide(a.clone(), b.clone()); //get the quotient\n\n\n        var t = _.multiply(b.clone(), q.getDenom().invert()); //multiply by the denominator\n        //if they have a common factor then the result will not equal one \n\n\n        if (!t.equals(1)) return t;\n      } //just take the gcd of each component when either of them is in group EX\n\n\n      if (a.group === EX || b.group === EX) {\n        var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\n\n        var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\n\n        var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\n\n        return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\n      }\n\n      if (a.length < b.length) {\n        //swap'm\n        var t = a;\n        a = b;\n        b = t;\n      }\n\n      var vars_a = variables(a),\n          vars_b = variables(b);\n\n      if (vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0] || vars_a.length === 1 && vars_b.length === 0 || vars_a.length === 0 && vars_b.length === 1) {\n        a = new Polynomial(a);\n        b = new Polynomial(b);\n        return _.divide(a.gcd(b).toSymbol(), den);\n      } else {\n        //get the gcd of the multipiers\n        //get rid of gcd in coeffs\n        var multipliers = [];\n        a.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        b.each(function (x) {\n          multipliers.push(x.multiplier);\n        });\n        var T;\n\n        while (!b.equals(0)) {\n          var t = b.clone();\n          a = a.clone();\n          T = __.div(a, t);\n          b = T[1];\n\n          if (T[0].equals(0)) {\n            //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\n            return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\n          }\n\n          a = t;\n        }\n\n        var gcd = core.Math2.QGCD.apply(undefined, multipliers);\n\n        if (!gcd.equals(1)) {\n          a.each(function (x) {\n            x.multiplier = x.multiplier.divide(gcd);\n          });\n        } //return symbolic function for gcd in indeterminate form\n\n\n        if (a.equals(1) && !a.isConstant() && !b.isConstant()) return _.divide(_.symfunction('gcd', arguments), den);\n        return _.divide(a, den);\n      }\n    },\n    lcm: function lcm() {\n      //https://math.stackexchange.com/a/319310\n      //generalization of the 2-variable formula of lcm\n      var args;\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof core.Vector) args = arguments[0].elements;else _.error('lcm expects either 1 vector or 2 or more arguments');\n      } else args = core.Utils.arguments2Array(arguments); //product of all arguments\n      //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n\n      var numer = args.reduce(function (prev, curr) {\n        return _.multiply(prev, curr.clone());\n      }, new Symbol(1)); //gcd of complementary terms\n\n      var denom_args = //https://stackoverflow.com/a/18223072\n      //take all complementary terms, e.g.\n      //[a,b,c] => [a*b, b*c, a*c]\n      //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\n      function (input, size) {\n        size = Number(size);\n        var results = [],\n            result,\n            mask,\n            i,\n            total = Math.pow(2, input.length);\n\n        for (mask = size; mask < total; mask++) {\n          result = [];\n          i = input.length - 1;\n\n          do {\n            if ((mask & 1 << i) !== 0) {\n              result.push(input[i]);\n            }\n          } while (i--);\n\n          if (result.length === size) {\n            results.push(result);\n          }\n        }\n\n        return results; //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\n      }(arguments, arguments.length - 1).map(function (x) {\n        return x.reduce(function (prev, curr) {\n          return _.multiply(prev, curr.clone());\n        }, new Symbol(1));\n      });\n\n      var denom; //don't eat the gcd term if all arguments are symbols\n\n      if (args.every(function (x) {\n        return core.Utils.isVariableSymbol(x);\n      })) denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));else denom = __.gcd.apply(null, denom_args); //divide product of all arguments by gcd of complementary terms\n\n      var div = _.divide(numer, denom);\n\n      return div;\n    },\n\n    /**\r\n     * Divides one expression by another\r\n     * @param {Symbol} symbol1\r\n     * @param {Symbol} symbol2\r\n     * @returns {Array}\r\n     */\n    divide: function divide(symbol1, symbol2) {\n      var result, remainder, factored, den;\n      factored = core.Algebra.Factor.factor(symbol1.clone());\n      den = factored.getDenom();\n\n      if (!den.isConstant('all')) {\n        symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\n      } else //reset the denominator since we're not dividing by it anymore\n        den = new Symbol(1);\n\n      result = __.div(symbol1, symbol2);\n      remainder = _.divide(result[1], symbol2);\n      return _.divide(_.add(result[0], remainder), den);\n    },\n    div: function div(symbol1, symbol2) {\n      // If all else fails then assume that division failed with\n      // a remainder of zero and the original quotient\n      var fail = [new Symbol(0), symbol1.clone()];\n\n      try {\n        // Division by constants\n        if (symbol2.isConstant('all')) {\n          symbol1.each(function (x) {\n            x.multiplier = x.multiplier.divide(symbol2.multiplier);\n          });\n          return [symbol1, new Symbol(0)];\n        } // So that factorized symbols don't affect the result\n\n\n        symbol1 = _.expand(symbol1);\n        symbol2 = _.expand(symbol2); // Special case. May need revisiting\n\n        if (symbol1.group === S && symbol2.group === CP) {\n          var x = symbol1.value;\n          var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\n\n          if (symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\n            var k = Symbol.create(symbol1.multiplier);\n            return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\n          }\n        }\n\n        if (symbol1.group === S && symbol2.group === S) {\n          var r = _.divide(symbol1.clone(), symbol2.clone());\n\n          if (r.isConstant()) //we have a whole\n            return [r, new Symbol(0)];\n          return [new Symbol(0), symbol1.clone()];\n        }\n\n        var symbol1_has_func = symbol1.hasFunc(),\n            symbol2_has_func = symbol2.hasFunc(),\n            parse_funcs = false; //substitute out functions so we can treat them as regular variables\n\n        if (symbol1_has_func || symbol2_has_func) {\n          parse_funcs = true;\n\n          var map = {},\n              symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\n              symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\n              subs = core.Utils.getFunctionsSubs(map);\n        } //get a list of the variables\n\n\n        var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\n            quot,\n            rem; //treat imaginary numbers as variables\n\n        if (symbol1.isImaginary() || symbol2.isImaginary()) {\n          vars.push(core.Settings.IMAGINARY);\n        }\n\n        if (vars.length === 1) {\n          var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\n          quot = q[0].toSymbol();\n          rem = q[1].toSymbol();\n        } else {\n          vars.push(CONST_HASH); //this is for the numbers\n\n          var reconvert = function reconvert(arr) {\n            var symbol = new Symbol(0);\n\n            for (var i = 0; i < arr.length; i++) {\n              var x = arr[i].toSymbol();\n              symbol = _.add(symbol, x);\n            }\n\n            return symbol;\n          }; // Silly Martin. This is why you document. I don't remember now\n\n\n          var get_unique_max = function get_unique_max(term, any) {\n            var max = Math.max.apply(null, term.terms),\n                count = 0,\n                idx;\n\n            if (!any) {\n              for (var i = 0; i < term.terms.length; i++) {\n                if (term.terms[i].equals(max)) {\n                  idx = i;\n                  count++;\n                }\n\n                if (count > 1) return;\n              }\n            }\n\n            if (any) {\n              for (i = 0; i < term.terms.length; i++) {\n                if (term.terms[i].equals(max)) {\n                  idx = i;\n                  break;\n                }\n              }\n            }\n\n            return [max, idx, term];\n          }; // Tries to find an LT in the dividend that will satisfy division\n\n\n          var get_det = function get_det(s, lookat) {\n            lookat = lookat || 0;\n            var det = s[lookat],\n                l = s.length;\n            if (!det) return; //eliminate the first term if it doesn't apply\n\n            var umax = get_unique_max(det);\n\n            for (var i = lookat + 1; i < l; i++) {\n              var term = s[i],\n                  is_equal = det.sum.equals(term.sum);\n\n              if (!is_equal && umax) {\n                break;\n              }\n\n              if (is_equal) {\n                // Check the differences of their maxes. The one with the biggest difference governs\n                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\n                var max1,\n                    max2,\n                    idx1,\n                    idx2,\n                    l2 = det.terms.length;\n\n                for (var j = 0; j < l2; j++) {\n                  var item1 = det.terms[j],\n                      item2 = term.terms[j];\n\n                  if (typeof max1 === 'undefined' || item1.greaterThan(max1)) {\n                    max1 = item1;\n                    idx1 = j;\n                  }\n\n                  if (typeof max2 === 'undefined' || item2.greaterThan(max2)) {\n                    max2 = item2;\n                    idx2 = j;\n                  }\n                } //check their differences\n\n\n                var d1 = max1.subtract(term.terms[idx1]),\n                    d2 = max2.subtract(det.terms[idx2]);\n\n                if (d2 > d1) {\n                  umax = [max2, idx2, term];\n                  break;\n                }\n\n                if (d1 > d2) {\n                  umax = [max1, idx1, det];\n                  break;\n                }\n              } else {\n                //check if it's a suitable pick to determine the order\n                umax = get_unique_max(term); //if(umax) return umax;\n\n                if (umax) break;\n              }\n\n              umax = get_unique_max(term); //calculate a new unique max\n            } //if still no umax then any will do since we have a tie\n\n\n            if (!umax) return get_unique_max(s[0], true);\n            var e, idx;\n\n            for (var i = 0; i < s2.length; i++) {\n              var cterm = s2[i].terms; //confirm that this is a good match for the denominator\n\n              idx = umax[1];\n              if (idx === cterm.length - 1) return;\n              e = cterm[idx];\n              if (!e.equals(0)) break;\n            }\n\n            if (e.equals(0)) return get_det(s, ++lookat); //look at the next term\n\n            return umax;\n          };\n\n          var t_map = core.Utils.toMapObj(vars);\n\n          var init_sort = function init_sort(a, b) {\n            return b.sum.subtract(a.sum);\n          };\n\n          var is_larger = function is_larger(a, b) {\n            if (!a || !b) return false; //it's empty so...\n\n            for (var i = 0; i < a.terms.length; i++) {\n              if (a.terms[i].lessThan(b.terms[i])) return false;\n            }\n\n            return true;\n          };\n\n          var s1 = symbol1.tBase(t_map).sort(init_sort),\n              s2 = symbol2.tBase(t_map).sort(init_sort);\n          var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\n\n          var det = get_det(target); //we'll begin by assuming that this will let us know which term \n\n          var quotient = [];\n\n          if (det) {\n            var lead_var = det[1];\n\n            var can_divide = function can_divide(a, b) {\n              if (a[0].sum.equals(b[0].sum)) return a.length >= b.length;\n              return true;\n            };\n\n            var try_better_lead_var = function try_better_lead_var(s1, s2, lead_var) {\n              var checked = [];\n\n              for (var i = 0; i < s1.length; i++) {\n                var t = s1[i];\n\n                for (var j = 0; j < t.terms.length; j++) {\n                  var cf = checked[j],\n                      tt = t.terms[j];\n                  if (i === 0) checked[j] = tt; //add the terms for the first one\n                  else if (cf && !cf.equals(tt)) checked[j] = undefined;\n                }\n              }\n\n              for (var i = 0; i < checked.length; i++) {\n                var t = checked[i];\n                if (t && !t.equals(0)) return i;\n              }\n\n              return lead_var;\n            };\n\n            var sf = function sf(a, b) {\n              var l1 = a.len(),\n                  l2 = b.len();\n              var blv = b.terms[lead_var],\n                  alv = a.terms[lead_var];\n              if (l2 > l1 && blv.greaterThan(alv)) return l2 - l1;\n              return blv.subtract(alv);\n            }; //check to see if there's a better lead_var\n\n\n            lead_var = try_better_lead_var(s1, s2, lead_var); //reorder both according to the max power\n\n            s1.sort(sf); //sort them both according to the leading variable power\n\n            s2.sort(sf); //try to adjust if den is larger\n\n            var fdt = s2[0],\n                fnt = s1[0];\n            var den = new MVTerm(new Frac(1), [], fnt.map);\n\n            if (fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\n              for (var i = 0; i < fnt.terms.length; i++) {\n                var d = fdt.terms[i].subtract(fnt.terms[i]);\n\n                if (!d.equals(0)) {\n                  var nd = d.add(new Frac(1));\n                  den.terms[i] = d;\n\n                  for (var j = 0; j < s1.length; j++) {\n                    s1[j].terms[i] = s1[j].terms[i].add(nd);\n                  }\n                } else den.terms[i] = new Frac(0);\n              }\n            }\n\n            var dividend_larger = is_larger(s1[0], s2[0]);\n            var safety = 0;\n            var max = 200;\n\n            while (dividend_larger && can_divide(s1, s2)) {\n              if (safety++ > max) {\n                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\n              }\n\n              var q = s1[0].divide(s2[0]);\n              quotient.push(q); //add what's divided to the quotient\n\n              s1.shift(); //the first one is guaranteed to be gone so remove from dividend\n\n              for (var i = 1; i < s2.length; i++) {\n                //loop through the denominator\n                var t = s2[i].multiply(q).generateImage(),\n                    l2 = s1.length; //if we're subtracting from 0\n\n                if (l2 === 0) {\n                  t.coeff = t.coeff.neg();\n                  s1.push(t);\n                  s1.sort(sf);\n                }\n\n                for (var j = 0; j < l2; j++) {\n                  var cur = s1[j];\n\n                  if (cur.getImg() === t.getImg()) {\n                    cur.coeff = cur.coeff.subtract(t.coeff);\n\n                    if (cur.coeff.equals(0)) {\n                      core.Utils.remove(s1, j);\n                      j--; //adjust the iterator\n                    }\n\n                    break;\n                  }\n\n                  if (j === l2 - 1) {\n                    t.coeff = t.coeff.neg();\n                    s1.push(t);\n                    s1.sort(sf);\n                  }\n                }\n              }\n\n              dividend_larger = is_larger(s1[0], s2[0]);\n\n              if (!dividend_larger && s1.length >= s2.length) {\n                //One more try since there might be a terms that is larger than the LT of the divisor\n                for (var i = 1; i < s1.length; i++) {\n                  dividend_larger = is_larger(s1[i], s2[0]);\n\n                  if (dividend_larger) {\n                    //take it from its current position and move it to the front\n                    s1.unshift(core.Utils.remove(s1, i));\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          quot = reconvert(quotient);\n          rem = reconvert(s1);\n\n          if (typeof den !== 'undefined') {\n            den = den.toSymbol();\n            quot = _.divide(quot, den.clone());\n            rem = _.divide(rem, den);\n          }\n        } //put back the functions\n\n\n        if (parse_funcs) {\n          quot = _.parse(quot.text(), subs);\n          rem = _.parse(rem.text(), subs);\n        }\n\n        return [quot, rem];\n      } catch (e) {\n        return fail;\n      }\n    },\n    line: function line(v1, v2, x) {\n      if (core.Utils.isArray(v1)) v1 = core.Utils.convertToVector(v1);\n      if (core.Utils.isArray(v2)) v2 = core.Utils.convertToVector(v2);\n      x = _.parse(x || 'x');\n      if (!core.Utils.isVector(v1) || !core.Utils.isVector(v2)) _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\n\n      var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\n          dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\n          m = _.divide(dy, dx),\n          a = _.multiply(x, m.clone()),\n          b = _.multiply(v1.e(1).clone(), m);\n\n      return _.add(_.subtract(a, b), v1.e(2).clone());\n    },\n    PartFrac: {\n      createTemplate: function createTemplate(den, denom_factors, f_array, v) {\n        //clean up the denominator function by factors so it reduces nicely\n        den = __.Factor.factor(den); //clean up factors. This is so inefficient but factors are wrapped in parens for safety\n\n        den.each(function (x, key) {\n          if (x.group === FN && x.fname === '' && x.args[0].group === S) {\n            var y = x.args[0];\n\n            if (this.symbols) {\n              delete this.symbols[key];\n              this.symbols[y.value] = y;\n            } else {\n              den = x.args[0];\n            }\n          }\n        });\n        var factors, factors_vec, f, p, deg, degrees, m;\n        factors = denom_factors.collectFactors();\n        factors_vec = []; //a vector for the template\n\n        degrees = [];\n        m = new Symbol(1);\n\n        for (var i = 0; i < factors.length; i++) {\n          //loop through the factors\n          var factor = Symbol.unwrapPARENS(factors[i]); //if in he for P^n where P is polynomial and n = integer\n\n          if (factor.power.greaterThan(1)) {\n            p = Number(factor.power);\n            f = factor.clone().toLinear(); //remove the power so we have only the function\n\n            deg = Number(__.degree(f, v)); //get the degree of f\n            //expand the factor\n\n            for (var j = 0; j < p; j++) {\n              var efactor = _.pow(f.clone(), new Symbol(j + 1));\n\n              f_array.push(efactor.clone());\n\n              var d = _.divide(den.clone(), efactor.clone());\n\n              degrees.push(deg);\n              factors_vec.push(d);\n            }\n          }\n          /*\r\n           Possible bug.\r\n           Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n           else if(factor.isConstant('all')) {\r\n           m = _.multiply(m, factor);\r\n           }\r\n           */\n          else {\n            //get the degree of the factor so we tack it on tot he factor. This should probably be an array\n            //but for now we note it on the symbol\n            deg = Number(__.degree(factor, v));\n            f_array.push(factor);\n\n            var d = _.divide(den.clone(), factor.clone());\n\n            d = _.expand(Symbol.unwrapPARENS(d));\n            degrees.push(deg);\n            factors_vec.push(d);\n          }\n        } //put back the constant\n\n\n        f_array = f_array.map(function (x) {\n          return _.multiply(x, m.clone());\n        });\n        return [f_array, factors_vec, degrees];\n      },\n      partfrac: function partfrac(symbol, v, as_array) {\n        var vars = variables(symbol);\n        v = v || _.parse(vars[0]); //make wrt optional and assume first variable\n\n        try {\n          var num, den, factors, tfactors, ofactors, nterms, degrees, dterms, max, M, c, powers, div, r, factors_vec, ks, template, tfactors;\n          num = _.expand(symbol.getNum());\n          den = _.expand(symbol.getDenom().toUnitMultiplier()); //move the entire multipier to the numerator\n\n          num.multiplier = symbol.multiplier; //we only have a meaningful change if n factors > 1. This means that\n          //the returned group will be a CB\n          //collect the terms wrt the x\n\n          nterms = num.groupTerms(v); //divide out wholes if top is larger\n\n          if (Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\n            div = __.div(num.clone(), _.expand(den.clone()));\n            r = div[0]; //remove the wholes\n\n            num = div[1]; //work with the remainder\n\n            nterms = num.groupTerms(v); //recalculate the nterms\n          } else r = new Symbol(0);\n\n          if (Number(__.degree(den, v)) === 1) {\n            var q = _.divide(num, den);\n\n            if (as_array) return [r, q];\n            return _.add(r, q);\n          } //first factor the denominator. This means that the strength of this\n          //algorithm depends on how well we can factor the denominator. \n\n\n          ofactors = __.Factor.factor(den); //create the template. This method will create the template for solving \n          //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\n\n          template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\n          tfactors = template[0]; //grab the factors\n\n          factors_vec = template[1]; //grab the factor vectors\n\n          degrees = template[2]; //grab the degrees\n          //make note of the powers of each term\n\n          powers = [nterms.length]; //create the dterms vector\n\n          dterms = [];\n          factors = [];\n          ks = [];\n          var factor, deg;\n          factors_vec.map(function (x, idx) {\n            factor = tfactors[idx];\n            deg = degrees[idx];\n\n            for (var i = 0; i < deg; i++) {\n              factors.push(factor.clone());\n              var k = Symbol.create(v, i);\n\n              var t = _.expand(_.multiply(x, k.clone())).groupTerms(v); //make a note of the power which corresponds to the length of the array\n\n\n              var p = t.length;\n              powers.push(p);\n              dterms.push(t);\n              ks.push(k.clone());\n            }\n          }); //get the max power\n\n          max = core.Utils.arrayMax(powers); //fill the holes and create a matrix\n\n          c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose(); //for each of the factors we do the same\n\n          M = new core.Matrix();\n\n          for (var i = 0; i < dterms.length; i++) {\n            M.elements.push(core.Utils.fillHoles(dterms[i], max));\n          } //solve the system of equations\n\n\n          var partials = _.multiply(M.transpose().invert(), c); //the results are backwards to reverse it\n          //partials.elements.reverse();\n          //convert it all back\n\n\n          var retval = as_array ? [r] : r;\n          partials.each(function (e, i) {\n            var term = _.multiply(ks[i], _.divide(e, factors[i]));\n\n            if (as_array) retval.push(term);else retval = _.add(retval, term);\n          }); //done\n\n          return retval;\n        } catch (e) {\n          //try to group symbols\n          try {\n            if (symbol.isComposite()) {\n              //group denominators\n              var denominators = {};\n              symbol.each(function (x) {\n                var d = x.getDenom();\n                var n = x.getNum();\n                var e = denominators[d];\n                denominators[d] = e ? _.add(e, n) : n;\n              });\n              var t = new Symbol(0);\n\n              for (var x in denominators) {\n                t = _.add(t, _.divide(denominators[x], _.parse(x)));\n              }\n\n              symbol = t;\n            }\n          } catch (e2) {}\n\n          ;\n        }\n\n        ;\n        return symbol;\n      }\n    },\n    degree: function degree(symbol, v, o) {\n      o = o || {\n        nd: [],\n        //numeric\n        sd: [],\n        //symbolic\n        depth: 0 //call depth\n\n      };\n\n      if (!v) {\n        var vars = variables(symbol); //The user must specify the variable for multivariate\n\n        if (vars.length > 1) throw new Error('You must specify the variable for multivariate polynomials!'); //if it's empty then we're dealing with a constant\n\n        if (vars.length === 0) return new Symbol(0); //assume the variable for univariate\n\n        v = _.parse(vars[0]);\n      } //store the group\n\n\n      var g = symbol.group; //we're going to trust the user and assume no EX. Calling isPoly \n      //would eliminate this but no sense in checking twice. \n\n      if (symbol.isComposite()) {\n        symbol = symbol.clone();\n        symbol.distributeExponent();\n        symbol.each(function (x) {\n          o.depth++; //mark a depth increase\n\n          __.degree(x, v, o);\n\n          o.depth--; //we're back\n        });\n      } else if (symbol.group === CB) {\n        symbol.each(function (x) {\n          o.depth++;\n\n          __.degree(x, v, o);\n\n          o.depth++;\n        });\n      } else if (g === EX && symbol.value === v.value) {\n        o.sd.push(symbol.power.clone());\n      } else if (g === S && symbol.value === v.value) {\n        o.nd.push(_.parse(symbol.power));\n      } else o.nd.push(new Symbol(0)); //get the max out of the array\n\n\n      var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\n\n      if (o.depth === 0 && o.sd.length > 0) {\n        if (deg !== undefined) o.sd.unshift(deg);\n        return _.symfunction('max', o.sd);\n      }\n\n      if (!core.Utils.isSymbol(deg)) deg = _.parse(deg); //return the degree\n\n      return deg;\n    },\n\n    /**\r\n     * Attempts to complete the square of a polynomial\r\n     * @param {type} symbol\r\n     * @param {type} v\r\n     * @param {type} raw\r\n     * @throws {Error} \r\n     * @returns {Object|Symbol[]}\r\n     */\n    sqComplete: function sqComplete(symbol, v, raw) {\n      if (!core.Utils.isSymbol(v)) v = _.parse(v);\n\n      var stop = function stop(msg) {\n        msg = msg || 'Stopping';\n        throw new core.exceptions.ValueLimitExceededError(msg);\n      }; //if not CP then nothing to do\n\n\n      if (!symbol.isPoly(true)) stop('Must be a polynomial!'); //declare vars\n\n      var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\n      br = core.Utils.inBrackets; //make a copy\n\n      symbol = symbol.clone();\n      deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\n      //must be in form ax^2 +/- bx +/- c\n\n      if (!deg.equals(2)) stop('Cannot complete square for degree ' + deg); //get the coeffs\n\n      coeffs = core.Algebra.coeffs(symbol, v);\n      a = coeffs[2]; //store the sign\n\n      sign = coeffs[1].sign(); //divide the linear term by two and square it\n\n      b = _.divide(coeffs[1], new Symbol(2)); //add the difference to the constant\n\n      c = _.pow(b.clone(), new Symbol(2));\n      if (raw) return [a, b, d];\n      sqrt_a = math.sqrt(a);\n      e = _.divide(math.sqrt(c), sqrt_a.clone()); //calculate d which is the constant\n\n      d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2))); //compute the square part\n\n      sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\n      return {\n        a: sym,\n        c: d,\n        f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\n      };\n    },\n    Simplify: {\n      strip: function strip(symbol) {\n        var c = _.parse(symbol.multiplier);\n\n        symbol.toUnitMultiplier();\n\n        var p = _.parse(symbol.power);\n\n        symbol.toLinear();\n        return [c, p, symbol];\n      },\n      unstrip: function unstrip(cp, symbol) {\n        var c = cp[0];\n        var p = cp[1];\n        return _.multiply(c, _.pow(symbol, p));\n      },\n      complexSimp: function complexSimp(num, den) {\n        var ac, bd, bc, ad, cd, r1, r2, i1, i2;\n        r1 = num.realpart();\n        i1 = num.imagpart();\n        r2 = den.realpart();\n        i2 = den.imagpart(); //apply complex arithmatic rule\n\n        ac = _.multiply(r1.clone(), r2.clone());\n        bd = _.multiply(i1.clone(), i2.clone());\n        bc = _.multiply(r2.clone(), i1);\n        ad = _.multiply(r1, i2.clone());\n        cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\n        return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\n      },\n      trigSimp: function trigSimp(symbol) {\n        if (symbol.containsFunction(['cos', 'sin', 'tan'])) {\n          symbol = symbol.clone(); //remove power and multiplier\n\n          var sym_array = __.Simplify.strip(symbol);\n\n          symbol = sym_array.pop(); //the default return value is the symbol\n\n          var retval = symbol.clone(); //rewrite the symbol\n\n          if (symbol.group === CP) {\n            var sym = new Symbol(0);\n            symbol.each(function (x) {\n              //rewrite the function\n              var tr = __.Simplify.trigSimp(x.fnTransform());\n\n              sym = _.add(sym, tr);\n            }, true); //put back the power and multiplier and return\n\n            retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\n          } else if (symbol.group === CB) {\n            var n = symbol.getNum();\n            var d = symbol.getDenom(); //try for tangent\n\n            if (n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\n              retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\n            }\n\n            if (retval.group === CB) {\n              var t = new Symbol(1);\n              retval.each(function (x) {\n                if (x.fname === 'tan') {\n                  x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\n                }\n\n                t = _.multiply(t, x);\n              });\n              retval = t;\n            }\n          }\n\n          retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\n          symbol = retval;\n        }\n\n        return symbol;\n      },\n      fracSimp: function fracSimp(symbol) {\n        //try a quick simplify of imaginary numbers\n        var den = symbol.getDenom();\n        var num = symbol.getNum();\n        if (num.isImaginary() && den.isImaginary()) symbol = __.Simplify.complexSimp(num, den);\n\n        if (symbol.isComposite()) {\n          if (symbol.power > 1) {\n            symbol = _.expand(symbol);\n          }\n\n          var symbols = symbol.collectSymbols(); //assumption 1.\n          //since it's a composite, it has a length of at least 1\n\n          var retval, a, b, d1, d2, n1, n2, s, x, y, c, den, num;\n          a = symbols.pop(); //grab the first symbol\n          //loop through each term and make denominator common\n\n          while (symbols.length) {\n            b = symbols.pop(); //grab the second symbol\n\n            d1 = _.parse(a.getDenom());\n            d2 = _.parse(b.getDenom());\n            n1 = a.getNum();\n            n2 = b.getNum();\n            c = _.multiply(d1.clone(), d2.clone());\n            x = _.multiply(n1, d2);\n            y = _.multiply(n2, d1);\n            s = _.add(x, y);\n            a = _.divide(s, c);\n          }\n\n          den = _.expand(a.getDenom());\n          num = _.expand(a.getNum()); //simplify imaginary\n\n          if (num.isImaginary() && den.isImaginary()) {\n            retval = __.Simplify.complexSimp(num, den);\n          } else {\n            retval = _.divide(num, den);\n          } //we've already hit the simplest form so return that\n\n\n          if (retval.equals(symbol)) {\n            return symbol;\n          } //otherwise simplify it some more\n\n\n          return __.Simplify.simplify(retval);\n        }\n\n        return symbol;\n      },\n      ratSimp: function ratSimp(symbol) {\n        if (symbol.group === CB) {\n          var den = symbol.getDenom();\n          var num = symbol.getNum().distributeMultiplier();\n\n          var d = __.Simplify.fracSimp(den);\n\n          var n = __.Simplify.fracSimp(num);\n\n          symbol = _.divide(n, d);\n        }\n\n        return symbol;\n      },\n      sqrtSimp: function sqrtSimp(symbol, sym_array) {\n        var retval;\n\n        if (symbol.isSQRT()) {\n          var factored = __.Factor.factor(symbol.args[0].clone());\n\n          var m = _.parse(factored.multiplier);\n\n          var sign = m.sign();\n\n          var retval = _.sqrt(m.abs());\n\n          var arg;\n\n          if (isInt(retval)) {\n            if (factored.group === CB) {\n              var rem = new Symbol(1);\n              factored.each(function (x) {\n                if (x.group === N) {\n                  var trial = _.sqrt(x.clone()); // Multiply back sqrt if it's an integer otherwise just put back the number\n\n\n                  if (isInt(trial)) {\n                    retval = _.multiply(retval, trial);\n                  } else {\n                    rem = _.multiply(rem, x);\n                  }\n                } else {\n                  rem = _.multiply(rem, x);\n                }\n              });\n\n              var t = _.multiply(rem, _.parse(sign));\n\n              arg = _.sqrt(t.clone()); // Expand if it's imaginary\n\n              if (arg.isImaginary) {\n                arg = _.sqrt(_.expand(t.clone()));\n              }\n            } else {\n              // Strip the multiplier\n              arg = _.sqrt(factored.clone().toUnitMultiplier());\n            }\n\n            return _.multiply(retval, arg);\n          }\n        } else if (symbol.isComposite() && symbol.isLinear()) {\n          retval = new Symbol(0);\n          symbol.each(function (x) {\n            retval = _.add(retval, __.Simplify.sqrtSimp(x));\n          }, true); // Put back the multiplier\n\n          retval = _.multiply(retval, _.parse(symbol.multiplier));\n        } else if (symbol.group === CB) {\n          retval = _.parse(symbol.multiplier);\n          symbol.each(function (x) {\n            var simp = __.Simplify.sqrtSimp(x);\n\n            retval = _.multiply(retval, simp);\n          }, true); // Put back the power\n\n          retval = _.pow(retval, _.parse(symbol.power));\n        }\n\n        return retval ? retval : _.parse(symbol);\n      },\n\n      /**\r\n       * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n       * @param {Symbol} symbol\r\n       * @return {Array} The symbol and the matched patterns\r\n       */\n      patternSub: function patternSub(symbol) {\n        var patterns = {};\n\n        var has_CP = function has_CP(symbol) {\n          var found = false;\n          symbol.each(function (x) {\n            if (x.group === CP) {\n              found = true;\n            } else if (x.symbols) {\n              found = has_CP(x);\n            }\n          });\n          return found;\n        };\n\n        var collect = function collect(sym) {\n          // We loop through each symbol looking for anything in the simplest\n          // form of ax+byz+...\n          sym.each(function (x) {\n            // Items of group N,P,S, need to apply\n            if (!x.symbols && x.group !== FN) {\n              return;\n            } // Check to see if it has any symbols of group CP\n            // Get the patterns in that symbol instead if it has anything of group CP\n\n\n            if (has_CP(x)) {\n              collect(x);\n            } else {\n              if (!patterns[x.value]) {\n                var u = core.Utils.getU(symbol); // Get a u value and mark it for subsitution\n\n                patterns[x.value] = u;\n                symbol = symbol.sub(x.value, u);\n              }\n            }\n          }, true);\n        }; // Collect a list of patterns\n\n\n        collect(symbol);\n        return [symbol, patterns];\n      },\n      simplify: function simplify(symbol) {\n        //remove the multiplier to make calculation easier;\n        var sym_array = __.Simplify.strip(symbol);\n\n        symbol = sym_array.pop(); //remove gcd from denominator\n\n        symbol = __.Simplify.fracSimp(symbol); //nothing more to do\n\n        if (symbol.isConstant() || symbol.group === core.groups.S) {\n          sym_array.push(symbol);\n\n          var ret = __.Simplify.unstrip(sym_array, symbol);\n\n          return ret;\n        } //var patterns;\n\n\n        var simplified = symbol.clone(); //make a copy\n        //[simplified, patterns] = __.Simplify.patternSub(symbol);\n        // Simplify sqrt within the symbol\n        //                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\n        // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\n\n        simplified = __.Simplify.trigSimp(simplified); // Simplify common denominators\n\n        simplified = __.Simplify.ratSimp(simplified); // First go for the \"cheapest\" simplification which may eliminate \n        // your problems right away. factor -> evaluate. Remember\n        // that there's no need to expand since factor already does that\n\n        simplified = __.Factor.factor(simplified); //If the simplfied is a sum then we can make a few more simplifications\n        //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\n\n        if (simplified.group === core.groups.CP && simplified.isLinear()) {\n          var m = simplified.multiplier.clone();\n          simplified.toUnitMultiplier(); //strip the multiplier\n\n          var r = new Symbol(0); //return the sum of simplifications\n\n          simplified.each(function (x) {\n            var s = __.Simplify.simplify(x);\n\n            r = _.add(r, s);\n          });\n          simplified = r; //put back the multiplier\n\n          r.multiplier = r.multiplier.multiply(m);\n        } //place back multiplier and return\n\n\n        var retval = __.Simplify.unstrip(sym_array, simplified); // Back substitute\n\n        /*\r\n         for(var x in patterns) {\r\n         retval = retval.sub(patterns[x], x);\r\n         }\r\n         */\n\n\n        return retval;\n      }\n    },\n    Classes: {\n      Polynomial: Polynomial,\n      Factors: Factors,\n      MVTerm: MVTerm\n    }\n  }; // Add a link to simplify\n\n\n  core.Expression.prototype.simplify = function () {\n    return __.Simplify.simplify(this.symbol);\n  };\n\n  nerdamer.useAlgebraDiv = function () {\n    var divide = __.divideFn = _.divide;\n    var calls = 0; //keep track of how many calls were made\n\n    _.divide = function (a, b) {\n      calls++;\n      var ans;\n      if (calls === 1) //check if this is the first call. If it is use algebra divide\n        ans = core.Algebra.divide(a, b);else //otherwise use parser divide\n        ans = divide(a, b);\n      calls = 0; //reset the number of calls back to none\n\n      return ans;\n    };\n  };\n\n  nerdamer.useParserDiv = function () {\n    if (__.divideFn) _.divide = __.divideFn;\n    delete __.divideFn;\n  };\n\n  nerdamer.register([{\n    name: 'factor',\n    visible: true,\n    numargs: 1,\n    build: function build() {\n      return __.Factor.factor;\n    }\n  }, {\n    name: 'simplify',\n    visible: true,\n    numargs: 1,\n    build: function build() {\n      return __.Simplify.simplify;\n    }\n  }, {\n    name: 'gcd',\n    visible: true,\n    numargs: [1],\n    build: function build() {\n      return __.gcd;\n    }\n  }, {\n    name: 'lcm',\n    visible: true,\n    numargs: [1],\n    build: function build() {\n      return __.lcm;\n    }\n  }, {\n    name: 'roots',\n    visible: true,\n    numargs: -1,\n    build: function build() {\n      return __.roots;\n    }\n  }, {\n    name: 'divide',\n    visible: true,\n    numargs: 2,\n    build: function build() {\n      return __.divide;\n    }\n  }, {\n    name: 'div',\n    visible: true,\n    numargs: 2,\n    build: function build() {\n      return __.div;\n    }\n  }, {\n    name: 'partfrac',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      return __.PartFrac.partfrac;\n    }\n  }, {\n    name: 'deg',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      return __.degree;\n    }\n  }, {\n    name: 'coeffs',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      var f = function f() {\n        var coeffs = __.coeffs.apply(__, arguments);\n\n        return new core.Vector(coeffs);\n      };\n\n      return f;\n    }\n  }, {\n    name: 'line',\n    visible: true,\n    numargs: [2, 3],\n    build: function build() {\n      return __.line;\n    }\n  }, {\n    name: 'sqcomp',\n    visible: true,\n    numargs: [1, 2],\n    build: function build() {\n      var f = function f(x, v) {\n        try {\n          v = v || variables(x)[0];\n\n          var sq = __.sqComplete(x.clone(), v);\n\n          return sq.f;\n        } catch (e) {\n          return x;\n        }\n      };\n\n      return f;\n    }\n  }]);\n  nerdamer.updateAPI();\n})();","map":{"version":3,"names":["module","nerdamer","require","core","getCore","_","PARSER","N","groups","P","S","EX","FN","PL","CP","CB","keys","Utils","even","variables","format","round","Frac","isInt","Symbol","CONST_HASH","Settings","math","importFunctions","evaluate","Polynomial","symbol","variable","order","isSymbol","parse","isNaN","undefined","exceptions","InvalidVariableNameError","coeffs","fill","fromArray","arr","p","fit","c1","c2","n","base","terms","Array","t","Math","pow","i","b","q","sign","c","floor","abs","length","prototype","isPoly","NerdamerTypeError","text","power","absEquals","expand","group","multiplier","toDecimal","x","symbols","sub","Number","l","trim","equalsZero","equals","pop","modP","j","subtract","add","d","mod","w","divide","up_one","next","poly","max","a","dividend","arrayClone","divisor","mp","quotient","multiply","p1","p2","l1","l2","x1","k","x2","e","isZero","sum","clone","deg","lc","monic","gcd","mp1","mp2","T","Math2","QGCD","apply","diff","new_array","push","integrate","gcf","toPolynomial","fnz","ca","indexOf","parr","quad","incl_img","roots","Error","dsc","sqrt","squareFree","output","equalsNumber","y","z","toSymbol","end","str","plus","String","toString","with_order","error","s","distributeMultiplier","isComposite","isConstant","isImaginary","m","each","imaginary","tBase","map","collectSymbols","g","nterm","MVTerm","sym","value","updateCount","altVar","sameVars","groupTerms","f","egrouped","grouped","el","decompose_fn","collectFactors","factors","Factors","getNumberSymbolics","fo","firstObject","symfunction","PARENTHESIS","obj","negate","key","preAdd","pFactor","is_constant","v","factored","Object","values","sort","factor","fname","unwrapPARENS","merge","o","isLinear","args","call","count","clean","h","lessThan","coeff","image","getVars","vars","term","rev_map","getRevMap","join","len","mapped","generateImage","getImg","mvterm","new_mvterm","toMapObj","filledArray","clss","arrSum","haveIntersection","some","subFunctions","subbed","previousGroup","val","tvar","inBrackets","getFunctionsSubs","subs","__","Algebra","version","proots","decp","zeros","known_roots","get_roots","rarr","powers","calcroots","concat","unshift","lowest_pow","arrayMin","lowest_symbol","toUnitMultiplier","minpower","arrayMax","isArray","last_power","MAXDEGREE","slice","ValueLimitExceededError","zeroi","degreePar","Degree","zeror","QuadSD_ak1","NN","u","iPar","calcSC_ak1","DBL_EPSILON","K","qk","sdPar","dumFlag","a3","a1","a7","nextK_ak1","tFlag","qp","temp","newest_ak1","a4","a5","b1","b2","c3","c4","Quad_ak1","sr","si","lr","li","QuadIT_ak1","uu","vv","calcPar","qPar","ee","omp","relstp","ui","vi","zm","triedFlag","NZ","szr","szi","lzr","lzi","RealIT_ak1","kv","ms","pv","nm1","Fxshfr_ak1","MDP1","L2","svk","betas","betav","oss","ots","otv","ovv","ss","ts","tss","tv","tvv","fflag","iFlag","spass","stry","vpass","vtry","rpSolve","degPar","RADFAC","LB2","LN2","pt","Fxshfr_Par","bnd","df","dx","ff","moduli_max","moduli_min","sc","xm","aa","bb","cc","xxx","jj","NM1","zerok","LO","MIN_VALUE","cosr","cos","sinr","sin","xx","yy","MAX_VALUE","log","exp","img","real","num","replace","nroots","Vector","froot","guess","newtonraph","xn","mesh","build","Calculus","fn","Function","done","safety","r","delta","sumProd","invert","wrt","contains","polyPowers","for_variable","arrayUnique","Factor","split","mix","include_negatives","ll","common","zeroes","exit","tp","allSame","n_terms","n_zeroes","div","_symbol","retval","_factor","create","_factored","quadFactor","degree","cf","root","filter","root1","root2","cubeFactor","sign_a","sign_b","isCube","m_root_a","getNth","m_root_b","arg","isSimple","greaterThan","untouched","den_array","num_array","den","dfact","nfact","Simplify","strip","getDenom","getNum","unstrip","ret","toLinear","IMAGINARY","multiVar","all_S","all_unit","coeff_factors","coeffFactor","power_factors","powerFactor","t_factors","trialAndError","tf_symbol","t_factor","mfactor","addPower","reduce","nn","result","sqfr","allNumeric","updateHash","LT","factor_array","cnst","cfactors","ifactor","search","forEach","check","candidate","ltfactors","isubbed","nfactors","cp","ceil","lc_is_neg","cnst_is_neg","factor_found","isPrime","mSqfrFactor","reverse","can_divide","is_factor","sqdiff","remove_square","block","separated","separate","obj_array","constants","powSimp","factors2","unwrapSQRT","sorted","maxes","new_factor","divided","has_fractions","neg_numeric_factor","rem","allLinear","set","status","sg","arguments","elements","arguments2Array","appeared","splice","every","aggregate","gcd_","lcm","gcd_m","GCD","gcd_v","gcd_p","vars_a","vars_b","multipliers","numer","prev","curr","denom_args","input","size","results","mask","total","denom","isVariableSymbol","symbol1","symbol2","remainder","fail","symbol1_has_func","hasFunc","symbol2_has_func","parse_funcs","quot","reconvert","get_unique_max","any","idx","get_det","lookat","det","umax","is_equal","max1","max2","idx1","idx2","item1","item2","d1","d2","s2","cterm","t_map","init_sort","is_larger","s1","target","lead_var","try_better_lead_var","checked","tt","sf","blv","alv","fdt","fnt","nd","dividend_larger","InfiniteLoopError","shift","neg","cur","remove","line","v1","v2","convertToVector","isVector","dy","PartFrac","createTemplate","denom_factors","f_array","factors_vec","degrees","efactor","partfrac","as_array","tfactors","ofactors","nterms","dterms","M","ks","template","Matrix","fillHoles","transpose","partials","denominators","e2","sd","depth","distributeExponent","sqComplete","raw","stop","msg","br","sqrt_a","complexSimp","ac","bd","bc","ad","cd","r1","r2","i1","i2","realpart","imagpart","trigSimp","containsFunction","sym_array","tr","fnTransform","simplify","fracSimp","n1","n2","ratSimp","sqrtSimp","isSQRT","trial","simp","patternSub","patterns","has_CP","found","collect","getU","simplified","Classes","Expression","useAlgebraDiv","divideFn","calls","ans","useParserDiv","register","name","visible","numargs","sq","updateAPI"],"sources":["G:/gitlab/TFG/Aplicacion/node_modules/nerdamer/Algebra.js"],"sourcesContent":["/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global module, Function */\r\n\r\nif((typeof module) !== 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Calculus.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    /*shortcuts*/\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            N = core.groups.N,\r\n            P = core.groups.P,\r\n            S = core.groups.S,\r\n            EX = core.groups.EX,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            keys = core.Utils.keys,\r\n            even = core.Utils.even,\r\n            variables = core.Utils.variables,\r\n            format = core.Utils.format,\r\n            round = core.Utils.round,\r\n            Frac = core.Frac,\r\n            isInt = core.Utils.isInt,\r\n            Symbol = core.Symbol,\r\n            CONST_HASH = core.Settings.CONST_HASH,\r\n            math = core.Utils.importFunctions(),\r\n            evaluate = core.Utils.evaluate;\r\n    //*************** CLASSES ***************//\r\n    /**\r\n     * Converts a symbol into an equivalent polynomial arrays of \r\n     * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n     * Univariate polymials only. \r\n     * @param {Symbol|Number} symbol\r\n     * @param {String} variable The variable name of the polynomial\r\n     * @param {int} order\r\n     */\r\n    function Polynomial(symbol, variable, order) {\r\n        if(core.Utils.isSymbol(symbol)) {\r\n            this.parse(symbol);\r\n            this.variable = this.variable || variable;\r\n        }\r\n        else if(!isNaN(symbol)) {\r\n            order = order || 0;\r\n            if(variable === undefined)\r\n                throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\r\n            this.coeffs = [];\r\n            this.coeffs[order] = symbol;\r\n            this.fill(symbol);\r\n        }\r\n        else if(typeof symbol === 'string') {\r\n            this.parse(_.parse(symbol));\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Polynomial given an array of coefficients\r\n     * @param {int[]} arr\r\n     * @param {String} variable\r\n     * @returns {Polynomial}\r\n     */\r\n    Polynomial.fromArray = function (arr, variable) {\r\n        if(typeof variable === 'undefined')\r\n            throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\r\n        var p = new Polynomial();\r\n        p.coeffs = arr;\r\n        p.variable = variable;\r\n        return p;\r\n    };\r\n\r\n    Polynomial.fit = function (c1, c2, n, base, p, variable) {\r\n        //after having looped through and mod 10 the number to get the matching factor\r\n        var terms = new Array(p + 1),\r\n                t = n - c2;\r\n        terms[0] = c2; //the constants is assumed to be correct\r\n        //constant for x^p is also assumed know so add\r\n        terms[p] = c1;\r\n        t -= c1 * Math.pow(base, p);\r\n        //start fitting\r\n        for(var i = p - 1; i > 0; i--) {\r\n            var b = Math.pow(base, i), //we want as many wholes as possible\r\n                    q = t / b,\r\n                    sign = Math.sign(q);\r\n            var c = sign * Math.floor(Math.abs(q));\r\n            t -= c * b;\r\n            terms[i] = c;\r\n        }\r\n        if(t !== 0)\r\n            return null;\r\n        for(var i = 0; i < terms.length; i++)\r\n            terms[i] = new Frac(terms[i]);\r\n\r\n        return Polynomial.fromArray(terms, variable);\r\n    };\r\n\r\n    Polynomial.prototype = {\r\n        /**\r\n         * Converts Symbol to Polynomial\r\n         * @param {Symbol} symbol\r\n         * @param {Array} c - a collector array\r\n         * @returns {Polynomial}\r\n         */\r\n        parse: function (symbol, c) {\r\n            this.variable = variables(symbol)[0];\r\n            if(!symbol.isPoly())\r\n                throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\r\n            c = c || [];\r\n            if(!symbol.power.absEquals(1))\r\n                symbol = _.expand(symbol);\r\n\r\n            if(symbol.group === core.groups.N) {\r\n                c[0] = symbol.multiplier;\r\n            }\r\n            else if(symbol.group === core.groups.S) {\r\n                c[symbol.power.toDecimal()] = symbol.multiplier;\r\n            }\r\n            else {\r\n                for(var x in symbol.symbols) {\r\n                    var sub = symbol.symbols[x],\r\n                            p = sub.power;\r\n                    if(core.Utils.isSymbol(p))\r\n                        throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\r\n\r\n                    p = sub.group === N ? 0 : p.toDecimal();\r\n                    if(sub.symbols) {\r\n                        this.parse(sub, c);\r\n                    }\r\n                    else {\r\n                        c[p] = sub.multiplier;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.coeffs = c;\r\n\r\n            this.fill();\r\n        },\r\n        /**\r\n         * Fills in the holes in a polynomial with zeroes\r\n         * @param {Number} x - The number to fill the holes with\r\n         */\r\n        fill: function (x) {\r\n            x = Number(x) || 0;\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(this.coeffs[i] === undefined) {\r\n                    this.coeffs[i] = new Frac(x);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Removes higher order zeros or a specific coefficient\r\n         * @returns {Array}\r\n         */\r\n        trim: function () {\r\n            var l = this.coeffs.length;\r\n            while(l--) {\r\n                var c = this.coeffs[l];\r\n                var equalsZero = c.equals(0);\r\n                if(c && equalsZero) {\r\n                    if(l === 0)\r\n                        break;\r\n                    this.coeffs.pop();\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /*\r\n         * Returns polynomial mod p **currently fails**\r\n         * @param {Number} p\r\n         * @returns {Polynomial}\r\n         */\r\n        modP: function (p) {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = this.coeffs[i];\r\n                if(c < 0) { //go borrow\r\n                    var b; //a coefficient > 0\r\n                    for(var j = i; j < l; j++) {//starting from where we left off\r\n                        if(this.coeffs[j] > 0) {\r\n                            b = this.coeffs[j];\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(b) { //if such a coefficient exists\r\n                        for(j; j > i; j--) { //go down the line and adjust using p\r\n                            this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\r\n                            this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\r\n                        }\r\n                        c = this.coeffs[i]; //reset c\r\n                    }\r\n                }\r\n\r\n                var d = c.mod(p);\r\n                var w = c.subtract(d).divide(p);\r\n                if(!w.equals(0)) {\r\n                    var up_one = i + 1;\r\n                    var next = this.coeffs[up_one] || new Frac(0);\r\n                    next = next.add(w);\r\n                    this.coeffs[up_one] = new Frac(next);\r\n                    this.coeffs[i] = new Frac(d);\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        add: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.add(b);\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        subtract: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.subtract(b);\r\n            }\r\n            return this;\r\n        },\r\n        divide: function (poly) {\r\n            var variable = this.variable,\r\n                    dividend = core.Utils.arrayClone(this.coeffs),\r\n                    divisor = core.Utils.arrayClone(poly.coeffs),\r\n                    n = dividend.length,\r\n                    mp = divisor.length - 1,\r\n                    quotient = [];\r\n\r\n            //loop through the dividend\r\n            for(var i = 0; i < n; i++) {\r\n                var p = n - (i + 1);\r\n                //get the difference of the powers\r\n                var d = p - mp;\r\n                //get the quotient of the coefficients\r\n                var q = dividend[p].divide(divisor[mp]);\r\n\r\n                if(d < 0)\r\n                    break;//the divisor is not greater than the dividend\r\n                //place it in the quotient\r\n                quotient[d] = q;\r\n\r\n                for(var j = 0; j <= mp; j++) {\r\n                    //reduce the dividend\r\n                    dividend[j + d] = dividend[j + d].subtract((divisor[j].multiply(q)));\r\n                }\r\n            }\r\n\r\n            //clean up\r\n            var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(), //pass in x for safety\r\n                    p2 = Polynomial.fromArray(quotient, variable || 'x');\r\n            return [p2, p1];\r\n        },\r\n        multiply: function (poly) {\r\n            var l1 = this.coeffs.length, l2 = poly.coeffs.length,\r\n                    c = []; //array to be returned\r\n            for(var i = 0; i < l1; i++) {\r\n                var x1 = this.coeffs[i];\r\n                for(var j = 0; j < l2; j++) {\r\n                    var k = i + j, //add the powers together\r\n                            x2 = poly.coeffs[j],\r\n                            e = c[k] || new Frac(0); //get the existing term from the new array\r\n                    c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\r\n                }\r\n            }\r\n            this.coeffs = c;\r\n            return this;\r\n        },\r\n        /**\r\n         * Checks if a polynomial is zero\r\n         * @returns {Boolean}\r\n         */\r\n        isZero: function () {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /** \r\n         * Substitutes in a number n into the polynomial p(n)\r\n         * @param {Number} n\r\n         * @returns {Frac}\r\n         */\r\n        sub: function (n) {\r\n            var sum = new Frac(0), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var t = this.coeffs[i];\r\n                if(!t.equals(0))\r\n                    sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\r\n            }\r\n            return sum;\r\n        },\r\n        /**\r\n         * Returns a clone of the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        clone: function () {\r\n            var p = new Polynomial();\r\n            p.coeffs = this.coeffs;\r\n            p.variable = this.variable;\r\n            return p;\r\n        },\r\n        /**\r\n         * Gets the degree of the polynomial\r\n         * @returns {Number}\r\n         */\r\n        deg: function () {\r\n            this.trim();\r\n            return this.coeffs.length - 1;\r\n        },\r\n        /**\r\n         * Returns a lead coefficient\r\n         * @returns {Frac}\r\n         */\r\n        lc: function () {\r\n            return this.coeffs[this.deg()].clone();\r\n        },\r\n        /**\r\n         * Converts polynomial into a monic polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        monic: function () {\r\n            var lc = this.lc(), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++)\r\n                this.coeffs[i] = this.coeffs[i].divide(lc);\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the GCD of two polynomials\r\n         * @param {Polynomial} poly\r\n         * @returns {Polynomial}\r\n         */\r\n        gcd: function (poly) {\r\n            //get the maximum power of each\r\n            var mp1 = this.coeffs.length - 1,\r\n                    mp2 = poly.coeffs.length - 1,\r\n                    T;\r\n            //swap so we always have the greater power first\r\n            if(mp1 < mp2) {\r\n                return poly.gcd(this);\r\n            }\r\n            var a = this;\r\n\r\n            while(!poly.isZero()) {\r\n                var t = poly.clone();\r\n                a = a.clone();\r\n                T = a.divide(t);\r\n                poly = T[1];\r\n                a = t;\r\n            }\r\n\r\n            var gcd = core.Math2.QGCD.apply(null, a.coeffs);\r\n            if(!gcd.equals(1)) {\r\n                var l = a.coeffs.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    a.coeffs[i] = a.coeffs[i].divide(gcd);\r\n                }\r\n            }\r\n            return a;\r\n        },\r\n        /**\r\n         * Differentiates the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        diff: function () {\r\n            var new_array = [], l = this.coeffs.length;\r\n            for(var i = 1; i < l; i++)\r\n                new_array.push(this.coeffs[i].multiply(new Frac(i)));\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Integrates the polynomial\r\n         * @returns {Polynomial} \r\n         */\r\n        integrate: function () {\r\n            var new_array = [0], l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = new Frac(i + 1);\r\n                new_array[c] = this.coeffs[i].divide(c);\r\n            }\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the Greatest common factor of the polynomial\r\n         * @param {bool} toPolynomial - true if a polynomial is wanted\r\n         * @returns {Frac|Polynomial}\r\n         */\r\n        gcf: function (toPolynomial) {\r\n            //get the first nozero coefficient and returns its power\r\n            var fnz = function (a) {\r\n                for(var i = 0; i < a.length; i++)\r\n                    if(!a[i].equals(0))\r\n                        return i;\r\n            },\r\n                    ca = [];\r\n            for(var i = 0; i < this.coeffs.length; i++) {\r\n                var c = this.coeffs[i];\r\n                if(!c.equals(0) && ca.indexOf(c) === -1)\r\n                    ca.push(c);\r\n            }\r\n            var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\r\n\r\n            if(toPolynomial) {\r\n                var parr = [];\r\n                parr[p[1] - 1] = p[0];\r\n                p = Polynomial.fromArray(parr, this.variable).fill();\r\n            }\r\n\r\n            return p;\r\n        },\r\n        /**\r\n         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n         * @param {bool} incl_img - Include imaginary numbers \r\n         */\r\n        quad: function (incl_img) {\r\n            var roots = [];\r\n            if(this.coeffs.length > 3)\r\n                throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\r\n            if(this.coeffs.length === 0)\r\n                throw new Error('Polynomial array has no terms');\r\n            var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];\r\n            var dsc = b * b - 4 * a * c;\r\n            if(dsc < 0 && !incl_img)\r\n                return roots;\r\n            else {\r\n                roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\r\n                roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\r\n            }\r\n            return roots;\r\n        },\r\n        /**\r\n         * Makes polynomial square free\r\n         * @returns {Array}\r\n         */\r\n        squareFree: function () {\r\n\r\n            var a = this.clone(),\r\n                    i = 1,\r\n                    b = a.clone().diff(),\r\n                    c = a.clone().gcd(b),\r\n                    w = a.divide(c)[0];\r\n            var output = Polynomial.fromArray([new Frac(1)], a.variable);\r\n            while(!c.equalsNumber(1)) {\r\n                var y = w.gcd(c);\r\n                var z = w.divide(y)[0];\r\n                //one of the factors may have shown up since it's square but smaller than the \r\n                //one where finding\r\n                if(!z.equalsNumber(1) && i > 1) {\r\n                    var t = z.clone();\r\n                    for(var j = 1; j < i; j++)\r\n                        t.multiply(z.clone());\r\n                    z = t;\r\n                }\r\n                output = output.multiply(z);\r\n                i++;\r\n                w = y;\r\n                c = c.divide(y)[0];\r\n            }\r\n\r\n            return [output, w, i];\r\n        },\r\n        /**\r\n         * Converts polynomial to Symbol\r\n         * @returns {Symbol}\r\n         */\r\n        toSymbol: function () {\r\n            var l = this.coeffs.length,\r\n                    variable = this.variable;\r\n            if(l === 0)\r\n                return new core.Symbol(0);\r\n            var end = l - 1, str = '';\r\n\r\n            for(var i = 0; i < l; i++) {\r\n                //place the plus sign for all but the last one\r\n                var plus = i === end ? '' : '+',\r\n                        e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    str += (e + '*' + variable + '^' + i + plus);\r\n            }\r\n            return _.parse(str);\r\n        },\r\n        /**\r\n         * Checks if polynomial is equal to a number\r\n         * @param {Number} x\r\n         * @returns {Boolean}\r\n         */\r\n        equalsNumber: function (x) {\r\n            this.trim();\r\n            return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\r\n        },\r\n        toString: function () {\r\n            return this.toSymbol().toString();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * TODO\r\n     * ===================================================================================\r\n     * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n     * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n     * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n     * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n     * ===================================================================================\r\n     * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n     * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n     * so the symbol multiplier carries the coefficients for all contained symbols.\r\n     * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n     * @param {Array} c The coefficient array\r\n     * @param {boolean} with_order \r\n     * @return {Array}\r\n     */\r\n    Symbol.prototype.coeffs = function (c, with_order) {\r\n        if(with_order && !this.isPoly(true))\r\n            _.error('Polynomial expected when requesting coefficients with order');\r\n        c = c || [];\r\n        var s = this.clone().distributeMultiplier();\r\n        if(s.isComposite()) {\r\n            for(var x in s.symbols) {\r\n                var sub = s.symbols[x];\r\n                if(sub.isComposite()) {\r\n                    sub.clone().distributeMultiplier().coeffs(c, with_order);\r\n                }\r\n                else {\r\n                    if(with_order)\r\n                        c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;\r\n                    else {\r\n                        c.push(sub.multiplier);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if(with_order)\r\n                c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;\r\n            else {\r\n                if(s.group === CB && s.isImaginary()) {\r\n                    var m = new Symbol(s.multiplier);\r\n                    s.each(function (x) {\r\n                        //add the imaginary part\r\n                        if(x.isConstant(true) || x.imaginary)\r\n                            m = _.multiply(m, x);\r\n                    });\r\n                    c.push(m);\r\n                }\r\n                else\r\n                    c.push(s.multiplier);\r\n            }\r\n        }\r\n        //fill the holes\r\n        if(with_order) {\r\n            for(var i = 0; i < c.length; i++)\r\n                if(c[i] === undefined)\r\n                    c[i] = new Symbol(0);\r\n        }\r\n        return c;\r\n    };\r\n    Symbol.prototype.tBase = function (map) {\r\n        if(typeof map === 'undefined')\r\n            throw new Error('Symbol.tBase requires a map object!');\r\n        var terms = [];\r\n        var symbols = this.collectSymbols(null, null, null, true),\r\n                l = symbols.length;\r\n        for(var i = 0; i < l; i++) {\r\n            var symbol = symbols[i],\r\n                    g = symbol.group,\r\n                    nterm = new MVTerm(symbol.multiplier, [], map);\r\n            if(g === CB) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n                    nterm.terms[map[x]] = sym.power;\r\n                }\r\n            }\r\n            else {\r\n                nterm.terms[map[symbol.value]] = symbol.power;\r\n            }\r\n\r\n            terms.push(nterm.fill());\r\n            nterm.updateCount();\r\n        }\r\n        return terms;\r\n    };\r\n    Symbol.prototype.altVar = function (x) {\r\n        var m = this.multiplier.toString(), p = this.power.toString();\r\n        return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\r\n    };\r\n    /**\r\n     * Checks to see if the symbols contain the same variables\r\n     * @param {Symbol} symbol\r\n     * @returns {Boolean}\r\n     */\r\n    Symbol.prototype.sameVars = function (symbol) {\r\n        if(!(this.symbols || this.group === symbol.group))\r\n            return false;\r\n        for(var x in this.symbols) {\r\n            var a = this.symbols[x], b = symbol.symbols[x];\r\n            if(!b)\r\n                return false;\r\n            if(a.value !== b.value)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Groups the terms in a symbol with respect to a variable\r\n     * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n     * @returns {Factors}\r\n     */\r\n    Symbol.prototype.groupTerms = function (x) {\r\n        x = String(x);\r\n        var f, p, egrouped;\r\n        var grouped = [];\r\n        this.each(function (e) {\r\n            if(e.group === PL) {\r\n                egrouped = e.groupTerms(x);\r\n                for(var i = 0; i < egrouped.length; i++) {\r\n                    var el = egrouped[i];\r\n                    if(el)\r\n                        grouped[i] = el;\r\n                }\r\n            }\r\n            else {\r\n                f = core.Utils.decompose_fn(e, x, true);\r\n                p = f.x.value === x ? Number(f.x.power) : 0;\r\n                //check if there's an existing value\r\n                grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\r\n            }\r\n        });\r\n        return grouped;\r\n    };\r\n    /**\r\n     * Use this to collect Factors\r\n     * @returns {Symbol[]}\r\n     */\r\n    Symbol.prototype.collectFactors = function () {\r\n        var factors = [];\r\n        if(this.group === CB)\r\n            this.each(function (x) {\r\n                factors.push(x.clone());\r\n            });\r\n        else\r\n            factors.push(this.clone());\r\n        return factors;\r\n    };\r\n    /**\r\n     * A container class for factors\r\n     * @returns {Factors}\r\n     */\r\n    function Factors() {\r\n        this.factors = {};\r\n        this.length = 0;\r\n    }\r\n    ;\r\n    Factors.prototype.getNumberSymbolics = function () {\r\n        var n = 0;\r\n        this.each(function (x) {\r\n            if(!x.isConstant(true))\r\n                n++;\r\n        });\r\n        return n;\r\n    };\r\n    /**\r\n     * Adds the factors to the factor object\r\n     * @param {Symbo} s\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.add = function (s) {\r\n        if(s.equals(0))\r\n            return this; //nothing to add\r\n\r\n        //we don't want to carry -1 as a factor. If a factor already exists,\r\n        //then add the minus one to that factor and return.\r\n        if(s.equals(-1) && this.length > 0) {\r\n            var fo = core.Utils.firstObject(this.factors, null, true);\r\n            this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\r\n            delete this.factors[fo.key];\r\n            this.length--;\r\n            return this;\r\n        }\r\n\r\n        if(s.group === CB) {\r\n            var factors = this;\r\n            if(!s.multiplier.equals(1))\r\n                factors.add(new Symbol(s.multiplier));\r\n            s.each(function (x) {\r\n                factors.add(x);\r\n            });\r\n        }\r\n        else {\r\n            if(this.preAdd) //if a preAdd function was defined call it to do prep\r\n                s = this.preAdd(s);\r\n            if(this.pFactor) //if the symbol isn't linear add back the power\r\n                s = _.pow(s, new Symbol(this.pFactor));\r\n\r\n            var is_constant = s.isConstant();\r\n            if(is_constant && s.equals(1))\r\n                return this; //don't add 1\r\n            var v = is_constant ? s.value : s.text();\r\n            if(v in this.factors) {\r\n                this.factors[v] = _.multiply(this.factors[v], s);\r\n                //did the addition cancel out the existing factor? If so remove it and decrement the length\r\n                if(this.factors[v].equals(1)) {\r\n                    delete this.factors[v];\r\n                    this.length--;\r\n                }\r\n            }\r\n            else {\r\n                this.factors[v] = s;\r\n                this.length++;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Converts the factor object to a Symbol\r\n     * @returns {Symbol}\r\n     */\r\n    Factors.prototype.toSymbol = function () {\r\n        var factored = new Symbol(1);\r\n        var factors = Object.values(this.factors).sort(function (a, b) {\r\n            return a.group > b.group;\r\n        });\r\n\r\n        for(var i = 0, l = factors.length; i < l; i++) {\r\n            var f = factors[i];\r\n\r\n            //don't wrap group S or FN\r\n            var factor = f.power.equals(1) && f.fname !== '' /* don't wrap it twice */ ?\r\n                    _.symfunction(core.PARENTHESIS, [f]) : f;\r\n\r\n            factored = _.multiply(factored, factor);\r\n        }\r\n        if(factored.fname === '')\r\n            factored = Symbol.unwrapPARENS(factored);\r\n        return factored;\r\n    };\r\n    /**\r\n     * Merges 2 factor objects into one\r\n     * @param {Factor} o\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.merge = function (o) {\r\n        for(var x in o) {\r\n            if(x in this.factors)\r\n                this.factors[x] = _.multiply(this.factors[x], o[x]);\r\n            else\r\n                this.factors[x] = o[x];\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * The iterator for the factor object\r\n     * @param {Function} f - callback\r\n     * @returns {Factor}\r\n     */\r\n    Factors.prototype.each = function (f) {\r\n        for(var x in this.factors) {\r\n            var factor = this.factors[x];\r\n            if(factor.fname === core.PARENTHESIS && factor.isLinear())\r\n                factor = factor.args[0];\r\n            f.call(this, factor, x);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Return the number of factors contained in the factor object\r\n     * @returns {int}\r\n     */\r\n    Factors.prototype.count = function () {\r\n        return keys(this.factors).length;\r\n    };\r\n    /**\r\n     * Cleans up factors from -1\r\n     * @returns {undefined}\r\n     */\r\n    Factors.prototype.clean = function () {\r\n        try {\r\n            var h = core.Settings.CONST_HASH;\r\n            if(this.factors[h].lessThan(0)) {\r\n                if(this.factors[h].equals(-1))\r\n                    delete this.factors[h];\r\n                else\r\n                    this.factors[h].negate();\r\n                this.each(function (x) {\r\n                    x.negate();\r\n                });\r\n            }\r\n        }\r\n        catch(e) {\r\n        }\r\n        ;\r\n    };\r\n    Factors.prototype.toString = function () {\r\n        return this.toSymbol().toString();\r\n    };\r\n\r\n    //a wrapper for performing multivariate division\r\n    function MVTerm(coeff, terms, map) {\r\n        this.terms = terms || [];\r\n        this.coeff = coeff;\r\n        this.map = map; //careful! all maps are the same object\r\n        this.sum = new core.Frac(0);\r\n        this.image = undefined;\r\n    }\r\n    ;\r\n    MVTerm.prototype.updateCount = function () {\r\n        this.count = this.count || 0;\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            if(!this.terms[i].equals(0))\r\n                this.count++;\r\n        }\r\n        return this;\r\n    };\r\n    MVTerm.prototype.getVars = function () {\r\n        var vars = [];\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var term = this.terms[i],\r\n                    rev_map = this.getRevMap();\r\n            if(!term.equals(0))\r\n                vars.push(this.rev_map[i]);\r\n        }\r\n        return vars.join(' ');\r\n    };\r\n    MVTerm.prototype.len = function () {\r\n        if(typeof this.count === 'undefined') {\r\n            this.updateCount();\r\n        }\r\n        return this.count;\r\n    };\r\n    MVTerm.prototype.toSymbol = function (rev_map) {\r\n        rev_map = rev_map || this.getRevMap();\r\n        var symbol = new Symbol(this.coeff);\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var v = rev_map[i],\r\n                    t = this.terms[i];\r\n            if(t.equals(0) || v === CONST_HASH)\r\n                continue;\r\n            var mapped = new Symbol(v);\r\n            mapped.power = t;\r\n            symbol = _.multiply(symbol, mapped);\r\n        }\r\n        return symbol;\r\n    };\r\n    MVTerm.prototype.getRevMap = function () {\r\n        if(this.rev_map)\r\n            return this.rev_map;\r\n        var o = {};\r\n        for(var x in this.map)\r\n            o[this.map[x]] = x;\r\n        this.rev_map = o;\r\n        return o;\r\n    };\r\n    MVTerm.prototype.generateImage = function () {\r\n        this.image = this.terms.join(' ');\r\n        return this;\r\n    },\r\n            MVTerm.prototype.getImg = function () {\r\n                if(!this.image)\r\n                    this.generateImage();\r\n                return this.image;\r\n            },\r\n            MVTerm.prototype.fill = function () {\r\n                var l = this.map.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    if(typeof this.terms[i] === 'undefined')\r\n                        this.terms[i] = new core.Frac(0);\r\n                    else {\r\n                        this.sum = this.sum.add(this.terms[i]);\r\n                    }\r\n                }\r\n                return this;\r\n            };\r\n    MVTerm.prototype.divide = function (mvterm) {\r\n        var c = this.coeff.divide(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.multiply = function (mvterm) {\r\n        var c = this.coeff.multiply(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.isZero = function () {\r\n        return this.coeff.equals(0);\r\n    };\r\n    MVTerm.prototype.toString = function () {\r\n        return '{ coeff: ' + this.coeff.toString() + ', terms: [' +\r\n                this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\r\n    };\r\n\r\n    core.Utils.toMapObj = function (arr) {\r\n        var c = 0, o = {};\r\n        for(var i = 0; i < arr.length; i++) {\r\n            var v = arr[i];\r\n            if(typeof o[v] === 'undefined') {\r\n                o[v] = c;\r\n                c++;\r\n            }\r\n        }\r\n        o.length = c;\r\n        return o;\r\n    };\r\n    core.Utils.filledArray = function (v, n, clss) {\r\n        var a = [];\r\n        while(n--) {\r\n            a[n] = clss ? new clss(v) : v;\r\n        }\r\n        return a;\r\n    };\r\n    core.Utils.arrSum = function (arr) {\r\n        var sum = 0, l = arr.length;\r\n        for(var i = 0; i < l; i++)\r\n            sum += arr[i];\r\n        return sum;\r\n    };\r\n    /**\r\n     * Determines if 2 arrays have intersecting elements.\r\n     * @param {Array} a\r\n     * @param {Array} b\r\n     * @returns {Boolean} True if a and b have intersecting elements.\r\n     */\r\n    core.Utils.haveIntersection = function (a, b) {\r\n        var t;\r\n        if(b.length > a.length)\r\n            t = b, b = a, a = t; // indexOf to loop over shorter\r\n        return a.some(function (e) {\r\n            return b.indexOf(e) > -1;\r\n        });\r\n    };\r\n    /**\r\n     * Substitutes out functions as variables so they can be used in regular algorithms\r\n     * @param {Symbol} symbol\r\n     * @param {Object} map\r\n     * @returns {String} The expression string\r\n     */\r\n    core.Utils.subFunctions = function (symbol, map) {\r\n        map = map || {};\r\n        var subbed = [];\r\n        symbol.each(function (x) {\r\n            if(x.group === FN || x.previousGroup === FN) {\r\n                //we need a new variable name so why not use one of the existing\r\n                var val = core.Utils.text(x, 'hash'), tvar = map[val];\r\n                if(!tvar) {\r\n                    //generate a unique enough name\r\n                    var t = x.fname + keys(map).length;\r\n                    map[val] = t;\r\n                    subbed.push(x.altVar(t));\r\n                }\r\n                else\r\n                    subbed.push(x.altVar(tvar));\r\n            }\r\n            else if(x.group === CB || x.group === PL || x.group === CP) {\r\n                subbed.push(core.Utils.subFunctions(x, map));\r\n            }\r\n            else\r\n                subbed.push(x.text());\r\n        });\r\n        if(symbol.group === CP || symbol.group === PL)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\r\n        ;\r\n        if(symbol.group === CB)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\r\n        return symbol.text();\r\n    };\r\n    core.Utils.getFunctionsSubs = function (map) {\r\n        var subs = {};\r\n        //prepare substitutions\r\n        for(var x in map)\r\n            subs[map[x]] = _.parse(x);\r\n        return subs;\r\n    };\r\n\r\n    var __ = core.Algebra = {\r\n        version: '1.4.6',\r\n        proots: function (symbol, decp) {\r\n            //the roots will be rounded up to 7 decimal places.\r\n            //if this causes trouble you can explicitly pass in a different number of places\r\n            //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\r\n            decp = decp || 7;\r\n            var zeros = 0;\r\n            var known_roots = [];\r\n            var get_roots = function (rarr, powers, max) {\r\n                var roots = calcroots(rarr, powers, max).concat(known_roots);\r\n                for(var i = 0; i < zeros; i++)\r\n                    roots.unshift(0);\r\n                return roots;\r\n            };\r\n\r\n            if(symbol instanceof Symbol && symbol.isPoly()) {\r\n                symbol.distributeMultiplier();\r\n                //make it so the symbol has a constants as the lowest term\r\n                if(symbol.group === PL) {\r\n                    var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\r\n                    var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\r\n                    symbol = _.expand(_.divide(symbol, lowest_symbol));\r\n                    known_roots.push(0); //add zero since this is a known root\r\n                }\r\n                if(symbol.group === core.groups.S) {\r\n                    return [0];\r\n                }\r\n                else if(symbol.group === core.groups.PL) {\r\n                    var powers = keys(symbol.symbols),\r\n                            minpower = core.Utils.arrayMin(powers),\r\n                            symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\r\n                }\r\n\r\n                var variable = keys(symbol.symbols).sort().pop(),\r\n                        sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\r\n                        g = sym.group,\r\n                        powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\r\n                        rarr = [],\r\n                        max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\r\n\r\n                // Prepare the data\r\n                for(var i = 1; i <= max; i++) {\r\n                    var c = 0; //if there is no power then the hole must be filled with a zero\r\n                    if(powers.indexOf(i + '') !== -1) {\r\n                        if(g === S) {\r\n                            c = sym.multiplier;\r\n                        }\r\n                        else {\r\n                            c = sym.symbols[i].multiplier;\r\n                        }\r\n                    }\r\n                    // Insert the coeffient but from the front\r\n                    rarr.unshift(c);\r\n                }\r\n\r\n                rarr.push(symbol.symbols[CONST_HASH].multiplier);\r\n\r\n                if(sym.group === S)\r\n                    rarr[0] = sym.multiplier;//the symbol maybe of group CP with one variable\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else if(core.Utils.isArray(symbol)) {\r\n                var parr = symbol;\r\n                var rarr = [],\r\n                        powers = [],\r\n                        last_power = 0;\r\n                for(var i = 0; i < parr.length; i++) {\r\n\r\n                    var coeff = parr[i][0],\r\n                            pow = parr[i][1],\r\n                            d = pow - last_power - 1;\r\n                    //insert the zeros\r\n                    for(var j = 0; j < d; j++)\r\n                        rarr.unshift(0);\r\n\r\n                    rarr.unshift(coeff);\r\n                    if(pow !== 0)\r\n                        powers.push(pow);\r\n                    last_power = pow;\r\n                }\r\n                var max = Math.max.apply(undefined, powers);\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else {\r\n                throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\r\n            }\r\n\r\n            function calcroots(rarr, powers, max) {\r\n                var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\r\n\r\n                // Make a clone of the coefficients before appending the max power\r\n                var p = rarr.slice(0);\r\n\r\n                // Divide the string up into its individual entries, which--presumably--are separated by whitespace\r\n                rarr.unshift(max);\r\n\r\n                if(max > MAXDEGREE) {\r\n                    throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\r\n                }\r\n\r\n                var zeroi = [], // Vector of imaginary components of roots\r\n                        degreePar = {};    // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\r\n                degreePar.Degree = max;\r\n\r\n                for(i = 0; i < max; i++) {\r\n                    zeroi.push(0);\r\n                }\r\n                var zeror = zeroi.slice(0); // Vector of real components of roots\r\n\r\n                // Find the roots\r\n                //--> Begin Jenkins-Traub\r\n\r\n                /*\r\n                 * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n                 */\r\n                function QuadSD_ak1(NN, u, v, p, q, iPar) {\r\n                    // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\r\n                    // iPar is a dummy variable for passing in the two parameters--a and b--by reference\r\n                    q[0] = iPar.b = p[0];\r\n                    q[1] = iPar.a = -(u * iPar.b) + p[1];\r\n\r\n                    for(var i = 2; i < NN; i++) {\r\n                        q[i] = -(u * iPar.a + v * iPar.b) + p[i];\r\n                        iPar.b = iPar.a;\r\n                        iPar.a = q[i];\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\r\n                    // This routine calculates scalar quantities used to compute the next K polynomial and\r\n                    // new estimates of the quadratic coefficients.\r\n                    // calcSC -\tinteger variable set here indicating how the calculations are normalized\r\n                    // to avoid overflow.\r\n                    // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\r\n\r\n                    // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\r\n                    var sdPar = new Object(),\r\n                            // TYPE = 3 indicates the quadratic is almost a factor of K\r\n                            dumFlag = 3;\r\n\r\n                    // Synthetic division of K by the quadratic 1, u, v\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(N, u, v, K, qk, sdPar);\r\n                    iPar.c = sdPar.a;\r\n                    iPar.d = sdPar.b;\r\n\r\n                    if(Math.abs(iPar.c) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 1]))) {\r\n                        if(Math.abs(iPar.d) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 2])))\r\n                            return dumFlag;\r\n                    }\r\n\r\n                    iPar.h = v * b;\r\n                    if(Math.abs(iPar.d) >= Math.abs(iPar.c)) {\r\n                        // TYPE = 2 indicates that all formulas are divided by d\r\n                        dumFlag = 2;\r\n                        iPar.e = a / (iPar.d);\r\n                        iPar.f = (iPar.c) / (iPar.d);\r\n                        iPar.g = u * b;\r\n                        iPar.a3 = (iPar.e) * ((iPar.g) + a) + (iPar.h) * (b / (iPar.d));\r\n                        iPar.a1 = -a + (iPar.f) * b;\r\n                        iPar.a7 = (iPar.h) + ((iPar.f) + u) * a;\r\n                    }\r\n                    else {\r\n                        // TYPE = 1 indicates that all formulas are divided by c;\r\n                        dumFlag = 1;\r\n                        iPar.e = a / (iPar.c);\r\n                        iPar.f = (iPar.d) / (iPar.c);\r\n                        iPar.g = (iPar.e) * u;\r\n                        iPar.a3 = (iPar.e) * a + ((iPar.g) + (iPar.h) / (iPar.c)) * b;\r\n                        iPar.a1 = -(a * ((iPar.d) / (iPar.c))) + b;\r\n                        iPar.a7 = (iPar.g) * (iPar.d) + (iPar.h) * (iPar.f) + a;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\r\n                    // Computes the next K polynomials using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\r\n                    var temp;\r\n                    if(tFlag == 3) {\t// Use unscaled form of the recurrence\r\n                        K[1] = K[0] = 0.0;\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = qk[i - 2];\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    temp = ((tFlag == 1) ? b : a);\r\n                    if(Math.abs(iPar.a1) > (10.0 * DBL_EPSILON * Math.abs(temp))) {\r\n                        // Use scaled form of the recurrence\r\n                        iPar.a7 /= iPar.a1;\r\n                        iPar.a3 /= iPar.a1;\r\n                        K[0] = qp[0];\r\n                        K[1] = -(qp[0] * iPar.a7) + qp[1];\r\n                        for(var i = 2; i < N; i++)\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\r\n                    }\r\n                    else {\r\n                        // If a1 is nearly zero, then use a special form of the recurrence\r\n                        K[0] = 0.0;\r\n                        K[1] = -(qp[0] * iPar.a7);\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\r\n                    // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\r\n                    // iPar.a = uu, iPar.b = vv\r\n\r\n                    var a4, a5, b1, b2, c1, c2, c3, c4, temp;\r\n                    iPar.b = iPar.a = 0.0;// The quadratic is zeroed\r\n\r\n                    if(tFlag != 3) {\r\n                        if(tFlag != 2) {\r\n                            a4 = a + u * b + h * f;\r\n                            a5 = c + (u + v * f) * d;\r\n                        }\r\n                        else {\r\n                            a4 = (a + g) * f + h;\r\n                            a5 = (f + u) * c + v * d;\r\n                        }\r\n\r\n                        // Evaluate new quadratic coefficients\r\n                        b1 = -(K[N - 1] / p[N]);\r\n                        b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\r\n                        c1 = v * b2 * a1;\r\n                        c2 = b1 * a7;\r\n                        c3 = b1 * b1 * a3;\r\n                        c4 = -(c2 + c3) + c1;\r\n                        temp = -c4 + a5 + b1 * a4;\r\n                        if(temp != 0.0) {\r\n                            iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\r\n                            iPar.b = v * (1.0 + c4 / temp);\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function Quad_ak1(a, b1, c, iPar) {\r\n                    // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\r\n                    // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\r\n                    // zeros are real and both zeros are complex. The smaller real zero is found directly from\r\n                    // the product of the zeros c/a.\r\n\r\n                    // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\r\n\r\n                    var b, d, e;\r\n                    iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\r\n\r\n                    if(a == 0) {\r\n                        iPar.sr = ((b1 != 0) ? -(c / b1) : iPar.sr);\r\n                        return;\r\n                    }\r\n                    if(c == 0) {\r\n                        iPar.lr = -(b1 / a);\r\n                        return;\r\n                    }\r\n\r\n                    // Compute discriminant avoiding overflow\r\n                    b = b1 / 2.0;\r\n                    if(Math.abs(b) < Math.abs(c)) {\r\n                        e = ((c >= 0) ? a : -a);\r\n                        e = -e + b * (b / Math.abs(c));\r\n                        d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\r\n                    }\r\n                    else {\r\n                        e = -((a / b) * (c / b)) + 1.0;\r\n                        d = Math.sqrt(Math.abs(e)) * (Math.abs(b));\r\n                    }\r\n\r\n                    if(e >= 0) {\r\n                        // Real zeros\r\n                        d = ((b >= 0) ? -d : d);\r\n                        iPar.lr = (-b + d) / a;\r\n                        iPar.sr = ((iPar.lr != 0) ? (c / (iPar.lr)) / a : iPar.sr);\r\n                    }\r\n                    else {\r\n                        // Complex conjugate zeros\r\n                        iPar.lr = iPar.sr = -(b / a);\r\n                        iPar.si = Math.abs(d / a);\r\n                        iPar.li = -(iPar.si);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\r\n                    // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\r\n                    // zeros are equimodular or nearly so.\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\r\n                    // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\r\n\r\n                    // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\r\n                    var qPar = new Object(),\r\n                            ee, mp, omp, relstp, t, u, ui, v, vi, zm,\r\n                            i, j = 0, tFlag, triedFlag = 0;   // Integer variables\r\n\r\n                    iPar.NZ = 0;// Number of zeros found\r\n                    u = uu; // uu and vv are coefficients of the starting quadratic\r\n                    v = vv;\r\n\r\n                    do {\r\n                        qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                        Quad_ak1(1.0, u, v, qPar);\r\n                        iPar.szr = qPar.sr;\r\n                        iPar.szi = qPar.si;\r\n                        iPar.lzr = qPar.lr;\r\n                        iPar.lzi = qPar.li;\r\n\r\n                        // Return if roots of the quadratic are real and not close to multiple or nearly\r\n                        // equal and of opposite sign.\r\n                        if(Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr))\r\n                            break;\r\n\r\n                        // Evaluate polynomial by quadratic synthetic division\r\n\r\n                        QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n\r\n                        mp = Math.abs(-((iPar.szr) * (sdPar.b)) + (sdPar.a)) + Math.abs((iPar.szi) * (sdPar.b));\r\n\r\n                        // Compute a rigorous bound on the rounding error in evaluating p\r\n\r\n                        zm = Math.sqrt(Math.abs(v));\r\n                        ee = 2.0 * Math.abs(qp[0]);\r\n                        t = -((iPar.szr) * (sdPar.b));\r\n\r\n                        for(i = 1; i < N; i++) {\r\n                            ee = ee * zm + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        ee = ee * zm + Math.abs(t + sdPar.a);\r\n                        ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs((sdPar.a) + t) + zm * Math.abs((sdPar.b)))) * DBL_EPSILON;\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\r\n                        if(mp <= 20.0 * ee) {\r\n                            iPar.NZ = 2;\r\n                            break;\r\n                        }\r\n\r\n                        j++;\r\n                        // Stop iteration after 20 steps\r\n                        if(j > 20)\r\n                            break;\r\n                        if(j >= 2) {\r\n                            if((relstp <= 0.01) && (mp >= omp) && (!triedFlag)) {\r\n                                // A cluster appears to be stalling the convergence. Five fixed shift\r\n                                // steps are taken with a u, v close to the cluster.\r\n                                relstp = ((relstp < DBL_EPSILON) ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp));\r\n                                u -= u * relstp;\r\n                                v += v * relstp;\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                for(i = 0; i < 5; i++) {\r\n                                    tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                                    nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                                }\r\n\r\n                                triedFlag = 1;\r\n                                j = 0;\r\n\r\n                            }\r\n                        }\r\n                        omp = mp;\r\n\r\n                        // Calculate next K polynomial and new u and v\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vi = sdPar.b;\r\n\r\n                        // If vi is zero, the iteration is not converging\r\n                        if(vi != 0) {\r\n                            relstp = Math.abs((-v + vi) / vi);\r\n                            u = ui;\r\n                            v = vi;\r\n                        }\r\n                    }\r\n                    while(vi != 0);\r\n                    return;\r\n                }\r\n\r\n                function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\r\n                    // Variable-shift H-polynomial iteration for a real zero\r\n                    // sss\t- starting iterate = sdPar.a\r\n                    // NZ\t\t- number of zeros found = iPar.NZ\r\n                    // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\r\n\r\n                    var ee, kv, mp, ms, omp, pv, s, t,\r\n                            dumFlag, i, j, nm1 = N - 1;   // Integer variables\r\n\r\n                    iPar.NZ = j = dumFlag = 0;\r\n                    s = sdPar.a;\r\n\r\n                    for(; ; ) {\r\n                        pv = p[0];\r\n\r\n                        // Evaluate p at s\r\n                        qp[0] = pv;\r\n                        for(i = 1; i < NN; i++) {\r\n                            qp[i] = pv = pv * s + p[i];\r\n                        }\r\n                        mp = Math.abs(pv);\r\n\r\n                        // Compute a rigorous bound on the error in evaluating p\r\n                        ms = Math.abs(s);\r\n                        ee = 0.5 * Math.abs(qp[0]);\r\n                        for(i = 1; i < NN; i++) {\r\n                            ee = ee * ms + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than\r\n                        // 20 times this bound\r\n                        if(mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\r\n                            iPar.NZ = 1;\r\n                            iPar.szr = s;\r\n                            iPar.szi = 0.0;\r\n                            break;\r\n                        }\r\n                        j++;\r\n                        // Stop iteration after 10 steps\r\n                        if(j > 10)\r\n                            break;\r\n\r\n                        if(j >= 2) {\r\n                            if((Math.abs(t) <= 0.001 * Math.abs(-t + s)) && (mp > omp)) {\r\n                                // A cluster of zeros near the real axis has been encountered.\r\n                                // Return with iFlag set to initiate a quadratic iteration.\r\n                                dumFlag = 1;\r\n                                iPar.a = s;\r\n                                break;\r\n                            } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\r\n                        } //End if (j >= 2)\r\n\r\n                        // Return if the polynomial value has increased significantly\r\n                        omp = mp;\r\n\r\n                        // Compute t, the next polynomial and the new iterate\r\n                        qk[0] = kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            qk[i] = kv = kv * s + K[i];\r\n                        }\r\n\r\n                        if(Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\r\n                            // Use the scaled form of the recurrence if the value of K at s is non-zero\r\n                            t = -(pv / kv);\r\n                            K[0] = qp[0];\r\n                            for(i = 1; i < N; i++) {\r\n                                K[i] = t * qk[i - 1] + qp[i];\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Use unscaled form\r\n                            K[0] = 0.0;\r\n                            for(i = 1; i < N; i++)\r\n                                K[i] = qk[i - 1];\r\n                        }\r\n\r\n                        kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            kv = kv * s + K[i];\r\n                        }\r\n                        t = ((Math.abs(kv) > (Math.abs(K[nm1]) * 10.0 * DBL_EPSILON)) ? -(pv / kv) : 0.0);\r\n                        s += t;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\r\n\r\n                    // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\r\n                    // quadratic case. Initiates one of the variable shift iterations and returns with the\r\n                    // number of zeros found.\r\n                    // L2\tlimit of fixed shift steps\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // NZ\tnumber of zeros found\r\n                    var sdPar = new Object(), // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\r\n                            calcPar = new Object(),\r\n                            // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\r\n\r\n                            qk = new Array(MDP1),\r\n                            svk = new Array(MDP1),\r\n                            a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv,\r\n                            fflag, i, iFlag = 1, j, spass, stry, tFlag, vpass, vtry;     // Integer variables\r\n\r\n                    iPar.NZ = 0;\r\n                    betav = betas = 0.25;\r\n                    oss = sr;\r\n                    ovv = v;\r\n\r\n                    //Evaluate polynomial by synthetic division\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                    a = sdPar.a;\r\n                    b = sdPar.b;\r\n                    calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\r\n                    tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                    for(j = 0; j < L2; j++) {\r\n                        fflag = 1;\r\n\r\n                        // Calculate next K polynomial and estimate v\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                        // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\r\n                        // sdPar.a = ui, sdPar.b = vi\r\n                        newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vv = vi = sdPar.b;\r\n\r\n                        // Estimate s\r\n                        ss = ((K[N - 1] != 0.0) ? -(p[N] / K[N - 1]) : 0.0);\r\n                        ts = tv = 1.0;\r\n\r\n                        if((j != 0) && (tFlag != 3)) {\r\n                            // Compute relative measures of convergence of s and v sequences\r\n                            tv = ((vv != 0.0) ? Math.abs((vv - ovv) / vv) : tv);\r\n                            ts = ((ss != 0.0) ? Math.abs((ss - oss) / ss) : ts);\r\n\r\n                            // If decreasing, multiply the two most recent convergence measures\r\n                            tvv = ((tv < otv) ? tv * otv : 1.0);\r\n                            tss = ((ts < ots) ? ts * ots : 1.0);\r\n\r\n                            // Compare with convergence criteria\r\n                            vpass = ((tvv < betav) ? 1 : 0);\r\n                            spass = ((tss < betas) ? 1 : 0);\r\n\r\n                            if((spass) || (vpass)) {\r\n\r\n                                // At least one sequence has passed the convergence test.\r\n                                // Store variables before iterating\r\n\r\n                                for(i = 0; i < N; i++) {\r\n                                    svk[i] = K[i];\r\n                                }\r\n                                s = ss;\r\n\r\n                                // Choose iteration according to the fastest converging sequence\r\n\r\n                                stry = vtry = 0;\r\n\r\n                                for(; ; ) {\r\n                                    if((fflag && ((fflag = 0) == 0)) && ((spass) && (!vpass || (tss < tvv)))) {\r\n                                        ;// Do nothing. Provides a quick \"short circuit\".\r\n                                    }\r\n                                    else {\r\n                                        QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\r\n                                        a = sdPar.a;\r\n                                        b = sdPar.b;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Quadratic iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        iFlag = vtry = 1;\r\n                                        betav *= 0.25;\r\n\r\n                                        // Try linear iteration if it has not been tried and the s sequence is converging\r\n                                        if(stry || (!spass)) {\r\n                                            iFlag = 0;\r\n                                        }\r\n                                        else {\r\n                                            for(i = 0; i < N; i++)\r\n                                                K[i] = svk[i];\r\n                                        }\r\n                                    }\r\n                                    //fflag = 0;\r\n                                    if(iFlag != 0) {\r\n                                        // Use sdPar for passing in s instead of defining a brand-new variable.\r\n                                        // sdPar.a = s\r\n                                        sdPar.a = s;\r\n                                        iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\r\n                                        s = sdPar.a;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Linear iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        stry = 1;\r\n                                        betas *= 0.25;\r\n\r\n                                        if(iFlag != 0) {\r\n                                            // If linear iteration signals an almost double real zero, attempt quadratic iteration\r\n                                            ui = -(s + s);\r\n                                            vi = s * s;\r\n                                            continue;\r\n\r\n                                        }\r\n                                    }\r\n\r\n                                    // Restore variables\r\n                                    for(i = 0; i < N; i++)\r\n                                        K[i] = svk[i];\r\n\r\n                                    // Try quadratic iteration if it has not been tried and the v sequence is converging\r\n                                    if(!vpass || vtry)\r\n                                        break;\t\t// Break out of infinite for loop\r\n\r\n                                }\r\n\r\n                                // Re-compute qp and scalar values to continue the second stage\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                a = sdPar.a;\r\n                                b = sdPar.b;\r\n\r\n                                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n                            }\r\n                        }\r\n                        ovv = vv;\r\n                        oss = ss;\r\n                        otv = tv;\r\n                        ots = ts;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function rpSolve(degPar, p, zeror, zeroi) {\r\n                    var N = degPar.Degree,\r\n                            RADFAC = 3.14159265358979323846 / 180, // Degrees-to-radians conversion factor = PI/180\r\n                            LB2 = Math.LN2, // Dummy variable to avoid re-calculating this value in loop below\r\n                            MDP1 = degPar.Degree + 1,\r\n                            K = new Array(MDP1),\r\n                            pt = new Array(MDP1),\r\n                            qp = new Array(MDP1),\r\n                            temp = new Array(MDP1),\r\n                            // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\r\n                            qPar = new Object(),\r\n                            // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\r\n                            Fxshfr_Par = new Object(),\r\n                            bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm,\r\n                            aa, bb, cc, sr, t, u, xxx,\r\n                            j, jj, l, NM1, NN, zerok;// Integer variables\r\n\r\n                    // Calculate the machine epsilon and store in the variable DBL_EPSILON.\r\n                    // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\r\n                    aa = 1.0;\r\n                    do {\r\n                        DBL_EPSILON = aa;\r\n                        aa /= 2;\r\n                        bb = 1.0 + aa;\r\n                    }\r\n                    while(bb > 1.0);\r\n\r\n                    var LO = Number.MIN_VALUE / DBL_EPSILON,\r\n                            cosr = Math.cos(94.0 * RADFAC), // = -0.069756474\r\n                            sinr = Math.sin(94.0 * RADFAC), // = 0.99756405\r\n                            xx = Math.sqrt(0.5), // = 0.70710678\r\n                            yy = -xx;\r\n\r\n                    Fxshfr_Par.NZ = j = 0;\r\n                    Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;\r\n\r\n                    // Remove zeros at the origin, if any\r\n                    while(p[N] == 0) {\r\n                        zeror[j] = zeroi[j] = 0;\r\n                        N--;\r\n                        j++;\r\n                    }\r\n                    NN = N + 1;\r\n\r\n                    // >>>>> Begin Main Loop <<<<<\r\n                    while(N >= 1) { // Main loop\r\n                        // Start the algorithm for one zero\r\n                        if(N <= 2) {\r\n                            // Calculate the final zero or pair of zeros\r\n                            if(N < 2) {\r\n                                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\r\n                                zeroi[degPar.Degree - 1] = 0;\r\n                            }\r\n                            else {\r\n                                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                                Quad_ak1(p[0], p[1], p[2], qPar);\r\n                                zeror[degPar.Degree - 2] = qPar.sr;\r\n                                zeroi[degPar.Degree - 2] = qPar.si;\r\n                                zeror[degPar.Degree - 1] = qPar.lr;\r\n                                zeroi[degPar.Degree - 1] = qPar.li;\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        // Find the largest and smallest moduli of the coefficients\r\n                        moduli_max = 0.0;\r\n                        moduli_min = Number.MAX_VALUE;\r\n\r\n                        for(i = 0; i < NN; i++) {\r\n                            x = Math.abs(p[i]);\r\n                            if(x > moduli_max)\r\n                                moduli_max = x;\r\n                            if((x != 0) && (x < moduli_min))\r\n                                moduli_min = x;\r\n                        }\r\n\r\n                        // Scale if there are large or very small coefficients\r\n                        // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\r\n                        // is done to avoid overflow and to avoid undetected underflow interfering with the\r\n                        // convergence criterion.\r\n                        // The factor is a power of the base.\r\n                        sc = LO / moduli_min;\r\n\r\n                        if(((sc <= 1.0) && (moduli_max >= 10)) || ((sc > 1.0) && (Number.MAX_VALUE / sc >= moduli_max))) {\r\n                            sc = ((sc == 0) ? Number.MIN_VALUE : sc);\r\n                            l = Math.floor(Math.log(sc) / LB2 + 0.5);\r\n                            factor = Math.pow(2.0, l);\r\n                            if(factor != 1.0) {\r\n                                for(i = 0; i < NN; i++)\r\n                                    p[i] *= factor;\r\n                            }\r\n                        }\r\n\r\n                        // Compute lower bound on moduli of zeros\r\n                        for(var i = 0; i < NN; i++)\r\n                            pt[i] = Math.abs(p[i]);\r\n                        pt[N] = -(pt[N]);\r\n                        NM1 = N - 1;\r\n\r\n                        // Compute upper estimate of bound\r\n                        x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\r\n\r\n                        if(pt[NM1] != 0) {\r\n                            // If Newton step at the origin is better, use it\r\n                            xm = -pt[N] / pt[NM1];\r\n                            x = ((xm < x) ? xm : x);\r\n                        }\r\n\r\n                        // Chop the interval (0, x) until ff <= 0\r\n                        xm = x;\r\n                        do {\r\n                            x = xm;\r\n                            xm = 0.1 * x;\r\n                            ff = pt[0];\r\n                            for(var i = 1; i < NN; i++) {\r\n                                ff = ff * xm + pt[i];\r\n                            }\r\n                        }\r\n                        while(ff > 0); // End do-while loop\r\n\r\n                        dx = x;\r\n                        // Do Newton iteration until x converges to two decimal places\r\n\r\n                        do {\r\n                            df = ff = pt[0];\r\n                            for(var i = 1; i < N; i++) {\r\n                                ff = x * ff + pt[i];\r\n                                df = x * df + ff;\r\n                            } // End for i\r\n                            ff = x * ff + pt[N];\r\n                            dx = ff / df;\r\n                            x -= dx;\r\n                        }\r\n                        while(Math.abs(dx / x) > 0.005); // End do-while loop\r\n\r\n                        bnd = x;\r\n\r\n                        // Compute the derivative as the initial K polynomial and do 5 steps with no shift\r\n                        for(var i = 1; i < N; i++)\r\n                            K[i] = (N - i) * p[i] / N;\r\n                        K[0] = p[0];\r\n                        aa = p[N];\r\n                        bb = p[NM1];\r\n                        zerok = ((K[NM1] == 0) ? 1 : 0);\r\n\r\n                        for(jj = 0; jj < 5; jj++) {\r\n                            cc = K[NM1];\r\n                            if(zerok) {\r\n                                // Use unscaled form of recurrence\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = K[j - 1];\r\n                                } // End for i\r\n                                K[0] = 0;\r\n                                zerok = ((K[NM1] == 0) ? 1 : 0);\r\n                            }\r\n                            else {\r\n                                // Used scaled form of recurrence if value of K at 0 is nonzero\r\n                                t = -aa / cc;\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = t * K[j - 1] + p[j];\r\n                                } // End for i\r\n                                K[0] = p[0];\r\n                                zerok = ((Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0) ? 1 : 0);\r\n                            }\r\n                        }\r\n\r\n                        // Save K for restarts with new shifts\r\n                        for(var i = 0; i < N; i++)\r\n                            temp[i] = K[i];\r\n\r\n                        // Loop to select the quadratic corresponding to each new shift\r\n                        for(jj = 1; jj <= 20; jj++) {\r\n\r\n                            // Quadratic corresponds to a double shift to a non-real point and its\r\n                            // complex conjugate. The point has modulus BND and amplitude rotated\r\n                            // by 94 degrees from the previous shift.\r\n\r\n                            xxx = -(sinr * yy) + cosr * xx;\r\n                            yy = sinr * xx + cosr * yy;\r\n                            xx = xxx;\r\n                            sr = bnd * xx;\r\n                            u = -(2.0 * sr);\r\n\r\n                            // Second stage calculation, fixed quadratic\r\n                            Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\r\n\r\n                            if(Fxshfr_Par.NZ != 0) {\r\n                                // The second stage jumps directly to one of the third stage iterations and\r\n                                // returns here if successful. Deflate the polynomial, store the zero or\r\n                                // zeros, and return to the main algorithm.\r\n                                j = degPar.Degree - N;\r\n                                zeror[j] = Fxshfr_Par.szr;\r\n                                zeroi[j] = Fxshfr_Par.szi;\r\n                                NN = NN - Fxshfr_Par.NZ;\r\n                                N = NN - 1;\r\n                                for(var i = 0; i < NN; i++)\r\n                                    p[i] = qp[i];\r\n                                if(Fxshfr_Par.NZ != 1) {\r\n                                    zeror[j + 1] = Fxshfr_Par.lzr;\r\n                                    zeroi[j + 1] = Fxshfr_Par.lzi;\r\n                                }\r\n                                break;\r\n                            }\r\n                            else {\r\n                                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\r\n                                for(var i = 0; i < N; i++) {\r\n                                    K[i] = temp[i];\r\n                                }\r\n                            }\r\n                        }\r\n                        // Return with failure if no convergence with 20 shifts\r\n                        if(jj > 20) {\r\n                            degPar.Degree -= N;\r\n                            break;\r\n                        }\r\n                    }\r\n                    // >>>>> End Main Loop <<<<<\r\n                    return;\r\n                }\r\n                //--> End Jenkins-Traub\r\n                rpSolve(degreePar, p, zeror, zeroi);\r\n\r\n                var l = zeroi.length;\r\n                //format the output\r\n                for(i = 0; i < l; i++) {\r\n                    // We round the imaginary part to avoid having something crazy like 5.67e-16.\r\n                    var img = round(zeroi[i], decp + 8),\r\n                            real = round(zeror[i], decp + 8);\r\n                    // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\r\n                    // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \r\n                    // the original otherwise the rounding was worth it.\r\n                    real = decp - String(real).length > 2 ? real : zeror[i];\r\n                    var sign = img < 0 ? '-' : '';\r\n\r\n                    // Remove the zeroes\r\n                    if(real === 0) {\r\n                        real = '';\r\n                    }\r\n                    if(img === 0) {\r\n                        img = '';\r\n                    }\r\n\r\n                    // Remove 1 as the multiplier and discard imaginary part if there isn't one.\r\n                    img = Math.abs(img) === 1 ? sign + 'i' : (img ? img + '*i' : '');\r\n\r\n                    var num = (real && img) ? real + '+' + img : real + img;\r\n                    zeror[i] = num.replace(/\\+\\-/g, '-');\r\n                }\r\n                return zeror;\r\n            }\r\n        },\r\n        roots: function (symbol) {\r\n\r\n            if(symbol.isConstant(true, true)) {\r\n                return core.Utils.nroots(symbol);\r\n            }\r\n            var roots = __.proots(symbol).map(function (x) {\r\n                return _.parse(x);\r\n            });\r\n            return core.Vector.fromArray(roots);\r\n        },\r\n        froot: function (f, guess, dx) {\r\n            var newtonraph = function (xn) {\r\n                var mesh = 1e-12,\r\n                        // If the derivative was already provided then don't recalculate.\r\n                        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\r\n                        // If the function was passed in as a function then don't recalculate.\r\n                        fn = f instanceof Function ? f : core.Utils.build(f),\r\n                        max = 10000,\r\n                        done = false,\r\n                        safety = 0;\r\n                while(!done) {\r\n                    var x = xn - (fn(xn) / df(xn));\r\n                    //absolute values for both x & xn ensures that we indeed have the radius    \r\n                    var r = Math.abs(x) - Math.abs(xn),\r\n                            delta = Math.abs(r);\r\n                    xn = x;\r\n\r\n                    if(delta < mesh)\r\n                        done = true;\r\n                    else if(safety > max) {\r\n                        xn = null;\r\n                        done = true;\r\n                    }\r\n\r\n                    safety++;\r\n                }\r\n                return xn;\r\n            };\r\n            return newtonraph(Number(guess));\r\n        },\r\n        quad: function (a, b, c) {\r\n            var q = function (a, b, c, sign) {\r\n                return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\r\n            };\r\n            return [q(a, b, c, 1), q(a, b, c, -1)];\r\n        },\r\n        sumProd: function (a, b) {\r\n            return __.quad(-b, a, -1).map(function (x) {\r\n                return x.invert();\r\n            });\r\n        },\r\n        coeffs: function (symbol, wrt, coeffs) {\r\n            wrt = String(wrt);\r\n            symbol = _.expand(symbol);\r\n            coeffs = coeffs || [new Symbol(0)];\r\n            //we cannot get coeffs for group EX\r\n            if(symbol.group === EX && symbol.contains(wrt, true))\r\n                _.error('Unable to get coefficients using expression ' + symbol.toString());\r\n            var vars = variables(symbol);\r\n            if(vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\r\n                var a = new Polynomial(symbol).coeffs.map(function (x) {\r\n                    return new Symbol(x);\r\n                });\r\n\r\n                for(var i = 0, l = a.length; i < l; i++) {\r\n                    var coeff = a[i],\r\n                            e = coeffs[i];\r\n                    if(e)\r\n                        coeff = _.add(e, coeff);\r\n                    coeffs[i] = coeff; //transfer it all over\r\n                }\r\n            }\r\n            else {\r\n                if(!wrt)\r\n                    _.error('Polynomial contains more than one variable. Please specify which variable is to be used!');\r\n                //if the variable isn't part of this polynomial then we're looking at x^0\r\n\r\n                if(vars.indexOf(wrt) === -1) {\r\n                    coeffs[0] = _.add(symbol, coeffs[0]);\r\n                }\r\n                else {\r\n                    coeffs = coeffs || [new Symbol(0)];\r\n                    if(symbol.group === CB) {\r\n                        var s = symbol.symbols[wrt];\r\n                        if(!s)\r\n                            _.error('Expression is not a polynomial!');\r\n                        var p = Number(s.power);\r\n                        coeff = _.divide(symbol.clone(), s.clone());\r\n                        if(coeff.contains(wrt, true) || p < 0 || !isInt(p))\r\n                            _.error('Expression is not a polynomial!');\r\n                        var e = coeffs[p];\r\n                        if(e)\r\n                            coeff = _.add(e, coeff);\r\n                        coeffs[p] = coeff;\r\n                    }\r\n                    else if(symbol.group === CP) {\r\n                        symbol.each(function (x) {\r\n                            __.coeffs(x.clone(), wrt, coeffs);\r\n                        }, true);\r\n                    }\r\n                }\r\n            }\r\n            //fill holes\r\n            for(var i = 0, l = coeffs.length; i < l; i++)\r\n                if(typeof coeffs[i] === 'undefined')\r\n                    coeffs[i] = new Symbol(0);\r\n\r\n            return coeffs;\r\n        },\r\n        /**\r\n         * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n         * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n         * @param {Symbol} e\r\n         * @param {String} for_variable\r\n         * @param {Array} powers\r\n         * @returns {Array} An array of the powers\r\n         */\r\n        //assumes you've already verified that it's a polynomial\r\n        polyPowers: function (e, for_variable, powers) {\r\n            powers = powers || [];\r\n            var g = g = e.group;\r\n            if(g === PL && for_variable === e.value) {\r\n                powers = powers.concat(keys(e.symbols));\r\n            }\r\n            else if(g === CP) {\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s];\r\n                    var g = symbol.group, v = symbol.value;\r\n                    if(g === S && for_variable === v)\r\n                        powers.push(symbol.power);\r\n                    else if(g === PL || g === CP)\r\n                        powers = __.polyPowers(symbol, for_variable, powers);\r\n                    else if(g === CB && symbol.contains(for_variable)) {\r\n                        var t = symbol.symbols[for_variable];\r\n                        if(t)\r\n                            powers.push((t.power));\r\n                    }\r\n                    else if(g === N || for_variable !== v)\r\n                        powers.push(0);\r\n                }\r\n            }\r\n            else if(g === CB && e.contains(for_variable)) {\r\n                powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\r\n            }\r\n            return core.Utils.arrayUnique(powers).sort();\r\n        },\r\n        //The factor object\r\n        Factor: {\r\n            //splits the symbol in symbol and constant\r\n            split: function (symbol) {\r\n                var c = new Symbol(1); //the constants part\r\n                var s = new Symbol(1); //the symbolic part\r\n                __.Factor.factor(symbol, new Factors()).each(function (x) {\r\n                    var t = _.parse(x);\r\n                    if(x.isConstant(true)) {\r\n                        c = _.multiply(c, t);\r\n                    }\r\n                    else {\r\n                        s = _.multiply(s, t);\r\n                    }\r\n                });\r\n                return [c, s];\r\n            },\r\n            mix: function (o, include_negatives) {\r\n                var factors = keys(o);\r\n                var l = factors.length;\r\n                var m = [];//create a row which we'r going to be mixing\r\n                for(var i = 0; i < l; i++) {\r\n                    var factor = factors[i],\r\n                            p = o[factor];\r\n                    var ll = m.length;\r\n                    for(var j = 0; j < ll; j++) {\r\n                        var t = m[j] * factor;\r\n                        m.push(t);\r\n                        if(include_negatives)\r\n                            m.push(-t);\r\n                    }\r\n\r\n                    for(var j = 1; j <= p; j++)\r\n                        m.push(Math.pow(factor, j));\r\n                }\r\n                return m;\r\n            },\r\n            //TODO: this method is to replace common factoring\r\n            common: function (symbol, factors) {\r\n                try {\r\n                    if(symbol.group === CP) {\r\n                        //this may have the unfortunate side effect of expanding and factoring again\r\n                        //to only end up with the same result. \r\n                        //TODO: try to avoid this\r\n                        //collect the symbols and sort to have the longest first. Thinking is that the longest terms \r\n                        //has to contain the variable in order for it to be factorable\r\n                        var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\r\n                            return (b.length || 1) - (a.length || 1);\r\n                        });\r\n\r\n                        var map = {}; //create a map of common factors\r\n                        var coeffs = [];\r\n                        for(var i = 0; i < symbols.length; i++) {\r\n                            var sym = symbols[i];\r\n                            coeffs.push(sym.multiplier.clone());\r\n                            sym.each(function (x) {\r\n                                var p = Number(x.power);\r\n                                //This check exits since we have a symbolic power.\r\n                                //For the future... think about removing this check and modify for symbolic powers\r\n                                if(isNaN(p))\r\n                                    throw new Error('exiting');\r\n                                //loop through the symbols and lump together common terms\r\n                                if(x.value in map) {\r\n                                    if(p < map[x.value][0])\r\n                                        map[x.value][0] = p;\r\n                                    map[x.value][1].push(x);\r\n                                }\r\n                                else\r\n                                    map[x.value] = [p, [x]];\r\n                            });\r\n                        }\r\n                        //the factor\r\n                        var factor = new Symbol(1);\r\n                        for(var x in map) {\r\n                            //if this factor is found in all terms since the length of \r\n                            //matching variable terms matches the number of original terms\r\n                            if(map[x][1].length === symbols.length) {\r\n                                //generate a symbol and multiply into the factor\r\n                                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\r\n                            }\r\n                        }\r\n                        //get coefficient factor\r\n                        var c = core.Math2.QGCD.apply(null, coeffs);\r\n\r\n                        if(!c.equals(1)) {\r\n                            factors.add(new Symbol(c));\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbols[i].multiplier = symbols[i].multiplier.divide(c);\r\n                            }\r\n                        }\r\n\r\n                        //if we actuall found any factors\r\n                        if(!factor.equals(1)) {\r\n                            factors.add(factor);\r\n                            symbol = new Symbol(0);\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            zeroes: function (symbol, factors) {\r\n                var exit = function () {\r\n                    throw new core.exceptions.ValueLimitExceededError('Exiting');\r\n                };\r\n                try {\r\n                    var vars, term, sum, p, e;\r\n                    symbol = _.expand(symbol.clone());\r\n                    e = symbol.toString();\r\n                    vars = variables(symbol);\r\n\r\n                    sum = new Symbol(0);\r\n\r\n                    var terms = [];\r\n                    var powers = [];\r\n\r\n                    //start setting each variable to zero\r\n                    for(var i = 0, l = vars.length; i < vars.length; i++) {\r\n                        var subs = {};\r\n                        //we want to create a subs object with all but the current variable set to zero\r\n                        for(var j = 0; j < l; j++)\r\n                            if(i !== j) //make sure we're not looking at the same variable\r\n                                subs[vars[j]] = 0;\r\n                        term = _.parse(e, subs);\r\n                        var tp = term.power;\r\n                        //the temporary power has to be an integer as well\r\n                        if(!isInt(tp))\r\n                            exit();\r\n                        terms.push(term);\r\n                        powers.push(term.power);\r\n                    }\r\n\r\n                    //get the gcd. This will be the p in (a^n+b^m)^p\r\n                    //if the gcd equals 1 meaning n = m then we need a tie breakder\r\n                    if(core.Utils.allSame(powers)) {\r\n                        //get p given x number of terms\r\n                        var n_terms = symbol.length;\r\n                        //the number of zeroes determines\r\n                        var n_zeroes = terms.length;\r\n                        if(n_zeroes === 2) {\r\n                            p = new Frac(powers[0] / (n_terms - 1));\r\n                        }\r\n                        if(n_zeroes === 3) {\r\n                            p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\r\n                        }\r\n                        /*\r\n                         //get the lowest possible power\r\n                         //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n                         symbol.each(function(x) {\r\n                         if(x.group === CB)\r\n                         x.each(function(y) {\r\n                         if(!p || y.power.lessThan(p))\r\n                         //p = Number(y.power);\r\n                         p = y.power;\r\n                         });\r\n                         else if(!p || x.power.lessThan(p))\r\n                         //p = Number(x.power);\r\n                         p = x.power;\r\n                         });\r\n                         */\r\n                    }\r\n                    else\r\n                        //p is just the gcd of the powers\r\n                        p = core.Math2.QGCD.apply(null, powers);\r\n\r\n                    //if we don't have an integer then exit\r\n                    if(!isInt(p))\r\n                        exit();\r\n\r\n                    //build the factor\r\n                    for(var i = 0; i < terms.length; i++) {\r\n                        var t = terms[i];\r\n                        var n = t.power.clone().divide(p);\r\n                        t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\r\n                        t.power = p.clone();\r\n                        sum = _.add(sum, t);\r\n                    }\r\n\r\n                    //by now we have the factor of zeroes. We'll know if we got it right because \r\n                    //we'll get a remainder of zero each time we divide by it\r\n                    if(sum.group !== CP)\r\n                        return symbol; //nothing to do\r\n\r\n                    while(true) {\r\n                        var d = __.div(symbol.clone(), sum.clone());\r\n                        if(d[1].equals(0)) {\r\n                            symbol = d[0];\r\n                            factors.add(sum.clone());\r\n                            if(symbol.equals(1)) //we've reached 1 so done.\r\n                                break;\r\n                        }\r\n                        else\r\n                            break;\r\n                    }\r\n                }\r\n                catch(e) {\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            },\r\n            factor: function (symbol, factors) {\r\n                // Don't try to factor constants\r\n                if(symbol.isConstant()) {\r\n                    return core.Math2.factor(symbol);\r\n                }\r\n\r\n                var _symbol = _.parse(symbol);\r\n                var retval = __.Factor._factor(_symbol, factors);\r\n                if(retval.equals(symbol)) {\r\n                    return retval;\r\n                }\r\n\r\n                if(retval.group === CB) {\r\n                    var t = new Symbol(1);\r\n                    var p = _.parse(retval.power);\r\n                    //store the multiplier and strip it\r\n                    var m = _.parse(retval.multiplier);\r\n\r\n                    retval.toUnitMultiplier();\r\n\r\n                    /* \r\n                     * NOTE: for sign issues with factor START DEBUGGING HERE\r\n                     */\r\n                    //move the sign to t\r\n                    if(retval.multiplier.lessThan(0)) {\r\n                        t.negate();\r\n                        retval.negate();\r\n                    }\r\n\r\n                    retval.each(function (x) {\r\n                        // Related to #566. Since the symbol's group may not have been properly\r\n                        // updated, it's easier to just parse the symbol and have the parser \r\n                        // do the update for us.\r\n                        var factored = _.parse(__.Factor._factor(x));\r\n\r\n                        if(factored.group === CB) {\r\n                            // Include the multiplier\r\n                            m = _.multiply(m, Symbol.create(factored.multiplier));\r\n                            factored.each(function (y) {\r\n                                var _factored = _.parse(__.Factor._factor(y));\r\n                                t = _.multiply(t, _factored);\r\n                                if(_factored.group === CB) {\r\n                                    m = _.multiply(m, Symbol.create(_factored.multiplier));\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            t = _.multiply(t, factored);\r\n                        }\r\n                    });\r\n\r\n                    //put back the multiplier and power\r\n                    retval = _.pow(_.multiply(m, t), p);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            quadFactor: function (symbol, factors) {\r\n                if(symbol.isPoly() && __.degree(symbol.equals(2))) {\r\n                    //We've  already checked that we're dealing with a polynomial\r\n                    var v = core.Utils.variables(symbol)[0]; //get the variable\r\n                    var coeffs = __.coeffs(symbol, v);\r\n                    //factor the lead coefficient\r\n                    var cf = __.Factor._factor(coeffs[2].clone());\r\n                    //check if we have factors\r\n                    if(cf.group === CB) {\r\n                        var symbols = cf.collectSymbols();\r\n                        //if the factors are greater than 2 we're done so exit\r\n                        if(symbols.length > 2)\r\n                            return symbol;\r\n                        //if we have two factors then attempt to factor the polynomial\r\n                        //let the factors be f1 and f1\r\n                        //let the factors be (ax+b)(cx+d)\r\n                        //let the coefficients be c1x^2+c2x+c3\r\n                        //then a(x1)+c(x2)=c2 and x1*x2=c3\r\n                        //we can solve for x1 and x2\r\n                        var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\r\n                        var b = _.parse(coeffs[1]).negate();\r\n                        var a = _.parse(symbols[1]);\r\n                        //solve the system\r\n                        var root = __.quad(a, b, c).filter(function (x) {\r\n                            if(core.Utils.isInt(x))\r\n                                return x;\r\n                        });\r\n                        //if we have one root then find the other one by dividing the constant\r\n                        if(root.length === 1) {\r\n                            var root1 = root[0];\r\n                            var root2 = _.divide(coeffs[0], _.parse(root1));\r\n                            if(core.Utils.isInt(root2)) {\r\n                                //we found them both\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            cubeFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var symbols = symbol.collectSymbols();\r\n                    // The symbol should be in the form of a^3+-b^3. The length\r\n                    // should therefore only be two. If it's any different from this\r\n                    // then we're done\r\n                    if(symbols.length === 2) {\r\n                        // Store the signs and then strip them from the symbols\r\n                        var sign_a = symbols[0].sign();\r\n                        var a = symbols[0].clone().abs();\r\n                        var sign_b = symbols[1].sign();\r\n                        var b = symbols[1].clone().abs();\r\n                        // Check if they're cube\r\n                        if(a.isCube() && b.isCube()) {\r\n                            // Keep the negative sign on the right, meaning b is always negative.\r\n                            if(sign_a < sign_b) {\r\n                                // Swap the signs and then the values\r\n                                [sign_a, sign_b] = [sign_b, sign_a];\r\n                                [a, b] = [b, a];\r\n                            }\r\n\r\n                            // Get teh roots\r\n                            var m_root_a = _.parse(a.getNth(3));\r\n                            var m_root_b = _.parse(b.getNth(3));\r\n\r\n                            // Remove the cube for both\r\n                            var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\r\n                            var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\r\n\r\n                            if(sign_a === 1 && sign_b === -1) {\r\n                                // Apply difference of cubes rule\r\n                                factors.add(_.parse(format('(({0})-({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                            else if(sign_a === 1 && sign_b === 1) {\r\n                                // Apply sum of cubes rule\r\n                                factors.add(_.parse(format('(({0})+({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            _factor: function (symbol, factors) {\r\n                var g = symbol.group;\r\n                //some items cannot be factored any further so return those right away\r\n                if(symbol.group === FN) {\r\n                    var arg = symbol.args[0];\r\n                    if(arg.group === S && arg.isSimple()) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n                else if(symbol.group === S && symbol.isSimple()) {\r\n                    return symbol;\r\n                }\r\n\r\n                // Expand the symbol to get it in a predictable form. If this step\r\n                // is skipped some factors are missed.\r\n                //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\r\n                if(symbol.group === CP) {\r\n                    symbol.distributeMultiplier(true);\r\n                    var t = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        if((x.group === CP && x.power.greaterThan(1) || x.group === CB))\r\n                            x = _.expand(x);\r\n                        t = _.add(t, x);\r\n                    });\r\n                    t.power = symbol.power;\r\n\r\n                    symbol = t;\r\n                }\r\n\r\n                if(symbol.group === FN && symbol.fname !== 'sqrt') {\r\n                    symbol = core.Utils.evaluate(symbol);\r\n                }\r\n\r\n                //make a copy of the symbol to return if something goes wrong\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    if(symbol.group === CB) {\r\n                        var p = _.parse(symbol.power);\r\n\r\n                        var den_array, num_array, den, num, dfact, nfact;\r\n                        //grab the denominator and strip the multiplier and power. Store them in an array\r\n                        den_array = __.Simplify.strip(symbol.getDenom());\r\n                        num_array = __.Simplify.strip(symbol.getNum());\r\n\r\n                        den = den_array.pop();\r\n                        num = num_array.pop();\r\n\r\n                        //if the numerator equals the symbol then we've hit the simplest form and then we're done\r\n                        if(num.equals(symbol)) {\r\n                            return symbol;\r\n                        }\r\n                        nfact = __.Factor.factor(num);\r\n                        dfact = __.Factor.factor(den);\r\n\r\n                        var n = __.Simplify.unstrip(num_array, nfact);\r\n                        var d = __.Simplify.unstrip(den_array, dfact);\r\n\r\n                        var retval = _.divide(n, d);\r\n\r\n                        return retval;\r\n                    }\r\n                    if(symbol.group === S) {\r\n                        return symbol; //absolutely nothing to do\r\n                    }\r\n\r\n                    if(symbol.isConstant()) {\r\n                        if(symbol.equals(1))\r\n                            return symbol.clone();\r\n                        var ret = core.Math2.factor(symbol);\r\n                        return ret;\r\n                    }\r\n\r\n                    var p = symbol.power.clone();\r\n\r\n                    if(isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\r\n                        var sign = p.sign();\r\n                        symbol.toLinear();\r\n                        factors = factors || new Factors();\r\n                        var map = {};\r\n                        symbol = _.parse(core.Utils.subFunctions(symbol, map));\r\n                        if(keys(map).length > 0) { //it might have functions\r\n                            factors.preAdd = function (factor) {\r\n                                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\r\n                                return ret;\r\n                            };\r\n                        }\r\n\r\n                        //strip the power\r\n                        if(!symbol.isLinear()) {\r\n                            factors.pFactor = symbol.power.toString();\r\n                            symbol.toLinear();\r\n                        }\r\n\r\n                        var vars = variables(symbol);\r\n                        //bypass for imaginary. TODO: find a better solution\r\n                        if(symbol.isImaginary()) {\r\n                            vars.push(core.Settings.IMAGINARY);\r\n                        }\r\n                        var multiVar = vars.length > 1;\r\n\r\n                        //minor optimization. Seems to cut factor time by half in some cases.\r\n                        if(multiVar) {\r\n                            var all_S = true, all_unit = true;\r\n                            symbol.each(function (x) {\r\n                                if(x.group !== S)\r\n                                    all_S = false;\r\n                                if(!x.multiplier.equals(1))\r\n                                    all_unit = false;\r\n                            });\r\n\r\n                            if(all_S && all_unit) {\r\n                                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\r\n                            }\r\n                        }\r\n\r\n                        //factor the coefficients\r\n                        var coeff_factors = new Factors();\r\n\r\n                        symbol = __.Factor.coeffFactor(symbol, coeff_factors);\r\n\r\n                        coeff_factors.each(function (x) {\r\n                            // If the factor was negative but was within a square then it becomes positive\r\n                            if(even(p) && x.lessThan(0)) {\r\n                                x.negate();\r\n                            }\r\n\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        //factor the power\r\n                        var power_factors = new Factors();\r\n                        symbol = __.Factor.powerFactor(symbol, power_factors);\r\n                        power_factors.each(function (x) {\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        if(!multiVar) {\r\n                            //pass in vars[0] for safety\r\n                            var v = vars[0];\r\n\r\n                            symbol = __.Factor.squareFree(symbol, factors, v);\r\n\r\n                            var t_factors = new Factors();\r\n\r\n                            symbol = __.Factor.trialAndError(symbol, t_factors, v);\r\n\r\n                            //generate a symbol based off the last factors\r\n                            var tf_symbol = t_factors.toSymbol();\r\n                            //if nothing was factored then return the factors\r\n                            if(tf_symbol.equals(untouched)) {\r\n                                return tf_symbol;\r\n                            }\r\n\r\n                            for(var x in t_factors.factors) {\r\n                                //store the current factor in t_factor\r\n                                var t_factor = t_factors.factors[x];\r\n                                factors.add(_.pow(t_factor, _.parse(p)));\r\n                            }\r\n                            //if we still don't have a factor and it's quadratic then let's just do a quad factor\r\n                            if(symbol.equals(untouched)) {\r\n                                symbol = __.Factor.quadFactor(symbol, factors);\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            // Try sum and difference of cubes\r\n                            symbol = __.Factor.cubeFactor(symbol, factors);\r\n\r\n                            symbol = __.Factor.mfactor(symbol, factors);\r\n\r\n                            //put back the sign of power\r\n                            factors.each(function (x) {\r\n                                if(sign < 0)\r\n                                    x.power.negate();\r\n                            });\r\n                        }\r\n\r\n                        //last minute clean up\r\n                        symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\r\n                        \r\n                        var addPower = factors.length === 1;\r\n                        \r\n                        factors.add(_.pow(symbol, _.parse(p)));\r\n\r\n                        var retval = factors.toSymbol();\r\n                        \r\n                        // We may have only factored out the symbol itself so we end up with a factor of one \r\n                        // where the power needs to be placed back\r\n                        // e.g. factor((2*y+p)^2). Here we end up having a factor of 1 remaining and a p of 2.\r\n                        if(addPower && symbol.equals(1) && retval.isLinear()) {\r\n                            retval = _.pow(retval, _.parse(p));\r\n                        }\r\n                        \r\n                        return retval;\r\n                    }\r\n\r\n                    return symbol;\r\n                }\r\n                catch(e) {\r\n                    //no need to stop the show because something went wrong :). Just return the unfactored.\r\n                    return untouched;\r\n                }\r\n            },\r\n            reduce: function (symbol, factors) {\r\n                if(symbol.group === CP && symbol.length === 2) {\r\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                        return b.multiplier - a.multiplier;\r\n                    });\r\n                    if(symbols[0].power.equals(symbols[1].power)) {\r\n                        //x^n-a^n\r\n                        var n = _.parse(symbols[0].power),\r\n                                a = symbols[0].clone().toLinear(),\r\n                                b = symbols[1].clone().toLinear();\r\n\r\n                        //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\r\n                        factors.add(_.add(a.clone(), b.clone()));\r\n                        //flip the sign\r\n                        b.negate();\r\n                        //turn n into a number\r\n                        var nn = Number(n);\r\n                        //the remainder\r\n                        var result = new Symbol(0);\r\n                        for(var i = 1; i <= nn; i++) {\r\n                            var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\r\n                                    bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\r\n                            result = _.add(result, _.multiply(aa, bb));\r\n                        }\r\n                        return result;\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Makes Symbol square free\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @@param {String} variable The variable which is being factored \r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            squareFree: function (symbol, factors, variable) {\r\n                if(symbol.isConstant() || symbol.group === S)\r\n                    return symbol;\r\n\r\n                var poly = new Polynomial(symbol, variable);\r\n                var sqfr = poly.squareFree();\r\n                var p = sqfr[2];\r\n                //if we found a square then the p entry in the array will be non-unit\r\n                if(p !== 1) {\r\n                    //make sure the remainder doesn't have factors\r\n                    var t = sqfr[1].toSymbol();\r\n                    t.power = t.power.multiply(new Frac(p));\r\n                    //send the factor to be fatored to be sure it's completely factored\r\n                    factors.add(__.Factor.factor(t));\r\n\r\n                    var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\r\n\r\n                    return retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Factors the powers such that the lowest power is a constant\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            powerFactor: function (symbol, factors) {\r\n                //only PL need apply\r\n                if(symbol.group !== PL || symbol.previousGroup === EX)\r\n                    return symbol;\r\n                var k = keys(symbol.symbols);\r\n                //we expect only numeric powers so return all else\r\n                if(!core.Utils.allNumeric(k))\r\n                    return symbol;\r\n\r\n                var d = core.Utils.arrayMin(k);\r\n                var retval = new Symbol(0);\r\n                var q = _.parse(symbol.value + '^' + d);\r\n                symbol.each(function (x) {\r\n                    x = _.divide(x, q.clone());\r\n                    retval = _.add(retval, x);\r\n                });\r\n\r\n                factors.add(q);\r\n                return retval;\r\n            },\r\n            /**\r\n             * Removes GCD from coefficients\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @returns {Symbol}\r\n             */\r\n            coeffFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\r\n\r\n                    if(!gcd.equals(1)) {\r\n                        symbol.each(function (x) {\r\n                            if(x.isComposite()) {\r\n                                x.each(function (y) {\r\n                                    y.multiplier = y.multiplier.divide(gcd);\r\n                                });\r\n                            }\r\n                            else\r\n                                x.multiplier = x.multiplier.divide(gcd);\r\n                        });\r\n                        symbol.updateHash();\r\n                    }\r\n                    else {\r\n                        // TODO: This should probably go to the prototype\r\n                        var power = function (symbol) {\r\n                            var p;\r\n                            if(symbol.group === CB) {\r\n                                p = 0;\r\n                                symbol.each(function (x) {\r\n                                    p += x.power;\r\n                                });\r\n                            }\r\n                            else {\r\n                                p = Number(symbol.power);\r\n                            }\r\n                            return p;\r\n                        };\r\n                        // Factor out negatives from the lead term\r\n                        var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\r\n                            // Push constants to the back\r\n                            if(a.isConstant(true))\r\n                                return 1;\r\n                            return b.power - a.power;\r\n                        });\r\n\r\n                        var LT = terms[0];\r\n\r\n                        // Check if the LT is indeed the greatest\r\n                        if(power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\r\n                            if(LT.multiplier.lessThan(0)) {\r\n                                // Although the symbol should always be linear at this point, remove the negative for squares\r\n                                // to be safe.\r\n                                factors.add(new Symbol(-1));\r\n\r\n                                symbol.each(function (x) {\r\n                                    x.negate();\r\n                                }, true);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(factors) {\r\n                        factors.add(new Symbol(gcd));\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * The name says it all :)\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @@param {String} variable \r\n             * @returns {Symbol}\r\n             */\r\n            trialAndError: function (symbol, factors, variable) {\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    // At temp holder for the factors. If all goes well then\r\n                    // they'll be moved to the actual factors.\r\n                    var factor_array = [];\r\n\r\n                    if(symbol.isConstant() || symbol.group === S)\r\n                        return symbol;\r\n                    var poly = new Polynomial(symbol, variable),\r\n                            cnst = poly.coeffs[0],\r\n                            cfactors = core.Math2.ifactor(cnst),\r\n                            roots = __.proots(symbol);\r\n                    for(var i = 0; i < roots.length; i++) {\r\n                        var r = roots[i],\r\n                                p = 1;\r\n                        if(!isNaN(r)) { //if it's a number\r\n                            for(var x in cfactors) {\r\n                                //check it's raised to a power\r\n                                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\r\n                                if(isInt(n)) {\r\n                                    r = x; //x must be the root since n gave us a whole\r\n                                    p = n;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            var root = new Frac(r),\r\n                                    terms = [new Frac(root.num).negate()];\r\n                            terms[p] = new Frac(root.den);\r\n                            //convert to Frac. The den is coeff of LT and the num is coeff of constant\r\n                            var div = Polynomial.fromArray(terms, poly.variable).fill(),\r\n                                    t = poly.divide(div);\r\n                            if(t[1].equalsNumber(0)) { //if it's zero we have a root and divide it out\r\n                                poly = t[0];\r\n                                // factors.add(div.toSymbol());\r\n                                factor_array.push(div.toSymbol());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(!poly.equalsNumber(1)) {\r\n                        poly = __.Factor.search(poly, factors);\r\n                    }\r\n\r\n                    // Move the factors over since all went well.\r\n                    factor_array.forEach(function (x) {\r\n                        factors.add(x);\r\n                    });\r\n\r\n                    return poly.toSymbol();\r\n                }\r\n                catch(e) {\r\n                    return untouched;\r\n                }\r\n            },\r\n            search: function (poly, factors, base) {\r\n                base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\r\n                var v = poly.variable; //the polynmial variable name\r\n                /**\r\n                 * Attempt to remove a root by division given a number by first creating\r\n                 * a polynomial fromt he given information\r\n                 * @param {int} c1 - coeffient for the constant\r\n                 * @param {int} c2 - coefficient for the LT\r\n                 * @param {int} n - the number to be used to construct the polynomial\r\n                 * @param {int} p - the power at which to create the polynomial\r\n                 * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n                 */\r\n                var check = function (c1, c2, n, p) {\r\n                    var candidate = Polynomial.fit(c1, c2, n, base, p, v);\r\n                    if(candidate && candidate.coeffs.length > 1) {\r\n                        var t = poly.divide(candidate);\r\n                        if(t[1].equalsNumber(0)) {\r\n                            factors.add(candidate.toSymbol());\r\n                            return [t[0], candidate];\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n                var cnst = poly.coeffs[0];\r\n                var cfactors = core.Math2.ifactor(cnst);\r\n                var lc = poly.lc();\r\n                var ltfactors = core.Math2.ifactor(lc);\r\n                var subbed = poly.sub(base);\r\n                var isubbed = core.Math2.ifactor(subbed);\r\n                var nfactors = __.Factor.mix(isubbed, subbed < 0);\r\n                var cp = Math.ceil(poly.coeffs.length / 2);\r\n                var lc_is_neg = lc.lessThan(0);\r\n                var cnst_is_neg = cnst.lessThan(0);\r\n                ltfactors['1'] = 1;\r\n                cfactors['1'] = 1;\r\n                while(cp--) {\r\n                    for(var x in ltfactors) {\r\n                        for(var y in cfactors) {\r\n                            for(var i = 0; i < nfactors.length; i++) {\r\n                                var factor_found = check(x, y, nfactors[i], cp);\r\n                                if(factor_found) {\r\n                                    poly = factor_found[0];\r\n                                    if(!core.Utils.isPrime(poly.sub(base)))\r\n                                        poly = __.Factor.search(poly, factors);\r\n                                    return poly;\r\n                                }\r\n                                else if(!factor_found) {\r\n                                    if(lc_is_neg && cnst_is_neg)\r\n                                        factor_found = check(-x, -y, nfactors[i], cp);\r\n                                    else if(lc_is_neg)\r\n                                        factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\r\n                                    else if(cnst_is_neg)\r\n                                        factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return poly;\r\n            },\r\n            /**\r\n             * Equivalent of square free factor for multivariate polynomials\r\n             * @param {type} symbol\r\n             * @param {type} factors\r\n             * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n             */\r\n            mSqfrFactor: function (symbol, factors) {\r\n                if(symbol.group !== FN) {\r\n                    var vars = variables(symbol).reverse();\r\n\r\n                    // Loop through all the variable and remove the partial derivatives\r\n                    for(var i = 0; i < vars.length; i++) {\r\n                        do {\r\n                            if(vars[i] === symbol.value) {\r\n                                //the derivative tells us nothing since this symbol is already the factor\r\n                                factors.add(symbol);\r\n                                symbol = new Symbol(1);\r\n                                continue;\r\n                            }\r\n\r\n                            var diff = core.Calculus.diff(symbol, vars[i]);\r\n\r\n                            var d = __.Factor.coeffFactor(diff);\r\n\r\n                            if(d.equals(0))\r\n                                break;\r\n\r\n                            //trial division to see if factors have whole numbers. \r\n                            //This can be optimized by stopping as soon as can_divide is false\r\n                            //this will also need utilize big number at some point\r\n                            var can_divide = true;\r\n                            if(d.isConstant() && symbol.isComposite()) {\r\n                                //check the coefficients\r\n\r\n                                symbol.each(function (x) {\r\n                                    if(x.multiplier % d !== 0)\r\n                                        can_divide = false;\r\n                                }, true);\r\n                            }\r\n\r\n                            //if we can divide then do so\r\n                            if(can_divide) {\r\n\r\n                                var div = __.div(symbol, d.clone()),\r\n                                        is_factor = div[1].equals(0);\r\n                                \r\n                                // Break infinite loop for factoring e^t*x-1\r\n                                if((symbol.equals(div[0]) && div[1].equals(0))) {\r\n                                    break;\r\n                                }\r\n                                \r\n                                if(div[0].isConstant()) {\r\n                                    factors.add(div[0]);\r\n                                    break;\r\n                                }\r\n                                \r\n                            }\r\n                            else\r\n                                is_factor = false;\r\n\r\n                            if(is_factor) {\r\n                                factors.add(div[0]);\r\n                                symbol = d;\r\n                            }\r\n                        }\r\n                        while(is_factor)\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //difference of squares factorization\r\n            sqdiff: function (symbol, factors) {\r\n                if(symbol.isConstant('all')) {\r\n                    // Nothing to do\r\n                    return symbol;\r\n                }\r\n\r\n                try {\r\n                    var remove_square = function (x) {\r\n                        return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\r\n                            return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\r\n                        }, true);\r\n                    };\r\n                    var separated = core.Utils.separate(symbol.clone());\r\n\r\n                    var obj_array = [];\r\n\r\n                    //get the unique variables\r\n                    for(var x in separated) {\r\n                        if(x !== 'constants') {\r\n                            obj_array.push(separated[x]);\r\n                        }\r\n                    }\r\n                    obj_array.sort(function (a, b) {\r\n                        return b.power - a.power;\r\n                    });\r\n\r\n                    //if we have the same number of variables as unique variables then we can apply the difference of squares\r\n                    if(obj_array.length === 2) {\r\n                        var a, b;\r\n                        a = obj_array.pop();\r\n                        b = obj_array.pop();\r\n\r\n                        if(even(a.power) && even(b.power)\r\n                                && a.sign() === b.sign()\r\n                                && a.group === S && b.group === S) {\r\n                            throw new Error('Unable to factor');\r\n                        }\r\n                        ;\r\n\r\n                        if(a.isComposite() && b.power.equals(2)) {\r\n                            //remove the square from b\r\n                            b = remove_square(b);\r\n                            var f = __.Factor.factor(_.add(a, separated.constants));\r\n                            if(f.power.equals(2)) {\r\n                                f.toLinear();\r\n                                factors.add(_.subtract(f.clone(), b.clone()));\r\n                                factors.add(_.add(f, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                        else {\r\n                            a = a.powSimp();\r\n                            b = b.powSimp();\r\n\r\n                            if((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\r\n                                if(a.multiplier.lessThan(0)) {\r\n                                    var t = b;\r\n                                    b = a;\r\n                                    a = t;\r\n                                }\r\n                                if(a.multiplier.greaterThan(0)) {\r\n                                    a = remove_square(a);\r\n                                    b = remove_square(b);\r\n                                }\r\n\r\n                                factors.add(_.subtract(a.clone(), b.clone()));\r\n                                factors.add(_.add(a, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //factoring for multivariate\r\n            mfactor: function (symbol, factors) {\r\n\r\n                if(symbol.group === FN) {\r\n                    if(symbol.fname === 'sqrt') {\r\n                        var factors2 = new Factors(),\r\n                                arg = __.Factor.common(symbol.args[0].clone(), factors2);\r\n                        arg = __.Factor.coeffFactor(arg, factors2);\r\n                        symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\r\n                        factors2.each(function (x) {\r\n                            symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\r\n                        });\r\n                    }\r\n                    else\r\n                        factors.add(symbol);\r\n                }\r\n                else {\r\n\r\n                    //square free factorization\r\n                    symbol = __.Factor.mSqfrFactor(symbol, factors);\r\n\r\n                    //try factor out common factors\r\n                    //symbol = __.Factor.common(symbol, factors);\r\n\r\n                    var vars = variables(symbol),\r\n                            symbols = symbol.collectSymbols().map(function (x) {\r\n                        return Symbol.unwrapSQRT(x);\r\n                    }),\r\n                            sorted = {},\r\n                            maxes = {},\r\n                            l = vars.length, n = symbols.length;\r\n                    //take all the variables in the symbol and organize by variable name\r\n                    //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\r\n\r\n                    for(var i = 0; i < l; i++) {\r\n                        var v = vars[i];\r\n                        sorted[v] = new Symbol(0);\r\n                        for(var j = 0; j < n; j++) {\r\n                            var s = symbols[j];\r\n                            if(s.contains(v)) {\r\n                                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\r\n                                if(!maxes[v] || p < maxes[v])\r\n                                    maxes[v] = p;\r\n                                sorted[v] = _.add(sorted[v], s.clone());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    for(var x in sorted) {\r\n                        var r = _.parse(x + '^' + maxes[x]);\r\n                        var div = _.divide(sorted[x], r);\r\n                        var new_factor = _.expand(div);\r\n\r\n                        if(new_factor.equals(1))\r\n                            break; //why divide by one. Just move \r\n                        var divided = __.div(symbol.clone(), new_factor);\r\n\r\n                        if(divided[0].equals(0)) {\r\n                            //cant factor anymore\r\n                            break;\r\n                        }\r\n\r\n                        // We potentially ended up with fractional coefficients when the\r\n                        // trial division was performed. We need to remove \r\n                        // This check will more then likely become superfluous with improvements\r\n                        // to polynomial division\r\n                        if(divided[1].equals(0)) {\r\n                            var has_fractions = false;\r\n\r\n                            divided[0].each(function (x) {\r\n                                if(!isInt(x.multiplier)) {\r\n                                    has_fractions = true;\r\n                                }\r\n                            });\r\n\r\n                            // The factor isn't really a factor and needs to be put back\r\n                            if(has_fractions) {\r\n                                divided[1] = _.expand(_.multiply(divided[1], new_factor));\r\n                                // Since the new factor is not just one, we exit.\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\r\n\r\n                        if(divided[1].equals(0) && !neg_numeric_factor) { //we found at least one factor\r\n\r\n                            //factors.add(new_factor);\r\n                            var d = __.div(symbol.clone(), divided[0].clone());\r\n                            var r = d[0];\r\n\r\n                            // Nothing left to do since we didn't get a reduction\r\n                            if(r.equals(0)) {\r\n                                return symbol;\r\n                            }\r\n\r\n                            symbol = d[1];\r\n                            //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\r\n                            //and we just return the symbol;\r\n                            //If r equals zero then there's nothing left to do so we're done\r\n\r\n                            if(r.equals(-1) && !symbol.equals(0))\r\n                                return symbol;\r\n\r\n                            var factor = divided[0];\r\n\r\n                            if(symbol.equals(factor)) {\r\n                                var rem = __.Factor.reduce(factor, factors);\r\n\r\n                                if(!symbol.equals(rem))\r\n                                    return __.Factor.mfactor(rem, factors);\r\n\r\n                                return rem;\r\n                            }\r\n                            else {\r\n                                factors.add(factor);\r\n                                //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\r\n                                if(symbol.equals(0))\r\n                                    return r;\r\n                            }\r\n\r\n                            if(r.isConstant('all')) {\r\n                                factors.add(r);\r\n                                return r;\r\n                            }\r\n\r\n                            return __.Factor.mfactor(r, factors);\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                //difference of squares factorization\r\n                symbol = __.Factor.sqdiff(symbol, factors);\r\n\r\n                //factors by fishing for zeroes\r\n                symbol = __.Factor.zeroes(symbol, factors);\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        /**\r\n         * Checks to see if a set of \"equations\" is linear. \r\n         * @param {type} set\r\n         * @returns {Boolean}\r\n         */\r\n        allLinear: function (set) {\r\n            var l = set.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(!__.isLinear(set[i]))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /*\r\n         * Checks to see if the \"equation\" is linear\r\n         * @param {Symbol} e\r\n         * @returns {boolean}\r\n         */\r\n        isLinear: function (e) {\r\n            var status = false, g = e.group;\r\n            if(g === PL || g === CP) {\r\n                status = true;\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s], sg = symbol.group;\r\n                    if(sg === FN || sg === EX) {\r\n                        status = false;\r\n                    }\r\n                    if(sg === CB) {\r\n                        //needs further checking since it might be imaginary\r\n                        status = variables(symbol).length === 1;\r\n                    }\r\n                    else {\r\n                        if(sg === PL || sg === CP)\r\n                            status = __.isLinear(symbol);\r\n                        else {\r\n                            if(symbol.group !== N && symbol.power.toString() !== '1') {\r\n                                status = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(g === S && e.power === 1)\r\n                status = true;\r\n            return status;\r\n        },\r\n        gcd: function () {\r\n            var args;\r\n            if(arguments.length === 1 && arguments[0] instanceof core.Vector)\r\n                args = arguments[0].elements;\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //short-circuit early\r\n            if(args.length === 0)\r\n                return new Symbol(1);\r\n            else if(args.length === 1)\r\n                return args[0];\r\n\r\n            var appeared = [], evaluate = false;\r\n            for(var i = 0; i < args.length; i++) {\r\n                if(args[i].group === FN && args[i].fname === 'gcd')\r\n                {\r\n                    //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\r\n                    args = args.concat(arguments[i].args);\r\n                    //do not keep gcd in args\r\n                    args.splice(i, 1);\r\n                }\r\n                else\r\n                {\r\n                    //Look if there are any common variables such that\r\n                    //gcd(a,b) => gcd(a,b); gcd(a,a) => a\r\n                    var vars = variables(args[i]);\r\n                    if(core.Utils.haveIntersection(vars, appeared))\r\n                    {\r\n                        //Ok, there are common variables\r\n                        evaluate = true;\r\n                        break;\r\n                    }\r\n                    else\r\n                        appeared = appeared.concat(vars);\r\n                }\r\n            }\r\n\r\n            //appeared.length is 0 when all arguments are group N\r\n            if(evaluate || appeared.length === 0) {\r\n                //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\r\n                if(args.every(function (symbol) {\r\n                    return symbol.getDenom().equals(1)\r\n                })) {\r\n                    var aggregate = args[0];\r\n\r\n                    for(var i = 1; i < args.length; i++) {\r\n                        aggregate = __.gcd_(args[i], aggregate);\r\n                    }\r\n                    return aggregate;\r\n                }\r\n                else {\r\n                    //gcd_ cannot handle denominators correctly\r\n                    return _.divide(__.gcd.apply(null, args.map(function (symbol) {\r\n                        return symbol.getNum();\r\n                    })),\r\n                            __.lcm.apply(null, args.map(function (symbol) {\r\n                                return symbol.getDenom();\r\n                            })));\r\n                }\r\n            }\r\n            else\r\n                return _.symfunction('gcd', args);\r\n        },\r\n        gcd_: function (a, b) {\r\n            if(a.group === FN || a.group === P)\r\n                a = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(a);\r\n                });\r\n\r\n            if(b.group === FN)\r\n                b = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(b);\r\n                });\r\n\r\n            if(a.isConstant() && b.isConstant()) {\r\n                // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\r\n                return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\r\n            }\r\n\r\n            var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\r\n            a = _.multiply(a.clone(), den.clone());\r\n            b = _.multiply(b.clone(), den.clone());\r\n\r\n            //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\r\n            a = _.expand(a);\r\n            b = _.expand(b);\r\n\r\n            if(a.group === CB || b.group === CB) {\r\n                var q = _.divide(a.clone(), b.clone()); //get the quotient\r\n                var t = _.multiply(b.clone(), q.getDenom().invert());//multiply by the denominator\r\n                //if they have a common factor then the result will not equal one \r\n                if(!t.equals(1))\r\n                    return t;\r\n            }\r\n\r\n            //just take the gcd of each component when either of them is in group EX\r\n            if(a.group === EX || b.group === EX)\r\n            {\r\n                var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\r\n                var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\r\n                var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\r\n                return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\r\n            }\r\n\r\n            if(a.length < b.length) { //swap'm\r\n                var t = a;\r\n                a = b;\r\n                b = t;\r\n            }\r\n            var vars_a = variables(a), vars_b = variables(b);\r\n            if((vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0])\r\n                    || vars_a.length === 1 && vars_b.length === 0\r\n                    || vars_a.length === 0 && vars_b.length === 1) {\r\n                a = new Polynomial(a);\r\n                b = new Polynomial(b);\r\n                return _.divide(a.gcd(b).toSymbol(), den);\r\n            }\r\n            else {\r\n                //get the gcd of the multipiers\r\n                //get rid of gcd in coeffs\r\n                var multipliers = [];\r\n                a.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n                b.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n\r\n                var T;\r\n                while(!b.equals(0)) {\r\n                    var t = b.clone();\r\n                    a = a.clone();\r\n                    T = __.div(a, t);\r\n\r\n                    b = T[1];\r\n                    if(T[0].equals(0)) {\r\n                        //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\r\n                        return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\r\n                    }\r\n                    a = t;\r\n                }\r\n\r\n                var gcd = core.Math2.QGCD.apply(undefined, multipliers);\r\n\r\n                if(!gcd.equals(1)) {\r\n                    a.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(gcd);\r\n                    });\r\n                }\r\n\r\n                //return symbolic function for gcd in indeterminate form\r\n                if(a.equals(1) && !a.isConstant() && !b.isConstant())\r\n                    return _.divide(_.symfunction('gcd', arguments), den);\r\n\r\n                return _.divide(a, den);\r\n            }\r\n        },\r\n        lcm: function () {\r\n            //https://math.stackexchange.com/a/319310\r\n            //generalization of the 2-variable formula of lcm\r\n\r\n            var args;\r\n            if(arguments.length === 1)\r\n                if(arguments[0] instanceof core.Vector)\r\n                    args = arguments[0].elements;\r\n                else\r\n                    _.error('lcm expects either 1 vector or 2 or more arguments');\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //product of all arguments\r\n            //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n            var numer = args.reduce(function (prev, curr) {\r\n                return _.multiply(prev, curr.clone())\r\n            }, new Symbol(1));\r\n\r\n            //gcd of complementary terms\r\n            var denom_args =\r\n                    //https://stackoverflow.com/a/18223072\r\n                //take all complementary terms, e.g.\r\n                //[a,b,c] => [a*b, b*c, a*c]\r\n                //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\r\n                (function (input, size) {\r\n                        size = Number(size);\r\n                        var results = [], result, mask, i, total = Math.pow(2, input.length);\r\n                        for(mask = size; mask < total; mask++) {\r\n                            result = [];\r\n                            i = input.length - 1;\r\n\r\n                            do {\r\n                                if((mask & (1 << i)) !== 0) {\r\n                                    result.push(input[i]);\r\n                                }\r\n                            }\r\n                            while(i--);\r\n\r\n                            if(result.length === size) {\r\n                                results.push(result);\r\n                            }\r\n                        }\r\n                        return results;\r\n                        //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n                    })(arguments, arguments.length - 1).map(function (x) {\r\n                return x.reduce(function (prev, curr) {\r\n                    return _.multiply(prev, curr.clone())\r\n                }, new Symbol(1))\r\n            });\r\n\r\n            var denom;\r\n            //don't eat the gcd term if all arguments are symbols\r\n            if(args.every(function (x) {\r\n                return core.Utils.isVariableSymbol(x)\r\n            }))\r\n                denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));\r\n            else\r\n                denom = __.gcd.apply(null, denom_args);\r\n            //divide product of all arguments by gcd of complementary terms\r\n            var div = _.divide(numer, denom);\r\n            return div;\r\n        },\r\n        /**\r\n         * Divides one expression by another\r\n         * @param {Symbol} symbol1\r\n         * @param {Symbol} symbol2\r\n         * @returns {Array}\r\n         */\r\n        divide: function (symbol1, symbol2) {\r\n            var result, remainder, factored, den;\r\n            factored = core.Algebra.Factor.factor(symbol1.clone());\r\n            den = factored.getDenom();\r\n            if(!den.isConstant('all')) {\r\n                symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\r\n            }\r\n            else\r\n                //reset the denominator since we're not dividing by it anymore\r\n                den = new Symbol(1);\r\n            result = __.div(symbol1, symbol2);\r\n            remainder = _.divide(result[1], symbol2);\r\n            return _.divide(_.add(result[0], remainder), den);\r\n        },\r\n        div: function (symbol1, symbol2) {\r\n            // If all else fails then assume that division failed with\r\n            // a remainder of zero and the original quotient\r\n            var fail = [new Symbol(0), symbol1.clone()];\r\n\r\n            try {\r\n\r\n                // Division by constants\r\n                if(symbol2.isConstant('all')) {\r\n                    symbol1.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(symbol2.multiplier);\r\n                    });\r\n                    return [symbol1, new Symbol(0)];\r\n                }\r\n                // So that factorized symbols don't affect the result\r\n                symbol1 = _.expand(symbol1);\r\n                symbol2 = _.expand(symbol2);\r\n                // Special case. May need revisiting\r\n                if(symbol1.group === S && symbol2.group === CP) {\r\n                    var x = symbol1.value;\r\n                    var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\r\n                    if(symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\r\n                        var k = Symbol.create(symbol1.multiplier);\r\n                        return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\r\n                    }\r\n                }\r\n                if(symbol1.group === S && symbol2.group === S) {\r\n                    var r = _.divide(symbol1.clone(), symbol2.clone());\r\n                    if(r.isConstant()) //we have a whole\r\n                        return [r, new Symbol(0)];\r\n                    return [new Symbol(0), symbol1.clone()];\r\n                }\r\n                var symbol1_has_func = symbol1.hasFunc(),\r\n                        symbol2_has_func = symbol2.hasFunc(),\r\n                        parse_funcs = false;\r\n\r\n                //substitute out functions so we can treat them as regular variables\r\n                if(symbol1_has_func || symbol2_has_func) {\r\n                    parse_funcs = true;\r\n                    var map = {},\r\n                            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\r\n                            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\r\n                            subs = core.Utils.getFunctionsSubs(map);\r\n                }\r\n                //get a list of the variables\r\n                var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\r\n                        quot, rem;\r\n\r\n                //treat imaginary numbers as variables\r\n                if(symbol1.isImaginary() || symbol2.isImaginary()) {\r\n                    vars.push(core.Settings.IMAGINARY);\r\n                }\r\n\r\n                if(vars.length === 1) {\r\n                    var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\r\n                    quot = q[0].toSymbol();\r\n                    rem = q[1].toSymbol();\r\n                }\r\n                else {\r\n                    vars.push(CONST_HASH); //this is for the numbers\r\n                    var reconvert = function (arr) {\r\n                        var symbol = new Symbol(0);\r\n                        for(var i = 0; i < arr.length; i++) {\r\n                            var x = arr[i].toSymbol();\r\n                            symbol = _.add(symbol, x);\r\n                        }\r\n                        return symbol;\r\n                    };\r\n\r\n                    // Silly Martin. This is why you document. I don't remember now\r\n                    var get_unique_max = function (term, any) {\r\n                        var max = Math.max.apply(null, term.terms),\r\n                                count = 0, idx;\r\n\r\n                        if(!any) {\r\n                            for(var i = 0; i < term.terms.length; i++) {\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    count++;\r\n                                }\r\n                                if(count > 1)\r\n                                    return;\r\n                            }\r\n                        }\r\n                        if(any) {\r\n                            for(i = 0; i < term.terms.length; i++)\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    break;\r\n                                }\r\n                        }\r\n                        return [max, idx, term];\r\n                    };\r\n\r\n                    // Tries to find an LT in the dividend that will satisfy division\r\n                    var get_det = function (s, lookat) {\r\n                        lookat = lookat || 0;\r\n                        var det = s[lookat], l = s.length;\r\n                        if(!det)\r\n                            return;\r\n                        //eliminate the first term if it doesn't apply\r\n                        var umax = get_unique_max(det);\r\n                        for(var i = lookat + 1; i < l; i++) {\r\n                            var term = s[i],\r\n                                    is_equal = det.sum.equals(term.sum);\r\n                            if(!is_equal && umax) {\r\n                                break;\r\n                            }\r\n                            if(is_equal) {\r\n                                // Check the differences of their maxes. The one with the biggest difference governs\r\n                                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\r\n                                var max1, max2, idx1, idx2, l2 = det.terms.length;\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var item1 = det.terms[j], item2 = term.terms[j];\r\n                                    if(typeof max1 === 'undefined' || item1.greaterThan(max1)) {\r\n                                        max1 = item1;\r\n                                        idx1 = j;\r\n                                    }\r\n                                    if(typeof max2 === 'undefined' || item2.greaterThan(max2)) {\r\n                                        max2 = item2;\r\n                                        idx2 = j;\r\n                                    }\r\n                                }\r\n                                //check their differences\r\n                                var d1 = max1.subtract(term.terms[idx1]),\r\n                                        d2 = max2.subtract(det.terms[idx2]);\r\n                                if(d2 > d1) {\r\n                                    umax = [max2, idx2, term];\r\n                                    break;\r\n                                }\r\n                                if(d1 > d2) {\r\n                                    umax = [max1, idx1, det];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else {\r\n                                //check if it's a suitable pick to determine the order\r\n                                umax = get_unique_max(term);\r\n                                //if(umax) return umax;\r\n                                if(umax)\r\n                                    break;\r\n                            }\r\n                            umax = get_unique_max(term); //calculate a new unique max\r\n                        }\r\n\r\n                        //if still no umax then any will do since we have a tie\r\n                        if(!umax)\r\n                            return get_unique_max(s[0], true);\r\n                        var e, idx;\r\n                        for(var i = 0; i < s2.length; i++) {\r\n                            var cterm = s2[i].terms;\r\n                            //confirm that this is a good match for the denominator\r\n                            idx = umax[1];\r\n                            if(idx === cterm.length - 1)\r\n                                return;\r\n                            e = cterm[idx];\r\n                            if(!e.equals(0))\r\n                                break;\r\n                        }\r\n                        if(e.equals(0))\r\n                            return get_det(s, ++lookat); //look at the next term\r\n\r\n                        return umax;\r\n                    };\r\n\r\n                    var t_map = core.Utils.toMapObj(vars);\r\n                    var init_sort = function (a, b) {\r\n                        return b.sum.subtract(a.sum);\r\n                    };\r\n                    var is_larger = function (a, b) {\r\n                        if(!a || !b)\r\n                            return false; //it's empty so...\r\n                        for(var i = 0; i < a.terms.length; i++) {\r\n                            if(a.terms[i].lessThan(b.terms[i]))\r\n                                return false;\r\n                        }\r\n                        return true;\r\n                    };\r\n\r\n                    var s1 = symbol1.tBase(t_map).sort(init_sort),\r\n                            s2 = symbol2.tBase(t_map).sort(init_sort);\r\n                    var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\r\n                    var det = get_det(target);//we'll begin by assuming that this will let us know which term \r\n                    var quotient = [];\r\n                    if(det) {\r\n                        var lead_var = det[1];\r\n                        var can_divide = function (a, b) {\r\n                            if(a[0].sum.equals(b[0].sum))\r\n                                return a.length >= b.length;\r\n                            return true;\r\n                        };\r\n\r\n                        var try_better_lead_var = function (s1, s2, lead_var) {\r\n                            var checked = [];\r\n                            for(var i = 0; i < s1.length; i++) {\r\n                                var t = s1[i];\r\n                                for(var j = 0; j < t.terms.length; j++) {\r\n                                    var cf = checked[j], tt = t.terms[j];\r\n                                    if(i === 0)\r\n                                        checked[j] = tt; //add the terms for the first one\r\n                                    else if(cf && !cf.equals(tt))\r\n                                        checked[j] = undefined;\r\n                                }\r\n                            }\r\n                            for(var i = 0; i < checked.length; i++) {\r\n                                var t = checked[i];\r\n                                if(t && !t.equals(0))\r\n                                    return i;\r\n                            }\r\n                            return lead_var;\r\n                        };\r\n                        var sf = function (a, b) {\r\n                            var l1 = a.len(), l2 = b.len();\r\n                            var blv = b.terms[lead_var], alv = a.terms[lead_var];\r\n                            if(l2 > l1 && blv.greaterThan(alv))\r\n                                return l2 - l1;\r\n                            return blv.subtract(alv);\r\n                        };\r\n\r\n                        //check to see if there's a better lead_var\r\n                        lead_var = try_better_lead_var(s1, s2, lead_var);\r\n                        //reorder both according to the max power\r\n                        s1.sort(sf); //sort them both according to the leading variable power\r\n                        s2.sort(sf);\r\n\r\n                        //try to adjust if den is larger\r\n                        var fdt = s2[0], fnt = s1[0];\r\n\r\n                        var den = new MVTerm(new Frac(1), [], fnt.map);\r\n                        if(fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\r\n                            for(var i = 0; i < fnt.terms.length; i++) {\r\n                                var d = fdt.terms[i].subtract(fnt.terms[i]);\r\n                                if(!d.equals(0)) {\r\n                                    var nd = d.add(new Frac(1));\r\n                                    den.terms[i] = d;\r\n                                    for(var j = 0; j < s1.length; j++) {\r\n                                        s1[j].terms[i] = s1[j].terms[i].add(nd);\r\n                                    }\r\n                                }\r\n                                else\r\n                                    den.terms[i] = new Frac(0);\r\n                            }\r\n                        }\r\n\r\n                        var dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                        var safety = 0;\r\n                        var max = 200;\r\n\r\n                        while(dividend_larger && can_divide(s1, s2)) {\r\n                            if(safety++ > max) {\r\n                                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\r\n                            }\r\n\r\n                            var q = s1[0].divide(s2[0]);\r\n\r\n                            quotient.push(q); //add what's divided to the quotient\r\n                            s1.shift();//the first one is guaranteed to be gone so remove from dividend\r\n                            for(var i = 1; i < s2.length; i++) { //loop through the denominator\r\n                                var t = s2[i].multiply(q).generateImage(),\r\n                                        l2 = s1.length;\r\n                                //if we're subtracting from 0\r\n                                if(l2 === 0) {\r\n                                    t.coeff = t.coeff.neg();\r\n                                    s1.push(t);\r\n                                    s1.sort(sf);\r\n                                }\r\n\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var cur = s1[j];\r\n                                    if(cur.getImg() === t.getImg()) {\r\n                                        cur.coeff = cur.coeff.subtract(t.coeff);\r\n                                        if(cur.coeff.equals(0)) {\r\n                                            core.Utils.remove(s1, j);\r\n                                            j--; //adjust the iterator\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if(j === l2 - 1) {\r\n                                        t.coeff = t.coeff.neg();\r\n                                        s1.push(t);\r\n                                        s1.sort(sf);\r\n                                    }\r\n                                }\r\n                            }\r\n                            dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                            if(!dividend_larger && s1.length >= s2.length) {\r\n                                //One more try since there might be a terms that is larger than the LT of the divisor\r\n                                for(var i = 1; i < s1.length; i++) {\r\n                                    dividend_larger = is_larger(s1[i], s2[0]);\r\n                                    if(dividend_larger) {\r\n                                        //take it from its current position and move it to the front\r\n                                        s1.unshift(core.Utils.remove(s1, i));\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    quot = reconvert(quotient);\r\n                    rem = reconvert(s1);\r\n\r\n                    if(typeof den !== 'undefined') {\r\n                        den = den.toSymbol();\r\n                        quot = _.divide(quot, den.clone());\r\n                        rem = _.divide(rem, den);\r\n                    }\r\n                }\r\n\r\n                //put back the functions\r\n                if(parse_funcs) {\r\n                    quot = _.parse(quot.text(), subs);\r\n                    rem = _.parse(rem.text(), subs);\r\n                }\r\n\r\n                return [quot, rem];\r\n            }\r\n            catch(e) {\r\n                return fail;\r\n            }\r\n\r\n        },\r\n        line: function (v1, v2, x) {\r\n            if(core.Utils.isArray(v1))\r\n                v1 = core.Utils.convertToVector(v1);\r\n            if(core.Utils.isArray(v2))\r\n                v2 = core.Utils.convertToVector(v2);\r\n            x = _.parse(x || 'x');\r\n            if(!core.Utils.isVector(v1) || !core.Utils.isVector(v2))\r\n                _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\r\n            var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\r\n                    dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\r\n                    m = _.divide(dy, dx),\r\n                    a = _.multiply(x, m.clone()),\r\n                    b = _.multiply(v1.e(1).clone(), m);\r\n            return _.add(_.subtract(a, b), v1.e(2).clone());\r\n        },\r\n        PartFrac: {\r\n            createTemplate: function (den, denom_factors, f_array, v) {\r\n                //clean up the denominator function by factors so it reduces nicely\r\n                den = __.Factor.factor(den);\r\n\r\n                //clean up factors. This is so inefficient but factors are wrapped in parens for safety\r\n                den.each(function (x, key) {\r\n                    if(x.group === FN && x.fname === '' && x.args[0].group === S) {\r\n                        var y = x.args[0];\r\n                        if(this.symbols) {\r\n                            delete this.symbols[key];\r\n                            this.symbols[y.value] = y;\r\n                        }\r\n                        else {\r\n                            den = x.args[0];\r\n                        }\r\n                    }\r\n                });\r\n\r\n                var factors, factors_vec, f, p, deg, degrees, m;\r\n                factors = denom_factors.collectFactors();\r\n                factors_vec = []; //a vector for the template\r\n                degrees = [];\r\n                m = new Symbol(1);\r\n\r\n                for(var i = 0; i < factors.length; i++) { //loop through the factors\r\n                    var factor = Symbol.unwrapPARENS(factors[i]);\r\n                    //if in he for P^n where P is polynomial and n = integer\r\n                    if(factor.power.greaterThan(1)) {\r\n                        p = Number(factor.power);\r\n                        f = factor.clone().toLinear(); //remove the power so we have only the function\r\n                        deg = Number(__.degree(f, v)); //get the degree of f\r\n                        //expand the factor\r\n                        for(var j = 0; j < p; j++) {\r\n                            var efactor = _.pow(f.clone(), new Symbol(j + 1));\r\n                            f_array.push(efactor.clone());\r\n                            var d = _.divide(den.clone(), efactor.clone());\r\n                            degrees.push(deg);\r\n                            factors_vec.push(d);\r\n                        }\r\n                    }\r\n                    /*\r\n                     Possible bug.\r\n                     Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n                     else if(factor.isConstant('all')) {\r\n                     m = _.multiply(m, factor);\r\n                     }\r\n                     */\r\n                    else {\r\n                        //get the degree of the factor so we tack it on tot he factor. This should probably be an array\r\n                        //but for now we note it on the symbol\r\n                        deg = Number(__.degree(factor, v));\r\n                        f_array.push(factor);\r\n                        var d = _.divide(den.clone(), factor.clone());\r\n                        d = _.expand(Symbol.unwrapPARENS(d));\r\n                        degrees.push(deg);\r\n                        factors_vec.push(d);\r\n                    }\r\n                }\r\n                //put back the constant\r\n                f_array = f_array.map(function (x) {\r\n                    return _.multiply(x, m.clone());\r\n                });\r\n                return [f_array, factors_vec, degrees];\r\n            },\r\n            partfrac: function (symbol, v, as_array) {\r\n\r\n                var vars = variables(symbol);\r\n\r\n                v = v || _.parse(vars[0]); //make wrt optional and assume first variable\r\n                try {\r\n                    var num, den, factors, tfactors, ofactors, nterms, degrees,\r\n                            dterms, max, M, c, powers, div, r, factors_vec, ks,\r\n                            template, tfactors;\r\n                    num = _.expand(symbol.getNum());\r\n                    den = _.expand(symbol.getDenom().toUnitMultiplier());\r\n                    //move the entire multipier to the numerator\r\n                    num.multiplier = symbol.multiplier;\r\n                    //we only have a meaningful change if n factors > 1. This means that\r\n                    //the returned group will be a CB\r\n                    //collect the terms wrt the x\r\n                    nterms = num.groupTerms(v);\r\n                    //divide out wholes if top is larger\r\n                    if(Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\r\n                        div = __.div(num.clone(), _.expand(den.clone()));\r\n                        r = div[0]; //remove the wholes\r\n                        num = div[1]; //work with the remainder\r\n                        nterms = num.groupTerms(v); //recalculate the nterms\r\n                    }\r\n                    else\r\n                        r = new Symbol(0);\r\n\r\n                    if(Number(__.degree(den, v)) === 1) {\r\n                        var q = _.divide(num, den);\r\n                        if(as_array)\r\n                            return [r, q];\r\n                        return _.add(r, q);\r\n                    }\r\n                    //first factor the denominator. This means that the strength of this\r\n                    //algorithm depends on how well we can factor the denominator. \r\n                    ofactors = __.Factor.factor(den);\r\n                    //create the template. This method will create the template for solving \r\n                    //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\r\n                    template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\r\n                    tfactors = template[0]; //grab the factors\r\n                    factors_vec = template[1]; //grab the factor vectors\r\n                    degrees = template[2]; //grab the degrees\r\n                    //make note of the powers of each term\r\n                    powers = [nterms.length];\r\n                    //create the dterms vector\r\n                    dterms = [];\r\n                    factors = [];\r\n                    ks = [];\r\n                    var factor, deg;\r\n                    factors_vec.map(function (x, idx) {\r\n                        factor = tfactors[idx];\r\n                        deg = degrees[idx];\r\n                        for(var i = 0; i < deg; i++) {\r\n                            factors.push(factor.clone());\r\n                            var k = Symbol.create(v, i);\r\n                            var t = _.expand(_.multiply(x, k.clone())).groupTerms(v);\r\n                            //make a note of the power which corresponds to the length of the array\r\n                            var p = t.length;\r\n                            powers.push(p);\r\n                            dterms.push(t);\r\n                            ks.push(k.clone());\r\n                        }\r\n                    });\r\n                    //get the max power\r\n                    max = core.Utils.arrayMax(powers);\r\n\r\n                    //fill the holes and create a matrix\r\n                    c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();\r\n                    //for each of the factors we do the same\r\n                    M = new core.Matrix();\r\n                    for(var i = 0; i < dterms.length; i++) {\r\n                        M.elements.push(core.Utils.fillHoles(dterms[i], max));\r\n                    }\r\n\r\n                    //solve the system of equations\r\n                    var partials = _.multiply(M.transpose().invert(), c);\r\n                    //the results are backwards to reverse it\r\n                    //partials.elements.reverse();\r\n                    //convert it all back\r\n                    var retval = as_array ? [r] : r;\r\n                    partials.each(function (e, i) {\r\n                        var term = _.multiply(ks[i], _.divide(e, factors[i]));\r\n                        if(as_array)\r\n                            retval.push(term);\r\n                        else\r\n                            retval = _.add(retval, term);\r\n                    });\r\n\r\n                    //done\r\n                    return retval;\r\n                }\r\n                catch(e) {\r\n                    //try to group symbols\r\n                    try {\r\n                        if(symbol.isComposite()) {\r\n                            //group denominators\r\n                            var denominators = {};\r\n\r\n                            symbol.each(function (x) {\r\n                                var d = x.getDenom();\r\n                                var n = x.getNum();\r\n                                var e = denominators[d];\r\n                                denominators[d] = e ? _.add(e, n) : n;\r\n                            });\r\n\r\n                            var t = new Symbol(0);\r\n\r\n                            for(var x in denominators) {\r\n                                t = _.add(t, _.divide(denominators[x], _.parse(x)));\r\n                            }\r\n\r\n                            symbol = t;\r\n                        }\r\n                    }\r\n                    catch(e2) {\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        degree: function (symbol, v, o) {\r\n            o = o || {\r\n                nd: [], //numeric\r\n                sd: [], //symbolic\r\n                depth: 0 //call depth\r\n            };\r\n\r\n            if(!v) {\r\n                var vars = variables(symbol);\r\n                //The user must specify the variable for multivariate\r\n                if(vars.length > 1)\r\n                    throw new Error('You must specify the variable for multivariate polynomials!');\r\n                //if it's empty then we're dealing with a constant\r\n                if(vars.length === 0)\r\n                    return new Symbol(0);\r\n                //assume the variable for univariate\r\n                v = _.parse(vars[0]);\r\n            }\r\n\r\n            //store the group\r\n            var g = symbol.group;\r\n            //we're going to trust the user and assume no EX. Calling isPoly \r\n            //would eliminate this but no sense in checking twice. \r\n            if(symbol.isComposite()) {\r\n                symbol = symbol.clone();\r\n                symbol.distributeExponent();\r\n                symbol.each(function (x) {\r\n                    o.depth++; //mark a depth increase\r\n                    __.degree(x, v, o);\r\n                    o.depth--; //we're back\r\n                });\r\n            }\r\n            else if(symbol.group === CB) {\r\n                symbol.each(function (x) {\r\n                    o.depth++;\r\n                    __.degree(x, v, o);\r\n                    o.depth++;\r\n                });\r\n            }\r\n            else if(g === EX && symbol.value === v.value) {\r\n                o.sd.push(symbol.power.clone());\r\n            }\r\n            else if(g === S && symbol.value === v.value) {\r\n                o.nd.push(_.parse(symbol.power));\r\n            }\r\n            else\r\n                o.nd.push(new Symbol(0));\r\n\r\n            //get the max out of the array\r\n            var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\r\n\r\n            if(o.depth === 0 && o.sd.length > 0) {\r\n                if(deg !== undefined)\r\n                    o.sd.unshift(deg);\r\n                return _.symfunction('max', o.sd);\r\n            }\r\n            if(!core.Utils.isSymbol(deg))\r\n                deg = _.parse(deg);\r\n            //return the degree\r\n            return deg;\r\n        },\r\n        /**\r\n         * Attempts to complete the square of a polynomial\r\n         * @param {type} symbol\r\n         * @param {type} v\r\n         * @param {type} raw\r\n         * @throws {Error} \r\n         * @returns {Object|Symbol[]}\r\n         */\r\n        sqComplete: function (symbol, v, raw) {\r\n            if(!core.Utils.isSymbol(v))\r\n                v = _.parse(v);\r\n            var stop = function (msg) {\r\n                msg = msg || 'Stopping';\r\n                throw new core.exceptions.ValueLimitExceededError(msg);\r\n            };\r\n            //if not CP then nothing to do\r\n            if(!symbol.isPoly(true))\r\n                stop('Must be a polynomial!');\r\n\r\n            //declare vars\r\n            var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\r\n\r\n            br = core.Utils.inBrackets;\r\n            //make a copy\r\n            symbol = symbol.clone();\r\n            deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\r\n            //must be in form ax^2 +/- bx +/- c\r\n            if(!deg.equals(2))\r\n                stop('Cannot complete square for degree ' + deg);\r\n            //get the coeffs\r\n            coeffs = core.Algebra.coeffs(symbol, v);\r\n            a = coeffs[2];\r\n            //store the sign\r\n            sign = coeffs[1].sign();\r\n            //divide the linear term by two and square it\r\n            b = _.divide(coeffs[1], new Symbol(2));\r\n            //add the difference to the constant\r\n            c = _.pow(b.clone(), new Symbol(2));\r\n            if(raw)\r\n                return [a, b, d];\r\n            sqrt_a = math.sqrt(a);\r\n            e = _.divide(math.sqrt(c), sqrt_a.clone());\r\n            //calculate d which is the constant\r\n            d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));\r\n            //compute the square part\r\n            sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\r\n            return {\r\n                a: sym,\r\n                c: d,\r\n                f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\r\n            };\r\n        },\r\n        Simplify: {\r\n            strip: function (symbol) {\r\n                var c = _.parse(symbol.multiplier);\r\n                symbol.toUnitMultiplier();\r\n                var p = _.parse(symbol.power);\r\n                symbol.toLinear();\r\n                return [c, p, symbol];\r\n            },\r\n            unstrip: function (cp, symbol) {\r\n                var c = cp[0];\r\n                var p = cp[1];\r\n                return _.multiply(c, _.pow(symbol, p));\r\n            },\r\n            complexSimp: function (num, den) {\r\n                var ac, bd, bc, ad, cd, r1, r2, i1, i2;\r\n                r1 = num.realpart();\r\n                i1 = num.imagpart();\r\n                r2 = den.realpart();\r\n                i2 = den.imagpart();\r\n                //apply complex arithmatic rule\r\n                ac = _.multiply(r1.clone(), r2.clone());\r\n                bd = _.multiply(i1.clone(), i2.clone());\r\n                bc = _.multiply(r2.clone(), i1);\r\n                ad = _.multiply(r1, i2.clone());\r\n                cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\r\n\r\n                return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\r\n            },\r\n            trigSimp: function (symbol) {\r\n                if(symbol.containsFunction(['cos', 'sin', 'tan'])) {\r\n                    symbol = symbol.clone();\r\n                    //remove power and multiplier\r\n                    var sym_array = __.Simplify.strip(symbol);\r\n                    symbol = sym_array.pop();\r\n                    //the default return value is the symbol\r\n                    var retval = symbol.clone();\r\n\r\n                    //rewrite the symbol\r\n                    if(symbol.group === CP) {\r\n                        var sym = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            //rewrite the function\r\n                            var tr = __.Simplify.trigSimp(x.fnTransform());\r\n                            sym = _.add(sym, tr);\r\n                        }, true);\r\n\r\n                        //put back the power and multiplier and return\r\n                        retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\r\n                    }\r\n                    else if(symbol.group === CB) {\r\n\r\n                        var n = symbol.getNum();\r\n                        var d = symbol.getDenom();\r\n\r\n                        //try for tangent\r\n                        if(n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\r\n                            retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\r\n                        }\r\n                        if(retval.group === CB) {\r\n                            var t = new Symbol(1);\r\n                            retval.each(function (x) {\r\n                                if(x.fname === 'tan') {\r\n                                    x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\r\n                                }\r\n                                t = _.multiply(t, x);\r\n                            });\r\n                            retval = t;\r\n                        }\r\n                    }\r\n\r\n\r\n                    retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\r\n\r\n                    symbol = retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            fracSimp: function (symbol) {\r\n                //try a quick simplify of imaginary numbers\r\n                var den = symbol.getDenom();\r\n                var num = symbol.getNum();\r\n\r\n                if(num.isImaginary() && den.isImaginary())\r\n                    symbol = __.Simplify.complexSimp(num, den);\r\n\r\n                if(symbol.isComposite()) {\r\n                    if(symbol.power > 1) {\r\n                        symbol = _.expand(symbol);\r\n                    }\r\n\r\n                    var symbols = symbol.collectSymbols();\r\n                    //assumption 1.\r\n                    //since it's a composite, it has a length of at least 1\r\n                    var retval, a, b, d1, d2, n1, n2, s, x, y, c, den, num;\r\n                    a = symbols.pop(); //grab the first symbol\r\n                    //loop through each term and make denominator common\r\n                    while(symbols.length) {\r\n                        b = symbols.pop(); //grab the second symbol\r\n                        d1 = _.parse(a.getDenom());\r\n                        d2 = _.parse(b.getDenom());\r\n                        n1 = a.getNum();\r\n                        n2 = b.getNum();\r\n                        c = _.multiply(d1.clone(), d2.clone());\r\n                        x = _.multiply(n1, d2);\r\n                        y = _.multiply(n2, d1);\r\n                        s = _.add(x, y);\r\n                        a = _.divide(s, c);\r\n                    }\r\n                    den = _.expand(a.getDenom());\r\n                    num = _.expand(a.getNum());\r\n                    //simplify imaginary\r\n                    if(num.isImaginary() && den.isImaginary()) {\r\n                        retval = __.Simplify.complexSimp(num, den);\r\n                    }\r\n                    else {\r\n                        retval = _.divide(num, den);\r\n                    }\r\n\r\n                    //we've already hit the simplest form so return that\r\n                    if(retval.equals(symbol)) {\r\n                        return symbol;\r\n                    }\r\n\r\n                    //otherwise simplify it some more\r\n                    return __.Simplify.simplify(retval);\r\n                }\r\n                return symbol;\r\n            },\r\n            ratSimp: function (symbol) {\r\n                if(symbol.group === CB) {\r\n                    var den = symbol.getDenom();\r\n                    var num = symbol.getNum().distributeMultiplier();\r\n                    var d = __.Simplify.fracSimp(den);\r\n                    var n = __.Simplify.fracSimp(num);\r\n                    symbol = _.divide(n, d);\r\n                }\r\n                return symbol;\r\n            },\r\n            sqrtSimp: function (symbol, sym_array) {\r\n                var retval;\r\n                if(symbol.isSQRT()) {\r\n                    var factored = __.Factor.factor(symbol.args[0].clone());\r\n                    var m = _.parse(factored.multiplier);\r\n                    var sign = m.sign();\r\n\r\n                    var retval = _.sqrt(m.abs());\r\n                    var arg;\r\n\r\n                    if(isInt(retval)) {\r\n\r\n                        if(factored.group === CB) {\r\n                            var rem = new Symbol(1);\r\n\r\n                            factored.each(function (x) {\r\n                                if(x.group === N) {\r\n                                    var trial = _.sqrt(x.clone());\r\n\r\n                                    // Multiply back sqrt if it's an integer otherwise just put back the number\r\n                                    if(isInt(trial)) {\r\n                                        retval = _.multiply(retval, trial);\r\n                                    }\r\n                                    else {\r\n                                        rem = _.multiply(rem, x);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    rem = _.multiply(rem, x);\r\n                                }\r\n\r\n                            });\r\n                            var t = _.multiply(rem, _.parse(sign));\r\n                            arg = _.sqrt(t.clone());\r\n\r\n                            // Expand if it's imaginary\r\n                            if(arg.isImaginary) {\r\n                                arg = _.sqrt(_.expand(t.clone()));\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Strip the multiplier\r\n                            arg = _.sqrt(factored.clone().toUnitMultiplier());\r\n                        }\r\n                        return _.multiply(retval, arg);\r\n\r\n                    }\r\n\r\n                }\r\n                else if(symbol.isComposite() && symbol.isLinear()) {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, __.Simplify.sqrtSimp(x));\r\n                    }, true);\r\n                    // Put back the multiplier\r\n                    retval = _.multiply(retval, _.parse(symbol.multiplier));\r\n                }\r\n                else if(symbol.group === CB) {\r\n                    retval = _.parse(symbol.multiplier);\r\n                    symbol.each(function (x) {\r\n                        var simp = __.Simplify.sqrtSimp(x);\r\n                        retval = _.multiply(retval, simp);\r\n\r\n                    }, true);\r\n                    // Put back the power\r\n                    retval = _.pow(retval, _.parse(symbol.power));\r\n                }\r\n\r\n                return retval ? retval : _.parse(symbol);\r\n            },\r\n            /**\r\n             * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n             * @param {Symbol} symbol\r\n             * @return {Array} The symbol and the matched patterns\r\n             */\r\n            patternSub: function (symbol) {\r\n                var patterns = {};\r\n\r\n                var has_CP = function (symbol) {\r\n                    var found = false;\r\n                    symbol.each(function (x) {\r\n                        if(x.group === CP) {\r\n                            found = true;\r\n                        }\r\n                        else if(x.symbols) {\r\n                            found = has_CP(x);\r\n                        }\r\n                    });\r\n\r\n                    return found;\r\n                };\r\n\r\n                var collect = function (sym) {\r\n                    // We loop through each symbol looking for anything in the simplest\r\n                    // form of ax+byz+...\r\n                    sym.each(function (x) {\r\n                        // Items of group N,P,S, need to apply\r\n                        if(!x.symbols && x.group !== FN) {\r\n                            return;\r\n                        }\r\n\r\n                        // Check to see if it has any symbols of group CP\r\n                        // Get the patterns in that symbol instead if it has anything of group CP\r\n                        if(has_CP(x)) {\r\n                            collect(x);\r\n                        }\r\n                        else {\r\n                            if(!patterns[x.value]) {\r\n                                var u = core.Utils.getU(symbol);\r\n                                // Get a u value and mark it for subsitution\r\n                                patterns[x.value] = u;\r\n                                symbol = symbol.sub(x.value, u);\r\n                            }\r\n                        }\r\n                    }, true);\r\n                };\r\n\r\n                // Collect a list of patterns\r\n                collect(symbol);\r\n\r\n                return [symbol, patterns];\r\n            },\r\n            simplify: function (symbol) {\r\n                //remove the multiplier to make calculation easier;\r\n                var sym_array = __.Simplify.strip(symbol);\r\n                symbol = sym_array.pop();\r\n                //remove gcd from denominator\r\n                symbol = __.Simplify.fracSimp(symbol);\r\n                //nothing more to do\r\n                if(symbol.isConstant() || symbol.group === core.groups.S) {\r\n                    sym_array.push(symbol);\r\n                    var ret = __.Simplify.unstrip(sym_array, symbol);\r\n                    return ret;\r\n                }\r\n\r\n                //var patterns;\r\n\r\n                var simplified = symbol.clone(); //make a copy\r\n\r\n                //[simplified, patterns] = __.Simplify.patternSub(symbol);\r\n\r\n                // Simplify sqrt within the symbol\r\n//                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\r\n\r\n                // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\r\n                simplified = __.Simplify.trigSimp(simplified);\r\n\r\n                // Simplify common denominators\r\n                simplified = __.Simplify.ratSimp(simplified);\r\n\r\n                // First go for the \"cheapest\" simplification which may eliminate \r\n                // your problems right away. factor -> evaluate. Remember\r\n                // that there's no need to expand since factor already does that\r\n\r\n                simplified = __.Factor.factor(simplified);\r\n\r\n                //If the simplfied is a sum then we can make a few more simplifications\r\n                //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\r\n                if(simplified.group === core.groups.CP && simplified.isLinear()) {\r\n                    var m = simplified.multiplier.clone();\r\n                    simplified.toUnitMultiplier(); //strip the multiplier\r\n                    var r = new Symbol(0);\r\n                    //return the sum of simplifications\r\n                    simplified.each(function (x) {\r\n                        var s = __.Simplify.simplify(x);\r\n                        r = _.add(r, s);\r\n                    });\r\n                    simplified = r;\r\n                    //put back the multiplier\r\n                    r.multiplier = r.multiplier.multiply(m);\r\n                }\r\n\r\n                //place back multiplier and return\r\n                var retval = __.Simplify.unstrip(sym_array, simplified);\r\n\r\n                // Back substitute\r\n                /*\r\n                 for(var x in patterns) {\r\n                 retval = retval.sub(patterns[x], x);\r\n                 }\r\n                 */\r\n\r\n                return retval;\r\n            }\r\n        },\r\n\r\n        Classes: {\r\n            Polynomial: Polynomial,\r\n            Factors: Factors,\r\n            MVTerm: MVTerm\r\n        }\r\n    };\r\n\r\n    // Add a link to simplify\r\n    core.Expression.prototype.simplify = function () {\r\n        return __.Simplify.simplify(this.symbol);\r\n    };\r\n\r\n    nerdamer.useAlgebraDiv = function () {\r\n        var divide = __.divideFn = _.divide;\r\n        var calls = 0; //keep track of how many calls were made\r\n        _.divide = function (a, b) {\r\n            calls++;\r\n            var ans;\r\n            if(calls === 1) //check if this is the first call. If it is use algebra divide\r\n                ans = core.Algebra.divide(a, b);\r\n            else //otherwise use parser divide\r\n                ans = divide(a, b);\r\n            calls = 0; //reset the number of calls back to none\r\n            return ans;\r\n        };\r\n    };\r\n\r\n    nerdamer.useParserDiv = function () {\r\n        if(__.divideFn)\r\n            _.divide = __.divideFn;\r\n        delete __.divideFn;\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'factor',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Factor.factor;\r\n            }\r\n        },\r\n        {\r\n            name: 'simplify',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Simplify.simplify;\r\n            }\r\n        },\r\n        {\r\n            name: 'gcd',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.gcd;\r\n            }\r\n        },\r\n        {\r\n            name: 'lcm',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.lcm;\r\n            }\r\n        },\r\n        {\r\n            name: 'roots',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.roots;\r\n            }\r\n        },\r\n        {\r\n            name: 'divide',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.divide;\r\n            }\r\n        },\r\n        {\r\n            name: 'div',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.div;\r\n            }\r\n        },\r\n        {\r\n            name: 'partfrac',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.PartFrac.partfrac;\r\n            }\r\n        },\r\n        {\r\n            name: 'deg',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.degree;\r\n            }\r\n        },\r\n        {\r\n            name: 'coeffs',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function () {\r\n                    var coeffs = __.coeffs.apply(__, arguments);\r\n                    return new core.Vector(coeffs);\r\n                };\r\n                return f;\r\n            }\r\n        },\r\n        {\r\n            name: 'line',\r\n            visible: true,\r\n            numargs: [2, 3],\r\n            build: function () {\r\n                return __.line;\r\n            }\r\n        },\r\n        {\r\n            name: 'sqcomp',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function (x, v) {\r\n                    try {\r\n                        v = v || variables(x)[0];\r\n                        var sq = __.sqComplete(x.clone(), v);\r\n                        return sq.f;\r\n                    }\r\n                    catch(e) {\r\n                        return x;\r\n                    }\r\n                };\r\n                return f;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.updateAPI();\r\n})();"],"mappings":"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"},"metadata":{},"sourceType":"script"}