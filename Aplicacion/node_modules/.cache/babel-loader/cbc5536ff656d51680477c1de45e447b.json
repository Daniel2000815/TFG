{"ast":null,"code":"import { operators } from './operators';\nexport var fs = function fs(sdf, primitives) {\n  return \"\\n    #ifdef GL_ES\\n    precision mediump float;\\n    #endif\\n\\n    // Constants\\n    const int MAX_MARCHING_STEPS=255;\\n    const float MIN_DIST=0.;\\n    const float MAX_DIST=100.;\\n    const float PRECISION=.0001;\\n    const float EPSILON=.0005;\\n    const float PI=3.14159265359;\\n\\n    struct Material\\n    {\\n    vec3 specular;\\n    vec3 diffuse;\\n    vec3 ambient;\\n    float smoothness;\\n    };\\n\\n    struct Surface{\\n        float sd;   // signed distance value\\n        Material mat;\\n    };\\n\\n    // Rotate around a circular path\\n    mat2 rotate2d(float theta){\\n        float s = sin(theta),c=cos(theta);\\n        return mat2(c,-s,s,c);\\n    }\\n\\n    // Rotation matrix around the X axis.\\n    mat3 rotateX(float theta){\\n        float c=cos(theta);\\n        float s=sin(theta);\\n        return mat3(\\n            vec3(1.,0.,0.),\\n            vec3(0.,c,-s),\\n            vec3(0.,s,c)\\n        );\\n    }\\n\\n    // Rotation matrix around the Y axis.\\n    mat3 rotateY(float theta){\\n        float c=cos(theta);\\n        float s=sin(theta);\\n        return mat3(\\n            vec3(c,0.,s),\\n            vec3(0.,1.,0.),\\n            vec3(-s,0.,c)\\n        );\\n    }\\n\\n    // Rotation matrix around the Z axis.\\n    mat3 rotateZ(float theta){\\n        float c=cos(theta);\\n        float s=sin(theta);\\n        return mat3(\\n            vec3(c,-s,0.),\\n            vec3(s,c,0.),\\n            vec3(0.,0.,1.)\\n        );\\n    }\\n\\n    // Identity matrix.\\n    mat3 identity(){\\n        return mat3(\\n            vec3(1,0,0),\\n            vec3(0,1,0),\\n            vec3(0,0,1)\\n        );\\n    }\\n\\n    \".concat(operators(), \"\\n    \").concat(primitives, \"\\n\\n    Surface minWithColor(Surface obj1,Surface obj2){\\n        if(obj2.sd<obj1.sd) return obj2;\\n        return obj1;\\n    }\\n\\n\\n    float sdf(vec3 p){\\n        \").concat(sdf, \";\\n    }\\n\\n    Surface map(vec3 p){\\n        Material mat = Material(u_specular, u_diffuse, u_ambient, u_smoothness);\\n        float d = sdf(p);\\n        \\n        Surface co = Surface(d, mat);\\n        \\n        return co;\\n    }\\n\\n    vec3 grad( in vec3 p )\\n    {\\n    return vec3(\\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\\n    );\\n    }\\n\\n    mat3 camera(vec3 cameraPos,vec3 lookAtPoint){\\n    vec3 cd = normalize(lookAtPoint-cameraPos);      // camera direction\\n    vec3 cr = normalize(cross(vec3(0.,1.,0.),cd)); // camera right\\n    vec3 cu = normalize(cross(cd,cr));               // camera up\\n    \\n    return mat3(-cr,cu,-cd);\\n    }\\n\\n    Surface rayMarch(vec3 ro,vec3 rd,float start,float end){\\n    float depth = start;\\n    Surface co; // closest object\\n    \\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\\n        vec3 p = ro + depth*rd;\\n        co = map(p);\\n        depth += co.sd;\\n        if(co.sd<PRECISION||depth>end)  break;\\n    }\\n    \\n    co.sd = depth;\\n    \\n    return co;\\n    }\\n\\n    vec3 lighting(vec3 p,vec3 n,vec3 eye,Material mat){\\n    vec3 ambient = vec3(.5);\\n    \\n    vec3 lights_pos[2];\\n    lights_pos[0] = vec3(4.,2.,2.);\\n    lights_pos[1] = vec3(-4.,-2.,-2.);\\n    \\n    vec3 lights_color[2];\\n    lights_color[0] = vec3(1.,1.,1.);\\n    lights_color[1] = vec3(1.,1.,1.);\\n    \\n    vec3 Ip = mat.ambient*ambient;\\n    \\n    for(int i=0;i<2;i++){\\n        vec3 Lm = normalize(lights_pos[i] - p);\\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm); // reflect(-Lm, n)\\n        vec3 V  = normalize(eye - p);\\n        \\n        float LN = dot(Lm,n);\\n        float RV = dot(Rm,V);\\n        \\n        if(LN<0.) // Light not visible\\n        Ip+=vec3(0.,0.,0.);\\n        else if(RV<0.)// opposite direction as viewer, apply only diffuse\\n        Ip+=lights_color[i]*(mat.diffuse*LN);\\n        else\\n        Ip+=lights_color[i]*(mat.diffuse*LN+mat.specular*pow(RV,mat.smoothness));\\n    }\\n    \\n    return Ip;\\n    }\\n\\n    vec3 calcNormal(in vec3 p){\\n    return normalize(vec3(\\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\\n    ));\\n    }\\n    \\n    void main()\\n    {\\n        vec2 uv = (gl_FragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\\n        \\n        vec2 mouseUV = iMouse.x>=0.0 ? iMouse.xy/iResolution.xy : vec2(0.5);  // [0,1]\\n\\n        vec3 backgroundColor = vec3(.835, 1.0, 1.0);\\n        vec3 col    = vec3(0.0);\\n        \\n        vec3 lookAt = vec3(0.0);\\n        vec3 eye    = vec3(0,5,0);\\n\\n        float cameraRadius = u_zoom;\\n        \\n        eye.yz = eye.yz * cameraRadius * rotate2d( mix(PI, 0.0, mouseUV.y) );\\n        eye.xz = eye.xz * rotate2d( mix(-PI, PI, mouseUV.x) ) \\n                    + vec2(lookAt.x, lookAt.z);\\n        \\n        vec3 rayDir = camera(eye, lookAt) * normalize(vec3(uv,-1));// ray direction\\n        \\n        Surface co = rayMarch(eye, rayDir, MIN_DIST, MAX_DIST);// closest object\\n        \\n        if(co.sd > MAX_DIST){\\n            col = backgroundColor;  // ray didn't hit anything\\n        }\\n        else{\\n            vec3 p = eye + rayDir*co.sd;  // point from ray marching\\n            vec3 normal = calcNormal(p);\\n            \\n            col = lighting(p, normal, eye, co.mat);\\n        }\\n        \\n        gl_FragColor = vec4(col, 1.0);\\n        return;\\n    }\\n  \");\n};","map":{"version":3,"names":["operators","fs","sdf","primitives"],"sources":["G:/gitlab/TFG/Aplicacion/src/ShaderStuff/sdfShader.js"],"sourcesContent":["import { operators } from './operators';\r\n\r\nexport const fs = (sdf, primitives) => {\r\n    return `\r\n    #ifdef GL_ES\r\n    precision mediump float;\r\n    #endif\r\n\r\n    // Constants\r\n    const int MAX_MARCHING_STEPS=255;\r\n    const float MIN_DIST=0.;\r\n    const float MAX_DIST=100.;\r\n    const float PRECISION=.0001;\r\n    const float EPSILON=.0005;\r\n    const float PI=3.14159265359;\r\n\r\n    struct Material\r\n    {\r\n    vec3 specular;\r\n    vec3 diffuse;\r\n    vec3 ambient;\r\n    float smoothness;\r\n    };\r\n\r\n    struct Surface{\r\n        float sd;   // signed distance value\r\n        Material mat;\r\n    };\r\n\r\n    // Rotate around a circular path\r\n    mat2 rotate2d(float theta){\r\n        float s = sin(theta),c=cos(theta);\r\n        return mat2(c,-s,s,c);\r\n    }\r\n\r\n    // Rotation matrix around the X axis.\r\n    mat3 rotateX(float theta){\r\n        float c=cos(theta);\r\n        float s=sin(theta);\r\n        return mat3(\r\n            vec3(1.,0.,0.),\r\n            vec3(0.,c,-s),\r\n            vec3(0.,s,c)\r\n        );\r\n    }\r\n\r\n    // Rotation matrix around the Y axis.\r\n    mat3 rotateY(float theta){\r\n        float c=cos(theta);\r\n        float s=sin(theta);\r\n        return mat3(\r\n            vec3(c,0.,s),\r\n            vec3(0.,1.,0.),\r\n            vec3(-s,0.,c)\r\n        );\r\n    }\r\n\r\n    // Rotation matrix around the Z axis.\r\n    mat3 rotateZ(float theta){\r\n        float c=cos(theta);\r\n        float s=sin(theta);\r\n        return mat3(\r\n            vec3(c,-s,0.),\r\n            vec3(s,c,0.),\r\n            vec3(0.,0.,1.)\r\n        );\r\n    }\r\n\r\n    // Identity matrix.\r\n    mat3 identity(){\r\n        return mat3(\r\n            vec3(1,0,0),\r\n            vec3(0,1,0),\r\n            vec3(0,0,1)\r\n        );\r\n    }\r\n\r\n    ${operators()}\r\n    ${primitives}\r\n\r\n    Surface minWithColor(Surface obj1,Surface obj2){\r\n        if(obj2.sd<obj1.sd) return obj2;\r\n        return obj1;\r\n    }\r\n\r\n\r\n    float sdf(vec3 p){\r\n        ${sdf};\r\n    }\r\n\r\n    Surface map(vec3 p){\r\n        Material mat = Material(u_specular, u_diffuse, u_ambient, u_smoothness);\r\n        float d = sdf(p);\r\n        \r\n        Surface co = Surface(d, mat);\r\n        \r\n        return co;\r\n    }\r\n\r\n    vec3 grad( in vec3 p )\r\n    {\r\n    return vec3(\r\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\r\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\r\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\r\n    );\r\n    }\r\n\r\n    mat3 camera(vec3 cameraPos,vec3 lookAtPoint){\r\n    vec3 cd = normalize(lookAtPoint-cameraPos);      // camera direction\r\n    vec3 cr = normalize(cross(vec3(0.,1.,0.),cd)); // camera right\r\n    vec3 cu = normalize(cross(cd,cr));               // camera up\r\n    \r\n    return mat3(-cr,cu,-cd);\r\n    }\r\n\r\n    Surface rayMarch(vec3 ro,vec3 rd,float start,float end){\r\n    float depth = start;\r\n    Surface co; // closest object\r\n    \r\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\r\n        vec3 p = ro + depth*rd;\r\n        co = map(p);\r\n        depth += co.sd;\r\n        if(co.sd<PRECISION||depth>end)  break;\r\n    }\r\n    \r\n    co.sd = depth;\r\n    \r\n    return co;\r\n    }\r\n\r\n    vec3 lighting(vec3 p,vec3 n,vec3 eye,Material mat){\r\n    vec3 ambient = vec3(.5);\r\n    \r\n    vec3 lights_pos[2];\r\n    lights_pos[0] = vec3(4.,2.,2.);\r\n    lights_pos[1] = vec3(-4.,-2.,-2.);\r\n    \r\n    vec3 lights_color[2];\r\n    lights_color[0] = vec3(1.,1.,1.);\r\n    lights_color[1] = vec3(1.,1.,1.);\r\n    \r\n    vec3 Ip = mat.ambient*ambient;\r\n    \r\n    for(int i=0;i<2;i++){\r\n        vec3 Lm = normalize(lights_pos[i] - p);\r\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm); // reflect(-Lm, n)\r\n        vec3 V  = normalize(eye - p);\r\n        \r\n        float LN = dot(Lm,n);\r\n        float RV = dot(Rm,V);\r\n        \r\n        if(LN<0.) // Light not visible\r\n        Ip+=vec3(0.,0.,0.);\r\n        else if(RV<0.)// opposite direction as viewer, apply only diffuse\r\n        Ip+=lights_color[i]*(mat.diffuse*LN);\r\n        else\r\n        Ip+=lights_color[i]*(mat.diffuse*LN+mat.specular*pow(RV,mat.smoothness));\r\n    }\r\n    \r\n    return Ip;\r\n    }\r\n\r\n    vec3 calcNormal(in vec3 p){\r\n    return normalize(vec3(\r\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\r\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\r\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\r\n    ));\r\n    }\r\n    \r\n    void main()\r\n    {\r\n        vec2 uv = (gl_FragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\r\n        \r\n        vec2 mouseUV = iMouse.x>=0.0 ? iMouse.xy/iResolution.xy : vec2(0.5);  // [0,1]\r\n\r\n        vec3 backgroundColor = vec3(.835, 1.0, 1.0);\r\n        vec3 col    = vec3(0.0);\r\n        \r\n        vec3 lookAt = vec3(0.0);\r\n        vec3 eye    = vec3(0,5,0);\r\n\r\n        float cameraRadius = u_zoom;\r\n        \r\n        eye.yz = eye.yz * cameraRadius * rotate2d( mix(PI, 0.0, mouseUV.y) );\r\n        eye.xz = eye.xz * rotate2d( mix(-PI, PI, mouseUV.x) ) \r\n                    + vec2(lookAt.x, lookAt.z);\r\n        \r\n        vec3 rayDir = camera(eye, lookAt) * normalize(vec3(uv,-1));// ray direction\r\n        \r\n        Surface co = rayMarch(eye, rayDir, MIN_DIST, MAX_DIST);// closest object\r\n        \r\n        if(co.sd > MAX_DIST){\r\n            col = backgroundColor;  // ray didn't hit anything\r\n        }\r\n        else{\r\n            vec3 p = eye + rayDir*co.sd;  // point from ray marching\r\n            vec3 normal = calcNormal(p);\r\n            \r\n            col = lighting(p, normal, eye, co.mat);\r\n        }\r\n        \r\n        gl_FragColor = vec4(col, 1.0);\r\n        return;\r\n    }\r\n  `;\r\n};\r\n"],"mappings":"AAAA,SAASA,SAAT,QAA0B,aAA1B;AAEA,OAAO,IAAMC,EAAE,GAAG,SAALA,EAAK,CAACC,GAAD,EAAMC,UAAN,EAAqB;EACnC,0lDA0EEH,SAAS,EA1EX,mBA2EEG,UA3EF,kLAoFMD,GApFN;AA6MH,CA9MM"},"metadata":{},"sourceType":"module"}