{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Node represents a node in an abstract syntax tree. Nodes have the following properties:\n *  - A type, which determines how it is evaluated;\n *  - A value, such as a number or function; and\n *  - An ordered list of children.\n */\n\n\nvar Node = function () {\n  function Node(type) {\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n\n    _classCallCheck(this, Node);\n\n    this.type = type;\n    this.value = value;\n    this.name = null; // Used in function and command nodes to retain the fn name when minified\n\n    this.children = [];\n  }\n  /**\n   * Adds a node to the list of children and returns this Node.\n   * @param node Child node to addChild.\n   * @returns {Node} This node.\n   */\n\n\n  _createClass(Node, [{\n    key: \"addChild\",\n    value: function addChild(node) {\n      this.children.push(node);\n      return this;\n    }\n    /**\n     * Returns this Node's first child.\n     */\n\n  }, {\n    key: \"evaluate\",\n\n    /**\n     * Evaluates this Node and all child nodes recursively, returning the numerical result of this Node.\n     */\n    value: function evaluate(vars) {\n      var result = 0;\n\n      switch (this.type) {\n        case Node.TYPE_FUNCTION:\n          var evaluatedChildren = this.children.map(function (childNode) {\n            return childNode.evaluate(vars);\n          });\n          result = this.value.apply(this, evaluatedChildren);\n          break;\n\n        case Node.TYPE_INVERSE:\n          result = 1.0 / this.child.evaluate(vars);\n          break;\n\n        case Node.TYPE_NEGATE:\n          result = -this.child.evaluate(vars);\n          break;\n\n        case Node.TYPE_NUMBER:\n          result = this.value;\n          break;\n\n        case Node.TYPE_POWER:\n          result = Math.pow(this.children[0].evaluate(vars), this.children[1].evaluate(vars));\n          break;\n\n        case Node.TYPE_PRODUCT:\n          result = this.children.reduce(function (product, child) {\n            return product * child.evaluate(vars);\n          }, 1);\n          break;\n\n        case Node.TYPE_SUM:\n          result = this.children.reduce(function (sum, child) {\n            return sum + child.evaluate(vars);\n          }, 0);\n          break;\n\n        case Node.TYPE_SYMBOL:\n          if (isFinite(vars[this.value])) {\n            return vars[this.value];\n          }\n\n          throw new Error(\"Symbol \" + this.value + \" is undefined or not a number\");\n      }\n\n      return result;\n    }\n    /**\n     * Determines whether this Node is unary, i.e., whether it can have only one child.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isUnary\",\n    value: function isUnary() {\n      return UNARY_NODES.indexOf(this.type) >= 0;\n    }\n  }, {\n    key: \"printTree\",\n\n    /**\n     * Prints a tree-like representation of this Node and all child Nodes to the console.\n     * Useful for debugging parser problems.\n     * If printTree() is called on the root node, it prints the whole AST!\n     * @param level (Integer, Optional) Initial level of indentation. You shouldn't need to use this.\n     */\n    value: function printTree() {\n      var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; // Generate the indent string from the current `level`.\n      // Child nodes will have a greater `level` and will appear indented.\n\n      var indent = \"\";\n      var indentString = \"  \";\n\n      for (var i = 0; i < level; i++) {\n        indent += indentString;\n      }\n\n      console.log(indent + this.toString()); // Print each child.\n\n      for (var _i in this.children) {\n        this.children[_i].printTree(level + 1);\n      }\n    }\n  }, {\n    key: \"simplify\",\n    value: function simplify() {\n      if (this.children.length > 1 || this.isUnary()) {\n        // Node can't be simplified.\n        // Clone this Node and simplify its children.\n        var newNode = new Node(this.type, this.value);\n\n        for (var i in this.children) {\n          newNode.addChild(this.children[i].simplify());\n        }\n\n        return newNode;\n      } else if (this.children.length === 1) {\n        // A non-unary node with no children has no function.\n        return this.children[0].simplify();\n      } else {\n        // A node with no children is a terminal.\n        return this;\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var val = typeof this.value === \"function\" ? this.name : this.value;\n      return this.children.length + \" \" + this.type + \" [\" + val + \"]\";\n    }\n  }, {\n    key: \"child\",\n    get: function get() {\n      return this.children[0];\n    }\n  }, {\n    key: \"nodeCount\",\n    get: function get() {\n      var count = 1;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var i = _step.value;\n          count += i.nodeCount;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return count;\n    }\n  }]);\n\n  return Node;\n}();\n\nNode.TYPE_FUNCTION = \"FUNCTION\";\nNode.TYPE_INVERSE = \"INVERSE\";\nNode.TYPE_NEGATE = \"NEGATE\";\nNode.TYPE_NUMBER = \"NUMBER\";\nNode.TYPE_POWER = \"POWER\";\nNode.TYPE_PRODUCT = \"PRODUCT\";\nNode.TYPE_SUM = \"SUM\";\nNode.TYPE_SYMBOL = \"SYMBOL\";\nexports.default = Node;\nvar UNARY_NODES = [\"FACTORIAL\", \"FUNCTION\", \"INVERSE\", \"NEGATE\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","Node","type","arguments","undefined","name","children","addChild","node","push","evaluate","vars","result","TYPE_FUNCTION","evaluatedChildren","map","childNode","apply","TYPE_INVERSE","child","TYPE_NEGATE","TYPE_NUMBER","TYPE_POWER","Math","pow","TYPE_PRODUCT","reduce","product","TYPE_SUM","sum","TYPE_SYMBOL","isFinite","Error","isUnary","UNARY_NODES","indexOf","printTree","level","indent","indentString","console","log","toString","_i","simplify","newNode","val","get","count","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","next","done","nodeCount","err","return","default"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/evaluatex/dist/Node.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Node represents a node in an abstract syntax tree. Nodes have the following properties:\n *  - A type, which determines how it is evaluated;\n *  - A value, such as a number or function; and\n *  - An ordered list of children.\n */\nvar Node = function () {\n    function Node(type) {\n        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n\n        _classCallCheck(this, Node);\n\n        this.type = type;\n        this.value = value;\n        this.name = null; // Used in function and command nodes to retain the fn name when minified\n        this.children = [];\n    }\n\n    /**\n     * Adds a node to the list of children and returns this Node.\n     * @param node Child node to addChild.\n     * @returns {Node} This node.\n     */\n\n\n    _createClass(Node, [{\n        key: \"addChild\",\n        value: function addChild(node) {\n            this.children.push(node);\n            return this;\n        }\n\n        /**\n         * Returns this Node's first child.\n         */\n\n    }, {\n        key: \"evaluate\",\n\n\n        /**\n         * Evaluates this Node and all child nodes recursively, returning the numerical result of this Node.\n         */\n        value: function evaluate(vars) {\n            var result = 0;\n\n            switch (this.type) {\n                case Node.TYPE_FUNCTION:\n                    var evaluatedChildren = this.children.map(function (childNode) {\n                        return childNode.evaluate(vars);\n                    });\n                    result = this.value.apply(this, evaluatedChildren);\n                    break;\n                case Node.TYPE_INVERSE:\n                    result = 1.0 / this.child.evaluate(vars);\n                    break;\n                case Node.TYPE_NEGATE:\n                    result = -this.child.evaluate(vars);\n                    break;\n                case Node.TYPE_NUMBER:\n                    result = this.value;\n                    break;\n                case Node.TYPE_POWER:\n                    result = Math.pow(this.children[0].evaluate(vars), this.children[1].evaluate(vars));\n                    break;\n                case Node.TYPE_PRODUCT:\n                    result = this.children.reduce(function (product, child) {\n                        return product * child.evaluate(vars);\n                    }, 1);\n                    break;\n                case Node.TYPE_SUM:\n                    result = this.children.reduce(function (sum, child) {\n                        return sum + child.evaluate(vars);\n                    }, 0);\n                    break;\n                case Node.TYPE_SYMBOL:\n                    if (isFinite(vars[this.value])) {\n                        return vars[this.value];\n                    }\n                    throw new Error(\"Symbol \" + this.value + \" is undefined or not a number\");\n            }\n\n            return result;\n        }\n\n        /**\n         * Determines whether this Node is unary, i.e., whether it can have only one child.\n         * @returns {boolean}\n         */\n\n    }, {\n        key: \"isUnary\",\n        value: function isUnary() {\n            return UNARY_NODES.indexOf(this.type) >= 0;\n        }\n    }, {\n        key: \"printTree\",\n\n\n        /**\n         * Prints a tree-like representation of this Node and all child Nodes to the console.\n         * Useful for debugging parser problems.\n         * If printTree() is called on the root node, it prints the whole AST!\n         * @param level (Integer, Optional) Initial level of indentation. You shouldn't need to use this.\n         */\n        value: function printTree() {\n            var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            // Generate the indent string from the current `level`.\n            // Child nodes will have a greater `level` and will appear indented.\n            var indent = \"\";\n            var indentString = \"  \";\n            for (var i = 0; i < level; i++) {\n                indent += indentString;\n            }\n\n            console.log(indent + this.toString());\n\n            // Print each child.\n            for (var _i in this.children) {\n                this.children[_i].printTree(level + 1);\n            }\n        }\n    }, {\n        key: \"simplify\",\n        value: function simplify() {\n            if (this.children.length > 1 || this.isUnary()) {\n                // Node can't be simplified.\n                // Clone this Node and simplify its children.\n                var newNode = new Node(this.type, this.value);\n                for (var i in this.children) {\n                    newNode.addChild(this.children[i].simplify());\n                }\n                return newNode;\n            } else if (this.children.length === 1) {\n                // A non-unary node with no children has no function.\n                return this.children[0].simplify();\n            } else {\n                // A node with no children is a terminal.\n                return this;\n            }\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            var val = typeof this.value === \"function\" ? this.name : this.value;\n            return this.children.length + \" \" + this.type + \" [\" + val + \"]\";\n        }\n    }, {\n        key: \"child\",\n        get: function get() {\n            return this.children[0];\n        }\n    }, {\n        key: \"nodeCount\",\n        get: function get() {\n            var count = 1;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var i = _step.value;\n\n                    count += i.nodeCount;\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return count;\n        }\n    }]);\n\n    return Node;\n}();\n\nNode.TYPE_FUNCTION = \"FUNCTION\";\nNode.TYPE_INVERSE = \"INVERSE\";\nNode.TYPE_NEGATE = \"NEGATE\";\nNode.TYPE_NUMBER = \"NUMBER\";\nNode.TYPE_POWER = \"POWER\";\nNode.TYPE_PRODUCT = \"PRODUCT\";\nNode.TYPE_SUM = \"SUM\";\nNode.TYPE_SYMBOL = \"SYMBOL\";\nexports.default = Node;\n\n\nvar UNARY_NODES = [\"FACTORIAL\", \"FUNCTION\", \"INVERSE\", \"NEGATE\"];"],"mappings":"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"},"metadata":{},"sourceType":"script"}