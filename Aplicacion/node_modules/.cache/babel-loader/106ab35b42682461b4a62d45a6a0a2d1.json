{"ast":null,"code":"export var fs = function fs(sdf) {\n  return \"\\n    /*\\n    Written by Alan Wolfe\\n    http://demofox.org/\\n    http://blog.demofox.org/\\n  \\n    My blog post talking about the techniques in this shadertoy:\\n    http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\\n  */\\n  \\n  // A great read on all this stuff:\\n  // https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\\n  \\n  // refractive index of some common materials:\\n  // http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\\n  #define REFRACTIVE_INDEX_OUTSIDE 1.00029\\n  #define REFRACTIVE_INDEX_INSIDE  1.125\\n  \\n  // lighting parameters\\n  #define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\\n  #define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\\n  #define LIGHT_AMBIENT           vec3(0.1)\\n  \\n  // object type\\n  #define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\\n  \\n  // object color parameters\\n  #define OBJECT_DIFFUSE      vec3(0.0)\\n  #define OBJECT_SPECPOWER    0.0\\n  #define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\\n  #define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\\n  \\n  // object surface parameters\\n  #define DO_REFRACTION 1  // 0 to turn off refraction\\n  #define DO_REFLECTION 1  // 0 to turn off reflection\\n  #define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\\n  \\n  // rendering params\\n  #define DO_AA           1  // 0 to turn off 16x jittered SSAA\\n  #define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\\n  \\n  // hash21 from https://www.shadertoy.com/view/4djSRW\\n  #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\\n  //----------------------------------------------------------------------------------------\\n  //  2 out, 1 in...\\n  vec2 hash21(float p)\\n  {\\n      vec3 p3 = fract(vec3(p) * HASHSCALE3);\\n      p3 += dot(p3, p3.yzx + 19.19);\\n      return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\\n  }\\n  \\n  //============================================================\\n  // this is ibox() from https://www.shadertoy.com/view/ld23DV\\n  // Just renamed some things to be more clear and minimized to needed functionality\\n  // returns t and normal\\n  vec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \\n  {\\n      // ray-box intersection\\n      vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\\n      vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\\n      vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\\n      \\n      vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\\n      vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\\n  \\n      float timeNear = max( max( t1.x, t1.y ), t1.z );\\n      float timeFar = min( min( t2.x, t2.y ), t2.z );\\n  \\n      if( timeNear > timeFar || timeFar < 0.0)\\n          return vec4(-1.0);\\n  \\n      //vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n      \\n      if (timeNear < 0.0)\\n          timeNear = timeFar;\\n      \\n      vec3 relPoint = rayOrigin + rayDirection * timeNear;\\n      \\n      vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\\n      \\n      vec3 normal;\\n      vec3 uaxis;\\n      vec3 vaxis;\\n      // if Y isn't the biggest value it can't be the normal axis\\n      if (absRelPoint.x >= absRelPoint.y)\\n      {\\n          // if X is the winner\\n          if (absRelPoint.x >= absRelPoint.z)\\n          {\\n              normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\\n              uaxis = vec3(0.0,1.0,0.0);\\n              vaxis = vec3(0.0,0.0,1.0);            \\n          }\\n          // else it's Z\\n          else\\n          {\\n              normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\\n              uaxis = vec3(1.0,0.0,0.0);\\n              vaxis = vec3(0.0,1.0,0.0);            \\n          }\\n      }\\n      // else X isn't the biggest value so it can't be the normal axis\\n      else\\n      {\\n          // if Y is the winner\\n          if (absRelPoint.y >= absRelPoint.z)\\n          {\\n              normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\\n              uaxis = vec3(1.0,0.0,0.0);\\n              vaxis = vec3(0.0,0.0,1.0);\\t           \\n          }\\n          // else it's Z\\n          else\\n          {\\n              normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\\n              uaxis = vec3(1.0,0.0,0.0);\\n              vaxis = vec3(0.0,1.0,0.0);            \\n          }        \\n      }\\n      \\n      uv = vec2\\n      (\\n          dot(relPoint, uaxis),\\n          dot(relPoint, vaxis)\\n      );    \\n  \\n      return vec4( timeNear, normal );    \\n  }\\n  \\n  //============================================================\\n  // returns t and surface normal\\n  // sphere xyz = position, w = radius\\n  vec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\\n  {\\n      //get the vector from the center of this circle to where the ray begins.\\n      vec3 m = rayPos - sphere.xyz;\\n  \\n      //get the dot product of the above vector and the ray's vector\\n      float b = dot(m, rayDir);\\n  \\n      float c = dot(m, m) - sphere.w * sphere.w;\\n  \\n      //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\\n      if(c > 0.0 && b > 0.0)\\n          return vec4(-1.0);\\n  \\n      //calculate discriminant\\n      float discr = b * b - c;\\n  \\n      //a negative discriminant corresponds to ray missing sphere\\n      if(discr < 0.0)\\n          return vec4(-1.0);\\n  \\n      //ray now found to intersect sphere, compute smallest t value of intersection\\n      float normalMultiplier = 1.0;\\n      float collisionTime = -b - sqrt(discr);\\n      if (collisionTime < 0.0)\\n      {\\n          collisionTime = -b + sqrt(discr);\\n          normalMultiplier = -1.0;\\n      }\\n      \\n      // calculate the normal, flipping it if we hit the inside of the sphere\\n      vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\\n      \\n      // return the time t that the collision happened, as well as the surface normal\\n      return vec4 (collisionTime, normal);\\n  }\\n  \\n  //============================================================\\n  // returns t and surface normal\\n  // plane xyz = normal, w = d\\n  // from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\\n  vec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\\n  {   \\n      float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\\n      vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\\n      vec3 vaxis = normalize(cross(plane.xyz, uaxis));\\n      vec3 collisionPos = rayPos + rayDir * collisionTime;\\n      uv.x = dot(collisionPos, uaxis);\\n      uv.y = dot(collisionPos, vaxis);    \\n      return vec4(collisionTime, plane.xyz);\\n  }\\n  \\n  //============================================================\\n  void TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\\n  {\\n      vec2 uv;\\n      vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \\n      if (dot(rayInfo.yzw, rayDir) < 0.0)\\n      {\\n          if (rayInfo.x > rayMinMax.x)\\n          {\\n              rayMinMax.x = rayInfo.x;\\n              nearNormal = rayInfo.yzw;\\n          }\\n      }\\n      else\\n      {\\n          if (rayInfo.x < rayMinMax.y)\\n          {\\n              rayMinMax.y = rayInfo.x;\\n              farNormal = rayInfo.yzw;\\n          }\\n      }\\n  }\\n  \\n  //============================================================\\n  vec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\\n  {\\n      #if OBJECT_TYPE == 0\\n          return RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\\n      #elif OBJECT_TYPE == 1\\n          vec2 uv;\\n          vec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\\n          if (dot(rayDir, ret.yzw) > 0.0)\\n              ret.yzw *= -1.0;\\n          return ret;\\n      #else\\n          vec2 rayMinMax = vec2(-1.0, 1000.0);\\n          vec3 nearNormal;\\n          vec3 farNormal;\\n      \\n          float size = -0.5;\\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \\n  \\n          if (rayMinMax.x > rayMinMax.y)\\n              return vec4(-1.0);\\n      \\n          if (rayMinMax.x > 0.0)\\n              return vec4(rayMinMax.x, nearNormal);\\n          else\\n              return vec4(rayMinMax.y, -farNormal);\\n      #endif\\n  }\\n  \\n  //============================================================\\n  vec3 Checkerboard (vec2 uv)\\n  {\\n      return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\\n  }\\n  \\n  //============================================================\\n  vec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\\n  {   \\n      // ambient\\n      vec3 pixelColor = diffuse * LIGHT_AMBIENT;\\n      \\n      // see if we are in shadow by casting in the light direction and seeing if we hit the object.\\n      // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\\n      if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\\n          return pixelColor;\\n      \\n      // diffuse\\n      float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\\n      pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\\n      \\n      // specular highlight\\n      if (specPower > 0.0)\\n      {\\n          vec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\\n          dp = clamp(dot(rayDir, reflection), 0.0, 1.0);\\n          pixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \\n      }\\n      \\n      return pixelColor;\\n  }\\n  \\n  //============================================================\\n  float FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\\n  {\\n      #if DO_FRESNEL\\n          // Schlick aproximation\\n          float r0 = (n1-n2) / (n1+n2);\\n          r0 *= r0;\\n          float cosX = -dot(normal, incident);\\n          if (n1 > n2)\\n          {\\n              float n = n1/n2;\\n              float sinT2 = n*n*(1.0-cosX*cosX);\\n              // Total internal reflection\\n              if (sinT2 > 1.0)\\n                  return 1.0;\\n              cosX = sqrt(1.0-sinT2);\\n          }\\n          float x = 1.0-cosX;\\n          float ret = r0+(1.0-r0)*x*x*x*x*x;\\n  \\n          // adjust reflect multiplier for object reflectivity\\n          ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\\n          return ret;\\n      #else\\n          return OBJECT_REFLECTIVITY;\\n      #endif\\n  }\\n  \\n  //============================================================\\n  vec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\\n  {\\n      // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\\n      // Used for reflection off the surface of the object, and refraction out the back of the object.\\n      \\n      // if we hit the box, return the lit box color\\n      vec2 uv;\\n      vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\\n      if (rayInfo.x >= 0.0)\\n          return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\\n      // else return skybox color\\n      else\\n          return texture(iChannel0, rayDir).rgb;\\n  }\\n  \\n  //============================================================\\n  vec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\\n  {\\n      // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\\n      float multiplier = 1.0;\\n      vec3 ret = vec3(0.0);\\n      float absorbDistance = 0.0;\\n      for (int i = 0; i < MAX_RAY_BOUNCES; ++i)\\n      {\\n          // try and intersect the object\\n          vec4 rayInfo = RayIntersectObject(rayPos, rayDir);\\n          \\n          // should \\\"never\\\" happen but handle it anyways\\n          if (rayInfo.x < 0.0)  \\n              return ret;\\n          \\n          // move the ray position to the intersection point.\\n          rayPos = rayPos + rayDir * rayInfo.x;\\n          \\n          // calculate beer's law absorption.\\n          absorbDistance += rayInfo.x;    \\n          vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\\n          \\n          // calculate how much to reflect or transmit (refract or diffuse)\\n          float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\\n          float refractMultiplier = 1.0 - reflectMultiplier;\\n          \\n          // add in refraction outside of the object\\n          vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\\n          ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\\n          \\n          // add specular highlight based on refracted ray direction\\n          ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \\n          \\n          // follow the ray down the internal reflection path.\\n          rayDir = reflect(rayDir, rayInfo.yzw);\\n          \\n          // move the ray slightly down the reflect path\\n          rayPos += rayDir * 0.001;\\n          \\n          // For reflection, we are only going to be reflecting what is refracted on further bounces.\\n          // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\\n          multiplier *= reflectMultiplier;        \\n      }\\n      \\n      // return the color we calculated\\n      return ret;\\n  }\\n  \\n  //============================================================\\n  vec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\\n  {   \\n      vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\\n      vec3 rayHitDiffuse = vec3(1.0);\\n      vec3 additiveColor = vec3(0.0);\\n      \\n      vec3 ret = vec3(0.0);\\n             \\n      // see if we've hit the platform and remember if we have\\n      vec2 uv;    \\n      vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\\n      if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\\n      {\\n          bestRayHitInfo = rayInfo;\\n          rayHitDiffuse = Checkerboard(uv);\\n      }\\n      \\n      // if we've hit the main object, and it's closer than the platform\\n      rayInfo = RayIntersectObject(rayPos, rayDir);\\n      if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\\n      {       \\n          // light the surface of the ball a bit\\n          additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\\n          \\n          // move the ray to the intersection point\\n          rayPos += rayDir * rayInfo.x;    \\n          \\n          // calculate how much to reflect or transmit (refract or diffuse)\\n          float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\\n          float refractMultiplier = 1.0 - reflectMultiplier;\\n          \\n          // get reflection color\\n          #if DO_REFLECTION\\n              vec3 reflectDir = reflect(rayDir, rayInfo.yzw);\\n              ret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\\n          #endif\\n          \\n          // get refraction color\\n          #if DO_REFRACTION\\n              vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\\n              ret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\\n          #endif\\n          \\n          return ret + additiveColor;\\n      }\\n      // else we missed the object, so return either the skybox color, or the platform color, as appropriate\\n      else\\n      {\\n          if (bestRayHitInfo.x == 1000.0)    \\n              return texture(iChannel0, rayDir).rgb;\\n          else\\n          {\\n              // move the ray to the intersection point (so we can shadow) and light the pixel\\n              rayPos += rayDir * bestRayHitInfo.x;    \\n              return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \\n          }\\n      }\\n  }\\n  \\n  //============================================================\\n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\\n  {        \\n      //----- Camera Setup\\n      vec2 mouse = iMouse.xy / iResolution.xy;\\n  \\n      vec3 cameraAt \\t= vec3(0.0);\\n  \\n      float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\\n      float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\\n      vec3 cameraPos\\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\\n  \\n      vec3 cameraFwd  = normalize(cameraAt - cameraPos);\\n      vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\\n      vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\\n  \\n      float cameraViewWidth\\t= 6.0;\\n      float cameraViewHeight\\t= cameraViewWidth * iResolution.y / iResolution.x;\\n      float cameraDistance\\t= 6.0;  // intuitively backwards!\\n  \\n      //----- Ray Setup\\n      vec2 rawPercent = (fragCoord.xy / iResolution.xy); \\n      vec2 percent = rawPercent - vec2(0.5,0.5);\\n  \\n      vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\\n          - (cameraLeft * percent.x * cameraViewWidth)\\n          + (cameraUp * percent.y * cameraViewHeight);\\n      vec3 rayDir = normalize(rayTarget);    \\n  \\n      //----- Ray Trace\\n      vec3 finalColor = vec3(0.0);\\n      #if DO_AA\\n          for (int i = 1; i <= 16; ++i)\\n          {\\n              // calculate stratified subpixel jitter in a 4x4 grid\\n              float x = mod(float(i)-1.0, 4.0);\\n              float y = mod(floor(float(i) / 4.0), 4.0);\\n              vec2 jitter = hash21(float(i)) / 4.0;\\n              jitter.x += x / 4.0;\\n              jitter.y += y / 4.0;\\n              \\n              // set up the jittered ray\\n              rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \\n              percent = rawPercent - vec2(0.5,0.5);\\n  \\n              rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\\n                  - (cameraLeft * percent.x * cameraViewWidth)\\n                  + (cameraUp * percent.y * cameraViewHeight);\\n              rayDir = normalize(rayTarget);                \\n             \\n              // raytrace\\n              vec3 color = RayTracePixelColor(cameraPos, rayDir);\\n              \\n              // incrementally average our pixel color in\\n              finalColor = mix(finalColor, color, 1.0 / float(i));            \\n          }\\n      #else\\n             finalColor = RayTracePixelColor(cameraPos, rayDir);\\n      #endif\\n      \\n      //----- Final color, gamma corrected\\n      fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \\n  }\\n  \\n  \\n  \";\n};","map":{"version":3,"names":["fs","sdf"],"sources":["C:/Users/daniz/TFG/Aplicacion/src/fragmentShaderMovable.js"],"sourcesContent":["export const fs = (sdf) => {\r\n    return `\r\n    /*\r\n    Written by Alan Wolfe\r\n    http://demofox.org/\r\n    http://blog.demofox.org/\r\n  \r\n    My blog post talking about the techniques in this shadertoy:\r\n    http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\r\n  */\r\n  \r\n  // A great read on all this stuff:\r\n  // https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\r\n  \r\n  // refractive index of some common materials:\r\n  // http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\r\n  #define REFRACTIVE_INDEX_OUTSIDE 1.00029\r\n  #define REFRACTIVE_INDEX_INSIDE  1.125\r\n  \r\n  // lighting parameters\r\n  #define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\r\n  #define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\r\n  #define LIGHT_AMBIENT           vec3(0.1)\r\n  \r\n  // object type\r\n  #define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\r\n  \r\n  // object color parameters\r\n  #define OBJECT_DIFFUSE      vec3(0.0)\r\n  #define OBJECT_SPECPOWER    0.0\r\n  #define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\r\n  #define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\r\n  \r\n  // object surface parameters\r\n  #define DO_REFRACTION 1  // 0 to turn off refraction\r\n  #define DO_REFLECTION 1  // 0 to turn off reflection\r\n  #define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\r\n  \r\n  // rendering params\r\n  #define DO_AA           1  // 0 to turn off 16x jittered SSAA\r\n  #define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\r\n  \r\n  // hash21 from https://www.shadertoy.com/view/4djSRW\r\n  #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n  //----------------------------------------------------------------------------------------\r\n  //  2 out, 1 in...\r\n  vec2 hash21(float p)\r\n  {\r\n      vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n      p3 += dot(p3, p3.yzx + 19.19);\r\n      return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\r\n  }\r\n  \r\n  //============================================================\r\n  // this is ibox() from https://www.shadertoy.com/view/ld23DV\r\n  // Just renamed some things to be more clear and minimized to needed functionality\r\n  // returns t and normal\r\n  vec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \r\n  {\r\n      // ray-box intersection\r\n      vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\r\n      vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\r\n      vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\r\n      \r\n      vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\r\n      vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\r\n  \r\n      float timeNear = max( max( t1.x, t1.y ), t1.z );\r\n      float timeFar = min( min( t2.x, t2.y ), t2.z );\r\n  \r\n      if( timeNear > timeFar || timeFar < 0.0)\r\n          return vec4(-1.0);\r\n  \r\n      //vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\r\n      \r\n      if (timeNear < 0.0)\r\n          timeNear = timeFar;\r\n      \r\n      vec3 relPoint = rayOrigin + rayDirection * timeNear;\r\n      \r\n      vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\r\n      \r\n      vec3 normal;\r\n      vec3 uaxis;\r\n      vec3 vaxis;\r\n      // if Y isn't the biggest value it can't be the normal axis\r\n      if (absRelPoint.x >= absRelPoint.y)\r\n      {\r\n          // if X is the winner\r\n          if (absRelPoint.x >= absRelPoint.z)\r\n          {\r\n              normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\r\n              uaxis = vec3(0.0,1.0,0.0);\r\n              vaxis = vec3(0.0,0.0,1.0);            \r\n          }\r\n          // else it's Z\r\n          else\r\n          {\r\n              normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\r\n              uaxis = vec3(1.0,0.0,0.0);\r\n              vaxis = vec3(0.0,1.0,0.0);            \r\n          }\r\n      }\r\n      // else X isn't the biggest value so it can't be the normal axis\r\n      else\r\n      {\r\n          // if Y is the winner\r\n          if (absRelPoint.y >= absRelPoint.z)\r\n          {\r\n              normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\r\n              uaxis = vec3(1.0,0.0,0.0);\r\n              vaxis = vec3(0.0,0.0,1.0);\t           \r\n          }\r\n          // else it's Z\r\n          else\r\n          {\r\n              normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\r\n              uaxis = vec3(1.0,0.0,0.0);\r\n              vaxis = vec3(0.0,1.0,0.0);            \r\n          }        \r\n      }\r\n      \r\n      uv = vec2\r\n      (\r\n          dot(relPoint, uaxis),\r\n          dot(relPoint, vaxis)\r\n      );    \r\n  \r\n      return vec4( timeNear, normal );    \r\n  }\r\n  \r\n  //============================================================\r\n  // returns t and surface normal\r\n  // sphere xyz = position, w = radius\r\n  vec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\r\n  {\r\n      //get the vector from the center of this circle to where the ray begins.\r\n      vec3 m = rayPos - sphere.xyz;\r\n  \r\n      //get the dot product of the above vector and the ray's vector\r\n      float b = dot(m, rayDir);\r\n  \r\n      float c = dot(m, m) - sphere.w * sphere.w;\r\n  \r\n      //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\r\n      if(c > 0.0 && b > 0.0)\r\n          return vec4(-1.0);\r\n  \r\n      //calculate discriminant\r\n      float discr = b * b - c;\r\n  \r\n      //a negative discriminant corresponds to ray missing sphere\r\n      if(discr < 0.0)\r\n          return vec4(-1.0);\r\n  \r\n      //ray now found to intersect sphere, compute smallest t value of intersection\r\n      float normalMultiplier = 1.0;\r\n      float collisionTime = -b - sqrt(discr);\r\n      if (collisionTime < 0.0)\r\n      {\r\n          collisionTime = -b + sqrt(discr);\r\n          normalMultiplier = -1.0;\r\n      }\r\n      \r\n      // calculate the normal, flipping it if we hit the inside of the sphere\r\n      vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\r\n      \r\n      // return the time t that the collision happened, as well as the surface normal\r\n      return vec4 (collisionTime, normal);\r\n  }\r\n  \r\n  //============================================================\r\n  // returns t and surface normal\r\n  // plane xyz = normal, w = d\r\n  // from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\r\n  vec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\r\n  {   \r\n      float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\r\n      vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\r\n      vec3 vaxis = normalize(cross(plane.xyz, uaxis));\r\n      vec3 collisionPos = rayPos + rayDir * collisionTime;\r\n      uv.x = dot(collisionPos, uaxis);\r\n      uv.y = dot(collisionPos, vaxis);    \r\n      return vec4(collisionTime, plane.xyz);\r\n  }\r\n  \r\n  //============================================================\r\n  void TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\r\n  {\r\n      vec2 uv;\r\n      vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \r\n      if (dot(rayInfo.yzw, rayDir) < 0.0)\r\n      {\r\n          if (rayInfo.x > rayMinMax.x)\r\n          {\r\n              rayMinMax.x = rayInfo.x;\r\n              nearNormal = rayInfo.yzw;\r\n          }\r\n      }\r\n      else\r\n      {\r\n          if (rayInfo.x < rayMinMax.y)\r\n          {\r\n              rayMinMax.y = rayInfo.x;\r\n              farNormal = rayInfo.yzw;\r\n          }\r\n      }\r\n  }\r\n  \r\n  //============================================================\r\n  vec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\r\n  {\r\n      #if OBJECT_TYPE == 0\r\n          return RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\r\n      #elif OBJECT_TYPE == 1\r\n          vec2 uv;\r\n          vec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\r\n          if (dot(rayDir, ret.yzw) > 0.0)\r\n              ret.yzw *= -1.0;\r\n          return ret;\r\n      #else\r\n          vec2 rayMinMax = vec2(-1.0, 1000.0);\r\n          vec3 nearNormal;\r\n          vec3 farNormal;\r\n      \r\n          float size = -0.5;\r\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\r\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \r\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\r\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \r\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\r\n          TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \r\n  \r\n          if (rayMinMax.x > rayMinMax.y)\r\n              return vec4(-1.0);\r\n      \r\n          if (rayMinMax.x > 0.0)\r\n              return vec4(rayMinMax.x, nearNormal);\r\n          else\r\n              return vec4(rayMinMax.y, -farNormal);\r\n      #endif\r\n  }\r\n  \r\n  //============================================================\r\n  vec3 Checkerboard (vec2 uv)\r\n  {\r\n      return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\r\n  }\r\n  \r\n  //============================================================\r\n  vec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\r\n  {   \r\n      // ambient\r\n      vec3 pixelColor = diffuse * LIGHT_AMBIENT;\r\n      \r\n      // see if we are in shadow by casting in the light direction and seeing if we hit the object.\r\n      // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\r\n      if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\r\n          return pixelColor;\r\n      \r\n      // diffuse\r\n      float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\r\n      pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\r\n      \r\n      // specular highlight\r\n      if (specPower > 0.0)\r\n      {\r\n          vec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\r\n          dp = clamp(dot(rayDir, reflection), 0.0, 1.0);\r\n          pixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \r\n      }\r\n      \r\n      return pixelColor;\r\n  }\r\n  \r\n  //============================================================\r\n  float FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\r\n  {\r\n      #if DO_FRESNEL\r\n          // Schlick aproximation\r\n          float r0 = (n1-n2) / (n1+n2);\r\n          r0 *= r0;\r\n          float cosX = -dot(normal, incident);\r\n          if (n1 > n2)\r\n          {\r\n              float n = n1/n2;\r\n              float sinT2 = n*n*(1.0-cosX*cosX);\r\n              // Total internal reflection\r\n              if (sinT2 > 1.0)\r\n                  return 1.0;\r\n              cosX = sqrt(1.0-sinT2);\r\n          }\r\n          float x = 1.0-cosX;\r\n          float ret = r0+(1.0-r0)*x*x*x*x*x;\r\n  \r\n          // adjust reflect multiplier for object reflectivity\r\n          ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\r\n          return ret;\r\n      #else\r\n          return OBJECT_REFLECTIVITY;\r\n      #endif\r\n  }\r\n  \r\n  //============================================================\r\n  vec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\r\n  {\r\n      // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\r\n      // Used for reflection off the surface of the object, and refraction out the back of the object.\r\n      \r\n      // if we hit the box, return the lit box color\r\n      vec2 uv;\r\n      vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\r\n      if (rayInfo.x >= 0.0)\r\n          return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\r\n      // else return skybox color\r\n      else\r\n          return texture(iChannel0, rayDir).rgb;\r\n  }\r\n  \r\n  //============================================================\r\n  vec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\r\n  {\r\n      // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\r\n      float multiplier = 1.0;\r\n      vec3 ret = vec3(0.0);\r\n      float absorbDistance = 0.0;\r\n      for (int i = 0; i < MAX_RAY_BOUNCES; ++i)\r\n      {\r\n          // try and intersect the object\r\n          vec4 rayInfo = RayIntersectObject(rayPos, rayDir);\r\n          \r\n          // should \"never\" happen but handle it anyways\r\n          if (rayInfo.x < 0.0)  \r\n              return ret;\r\n          \r\n          // move the ray position to the intersection point.\r\n          rayPos = rayPos + rayDir * rayInfo.x;\r\n          \r\n          // calculate beer's law absorption.\r\n          absorbDistance += rayInfo.x;    \r\n          vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\r\n          \r\n          // calculate how much to reflect or transmit (refract or diffuse)\r\n          float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\r\n          float refractMultiplier = 1.0 - reflectMultiplier;\r\n          \r\n          // add in refraction outside of the object\r\n          vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\r\n          ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\r\n          \r\n          // add specular highlight based on refracted ray direction\r\n          ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \r\n          \r\n          // follow the ray down the internal reflection path.\r\n          rayDir = reflect(rayDir, rayInfo.yzw);\r\n          \r\n          // move the ray slightly down the reflect path\r\n          rayPos += rayDir * 0.001;\r\n          \r\n          // For reflection, we are only going to be reflecting what is refracted on further bounces.\r\n          // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\r\n          multiplier *= reflectMultiplier;        \r\n      }\r\n      \r\n      // return the color we calculated\r\n      return ret;\r\n  }\r\n  \r\n  //============================================================\r\n  vec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\r\n  {   \r\n      vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\r\n      vec3 rayHitDiffuse = vec3(1.0);\r\n      vec3 additiveColor = vec3(0.0);\r\n      \r\n      vec3 ret = vec3(0.0);\r\n             \r\n      // see if we've hit the platform and remember if we have\r\n      vec2 uv;    \r\n      vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\r\n      if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\r\n      {\r\n          bestRayHitInfo = rayInfo;\r\n          rayHitDiffuse = Checkerboard(uv);\r\n      }\r\n      \r\n      // if we've hit the main object, and it's closer than the platform\r\n      rayInfo = RayIntersectObject(rayPos, rayDir);\r\n      if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\r\n      {       \r\n          // light the surface of the ball a bit\r\n          additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\r\n          \r\n          // move the ray to the intersection point\r\n          rayPos += rayDir * rayInfo.x;    \r\n          \r\n          // calculate how much to reflect or transmit (refract or diffuse)\r\n          float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\r\n          float refractMultiplier = 1.0 - reflectMultiplier;\r\n          \r\n          // get reflection color\r\n          #if DO_REFLECTION\r\n              vec3 reflectDir = reflect(rayDir, rayInfo.yzw);\r\n              ret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\r\n          #endif\r\n          \r\n          // get refraction color\r\n          #if DO_REFRACTION\r\n              vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\r\n              ret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\r\n          #endif\r\n          \r\n          return ret + additiveColor;\r\n      }\r\n      // else we missed the object, so return either the skybox color, or the platform color, as appropriate\r\n      else\r\n      {\r\n          if (bestRayHitInfo.x == 1000.0)    \r\n              return texture(iChannel0, rayDir).rgb;\r\n          else\r\n          {\r\n              // move the ray to the intersection point (so we can shadow) and light the pixel\r\n              rayPos += rayDir * bestRayHitInfo.x;    \r\n              return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \r\n          }\r\n      }\r\n  }\r\n  \r\n  //============================================================\r\n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n  {        \r\n      //----- Camera Setup\r\n      vec2 mouse = iMouse.xy / iResolution.xy;\r\n  \r\n      vec3 cameraAt \t= vec3(0.0);\r\n  \r\n      float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\r\n      float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\r\n      vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\r\n  \r\n      vec3 cameraFwd  = normalize(cameraAt - cameraPos);\r\n      vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\r\n      vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\r\n  \r\n      float cameraViewWidth\t= 6.0;\r\n      float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\r\n      float cameraDistance\t= 6.0;  // intuitively backwards!\r\n  \r\n      //----- Ray Setup\r\n      vec2 rawPercent = (fragCoord.xy / iResolution.xy); \r\n      vec2 percent = rawPercent - vec2(0.5,0.5);\r\n  \r\n      vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\r\n          - (cameraLeft * percent.x * cameraViewWidth)\r\n          + (cameraUp * percent.y * cameraViewHeight);\r\n      vec3 rayDir = normalize(rayTarget);    \r\n  \r\n      //----- Ray Trace\r\n      vec3 finalColor = vec3(0.0);\r\n      #if DO_AA\r\n          for (int i = 1; i <= 16; ++i)\r\n          {\r\n              // calculate stratified subpixel jitter in a 4x4 grid\r\n              float x = mod(float(i)-1.0, 4.0);\r\n              float y = mod(floor(float(i) / 4.0), 4.0);\r\n              vec2 jitter = hash21(float(i)) / 4.0;\r\n              jitter.x += x / 4.0;\r\n              jitter.y += y / 4.0;\r\n              \r\n              // set up the jittered ray\r\n              rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \r\n              percent = rawPercent - vec2(0.5,0.5);\r\n  \r\n              rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\r\n                  - (cameraLeft * percent.x * cameraViewWidth)\r\n                  + (cameraUp * percent.y * cameraViewHeight);\r\n              rayDir = normalize(rayTarget);                \r\n             \r\n              // raytrace\r\n              vec3 color = RayTracePixelColor(cameraPos, rayDir);\r\n              \r\n              // incrementally average our pixel color in\r\n              finalColor = mix(finalColor, color, 1.0 / float(i));            \r\n          }\r\n      #else\r\n             finalColor = RayTracePixelColor(cameraPos, rayDir);\r\n      #endif\r\n      \r\n      //----- Final color, gamma corrected\r\n      fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \r\n  }\r\n  \r\n  \r\n  `;\r\n  };\r\n  "],"mappings":"AAAA,OAAO,IAAMA,EAAE,GAAG,SAALA,EAAK,CAACC,GAAD,EAAS;EACvB;AA6eD,CA9eI"},"metadata":{},"sourceType":"module"}