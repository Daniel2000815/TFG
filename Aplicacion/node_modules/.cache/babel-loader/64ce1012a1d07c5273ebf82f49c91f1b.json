{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar heyListen = require('hey-listen');\n\nvar utils = require('@motionone/utils');\n\nvar stagger = require('../utils/stagger.cjs.js');\n\nvar animateStyle = require('../animate/animate-style.cjs.js');\n\nvar controls = require('../animate/utils/controls.cjs.js');\n\nvar keyframes = require('../animate/utils/keyframes.cjs.js');\n\nvar options = require('../animate/utils/options.cjs.js');\n\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\n\nvar transforms = require('../animate/utils/transforms.cjs.js');\n\nvar calcTime = require('./utils/calc-time.cjs.js');\n\nvar edit = require('./utils/edit.cjs.js');\n\nvar sort = require('./utils/sort.cjs.js');\n\nfunction timeline(definition) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  var animationDefinitions = createAnimationsFromTimeline(definition, options);\n  /**\n   * Create and start animations\n   */\n\n  var animationFactories = animationDefinitions.map(function (definition) {\n    return animateStyle.animateStyle.apply(animateStyle, _toConsumableArray(definition));\n  }).filter(Boolean);\n  return controls.withControls(animationFactories, options, // Get the duration from the first animation definition\n  (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\n\nfunction createAnimationsFromTimeline(definition) {\n  var _a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a$defaultOptions = _a.defaultOptions,\n      defaultOptions = _a$defaultOptions === void 0 ? {} : _a$defaultOptions,\n      timelineOptions = tslib.__rest(_a, [\"defaultOptions\"]);\n\n  var animationDefinitions = [];\n  var elementSequences = new Map();\n  var elementCache = {};\n  var timeLabels = new Map();\n  var prevTime = 0;\n  var currentTime = 0;\n  var totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the definition array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n\n  for (var i = 0; i < definition.length; i++) {\n    var segment = definition[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n\n    if (utils.isString(segment)) {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcTime.calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n\n    var _segment = _slicedToArray(segment, 3),\n        elementDefinition = _segment[0],\n        keyframes$1 = _segment[1],\n        _segment$ = _segment[2],\n        options$1 = _segment$ === void 0 ? {} : _segment$;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n\n\n    if (options$1.at !== undefined) {\n      currentTime = calcTime.calcNextTime(currentTime, options$1.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n\n\n    var maxDuration = 0;\n    /**\n     * Find all the elements specified in the definition and parse value\n     * keyframes from their timeline definitions.\n     */\n\n    var elements = resolveElements.resolveElements(elementDefinition, elementCache);\n    var numElements = elements.length;\n\n    for (var elementIndex = 0; elementIndex < numElements; elementIndex++) {\n      var element = elements[elementIndex];\n      var elementSequence = getElementSequence(element, elementSequences);\n\n      for (var key in keyframes$1) {\n        var valueSequence = getValueSequence(key, elementSequence);\n        var valueKeyframes = keyframes.keyframesList(keyframes$1[key]);\n        var valueOptions = options.getOptions(options$1, key);\n        var _valueOptions$duratio = valueOptions.duration,\n            duration = _valueOptions$duratio === void 0 ? defaultOptions.duration || utils.defaults.duration : _valueOptions$duratio,\n            _valueOptions$easing = valueOptions.easing,\n            easing = _valueOptions$easing === void 0 ? defaultOptions.easing || utils.defaults.easing : _valueOptions$easing;\n\n        if (utils.isEasingGenerator(easing)) {\n          var valueIsTransform = transforms.isTransform(key);\n          heyListen.invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n          var custom = easing.createAnimation(valueKeyframes, // TODO We currently only support explicit keyframes\n          // so this doesn't currently read from the DOM\n          function () {\n            return \"0\";\n          }, valueIsTransform);\n          easing = custom.easing;\n          if (custom.keyframes !== undefined) valueKeyframes = custom.keyframes;\n          if (custom.duration !== undefined) duration = custom.duration;\n        }\n\n        var delay = stagger.resolveOption(options$1.delay, elementIndex, numElements) || 0;\n        var startTime = currentTime + delay;\n        var targetTime = startTime + duration;\n        /**\n         *\n         */\n\n        var _valueOptions$offset = valueOptions.offset,\n            offset = _valueOptions$offset === void 0 ? utils.defaultOffset(valueKeyframes.length) : _valueOptions$offset;\n        /**\n         * If there's only one offset of 0, fill in a second with length 1\n         *\n         * TODO: Ensure there's a test that covers this removal\n         */\n\n        if (offset.length === 1 && offset[0] === 0) {\n          offset[1] = 1;\n        }\n        /**\n         * Fill out if offset if fewer offsets than keyframes\n         */\n\n\n        var remainder = length - valueKeyframes.length;\n        remainder > 0 && utils.fillOffset(offset, remainder);\n        /**\n         * If only one value has been set, ie [1], push a null to the start of\n         * the keyframe array. This will let us mark a keyframe at this point\n         * that will later be hydrated with the previous value.\n         */\n\n        valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n        /**\n         * Add keyframes, mapping offsets to absolute time.\n         */\n\n        edit.addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n        maxDuration = Math.max(delay + duration, maxDuration);\n        totalDuration = Math.max(targetTime, totalDuration);\n      }\n    }\n\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n\n\n  elementSequences.forEach(function (valueSequences, element) {\n    for (var _key in valueSequences) {\n      var _valueSequence = valueSequences[_key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n\n      _valueSequence.sort(sort.compareByTime);\n\n      var _keyframes = [];\n      var valueOffset = [];\n      var valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n\n      for (var _i = 0; _i < _valueSequence.length; _i++) {\n        var _valueSequence$_i = _valueSequence[_i],\n            at = _valueSequence$_i.at,\n            value = _valueSequence$_i.value,\n            _easing = _valueSequence$_i.easing;\n\n        _keyframes.push(value);\n\n        valueOffset.push(utils.progress(0, totalDuration, at));\n        valueEasing.push(_easing || utils.defaults.easing);\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n\n\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n\n        _keyframes.unshift(_keyframes[0]);\n\n        valueEasing.unshift(\"linear\");\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n\n\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n\n        _keyframes.push(null);\n      }\n\n      animationDefinitions.push([element, _key, _keyframes, Object.assign(Object.assign(Object.assign({}, defaultOptions), {\n        duration: totalDuration,\n        easing: valueEasing,\n        offset: valueOffset\n      }), timelineOptions)]);\n    }\n  });\n  return animationDefinitions;\n}\n\nfunction getElementSequence(element, sequences) {\n  !sequences.has(element) && sequences.set(element, {});\n  return sequences.get(element);\n}\n\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\n\nexports.createAnimationsFromTimeline = createAnimationsFromTimeline;\nexports.timeline = timeline;","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib","require","heyListen","utils","stagger","animateStyle","controls","keyframes","options","resolveElements","transforms","calcTime","edit","sort","timeline","definition","_a","animationDefinitions","createAnimationsFromTimeline","animationFactories","map","filter","Boolean","withControls","duration","defaultOptions","timelineOptions","__rest","elementSequences","Map","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","length","segment","isString","set","Array","isArray","name","calcNextTime","at","elementDefinition","keyframes$1","options$1","undefined","maxDuration","elements","numElements","elementIndex","element","elementSequence","getElementSequence","key","valueSequence","getValueSequence","valueKeyframes","keyframesList","valueOptions","getOptions","defaults","easing","isEasingGenerator","valueIsTransform","isTransform","invariant","custom","createAnimation","delay","resolveOption","startTime","targetTime","offset","defaultOffset","remainder","fillOffset","unshift","addKeyframes","Math","max","forEach","valueSequences","compareByTime","valueOffset","valueEasing","push","progress","assign","sequences","has","get"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/@motionone/dom/dist/timeline/index.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar heyListen = require('hey-listen');\nvar utils = require('@motionone/utils');\nvar stagger = require('../utils/stagger.cjs.js');\nvar animateStyle = require('../animate/animate-style.cjs.js');\nvar controls = require('../animate/utils/controls.cjs.js');\nvar keyframes = require('../animate/utils/keyframes.cjs.js');\nvar options = require('../animate/utils/options.cjs.js');\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\nvar transforms = require('../animate/utils/transforms.cjs.js');\nvar calcTime = require('./utils/calc-time.cjs.js');\nvar edit = require('./utils/edit.cjs.js');\nvar sort = require('./utils/sort.cjs.js');\n\nfunction timeline(definition, options = {}) {\n    var _a;\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\n    /**\n     * Create and start animations\n     */\n    const animationFactories = animationDefinitions\n        .map((definition) => animateStyle.animateStyle(...definition))\n        .filter(Boolean);\n    return controls.withControls(animationFactories, options, \n    // Get the duration from the first animation definition\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition, _a = {}) {\n    var { defaultOptions = {} } = _a, timelineOptions = tslib.__rest(_a, [\"defaultOptions\"]);\n    const animationDefinitions = [];\n    const elementSequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the definition array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < definition.length; i++) {\n        const segment = definition[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (utils.isString(segment)) {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcTime.calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        const [elementDefinition, keyframes$1, options$1 = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (options$1.at !== undefined) {\n            currentTime = calcTime.calcNextTime(currentTime, options$1.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        const elements = resolveElements.resolveElements(elementDefinition, elementCache);\n        const numElements = elements.length;\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n            const element = elements[elementIndex];\n            const elementSequence = getElementSequence(element, elementSequences);\n            for (const key in keyframes$1) {\n                const valueSequence = getValueSequence(key, elementSequence);\n                let valueKeyframes = keyframes.keyframesList(keyframes$1[key]);\n                const valueOptions = options.getOptions(options$1, key);\n                let { duration = defaultOptions.duration || utils.defaults.duration, easing = defaultOptions.easing || utils.defaults.easing, } = valueOptions;\n                if (utils.isEasingGenerator(easing)) {\n                    const valueIsTransform = transforms.isTransform(key);\n                    heyListen.invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n                    const custom = easing.createAnimation(valueKeyframes, \n                    // TODO We currently only support explicit keyframes\n                    // so this doesn't currently read from the DOM\n                    () => \"0\", valueIsTransform);\n                    easing = custom.easing;\n                    if (custom.keyframes !== undefined)\n                        valueKeyframes = custom.keyframes;\n                    if (custom.duration !== undefined)\n                        duration = custom.duration;\n                }\n                const delay = stagger.resolveOption(options$1.delay, elementIndex, numElements) || 0;\n                const startTime = currentTime + delay;\n                const targetTime = startTime + duration;\n                /**\n                 *\n                 */\n                let { offset = utils.defaultOffset(valueKeyframes.length) } = valueOptions;\n                /**\n                 * If there's only one offset of 0, fill in a second with length 1\n                 *\n                 * TODO: Ensure there's a test that covers this removal\n                 */\n                if (offset.length === 1 && offset[0] === 0) {\n                    offset[1] = 1;\n                }\n                /**\n                 * Fill out if offset if fewer offsets than keyframes\n                 */\n                const remainder = length - valueKeyframes.length;\n                remainder > 0 && utils.fillOffset(offset, remainder);\n                /**\n                 * If only one value has been set, ie [1], push a null to the start of\n                 * the keyframe array. This will let us mark a keyframe at this point\n                 * that will later be hydrated with the previous value.\n                 */\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n                /**\n                 * Add keyframes, mapping offsets to absolute time.\n                 */\n                edit.addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n                maxDuration = Math.max(delay + duration, maxDuration);\n                totalDuration = Math.max(targetTime, totalDuration);\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    elementSequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(sort.compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(utils.progress(0, totalDuration, at));\n                valueEasing.push(easing || utils.defaults.easing);\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            animationDefinitions.push([\n                element,\n                key,\n                keyframes,\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\n            ]);\n        }\n    });\n    return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n    !sequences.has(element) && sequences.set(element, {});\n    return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\n\nexports.createAnimationsFromTimeline = createAnimationsFromTimeline;\nexports.timeline = timeline;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}