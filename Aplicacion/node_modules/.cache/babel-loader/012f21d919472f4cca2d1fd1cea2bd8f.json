{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport nerdamer from \"nerdamer\";\n\nvar Polynomial = /*#__PURE__*/function () {\n  function Polynomial(p) {\n    _classCallCheck(this, Polynomial);\n\n    this.pol = \"0\";\n    this.lc = \"0\";\n    this.coefMap = {};\n\n    try {\n      this.pol = nerdamer(p).expand().toString();\n    } catch (e) {\n      console.log(\"ERROR PARSING POLYNOMIAL \".concat(p));\n    }\n\n    console.log(this.pol);\n    this.findCoefficients(nerdamer.tree(this.pol));\n    console.log(\"FINAL COEFFS\");\n    console.log(this.coefMap);\n  }\n\n  _createClass(Polynomial, [{\n    key: \"multiply\",\n    value: function multiply(q) {\n      var product = \"\";\n\n      for (var keyP in this.coefMap) {\n        for (var keyQ in q.coefMap) {\n          product += \"(\".concat(this.coefMap[keyP], \"*\").concat(keyP, \") * (\").concat(q.coefMap[keyQ], \"*\").concat(keyQ, \")\");\n        }\n      }\n\n      this.p = nerdamer(product).expand().toString();\n      console.log(\"PRODUCT;\");\n      console.log(this.p);\n    }\n  }, {\n    key: \"findCoefficients\",\n    value: function findCoefficients(node) {\n      if (node === null || node === undefined) return;\n      var pol = this.nodeToString(node);\n      console.log(pol);\n      var pattern = /[+-]/;\n\n      if (!pattern.test(pol) && pol !== '') {\n        // const coef = this.nodeToString(node.left);\n        // const variable = this.nodeToString(node.right);\n        var coef = \"\";\n        var variable = \"\";\n        var writingCoef = true;\n\n        for (var i = 0; i < pol.length; i++) {\n          if (['x', 'y', 'z'].includes(pol[i])) {\n            writingCoef = false;\n            console.log(\"HOLA:\" + coef[coef.length - 1]);\n            if (coef[coef.length - 1] === \"*\") coef = coef.slice(0, -1);\n          }\n\n          if (!['(', ')'].includes(pol[i])) {\n            if (writingCoef) coef += pol[i];else variable += pol[i];\n          }\n        }\n\n        this.coefMap[variable] = coef;\n        console.log(\"COEF: \".concat(coef, \", VAR: \").concat(variable));\n      } else {\n        this.findCoefficients(node.left);\n        this.findCoefficients(node.right);\n      }\n\n      if (node !== null && node !== undefined) {\n        if (node.type === 'OPERATOR' && node.value === \"*\") {\n          console.log(\"PRODUC\");\n          console.log(node.left);\n          console.log(node.right);\n        }\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.pol;\n    }\n  }, {\n    key: \"nodeToString\",\n    value: function nodeToString(node) {\n      // console.log(node);\n      if (node !== null && node !== undefined) {\n        if (node.type === 'VARIABLE_OR_LITERAL') {\n          var isVariable = ['x', 'y', 'z'].includes(node.value); // console.log(\"ES LITERAL O VARIABLE: \" + node.value);\n          // console.log(node.value);\n\n          return isVariable ? node.value : parseFloat(node.value).toFixed(4);\n        }\n\n        if (node.type === 'OPERATOR') {\n          var _node$left, _node$right;\n\n          var left = this.nodeToString(node.left);\n          var right = this.nodeToString(node.right); // console.log(\"ES OPERATOR: \" + node.value);\n          // console.log(\"OPERATOR LEFT: \" + left);\n          // console.log(\"OPERATOR RIGHT: \" + right);\n          // console.log(`DEVUELVO ${(right && left) ? `${left}${node.value}${right}` : `${node.value}${left}`}`);\n\n          var leftParenthesis = ((_node$left = node.left) === null || _node$left === void 0 ? void 0 : _node$left.type) !== \"VARIABLE_OR_LITERAL\";\n          var rightParenthesis = ((_node$right = node.right) === null || _node$right === void 0 ? void 0 : _node$right.type) !== \"VARIABLE_OR_LITERAL\"; // console.log(\"OPERATOR: \" + node.value);\n          // console.log(\"TYPEL: \" + node.left.type);\n          // console.log(\"TYPER: \" + node.right.type);\n          // console.log(`PAR.LEFT: ${leftParenthesis}, RIGHT. PAR: ${rightParenthesis}`);\n\n          var l = leftParenthesis ? \"(\".concat(left, \")\") : \"\".concat(left);\n          var r = rightParenthesis ? \"(\".concat(right, \")\") : \"\".concat(right);\n          if (right && left) return \"\".concat(l).concat(node.value).concat(r);else return \"\".concat(node.value).concat(l);\n        }\n\n        if (node.type === 'FUNCTION') {\n          // console.log(\"ES F: \" + node.value);\n          var _left = this.nodeToString(node.left);\n\n          var _right = this.nodeToString(node.right); // console.log(`DEVUELVO ${left}${node.value}${right}`);\n\n\n          return \"\".concat(_left).concat(node.value).concat(_right);\n        }\n      }\n\n      return '';\n    }\n  }]);\n\n  return Polynomial;\n}();\n\nexport { Polynomial as default };","map":{"version":3,"names":["nerdamer","Polynomial","p","pol","lc","coefMap","expand","toString","e","console","log","findCoefficients","tree","q","product","keyP","keyQ","node","undefined","nodeToString","pattern","test","coef","variable","writingCoef","i","length","includes","slice","left","right","type","value","isVariable","parseFloat","toFixed","leftParenthesis","rightParenthesis","l","r"],"sources":["C:/Users/daniz/TFG/Aplicacion/src/Polynomial.js"],"sourcesContent":["import nerdamer from \"nerdamer\";\r\n\r\nexport default class Polynomial {\r\n    pol = \"0\";\r\n    lc = \"0\";\r\n    coefMap = {};\r\n\r\n    constructor(p){\r\n        try{\r\n            this.pol = nerdamer(p).expand().toString();\r\n        }catch(e){\r\n            console.log(`ERROR PARSING POLYNOMIAL ${p}`);\r\n        }\r\n\r\n        console.log(this.pol);\r\n        this.findCoefficients(nerdamer.tree(this.pol));\r\n\r\n        console.log(\"FINAL COEFFS\");\r\n        console.log(this.coefMap);\r\n    }\r\n\r\n    multiply(q){\r\n      let product= \"\";\r\n\r\n      for (let keyP in this.coefMap) {\r\n        for (let keyQ in q.coefMap) {\r\n          product += `(${this.coefMap[keyP]}*${keyP}) * (${q.coefMap[keyQ]}*${keyQ})`;\r\n        }\r\n      }\r\n\r\n      this.p = nerdamer(product).expand().toString();\r\n      console.log(\"PRODUCT;\");\r\n      console.log(this.p);\r\n    }\r\n\r\n    findCoefficients(node){\r\n\r\n      if(node===null || node===undefined)\r\n        return;\r\n\r\n      const pol = this.nodeToString(node);\r\n      console.log(pol);\r\n      var pattern = /[+-]/;\r\n\r\n      if(!pattern.test(pol) && pol!==''){\r\n        // const coef = this.nodeToString(node.left);\r\n        // const variable = this.nodeToString(node.right);\r\n\r\n        let coef = \"\";\r\n        let variable = \"\";\r\n        let writingCoef = true;\r\n\r\n        for(let i=0; i<pol.length; i++){\r\n          if(['x','y','z'].includes(pol[i])){\r\n            writingCoef = false;\r\n\r\n            console.log(\"HOLA:\" + coef[coef.length-1]);\r\n            if(coef[coef.length-1] === \"*\")\r\n              coef = coef.slice(0, -1);\r\n          }\r\n\r\n          \r\n          if(!['(', ')'].includes(pol[i])){\r\n            if(writingCoef) coef += pol[i];\r\n            else            variable += pol[i];\r\n          }\r\n        }\r\n\r\n        this.coefMap[variable] = coef;\r\n\r\n        console.log(`COEF: ${coef}, VAR: ${variable}`);\r\n      }\r\n      else{\r\n        this.findCoefficients(node.left);\r\n        this.findCoefficients(node.right);\r\n      }\r\n\r\n      \r\n\r\n      if (node!==null && node!==undefined) {\r\n        if(node.type === 'OPERATOR' && node.value === \"*\"){\r\n          console.log(\"PRODUC\");\r\n          console.log(node.left);\r\n          console.log(node.right);\r\n        }\r\n      }\r\n    }\r\n\r\n    toString(){\r\n      return this.pol;\r\n    }\r\n\r\n    nodeToString(node) {\r\n        // console.log(node);\r\n        if (node!==null && node!==undefined) {\r\n\r\n          if (node.type === 'VARIABLE_OR_LITERAL') {\r\n            const isVariable = ['x', 'y', 'z'].includes(node.value);\r\n            // console.log(\"ES LITERAL O VARIABLE: \" + node.value);\r\n            // console.log(node.value);\r\n            return isVariable ? node.value : parseFloat(node.value).toFixed(4);\r\n          }\r\n\r\n          if (node.type === 'OPERATOR') {\r\n            \r\n            let left = this.nodeToString(node.left);\r\n            let right = this.nodeToString(node.right);\r\n\r\n            // console.log(\"ES OPERATOR: \" + node.value);\r\n            // console.log(\"OPERATOR LEFT: \" + left);\r\n            // console.log(\"OPERATOR RIGHT: \" + right);\r\n            // console.log(`DEVUELVO ${(right && left) ? `${left}${node.value}${right}` : `${node.value}${left}`}`);\r\n\r\n            const leftParenthesis = node.left?.type!==\"VARIABLE_OR_LITERAL\";\r\n            const rightParenthesis = node.right?.type!==\"VARIABLE_OR_LITERAL\";\r\n\r\n            // console.log(\"OPERATOR: \" + node.value);\r\n            // console.log(\"TYPEL: \" + node.left.type);\r\n            // console.log(\"TYPER: \" + node.right.type);\r\n            // console.log(`PAR.LEFT: ${leftParenthesis}, RIGHT. PAR: ${rightParenthesis}`);\r\n            const l = leftParenthesis ? `(${left})` : `${left}`;\r\n            const r = rightParenthesis ? `(${right})` : `${right}`;\r\n\r\n            if(right && left)   return `${l}${node.value}${r}`;\r\n            else                return `${node.value}${l}`;\r\n          }\r\n\r\n          if (node.type === 'FUNCTION') {\r\n            // console.log(\"ES F: \" + node.value);\r\n            let left = this.nodeToString(node.left);\r\n            let right = this.nodeToString(node.right);\r\n            \r\n            // console.log(`DEVUELVO ${left}${node.value}${right}`);\r\n            return `${left}${node.value}${right}`;\r\n            \r\n          }\r\n        }\r\n\r\n        return '';\r\n      };\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}