{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport Token from \"./Token\";\nimport arities from \"./util/arities\";\nimport localFunctions from \"./util/localFunctions\"; // Single-arg tokens are those that, when in LaTeX mode, read only one character as their argument OR a block delimited by { }. For example, `x ^ 24` would be read as `SYMBOL(x) POWER NUMBER(2) NUMBER(4).\n\nvar CHAR_ARG_TOKENS = [Token.TYPE_POWER, Token.TYPE_COMMAND];\nvar DEFAULT_OPTS = {\n  latex: false\n};\n/**\n * The lexer reads a math expression and breaks it down into easily-digestible Tokens.\n * A list of valid tokens can be found lower in this file.\n * @param equation (String) The equation to lex.\n * @param constants (Object) An object of functions and variables.\n * @param opts Options.\n * @returns {Array} An array of Tokens.\n */\n\nexport default function lexer(equation) {\n  var constants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTS;\n  var l = new Lexer(equation, constants, opts);\n  l.lex(); // toString() each token and concatenate into a big string. Useful for debugging.\n\n  l.tokens.toString = function () {\n    return l.tokens.map(function (token) {\n      return token.toString();\n    }).join(\" \");\n  };\n\n  return l.tokens;\n}\n\nvar Lexer = /*#__PURE__*/function () {\n  function Lexer(buffer, constants, opts) {\n    _classCallCheck(this, Lexer);\n\n    this.buffer = buffer;\n    this.constants = Object.assign({}, constants, localFunctions);\n    this.opts = opts;\n    this.tokens = [];\n  }\n\n  _createClass(Lexer, [{\n    key: \"lex\",\n    value: function lex() {\n      this.lexExpression();\n      this.replaceConstants();\n      this.replaceCommands();\n    }\n    /**\n     * Lexes an expression or sub-expression.\n     */\n\n  }, {\n    key: \"lexExpression\",\n    value: function lexExpression() {\n      var charMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      while (this.hasNext()) {\n        var token = charMode ? this.nextCharToken() : this.next();\n        this.tokens.push(token);\n\n        if (this.opts.latex && isCharArgToken(token)) {\n          var arity = 1;\n\n          if (token.type === Token.TYPE_COMMAND) {\n            arity = arities[token.value.substr(1).toLowerCase()];\n          }\n\n          for (var i = 0; i < arity; i++) {\n            this.lexExpression(true);\n          }\n        } else if (isStartGroupToken(token)) {\n          this.lexExpression(false);\n        }\n\n        if (charMode || isEndGroupToken(token)) {\n          return;\n        }\n      }\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext() {\n      return this.buffer.length > 0;\n    }\n    /**\n     * Retrieves the next non-whitespace token from the buffer.\n     * @param len\n     * @returns {Token}\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      var len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      this.skipWhitespace();\n\n      if (!this.hasNext()) {\n        throw \"Lexer error: reached end of stream\";\n      } // Try to match each pattern in tokenPatterns to the remaining buffer\n\n\n      var _iterator = _createForOfIteratorHelper(Token.patterns),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              type = _step$value[0],\n              regex = _step$value[1];\n\n          // Force the regex to match only at the beginning of the string\n          var regexFromStart = new RegExp(/^/.source + regex.source); // When `len` is undefined, substr reads to the end\n\n          var match = regexFromStart.exec(this.buffer.substr(0, len));\n\n          if (match) {\n            this.buffer = this.buffer.substr(match[0].length);\n            return new Token(type, match[0]);\n          }\n        } // TODO: Meaningful error\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      throw \"Lexer error: can't match any token\";\n    }\n    /**\n     * Tokenizes the next single character of the buffer, unless the following token is a LaTeX command, in which case the entire command is tokenized.\n     */\n\n  }, {\n    key: \"nextCharToken\",\n    value: function nextCharToken() {\n      this.skipWhitespace();\n\n      if (this.buffer.charAt(0) === \"\\\\\") {\n        return this.next();\n      }\n\n      return this.next(1);\n    }\n  }, {\n    key: \"replaceCommands\",\n    value: function replaceCommands() {\n      var _iterator2 = _createForOfIteratorHelper(this.tokens),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var token = _step2.value;\n\n          if (token.type === Token.TYPE_COMMAND) {\n            token.value = token.value.substr(1).toLowerCase();\n            token.name = token.value; // Save name of function for debugging later\n\n            token.value = this.constants[token.name];\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"replaceConstants\",\n    value: function replaceConstants() {\n      var _iterator3 = _createForOfIteratorHelper(this.tokens),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var token = _step3.value;\n\n          if (token.type === Token.TYPE_SYMBOL) {\n            // Symbols will need to be looked up during the evaluation phase.\n            // If the symbol refers to things defined in either Math or\n            // the locals, compile them, to prevent slow lookups later.\n            if (typeof this.constants[token.value] === \"function\") {\n              token.type = Token.TYPE_FUNCTION;\n              token.name = token.value; // Save name of function for debugging later\n\n              token.value = this.constants[token.value];\n            } else if (typeof this.constants[token.value] === \"number\") {\n              token.type = Token.TYPE_NUMBER;\n              token.value = token.fn = this.constants[token.value];\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * Removes whitespace from the beginning of the buffer.\n     */\n\n  }, {\n    key: \"skipWhitespace\",\n    value: function skipWhitespace() {\n      var regex = new RegExp(/^/.source + Token.patterns.get(Token.TYPE_WHITESPACE).source);\n      this.buffer = this.buffer.replace(regex, \"\");\n    }\n  }]);\n\n  return Lexer;\n}();\n\nfunction isCharArgToken(token) {\n  return CHAR_ARG_TOKENS.indexOf(token.type) !== -1;\n}\n\nfunction isStartGroupToken(token) {\n  return token.type === Token.TYPE_LPAREN && token.value === \"{\";\n}\n\nfunction isEndGroupToken(token) {\n  return token.type === Token.TYPE_RPAREN && token.value === \"}\";\n}","map":{"version":3,"names":["Token","arities","localFunctions","CHAR_ARG_TOKENS","TYPE_POWER","TYPE_COMMAND","DEFAULT_OPTS","latex","lexer","equation","constants","opts","l","Lexer","lex","tokens","toString","map","token","join","buffer","Object","assign","lexExpression","replaceConstants","replaceCommands","charMode","hasNext","nextCharToken","next","push","isCharArgToken","arity","type","value","substr","toLowerCase","i","isStartGroupToken","isEndGroupToken","length","len","undefined","skipWhitespace","patterns","regex","regexFromStart","RegExp","source","match","exec","charAt","name","TYPE_SYMBOL","TYPE_FUNCTION","TYPE_NUMBER","fn","get","TYPE_WHITESPACE","replace","indexOf","TYPE_LPAREN","TYPE_RPAREN"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/evaluatex/src/lexer.js"],"sourcesContent":["import Token from \"./Token\";\nimport arities from \"./util/arities\";\nimport localFunctions from \"./util/localFunctions\";\n\n// Single-arg tokens are those that, when in LaTeX mode, read only one character as their argument OR a block delimited by { }. For example, `x ^ 24` would be read as `SYMBOL(x) POWER NUMBER(2) NUMBER(4).\nconst CHAR_ARG_TOKENS = [Token.TYPE_POWER, Token.TYPE_COMMAND];\n\nconst DEFAULT_OPTS = {\n    latex: false\n};\n\n/**\n * The lexer reads a math expression and breaks it down into easily-digestible Tokens.\n * A list of valid tokens can be found lower in this file.\n * @param equation (String) The equation to lex.\n * @param constants (Object) An object of functions and variables.\n * @param opts Options.\n * @returns {Array} An array of Tokens.\n */\nexport default function lexer(equation, constants = {}, opts = DEFAULT_OPTS) {\n    let l = new Lexer(equation, constants, opts);\n    l.lex();\n\n    // toString() each token and concatenate into a big string. Useful for debugging.\n    l.tokens.toString = () => l.tokens.map(token => token.toString()).join(\" \");\n\n    return l.tokens;\n}\n\nclass Lexer {\n    constructor(buffer, constants, opts) {\n        this.buffer = buffer;\n        this.constants = Object.assign({}, constants, localFunctions);\n        this.opts = opts;\n        this.tokens = [];\n    }\n\n    lex() {\n        this.lexExpression();\n        this.replaceConstants();\n        this.replaceCommands();\n    }\n\n    /**\n     * Lexes an expression or sub-expression.\n     */\n    lexExpression(charMode = false) {\n        while (this.hasNext()) {\n            let token = charMode ? this.nextCharToken() : this.next();\n            this.tokens.push(token);\n\n            if (this.opts.latex && isCharArgToken(token)) {\n                let arity = 1;\n                if (token.type === Token.TYPE_COMMAND) {\n                    arity = arities[token.value.substr(1).toLowerCase()];\n                }\n                for (let i = 0; i < arity; i++) {\n                    this.lexExpression(true);\n                }\n            }\n            else if (isStartGroupToken(token)) {\n                this.lexExpression(false);\n            }\n\n            if (charMode || isEndGroupToken(token)) {\n                return;\n            }\n        }\n    }\n\n    hasNext() {\n        return this.buffer.length > 0;\n    }\n\n    /**\n     * Retrieves the next non-whitespace token from the buffer.\n     * @param len\n     * @returns {Token}\n     */\n    next(len = undefined) {\n        this.skipWhitespace();\n\n        if (!this.hasNext()) {\n            throw \"Lexer error: reached end of stream\";\n        }\n\n        // Try to match each pattern in tokenPatterns to the remaining buffer\n        for (const [type, regex] of Token.patterns) {\n            // Force the regex to match only at the beginning of the string\n            const regexFromStart = new RegExp(/^/.source + regex.source);\n\n            // When `len` is undefined, substr reads to the end\n            let match = regexFromStart.exec(this.buffer.substr(0, len));\n            if (match) {\n                this.buffer = this.buffer.substr(match[0].length);\n                return new Token(type, match[0]);\n            }\n        }\n\n        // TODO: Meaningful error\n        throw \"Lexer error: can't match any token\";\n    }\n\n    /**\n     * Tokenizes the next single character of the buffer, unless the following token is a LaTeX command, in which case the entire command is tokenized.\n     */\n    nextCharToken() {\n        this.skipWhitespace();\n        if (this.buffer.charAt(0) === \"\\\\\") {\n            return this.next();\n        }\n        return this.next(1);\n    }\n\n    replaceCommands() {\n        for (const token of this.tokens) {\n            if (token.type === Token.TYPE_COMMAND) {\n                token.value = token.value.substr(1).toLowerCase();\n                token.name = token.value; // Save name of function for debugging later\n                token.value = this.constants[token.name];\n            }\n        }\n    }\n\n    replaceConstants() {\n        for (const token of this.tokens) {\n            if (token.type === Token.TYPE_SYMBOL) {\n                // Symbols will need to be looked up during the evaluation phase.\n                // If the symbol refers to things defined in either Math or\n                // the locals, compile them, to prevent slow lookups later.\n                if (typeof this.constants[token.value] === \"function\") {\n                    token.type = Token.TYPE_FUNCTION;\n                    token.name = token.value; // Save name of function for debugging later\n                    token.value = this.constants[token.value];\n                }\n                else if (typeof this.constants[token.value] === \"number\") {\n                    token.type = Token.TYPE_NUMBER;\n                    token.value = token.fn = this.constants[token.value];\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes whitespace from the beginning of the buffer.\n     */\n    skipWhitespace() {\n        const regex = new RegExp(/^/.source + Token.patterns.get(Token.TYPE_WHITESPACE).source);\n        this.buffer = this.buffer.replace(regex, \"\");\n    }\n}\n\nfunction isCharArgToken(token) {\n    return CHAR_ARG_TOKENS.indexOf(token.type) !== -1;\n}\n\nfunction isStartGroupToken(token) {\n    return token.type === Token.TYPE_LPAREN && token.value === \"{\";\n}\n\nfunction isEndGroupToken(token) {\n    return token.type === Token.TYPE_RPAREN && token.value === \"}\";\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}