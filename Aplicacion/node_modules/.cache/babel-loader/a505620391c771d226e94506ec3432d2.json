{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { escape, stringify } from '../../utils/string.js';\nimport { isSafeProperty } from '../../utils/customs.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ObjectNode';\nvar dependencies = ['Node'];\nexport var createObjectNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n\n  var ObjectNode = /*#__PURE__*/function (_Node) {\n    _inherits(ObjectNode, _Node);\n\n    var _super = _createSuper(ObjectNode);\n\n    /**\r\n     * @constructor ObjectNode\r\n     * @extends {Node}\r\n     * Holds an object with keys/values\r\n     * @param {Object.<string, Node>} [properties]   object with key/value pairs\r\n     */\n    function ObjectNode(properties) {\n      var _this;\n\n      _classCallCheck(this, ObjectNode);\n\n      _this = _super.call(this);\n      _this.properties = properties || {}; // validate input\n\n      if (properties) {\n        if (!(typeof properties === 'object') || !Object.keys(properties).every(function (key) {\n          return isNode(properties[key]);\n        })) {\n          throw new TypeError('Object containing Nodes expected');\n        }\n      }\n\n      return _this;\n    }\n\n    _createClass(ObjectNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isObjectNode\",\n      get: function get() {\n        return true;\n      }\n      /**\r\n       * Compile a node into a JavaScript function.\r\n       * This basically pre-calculates as much as possible and only leaves open\r\n       * calculations which depend on a dynamic scope with variables.\r\n       * @param {Object} math     Math.js namespace with functions and constants.\r\n       * @param {Object} argNames An object with argument names as key and `true`\r\n       *                          as value. Used in the SymbolNode to optimize\r\n       *                          for arguments from user assigned functions\r\n       *                          (see FunctionAssignmentNode) or special symbols\r\n       *                          like `end` (see IndexNode).\r\n       * @return {function} Returns a function which can be called like:\r\n       *                        evalNode(scope: Object, args: Object, context: *)\r\n       */\n\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var evalEntries = {};\n\n        for (var key in this.properties) {\n          if (hasOwnProperty(this.properties, key)) {\n            // we stringify/parse the key here to resolve unicode characters,\n            // so you cannot create a key like {\"co\\\\u006Estructor\": null}\n            var stringifiedKey = stringify(key);\n            var parsedKey = JSON.parse(stringifiedKey);\n\n            if (!isSafeProperty(this.properties, parsedKey)) {\n              throw new Error('No access to property \"' + parsedKey + '\"');\n            }\n\n            evalEntries[parsedKey] = this.properties[key]._compile(math, argNames);\n          }\n        }\n\n        return function evalObjectNode(scope, args, context) {\n          var obj = {};\n\n          for (var _key in evalEntries) {\n            if (hasOwnProperty(evalEntries, _key)) {\n              obj[_key] = evalEntries[_key](scope, args, context);\n            }\n          }\n\n          return obj;\n        };\n      }\n      /**\r\n       * Execute a callback for each of the child nodes of this node\r\n       * @param {function(child: Node, path: string, parent: Node)} callback\r\n       */\n\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        for (var key in this.properties) {\n          if (hasOwnProperty(this.properties, key)) {\n            callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\n          }\n        }\n      }\n      /**\r\n       * Create a new ObjectNode whose children are the results of calling\r\n       * the provided callback function for each child of the original node.\r\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n       * @returns {ObjectNode} Returns a transformed copy of the node\r\n       */\n\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        var properties = {};\n\n        for (var key in this.properties) {\n          if (hasOwnProperty(this.properties, key)) {\n            properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));\n          }\n        }\n\n        return new ObjectNode(properties);\n      }\n      /**\r\n       * Create a clone of this node, a shallow copy\r\n       * @return {ObjectNode}\r\n       */\n\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        var properties = {};\n\n        for (var key in this.properties) {\n          if (hasOwnProperty(this.properties, key)) {\n            properties[key] = this.properties[key];\n          }\n        }\n\n        return new ObjectNode(properties);\n      }\n      /**\r\n       * Get string representation\r\n       * @param {Object} options\r\n       * @return {string} str\r\n       * @override\r\n       */\n\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var entries = [];\n\n        for (var key in this.properties) {\n          if (hasOwnProperty(this.properties, key)) {\n            entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\n          }\n        }\n\n        return '{' + entries.join(', ') + '}';\n      }\n      /**\r\n       * Get a JSON representation of the node\r\n       * @returns {Object}\r\n       */\n\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          properties: this.properties\n        };\n      }\n      /**\r\n       * Instantiate an OperatorNode from its JSON representation\r\n       * @param {Object} json  An object structured like\r\n       *                       `{\"mathjs\": \"ObjectNode\", \"properties\": {...}}`,\r\n       *                       where mathjs is optional\r\n       * @returns {ObjectNode}\r\n       */\n\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\r\n       * Get HTML representation\r\n       * @param {Object} options\r\n       * @return {string} str\r\n       * @override\r\n       */\n      function toHTML(options) {\n        var entries = [];\n\n        for (var key in this.properties) {\n          if (hasOwnProperty(this.properties, key)) {\n            entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-property-assignment-operator math-binary-operator\">' + ':</span>' + this.properties[key].toHTML(options));\n          }\n        }\n\n        return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\n      }\n      /**\r\n       * Get LaTeX representation\r\n       * @param {Object} options\r\n       * @return {string} str\r\n       */\n\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        var entries = [];\n\n        for (var key in this.properties) {\n          if (hasOwnProperty(this.properties, key)) {\n            entries.push('\\\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\\\\\');\n          }\n        }\n\n        var tex = '\\\\left\\\\{\\\\begin{array}{ll}' + entries.join('\\n') + '\\\\end{array}\\\\right\\\\}';\n        return tex;\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new ObjectNode(json.properties);\n      }\n    }]);\n\n    return ObjectNode;\n  }(Node);\n\n  _defineProperty(ObjectNode, \"name\", name);\n\n  return ObjectNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","escape","stringify","isSafeProperty","hasOwnProperty","factory","name","dependencies","createObjectNode","_ref","Node","ObjectNode","properties","Object","keys","every","key","TypeError","math","argNames","evalEntries","stringifiedKey","parsedKey","JSON","parse","Error","_compile","evalObjectNode","scope","args","context","obj","_key","callback","_ifNode","options","entries","push","toString","join","mathjs","toHTML","toTex","tex","json","isClass"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/mathjs/lib/esm/expression/node/ObjectNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { isNode } from '../../utils/is.js';\r\nimport { escape, stringify } from '../../utils/string.js';\r\nimport { isSafeProperty } from '../../utils/customs.js';\r\nimport { hasOwnProperty } from '../../utils/object.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'ObjectNode';\r\nvar dependencies = ['Node'];\r\nexport var createObjectNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n\r\n  class ObjectNode extends Node {\r\n    /**\r\n     * @constructor ObjectNode\r\n     * @extends {Node}\r\n     * Holds an object with keys/values\r\n     * @param {Object.<string, Node>} [properties]   object with key/value pairs\r\n     */\r\n    constructor(properties) {\r\n      super();\r\n      this.properties = properties || {}; // validate input\r\n\r\n      if (properties) {\r\n        if (!(typeof properties === 'object') || !Object.keys(properties).every(function (key) {\r\n          return isNode(properties[key]);\r\n        })) {\r\n          throw new TypeError('Object containing Nodes expected');\r\n        }\r\n      }\r\n    }\r\n\r\n    get type() {\r\n      return name;\r\n    }\r\n\r\n    get isObjectNode() {\r\n      return true;\r\n    }\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n\r\n\r\n    _compile(math, argNames) {\r\n      var evalEntries = {};\r\n\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          // we stringify/parse the key here to resolve unicode characters,\r\n          // so you cannot create a key like {\"co\\\\u006Estructor\": null}\r\n          var stringifiedKey = stringify(key);\r\n          var parsedKey = JSON.parse(stringifiedKey);\r\n\r\n          if (!isSafeProperty(this.properties, parsedKey)) {\r\n            throw new Error('No access to property \"' + parsedKey + '\"');\r\n          }\r\n\r\n          evalEntries[parsedKey] = this.properties[key]._compile(math, argNames);\r\n        }\r\n      }\r\n\r\n      return function evalObjectNode(scope, args, context) {\r\n        var obj = {};\r\n\r\n        for (var _key in evalEntries) {\r\n          if (hasOwnProperty(evalEntries, _key)) {\r\n            obj[_key] = evalEntries[_key](scope, args, context);\r\n          }\r\n        }\r\n\r\n        return obj;\r\n      };\r\n    }\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n\r\n\r\n    forEach(callback) {\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          callback(this.properties[key], 'properties[' + stringify(key) + ']', this);\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Create a new ObjectNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ObjectNode} Returns a transformed copy of the node\r\n     */\r\n\r\n\r\n    map(callback) {\r\n      var properties = {};\r\n\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          properties[key] = this._ifNode(callback(this.properties[key], 'properties[' + stringify(key) + ']', this));\r\n        }\r\n      }\r\n\r\n      return new ObjectNode(properties);\r\n    }\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ObjectNode}\r\n     */\r\n\r\n\r\n    clone() {\r\n      var properties = {};\r\n\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          properties[key] = this.properties[key];\r\n        }\r\n      }\r\n\r\n      return new ObjectNode(properties);\r\n    }\r\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n\r\n\r\n    _toString(options) {\r\n      var entries = [];\r\n\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          entries.push(stringify(key) + ': ' + this.properties[key].toString(options));\r\n        }\r\n      }\r\n\r\n      return '{' + entries.join(', ') + '}';\r\n    }\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n\r\n\r\n    toJSON() {\r\n      return {\r\n        mathjs: name,\r\n        properties: this.properties\r\n      };\r\n    }\r\n    /**\r\n     * Instantiate an OperatorNode from its JSON representation\r\n     * @param {Object} json  An object structured like\r\n     *                       `{\"mathjs\": \"ObjectNode\", \"properties\": {...}}`,\r\n     *                       where mathjs is optional\r\n     * @returns {ObjectNode}\r\n     */\r\n\r\n\r\n    static fromJSON(json) {\r\n      return new ObjectNode(json.properties);\r\n    }\r\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n\r\n\r\n    toHTML(options) {\r\n      var entries = [];\r\n\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          entries.push('<span class=\"math-symbol math-property\">' + escape(key) + '</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-property-assignment-operator math-binary-operator\">' + ':</span>' + this.properties[key].toHTML(options));\r\n        }\r\n      }\r\n\r\n      return '<span class=\"math-parenthesis math-curly-parenthesis\">{</span>' + entries.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-curly-parenthesis\">}</span>';\r\n    }\r\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n\r\n\r\n    _toTex(options) {\r\n      var entries = [];\r\n\r\n      for (var key in this.properties) {\r\n        if (hasOwnProperty(this.properties, key)) {\r\n          entries.push('\\\\mathbf{' + key + ':} & ' + this.properties[key].toTex(options) + '\\\\\\\\');\r\n        }\r\n      }\r\n\r\n      var tex = '\\\\left\\\\{\\\\begin{array}{ll}' + entries.join('\\n') + '\\\\end{array}\\\\right\\\\}';\r\n      return tex;\r\n    }\r\n\r\n  }\r\n\r\n  _defineProperty(ObjectNode, \"name\", name);\r\n\r\n  return ObjectNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}