{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport nerdamer from \"nerdamer\";\n\nvar Polynomial = /*#__PURE__*/function () {\n  function Polynomial(p) {\n    _classCallCheck(this, Polynomial);\n\n    this.pol = \"0\";\n    this.lc = \"0\";\n\n    try {\n      this.pol = nerdamer(p).expand().toString();\n    } catch (e) {\n      console.log(\"ERROR PARSING POLYNOMIAL \".concat(p));\n    }\n\n    console.log(this.pol);\n    this.findCoefficients(this.pol);\n  }\n\n  _createClass(Polynomial, [{\n    key: \"findCoefficients\",\n    value: function findCoefficients(pol) {\n      var node = nerdamer.tree(pol);\n      var pattern = /[+-]/;\n\n      if (!pattern.test(pol)) {\n        var coef = this.nodeToString(node.left);\n        var variable = this.nodeToString(node.right);\n        console.log(\"COEF: \".concat(coef, \", VAR: \").concat(variable));\n      } else {\n        console.log(\"INCLUYE\");\n      }\n\n      if (node !== null && node !== undefined) {\n        if (node.type === 'OPERATOR' && node.value === \"*\") {\n          console.log(\"PRODUC\");\n          console.log(node.left);\n          console.log(node.right);\n        }\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.pol;\n    }\n  }, {\n    key: \"nodeToString\",\n    value: function nodeToString(node) {\n      // console.log(node);\n      if (node !== null && node !== undefined) {\n        if (node.type === 'VARIABLE_OR_LITERAL') {\n          var isVariable = ['x', 'y', 'z'].includes(node.value); // console.log(\"ES LITERAL O VARIABLE: \" + node.value);\n          // console.log(node.value);\n\n          return isVariable ? node.value : parseFloat(node.value).toFixed(4);\n        }\n\n        if (node.type === 'OPERATOR') {\n          var left = this.traverseTree(node.left);\n          var right = this.traverseTree(node.right); // console.log(\"ES OPERATOR: \" + node.value);\n          // console.log(\"OPERATOR LEFT: \" + left);\n          // console.log(\"OPERATOR RIGHT: \" + right);\n          // console.log(`DEVUELVO ${(right && left) ? `${left}${node.value}${right}` : `${node.value}${left}`}`);\n\n          var leftParenthesis = node.left.type !== \"VARIABLE_OR_LITERAL\";\n          var rightParenthesis = node.right.type !== \"VARIABLE_OR_LITERAL\"; // console.log(\"OPERATOR: \" + node.value);\n          // console.log(\"TYPEL: \" + node.left.type);\n          // console.log(\"TYPER: \" + node.right.type);\n          // console.log(`PAR.LEFT: ${leftParenthesis}, RIGHT. PAR: ${rightParenthesis}`);\n\n          var l = leftParenthesis ? \"(\".concat(left, \")\") : \"\".concat(left);\n          var r = rightParenthesis ? \"(\".concat(right, \")\") : \"\".concat(right);\n          if (right && left) return \"\".concat(l).concat(node.value).concat(r);else return \"\".concat(node.value).concat(l);\n        }\n\n        if (node.type === 'FUNCTION') {\n          // console.log(\"ES F: \" + node.value);\n          var _left = this.traverseTree(node.left);\n\n          var _right = this.traverseTree(node.right); // console.log(`DEVUELVO ${left}${node.value}${right}`);\n\n\n          return \"\".concat(_left).concat(node.value).concat(_right);\n        }\n      }\n\n      return '';\n    }\n  }]);\n\n  return Polynomial;\n}();\n\nexport { Polynomial as default };","map":{"version":3,"names":["nerdamer","Polynomial","p","pol","lc","expand","toString","e","console","log","findCoefficients","node","tree","pattern","test","coef","nodeToString","left","variable","right","undefined","type","value","isVariable","includes","parseFloat","toFixed","traverseTree","leftParenthesis","rightParenthesis","l","r"],"sources":["C:/Users/daniz/TFG/Aplicacion/src/Polynomial.js"],"sourcesContent":["import nerdamer from \"nerdamer\";\r\n\r\nexport default class Polynomial {\r\n    pol = \"0\";\r\n    lc = \"0\";\r\n\r\n    constructor(p){\r\n        try{\r\n            this.pol = nerdamer(p).expand().toString();\r\n        }catch(e){\r\n            console.log(`ERROR PARSING POLYNOMIAL ${p}`);\r\n        }\r\n\r\n        console.log(this.pol);\r\n        this.findCoefficients(this.pol);\r\n    }\r\n\r\n    findCoefficients(pol){\r\n\r\n      const node = nerdamer.tree(pol);\r\n\r\n      var pattern = /[+-]/;\r\n\r\n      if(!pattern.test(pol)){\r\n        const coef = this.nodeToString(node.left);\r\n        const variable = this.nodeToString(node.right);\r\n\r\n        console.log(`COEF: ${coef}, VAR: ${variable}`);\r\n      }\r\n      else{\r\n        console.log(\"INCLUYE\");\r\n      }\r\n\r\n      \r\n\r\n      if (node!==null && node!==undefined) {\r\n        if(node.type === 'OPERATOR' && node.value === \"*\"){\r\n          console.log(\"PRODUC\");\r\n          console.log(node.left);\r\n          console.log(node.right);\r\n        }\r\n      }\r\n    }\r\n\r\n    toString(){\r\n      return this.pol;\r\n    }\r\n\r\n    nodeToString(node) {\r\n        // console.log(node);\r\n        if (node!==null && node!==undefined) {\r\n\r\n          if (node.type === 'VARIABLE_OR_LITERAL') {\r\n            const isVariable = ['x', 'y', 'z'].includes(node.value);\r\n            // console.log(\"ES LITERAL O VARIABLE: \" + node.value);\r\n            // console.log(node.value);\r\n            return isVariable ? node.value : parseFloat(node.value).toFixed(4);\r\n          }\r\n\r\n          if (node.type === 'OPERATOR') {\r\n            \r\n            let left = this.traverseTree(node.left);\r\n            let right = this.traverseTree(node.right);\r\n\r\n            // console.log(\"ES OPERATOR: \" + node.value);\r\n            // console.log(\"OPERATOR LEFT: \" + left);\r\n            // console.log(\"OPERATOR RIGHT: \" + right);\r\n            // console.log(`DEVUELVO ${(right && left) ? `${left}${node.value}${right}` : `${node.value}${left}`}`);\r\n\r\n            const leftParenthesis = node.left.type!==\"VARIABLE_OR_LITERAL\";\r\n            const rightParenthesis = node.right.type!==\"VARIABLE_OR_LITERAL\";\r\n\r\n            // console.log(\"OPERATOR: \" + node.value);\r\n            // console.log(\"TYPEL: \" + node.left.type);\r\n            // console.log(\"TYPER: \" + node.right.type);\r\n            // console.log(`PAR.LEFT: ${leftParenthesis}, RIGHT. PAR: ${rightParenthesis}`);\r\n            const l = leftParenthesis ? `(${left})` : `${left}`;\r\n            const r = rightParenthesis ? `(${right})` : `${right}`;\r\n\r\n            if(right && left)   return `${l}${node.value}${r}`;\r\n            else                return `${node.value}${l}`;\r\n          }\r\n\r\n          if (node.type === 'FUNCTION') {\r\n            // console.log(\"ES F: \" + node.value);\r\n            let left = this.traverseTree(node.left);\r\n            let right = this.traverseTree(node.right);\r\n            \r\n            // console.log(`DEVUELVO ${left}${node.value}${right}`);\r\n            return `${left}${node.value}${right}`;\r\n            \r\n          }\r\n        }\r\n\r\n        return '';\r\n      };\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}