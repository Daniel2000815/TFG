{"ast":null,"code":"import React, { useEffect, useState } from 'react';\nimport { operators } from './operators';\nimport usePrimitivesHook from '../primitivesHook';\nexport var fs = function fs(sdf, primitives) {\n  return \"\\n    #ifdef GL_ES\\n    precision mediump float;\\n    #endif\\n\\n    uniform vec2 u_resolution;\\n    uniform vec2 u_mouse;\\n    uniform vec3 u_specular;\\n    uniform vec3 u_diffuse;\\n    uniform vec3 u_ambient;\\n    uniform float u_smoothness;\\n\\n    // Constants\\n    const int MAX_MARCHING_STEPS=255;\\n    const float MIN_DIST=0.;\\n    const float MAX_DIST=100.;\\n    const float PRECISION=.0001;\\n    const float EPSILON=.0005;\\n    const float PI=3.14159265359;\\n\\n    struct Material\\n    {\\n    vec3 specular;\\n    vec3 diffuse;\\n    vec3 ambient;\\n    float smoothness;\\n    };\\n\\n    struct Surface{\\n    float sd;// signed distance value\\n    Material mat;\\n    };\\n\\n    // Rotate around a circular path\\n    mat2 rotate2d(float theta){\\n    float s = sin(theta),c=cos(theta);\\n    return mat2(c,-s,s,c);\\n    }\\n\\n    // Rotation matrix around the X axis.\\n    mat3 rotateX(float theta){\\n    float c=cos(theta);\\n    float s=sin(theta);\\n    return mat3(\\n        vec3(1.,0.,0.),\\n        vec3(0.,c,-s),\\n        vec3(0.,s,c)\\n    );\\n    }\\n\\n    // Rotation matrix around the Y axis.\\n    mat3 rotateY(float theta){\\n    float c=cos(theta);\\n    float s=sin(theta);\\n    return mat3(\\n        vec3(c,0.,s),\\n        vec3(0.,1.,0.),\\n        vec3(-s,0.,c)\\n    );\\n    }\\n\\n    // Rotation matrix around the Z axis.\\n    mat3 rotateZ(float theta){\\n    float c=cos(theta);\\n    float s=sin(theta);\\n    return mat3(\\n        vec3(c,-s,0.),\\n        vec3(s,c,0.),\\n        vec3(0.,0.,1.)\\n    );\\n    }\\n\\n    // Identity matrix.\\n    mat3 identity(){\\n    return mat3(\\n        vec3(1,0,0),\\n        vec3(0,1,0),\\n        vec3(0,0,1)\\n    );\\n    }\\n\\n    \".concat(operators(), \"\\n\\n    Surface minWithColor(Surface obj1,Surface obj2){\\n        if(obj2.sd<obj1.sd) return obj2;\\n        return obj1;\\n    }\\n\\n    float f(vec3 p)                                 \\n    {\\n        float x = p.r;\\n        float y = p.g;\\n        float z = p.b;\\n\\n        return \").concat(sdf, \";\\n    } \\n\\n    Surface map(vec3 p){\\n        Material mat = Material(u_specular, u_diffuse, u_ambient, u_smoothness);\\n        float sphere = f(p);\\n        \\n        Surface co = Surface(sphere, mat);\\n        \\n        return co;\\n    }\\n\\n    vec3 grad( in vec3 p )\\n    {\\n    return vec3(\\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\\n    );\\n    }\\n\\n    mat3 camera(vec3 cameraPos,vec3 lookAtPoint){\\n    vec3 cd = normalize(lookAtPoint-cameraPos);      // camera direction\\n    vec3 cr = normalize(cross(vec3(0.,1.,0.),cd)); // camera right\\n    vec3 cu = normalize(cross(cd,cr));               // camera up\\n    \\n    return mat3(-cr,cu,-cd);\\n    }\\n\\n    Surface rayMarch(vec3 ro,vec3 rd,float start,float end){\\n    float depth = start;\\n    Surface co; // closest object\\n    \\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\\n        vec3 p = ro + depth*rd;\\n        co = map(p);\\n        depth += co.sd;\\n        if(co.sd<PRECISION||depth>end)  break;\\n    }\\n    \\n    co.sd = depth;\\n    \\n    return co;\\n    }\\n\\n    vec3 lighting(vec3 p,vec3 n,vec3 eye,Material mat){\\n    vec3 ambient = vec3(.5);\\n    \\n    vec3 lights_pos[2];\\n    lights_pos[0] = vec3(4.,2.,2.);\\n    lights_pos[1] = vec3(-4.,-2.,-2.);\\n    \\n    vec3 lights_color[2];\\n    lights_color[0] = vec3(1.,1.,1.);\\n    lights_color[1] = vec3(1.,1.,1.);\\n    \\n    vec3 Ip = mat.ambient*ambient;\\n    \\n    for(int i=0;i<2;i++){\\n        vec3 Lm = normalize(lights_pos[i] - p);\\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm); // reflect(-Lm, n)\\n        vec3 V  = normalize(eye - p);\\n        \\n        float LN = dot(Lm,n);\\n        float RV = dot(Rm,V);\\n        \\n        if(LN<0.) // Light not visible\\n        Ip+=vec3(0.,0.,0.);\\n        else if(RV<0.)// opposite direction as viewer, apply only diffuse\\n        Ip+=lights_color[i]*(mat.diffuse*LN);\\n        else\\n        Ip+=lights_color[i]*(mat.diffuse*LN+mat.specular*pow(RV,mat.smoothness));\\n    }\\n    \\n    return Ip;\\n    }\\n\\n    vec3 calcNormal(in vec3 p){\\n    return normalize(vec3(\\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\\n    ));\\n    }\\n    \\n    void main()\\n    {\\n    vec2 uv = (gl_FragCoord.xy - 0.5*u_resolution.xy) / u_resolution.y;\\n    vec2 mouseUV = u_mouse.xy/u_resolution.xy;  // [0,1]\\n\\n    vec3 backgroundColor = vec3(.835, 1.0, 1.0);\\n    vec3 col    = vec3(0.0);\\n    \\n    vec3 lookAt = vec3(0.0);\\n    vec3 eye    = vec3(0,5,0);\\n\\n    float cameraRadius = 2.0;\\n    eye.yz = eye.yz * cameraRadius * rotate2d( mix(PI, 0.0, mouseUV.y) );\\n    eye.xz = eye.xz * rotate2d( mix(-PI, PI, mouseUV.x) ) \\n                + vec2(lookAt.x, lookAt.z);\\n    \\n    vec3 rayDir = camera(eye, lookAt) * normalize(vec3(uv,-1));// ray direction\\n    \\n    Surface co = rayMarch(eye, rayDir, MIN_DIST, MAX_DIST);// closest object\\n    \\n    if(co.sd > MAX_DIST){\\n        col = backgroundColor;  // ray didn't hit anything\\n    }\\n    else{\\n        vec3 p = eye + rayDir*co.sd;  // point from ray marching\\n        vec3 normal = calcNormal(p);\\n        \\n        col = lighting(p, normal, eye, co.mat);\\n    }\\n    \\n    gl_FragColor = vec4(col, 1.0);\\n    return;\\n    }\\n  \");\n};","map":{"version":3,"names":["React","useEffect","useState","operators","usePrimitivesHook","fs","sdf","primitives"],"sources":["C:/Users/daniz/TFG/Aplicacion/src/ShaderStuff/sdfShader.js"],"sourcesContent":["import React, { useEffect, useState } from 'react';\r\nimport { operators } from './operators';\r\nimport usePrimitivesHook from '../primitivesHook';\r\n\r\nexport const fs = (sdf, primitives) => {\r\n  return  `\r\n    #ifdef GL_ES\r\n    precision mediump float;\r\n    #endif\r\n\r\n    uniform vec2 u_resolution;\r\n    uniform vec2 u_mouse;\r\n    uniform vec3 u_specular;\r\n    uniform vec3 u_diffuse;\r\n    uniform vec3 u_ambient;\r\n    uniform float u_smoothness;\r\n\r\n    // Constants\r\n    const int MAX_MARCHING_STEPS=255;\r\n    const float MIN_DIST=0.;\r\n    const float MAX_DIST=100.;\r\n    const float PRECISION=.0001;\r\n    const float EPSILON=.0005;\r\n    const float PI=3.14159265359;\r\n\r\n    struct Material\r\n    {\r\n    vec3 specular;\r\n    vec3 diffuse;\r\n    vec3 ambient;\r\n    float smoothness;\r\n    };\r\n\r\n    struct Surface{\r\n    float sd;// signed distance value\r\n    Material mat;\r\n    };\r\n\r\n    // Rotate around a circular path\r\n    mat2 rotate2d(float theta){\r\n    float s = sin(theta),c=cos(theta);\r\n    return mat2(c,-s,s,c);\r\n    }\r\n\r\n    // Rotation matrix around the X axis.\r\n    mat3 rotateX(float theta){\r\n    float c=cos(theta);\r\n    float s=sin(theta);\r\n    return mat3(\r\n        vec3(1.,0.,0.),\r\n        vec3(0.,c,-s),\r\n        vec3(0.,s,c)\r\n    );\r\n    }\r\n\r\n    // Rotation matrix around the Y axis.\r\n    mat3 rotateY(float theta){\r\n    float c=cos(theta);\r\n    float s=sin(theta);\r\n    return mat3(\r\n        vec3(c,0.,s),\r\n        vec3(0.,1.,0.),\r\n        vec3(-s,0.,c)\r\n    );\r\n    }\r\n\r\n    // Rotation matrix around the Z axis.\r\n    mat3 rotateZ(float theta){\r\n    float c=cos(theta);\r\n    float s=sin(theta);\r\n    return mat3(\r\n        vec3(c,-s,0.),\r\n        vec3(s,c,0.),\r\n        vec3(0.,0.,1.)\r\n    );\r\n    }\r\n\r\n    // Identity matrix.\r\n    mat3 identity(){\r\n    return mat3(\r\n        vec3(1,0,0),\r\n        vec3(0,1,0),\r\n        vec3(0,0,1)\r\n    );\r\n    }\r\n\r\n    ${operators()}\r\n\r\n    Surface minWithColor(Surface obj1,Surface obj2){\r\n        if(obj2.sd<obj1.sd) return obj2;\r\n        return obj1;\r\n    }\r\n\r\n    float f(vec3 p)                                 \r\n    {\r\n        float x = p.r;\r\n        float y = p.g;\r\n        float z = p.b;\r\n\r\n        return ${sdf};\r\n    } \r\n\r\n    Surface map(vec3 p){\r\n        Material mat = Material(u_specular, u_diffuse, u_ambient, u_smoothness);\r\n        float sphere = f(p);\r\n        \r\n        Surface co = Surface(sphere, mat);\r\n        \r\n        return co;\r\n    }\r\n\r\n    vec3 grad( in vec3 p )\r\n    {\r\n    return vec3(\r\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\r\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\r\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\r\n    );\r\n    }\r\n\r\n    mat3 camera(vec3 cameraPos,vec3 lookAtPoint){\r\n    vec3 cd = normalize(lookAtPoint-cameraPos);      // camera direction\r\n    vec3 cr = normalize(cross(vec3(0.,1.,0.),cd)); // camera right\r\n    vec3 cu = normalize(cross(cd,cr));               // camera up\r\n    \r\n    return mat3(-cr,cu,-cd);\r\n    }\r\n\r\n    Surface rayMarch(vec3 ro,vec3 rd,float start,float end){\r\n    float depth = start;\r\n    Surface co; // closest object\r\n    \r\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\r\n        vec3 p = ro + depth*rd;\r\n        co = map(p);\r\n        depth += co.sd;\r\n        if(co.sd<PRECISION||depth>end)  break;\r\n    }\r\n    \r\n    co.sd = depth;\r\n    \r\n    return co;\r\n    }\r\n\r\n    vec3 lighting(vec3 p,vec3 n,vec3 eye,Material mat){\r\n    vec3 ambient = vec3(.5);\r\n    \r\n    vec3 lights_pos[2];\r\n    lights_pos[0] = vec3(4.,2.,2.);\r\n    lights_pos[1] = vec3(-4.,-2.,-2.);\r\n    \r\n    vec3 lights_color[2];\r\n    lights_color[0] = vec3(1.,1.,1.);\r\n    lights_color[1] = vec3(1.,1.,1.);\r\n    \r\n    vec3 Ip = mat.ambient*ambient;\r\n    \r\n    for(int i=0;i<2;i++){\r\n        vec3 Lm = normalize(lights_pos[i] - p);\r\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm); // reflect(-Lm, n)\r\n        vec3 V  = normalize(eye - p);\r\n        \r\n        float LN = dot(Lm,n);\r\n        float RV = dot(Rm,V);\r\n        \r\n        if(LN<0.) // Light not visible\r\n        Ip+=vec3(0.,0.,0.);\r\n        else if(RV<0.)// opposite direction as viewer, apply only diffuse\r\n        Ip+=lights_color[i]*(mat.diffuse*LN);\r\n        else\r\n        Ip+=lights_color[i]*(mat.diffuse*LN+mat.specular*pow(RV,mat.smoothness));\r\n    }\r\n    \r\n    return Ip;\r\n    }\r\n\r\n    vec3 calcNormal(in vec3 p){\r\n    return normalize(vec3(\r\n        map(vec3(p.x+EPSILON,p.y,p.z)).sd - map(vec3(p.x-EPSILON,p.y,p.z)).sd,\r\n        map(vec3(p.x,p.y+EPSILON,p.z)).sd - map(vec3(p.x,p.y-EPSILON,p.z)).sd,\r\n        map(vec3(p.x,p.y,p.z+EPSILON)).sd - map(vec3(p.x,p.y,p.z-EPSILON)).sd\r\n    ));\r\n    }\r\n    \r\n    void main()\r\n    {\r\n    vec2 uv = (gl_FragCoord.xy - 0.5*u_resolution.xy) / u_resolution.y;\r\n    vec2 mouseUV = u_mouse.xy/u_resolution.xy;  // [0,1]\r\n\r\n    vec3 backgroundColor = vec3(.835, 1.0, 1.0);\r\n    vec3 col    = vec3(0.0);\r\n    \r\n    vec3 lookAt = vec3(0.0);\r\n    vec3 eye    = vec3(0,5,0);\r\n\r\n    float cameraRadius = 2.0;\r\n    eye.yz = eye.yz * cameraRadius * rotate2d( mix(PI, 0.0, mouseUV.y) );\r\n    eye.xz = eye.xz * rotate2d( mix(-PI, PI, mouseUV.x) ) \r\n                + vec2(lookAt.x, lookAt.z);\r\n    \r\n    vec3 rayDir = camera(eye, lookAt) * normalize(vec3(uv,-1));// ray direction\r\n    \r\n    Surface co = rayMarch(eye, rayDir, MIN_DIST, MAX_DIST);// closest object\r\n    \r\n    if(co.sd > MAX_DIST){\r\n        col = backgroundColor;  // ray didn't hit anything\r\n    }\r\n    else{\r\n        vec3 p = eye + rayDir*co.sd;  // point from ray marching\r\n        vec3 normal = calcNormal(p);\r\n        \r\n        col = lighting(p, normal, eye, co.mat);\r\n    }\r\n    \r\n    gl_FragColor = vec4(col, 1.0);\r\n    return;\r\n    }\r\n  `;\r\n};\r\n"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,QAA2C,OAA3C;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,OAAOC,iBAAP,MAA8B,mBAA9B;AAEA,OAAO,IAAMC,EAAE,GAAG,SAALA,EAAK,CAACC,GAAD,EAAMC,UAAN,EAAqB;EACrC,qpDAiFIJ,SAAS,EAjFb,sSA8FeG,GA9Ff;AAqND,CAtNM"},"metadata":{},"sourceType":"module"}