{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = updateScrollIndexHelper;\n\nvar _ScalingCellSizeAndPositionManager = _interopRequireDefault(require(\"./ScalingCellSizeAndPositionManager.js\"));\n\nvar _types = require(\"../types\");\n\nfunction updateScrollIndexHelper(_ref) {\n  var cellSize = _ref.cellSize,\n      cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,\n      previousCellsCount = _ref.previousCellsCount,\n      previousCellSize = _ref.previousCellSize,\n      previousScrollToAlignment = _ref.previousScrollToAlignment,\n      previousScrollToIndex = _ref.previousScrollToIndex,\n      previousSize = _ref.previousSize,\n      scrollOffset = _ref.scrollOffset,\n      scrollToAlignment = _ref.scrollToAlignment,\n      scrollToIndex = _ref.scrollToIndex,\n      size = _ref.size,\n      sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,\n      updateScrollIndexCallback = _ref.updateScrollIndexCallback;\n  var cellCount = cellSizeAndPositionManager.getCellCount();\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize; // If we have a new scroll target OR if height/row-height has changed,\n  // We should ensure that the scroll target is visible.\n\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\n    updateScrollIndexCallback(scrollToIndex); // If we don't have a selected item but list size or number of children have decreased,\n    // Make sure we aren't scrolled too far past the current content.\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\n    // We need to ensure that the current scroll offset is still within the collection's range.\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\n    // Just check to make sure we're still okay.\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\n      updateScrollIndexCallback(cellCount - 1);\n    }\n  }\n}","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","updateScrollIndexHelper","_ScalingCellSizeAndPositionManager","_types","_ref","cellSize","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToAlignment","scrollToIndex","size","sizeJustIncreasedFromZero","updateScrollIndexCallback","cellCount","getCellCount","hasScrollToIndex","sizeHasChanged","getTotalSize"],"sources":["G:/gitlab/TFG/Aplicacion/node_modules/rsuite/node_modules/react-virtualized/dist/commonjs/Grid/utils/updateScrollIndexHelper.js"],"sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports[\"default\"] = updateScrollIndexHelper;\r\n\r\nvar _ScalingCellSizeAndPositionManager = _interopRequireDefault(require(\"./ScalingCellSizeAndPositionManager.js\"));\r\n\r\nvar _types = require(\"../types\");\r\n\r\nfunction updateScrollIndexHelper(_ref) {\r\n  var cellSize = _ref.cellSize,\r\n      cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,\r\n      previousCellsCount = _ref.previousCellsCount,\r\n      previousCellSize = _ref.previousCellSize,\r\n      previousScrollToAlignment = _ref.previousScrollToAlignment,\r\n      previousScrollToIndex = _ref.previousScrollToIndex,\r\n      previousSize = _ref.previousSize,\r\n      scrollOffset = _ref.scrollOffset,\r\n      scrollToAlignment = _ref.scrollToAlignment,\r\n      scrollToIndex = _ref.scrollToIndex,\r\n      size = _ref.size,\r\n      sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,\r\n      updateScrollIndexCallback = _ref.updateScrollIndexCallback;\r\n  var cellCount = cellSizeAndPositionManager.getCellCount();\r\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\r\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize; // If we have a new scroll target OR if height/row-height has changed,\r\n  // We should ensure that the scroll target is visible.\r\n\r\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\r\n    updateScrollIndexCallback(scrollToIndex); // If we don't have a selected item but list size or number of children have decreased,\r\n    // Make sure we aren't scrolled too far past the current content.\r\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\r\n    // We need to ensure that the current scroll offset is still within the collection's range.\r\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\r\n    // Just check to make sure we're still okay.\r\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\r\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\r\n      updateScrollIndexCallback(cellCount - 1);\r\n    }\r\n  }\r\n}"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,uBAArB;;AAEA,IAAIC,kCAAkC,GAAGP,sBAAsB,CAACC,OAAO,CAAC,wCAAD,CAAR,CAA/D;;AAEA,IAAIO,MAAM,GAAGP,OAAO,CAAC,UAAD,CAApB;;AAEA,SAASK,uBAAT,CAAiCG,IAAjC,EAAuC;EACrC,IAAIC,QAAQ,GAAGD,IAAI,CAACC,QAApB;EAAA,IACIC,0BAA0B,GAAGF,IAAI,CAACE,0BADtC;EAAA,IAEIC,kBAAkB,GAAGH,IAAI,CAACG,kBAF9B;EAAA,IAGIC,gBAAgB,GAAGJ,IAAI,CAACI,gBAH5B;EAAA,IAIIC,yBAAyB,GAAGL,IAAI,CAACK,yBAJrC;EAAA,IAKIC,qBAAqB,GAAGN,IAAI,CAACM,qBALjC;EAAA,IAMIC,YAAY,GAAGP,IAAI,CAACO,YANxB;EAAA,IAOIC,YAAY,GAAGR,IAAI,CAACQ,YAPxB;EAAA,IAQIC,iBAAiB,GAAGT,IAAI,CAACS,iBAR7B;EAAA,IASIC,aAAa,GAAGV,IAAI,CAACU,aATzB;EAAA,IAUIC,IAAI,GAAGX,IAAI,CAACW,IAVhB;EAAA,IAWIC,yBAAyB,GAAGZ,IAAI,CAACY,yBAXrC;EAAA,IAYIC,yBAAyB,GAAGb,IAAI,CAACa,yBAZrC;EAaA,IAAIC,SAAS,GAAGZ,0BAA0B,CAACa,YAA3B,EAAhB;EACA,IAAIC,gBAAgB,GAAGN,aAAa,IAAI,CAAjB,IAAsBA,aAAa,GAAGI,SAA7D;EACA,IAAIG,cAAc,GAAGN,IAAI,KAAKJ,YAAT,IAAyBK,yBAAzB,IAAsD,CAACR,gBAAvD,IAA2E,OAAOH,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAKG,gBAA7I,CAhBqC,CAgB0H;EAC/J;;EAEA,IAAIY,gBAAgB,KAAKC,cAAc,IAAIR,iBAAiB,KAAKJ,yBAAxC,IAAqEK,aAAa,KAAKJ,qBAA5F,CAApB,EAAwI;IACtIO,yBAAyB,CAACH,aAAD,CAAzB,CADsI,CAC5F;IAC1C;EACD,CAHD,MAGO,IAAI,CAACM,gBAAD,IAAqBF,SAAS,GAAG,CAAjC,KAAuCH,IAAI,GAAGJ,YAAP,IAAuBO,SAAS,GAAGX,kBAA1E,CAAJ,EAAmG;IACxG;IACA;IACA;IACA;IACA,IAAIK,YAAY,GAAGN,0BAA0B,CAACgB,YAA3B,KAA4CP,IAA/D,EAAqE;MACnEE,yBAAyB,CAACC,SAAS,GAAG,CAAb,CAAzB;IACD;EACF;AACF"},"metadata":{},"sourceType":"script"}