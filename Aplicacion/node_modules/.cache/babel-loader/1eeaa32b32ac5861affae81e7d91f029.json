{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nthroot = void 0;\nvar Utils_1 = require(\"../../../Core/Utils\");\nvar abs_1 = require(\"./abs\");\nvar Frac_1 = require(\"../../../Types/Frac\");\nvar Math2_1 = require(\"../../Math2\");\nvar Symbol_1 = require(\"../../../Types/Symbol\");\nvar Errors_1 = require(\"../../../Core/Errors\");\nvar index_1 = require(\"../index\");\nvar Groups_1 = require(\"../../../Types/Groups\");\nvar Parser_1 = require(\"../../../Parser/Parser\");\n/**\n *\n * @param {Symbol} num - the number being raised\n * @param {Symbol} p - the exponent\n * @param {type} prec - the precision wanted\n * @param {bool} asbig - true if a bigDecimal is wanted\n * @returns {Symbol}\n */\nfunction nthroot(num, p, prec, asbig) {\n  //clone p and convert to a number if possible\n  p = (0, Parser_1.evaluate)((0, Parser_1.parse)(p));\n  //cannot calculate if p = 0. nthroot(0, 0) => 0^(1/0) => undefined\n  if (p.equals(0)) {\n    throw new Errors_1.UndefinedError('Unable to calculate nthroots of zero');\n  }\n  //Stop computation if it negative and even since we have an imaginary result\n  if (num < 0 && (0, Utils_1.even)(p)) throw new Error('Cannot calculate nthroot of negative number for even powers');\n  //return non numeric values unevaluated\n  if (!num.isConstant(true)) {\n    return (0, Symbol_1.symfunction)('nthroot', arguments);\n  }\n  //evaluate numeric values\n  if (num.group !== Groups_1.Groups.N) {\n    num = (0, Parser_1.evaluate)(num);\n  }\n  //default is to return a big value\n  if (typeof asbig === 'undefined') asbig = true;\n  prec = prec || 25;\n  var sign = num.sign();\n  var ans;\n  if (sign < 0) {\n    num = (0, abs_1.abs)(num); //remove the sign\n  }\n\n  if ((0, Utils_1.isInt)(num) && p.isConstant()) {\n    if (num < 18446744073709551616) {\n      //2^64\n      ans = Frac_1.Frac.create(Math.pow(num, 1 / p));\n    } else {\n      ans = Math2_1.Math2.nthroot(num, p);\n    }\n    var retval;\n    if (asbig) {\n      // FIXME: unused retval\n      retval = new Symbol_1.Symbol(ans);\n    }\n    retval = new Symbol_1.Symbol(ans.toDecimal(prec));\n    return (0, index_1.multiply)(new Symbol_1.Symbol(sign), retval);\n  }\n}\nexports.nthroot = nthroot;","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA,SAAgBA,OAAO,CAACC,GAAG,EAAEC,CAAC,EAAEC,IAAI,EAAEC,KAAK;EACvC;EACAF,CAAC,GAAG,qBAAQ,EAAC,kBAAK,EAACA,CAAC,CAAC,CAAC;EAEtB;EACA,IAAIA,CAAC,CAACG,MAAM,CAAC,CAAC,CAAC,EAAE;IACb,MAAM,IAAIC,uBAAc,CAAC,sCAAsC,CAAC;;EAGpE;EACA,IAAIL,GAAG,GAAG,CAAC,IAAI,gBAAI,EAACC,CAAC,CAAC,EAClB,MAAM,IAAIK,KAAK,CAAC,6DAA6D,CAAC;EAElF;EACA,IAAI,CAACN,GAAG,CAACO,UAAU,CAAC,IAAI,CAAC,EAAE;IACvB,OAAO,wBAAW,EAAC,SAAS,EAAEC,SAAS,CAAC;;EAG5C;EACA,IAAIR,GAAG,CAACS,KAAK,KAAKC,eAAM,CAACC,CAAC,EAAE;IACxBX,GAAG,GAAG,qBAAQ,EAACA,GAAG,CAAC;;EAGvB;EACA,IAAI,OAAOG,KAAK,KAAK,WAAW,EAC5BA,KAAK,GAAG,IAAI;EAEhBD,IAAI,GAAGA,IAAI,IAAI,EAAE;EAEjB,IAAIU,IAAI,GAAGZ,GAAG,CAACY,IAAI,EAAE;EACrB,IAAIC,GAAG;EAEP,IAAID,IAAI,GAAG,CAAC,EAAE;IACVZ,GAAG,GAAG,aAAG,EAACA,GAAG,CAAC,CAAC,CAAC;;;EAGpB,IAAI,iBAAK,EAACA,GAAG,CAAC,IAAIC,CAAC,CAACM,UAAU,EAAE,EAAE;IAE9B,IAAIP,GAAG,GAAG,oBAAoB,EAAE;MAC5B;MACAa,GAAG,GAAGC,WAAI,CAACC,MAAM,CAACC,IAAI,CAACC,GAAG,CAACjB,GAAG,EAAE,CAAC,GAAGC,CAAC,CAAC,CAAC;KAC1C,MACI;MACDY,GAAG,GAAGK,aAAK,CAACnB,OAAO,CAACC,GAAG,EAAEC,CAAC,CAAC;;IAG/B,IAAIkB,MAAM;IACV,IAAIhB,KAAK,EAAE;MACP;MACAgB,MAAM,GAAG,IAAIC,eAAM,CAACP,GAAG,CAAC;;IAE5BM,MAAM,GAAG,IAAIC,eAAM,CAACP,GAAG,CAACQ,SAAS,CAACnB,IAAI,CAAC,CAAC;IAExC,OAAO,oBAAQ,EAAC,IAAIkB,eAAM,CAACR,IAAI,CAAC,EAAEO,MAAM,CAAC;;AAEjD;AAvDAG","names":["nthroot","num","p","prec","asbig","equals","Errors_1","Error","isConstant","arguments","group","Groups_1","N","sign","ans","Frac_1","create","Math","pow","Math2_1","retval","Symbol_1","toDecimal","exports"],"sourceRoot":"","sources":["../../../../src/Functions/Core/math/nthroot.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}