{"ast":null,"code":"import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { getOperator } from '../../expression/operators.js';\nimport { createUtil } from './simplify/util.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['typed', 'parse', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      parse = _ref.parse,\n      equal = _ref.equal,\n      isZero = _ref.isZero,\n      add = _ref.add,\n      subtract = _ref.subtract,\n      multiply = _ref.multiply,\n      divide = _ref.divide,\n      pow = _ref.pow,\n      AccessorNode = _ref.AccessorNode,\n      ArrayNode = _ref.ArrayNode,\n      ConstantNode = _ref.ConstantNode,\n      FunctionNode = _ref.FunctionNode,\n      IndexNode = _ref.IndexNode,\n      ObjectNode = _ref.ObjectNode,\n      OperatorNode = _ref.OperatorNode,\n      ParenthesisNode = _ref.ParenthesisNode,\n      SymbolNode = _ref.SymbolNode;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  var nodeT = new ConstantNode(true);\n  var nodeF = new ConstantNode(false); // test if a node will always have a boolean value (true/false)\n  // not sure if this list is complete\n\n  function isAlwaysBoolean(node) {\n    return isOperatorNode(node) && ['and', 'not', 'or'].includes(node.op);\n  }\n\n  var _createUtil = createUtil({\n    FunctionNode: FunctionNode,\n    OperatorNode: OperatorNode,\n    SymbolNode: SymbolNode\n  }),\n      hasProperty = _createUtil.hasProperty,\n      isCommutative = _createUtil.isCommutative;\n  /**\r\n   * simplifyCore() performs single pass simplification suitable for\r\n   * applications requiring ultimate performance. To roughly summarize,\r\n   * it handles cases along the lines of simplifyConstant() but where\r\n   * knowledge of a single argument is sufficient to determine the value.\r\n   * In contrast, simplify() extends simplifyCore() with additional passes\r\n   * to provide deeper simplification (such as gathering like terms).\r\n   *\r\n   * Specifically, simplifyCore:\r\n   *\r\n   * * Converts all function calls with operator equivalents to their\r\n   *   operator forms.\r\n   * * Removes operators or function calls that are guaranteed to have no\r\n   *   effect (such as unary '+').\r\n   * * Removes double unary '-', '~', and 'not'\r\n   * * Eliminates addition/subtraction of 0 and multiplication/division/powers\r\n   *   by 1 or 0.\r\n   * * Converts addition of a negation into subtraction.\r\n   * * Eliminates logical operations with constant true or false leading\r\n   *   arguments.\r\n   * * Puts constants on the left of a product, if multiplication is\r\n   *   considered commutative by the options (which is the default)\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     simplifyCore(expr)\r\n   *     simplifyCore(expr, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     const f = math.parse('2 * 1 * x ^ (1 - 0)')\r\n   *     math.simplifyCore(f)                          // Node \"2 * x\"\r\n   *     math.simplify('2 * 1 * x ^ (1 - 0)', [math.simplifyCore]) // Node \"2 * x\"\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, simplifyConstant, resolve, derivative\r\n   *\r\n   * @param {Node | string} node\r\n   *     The expression to be simplified\r\n   * @param {Object} options\r\n   *     Simplification options, as per simplify()\r\n   * @return {Node} Returns expression with basic simplifications applied\r\n   */\n\n\n  function _simplifyCore(nodeToSimplify) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var context = options ? options.context : undefined;\n\n    if (hasProperty(nodeToSimplify, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {\n        return _simplifyCore(nodeToSimplify.args[0], options);\n      } // For other node types, we try the generic methods\n\n\n      var simpChild = false;\n      var childCount = 0;\n      nodeToSimplify.forEach(function (c) {\n        ++childCount;\n\n        if (childCount === 1) {\n          simpChild = _simplifyCore(c, options);\n        }\n      });\n\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n\n    var node = nodeToSimplify;\n\n    if (isFunctionNode(node)) {\n      var op = getOperator(node.name);\n\n      if (op) {\n        // Replace FunctionNode with a new OperatorNode\n        if (node.args.length > 2 && hasProperty(node, 'associative', context)) {\n          // unflatten into binary operations since that's what simplifyCore handles\n          while (node.args.length > 2) {\n            var last = node.args.pop();\n            var seclast = node.args.pop();\n            node.args.push(new OperatorNode(op, node.name, [last, seclast]));\n          }\n        }\n\n        node = new OperatorNode(op, node.name, node.args);\n      } else {\n        return new FunctionNode(_simplifyCore(node.fn), node.args.map(function (n) {\n          return _simplifyCore(n, options);\n        }));\n      }\n    }\n\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = _simplifyCore(node.args[0], options);\n\n      if (node.op === '~') {\n        // bitwise not\n        if (isOperatorNode(a0) && a0.isUnary() && a0.op === '~') {\n          return a0.args[0];\n        }\n      }\n\n      if (node.op === 'not') {\n        // logical not\n        if (isOperatorNode(a0) && a0.isUnary() && a0.op === 'not') {\n          // Has the effect of turning the argument into a boolean\n          // So can only eliminate the double negation if\n          // the inside is already boolean\n          if (isAlwaysBoolean(a0.args[0])) {\n            return a0.args[0];\n          }\n        }\n      }\n\n      var finish = true;\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isBinary() && a0.fn === 'subtract') {\n            node = new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n            finish = false; // continue to process the new binary node\n          }\n\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          }\n        }\n      }\n\n      if (finish) return new OperatorNode(node.op, node.fn, [a0]);\n    }\n\n    if (isOperatorNode(node) && node.isBinary()) {\n      var _a = _simplifyCore(node.args[0], options);\n\n      var a1 = _simplifyCore(node.args[1], options);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a) && isZero(_a.value)) {\n          return a1;\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          a1 = a1.args[0];\n          node = new OperatorNode('-', 'subtract', [_a, a1]);\n        }\n      }\n\n      if (node.op === '-') {\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return _simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n        }\n\n        if (isConstantNode(_a) && isZero(_a.value)) {\n          return _simplifyCore(new OperatorNode('-', 'unaryMinus', [a1]));\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n\n      if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          }\n\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      }\n\n      if (node.op === '/') {\n        if (isConstantNode(_a) && isZero(_a.value)) {\n          return node0;\n        }\n\n        if (isConstantNode(a1) && equal(a1.value, 1)) {\n          return _a;\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      }\n\n      if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          }\n        }\n      }\n\n      if (node.op === 'and') {\n        if (isConstantNode(_a)) {\n          if (_a.value) {\n            if (isAlwaysBoolean(a1)) return a1;\n          } else {\n            return nodeF;\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (a1.value) {\n            if (isAlwaysBoolean(_a)) return _a;\n          } else {\n            return nodeF;\n          }\n        }\n      }\n\n      if (node.op === 'or') {\n        if (isConstantNode(_a)) {\n          if (_a.value) {\n            return nodeT;\n          } else {\n            if (isAlwaysBoolean(a1)) return a1;\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (a1.value) {\n            return nodeT;\n          } else {\n            if (isAlwaysBoolean(_a)) return _a;\n          }\n        }\n      }\n\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    }\n\n    if (isOperatorNode(node)) {\n      return new OperatorNode(node.op, node.fn, node.args.map(function (a) {\n        return _simplifyCore(a, options);\n      }));\n    }\n\n    if (isArrayNode(node)) {\n      return new ArrayNode(node.items.map(function (n) {\n        return _simplifyCore(n, options);\n      }));\n    }\n\n    if (isAccessorNode(node)) {\n      return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));\n    }\n\n    if (isIndexNode(node)) {\n      return new IndexNode(node.dimensions.map(function (n) {\n        return _simplifyCore(n, options);\n      }));\n    }\n\n    if (isObjectNode(node)) {\n      var newProps = {};\n\n      for (var prop in node.properties) {\n        newProps[prop] = _simplifyCore(node.properties[prop], options);\n      }\n\n      return new ObjectNode(newProps);\n    } // cannot simplify\n\n\n    return node;\n  }\n\n  return typed(name, {\n    Node: _simplifyCore,\n    'Node,Object': _simplifyCore\n  });\n});","map":{"version":3,"names":["isAccessorNode","isArrayNode","isConstantNode","isFunctionNode","isIndexNode","isObjectNode","isOperatorNode","getOperator","createUtil","factory","name","dependencies","createSimplifyCore","_ref","typed","parse","equal","isZero","add","subtract","multiply","divide","pow","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode","node0","node1","nodeT","nodeF","isAlwaysBoolean","node","includes","op","hasProperty","isCommutative","_simplifyCore","nodeToSimplify","options","arguments","length","undefined","context","args","simpChild","childCount","forEach","c","last","pop","seclast","push","fn","map","n","isUnary","a0","finish","isBinary","_a","a1","value","implicit","a","items","object","index","dimensions","newProps","prop","properties","Node"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js"],"sourcesContent":["import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\r\nimport { getOperator } from '../../expression/operators.js';\r\nimport { createUtil } from './simplify/util.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'simplifyCore';\r\nvar dependencies = ['typed', 'parse', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\r\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    parse,\r\n    equal,\r\n    isZero,\r\n    add,\r\n    subtract,\r\n    multiply,\r\n    divide,\r\n    pow,\r\n    AccessorNode,\r\n    ArrayNode,\r\n    ConstantNode,\r\n    FunctionNode,\r\n    IndexNode,\r\n    ObjectNode,\r\n    OperatorNode,\r\n    ParenthesisNode,\r\n    SymbolNode\r\n  } = _ref;\r\n  var node0 = new ConstantNode(0);\r\n  var node1 = new ConstantNode(1);\r\n  var nodeT = new ConstantNode(true);\r\n  var nodeF = new ConstantNode(false); // test if a node will always have a boolean value (true/false)\r\n  // not sure if this list is complete\r\n\r\n  function isAlwaysBoolean(node) {\r\n    return isOperatorNode(node) && ['and', 'not', 'or'].includes(node.op);\r\n  }\r\n\r\n  var {\r\n    hasProperty,\r\n    isCommutative\r\n  } = createUtil({\r\n    FunctionNode,\r\n    OperatorNode,\r\n    SymbolNode\r\n  });\r\n  /**\r\n   * simplifyCore() performs single pass simplification suitable for\r\n   * applications requiring ultimate performance. To roughly summarize,\r\n   * it handles cases along the lines of simplifyConstant() but where\r\n   * knowledge of a single argument is sufficient to determine the value.\r\n   * In contrast, simplify() extends simplifyCore() with additional passes\r\n   * to provide deeper simplification (such as gathering like terms).\r\n   *\r\n   * Specifically, simplifyCore:\r\n   *\r\n   * * Converts all function calls with operator equivalents to their\r\n   *   operator forms.\r\n   * * Removes operators or function calls that are guaranteed to have no\r\n   *   effect (such as unary '+').\r\n   * * Removes double unary '-', '~', and 'not'\r\n   * * Eliminates addition/subtraction of 0 and multiplication/division/powers\r\n   *   by 1 or 0.\r\n   * * Converts addition of a negation into subtraction.\r\n   * * Eliminates logical operations with constant true or false leading\r\n   *   arguments.\r\n   * * Puts constants on the left of a product, if multiplication is\r\n   *   considered commutative by the options (which is the default)\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     simplifyCore(expr)\r\n   *     simplifyCore(expr, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     const f = math.parse('2 * 1 * x ^ (1 - 0)')\r\n   *     math.simplifyCore(f)                          // Node \"2 * x\"\r\n   *     math.simplify('2 * 1 * x ^ (1 - 0)', [math.simplifyCore]) // Node \"2 * x\"\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, simplifyConstant, resolve, derivative\r\n   *\r\n   * @param {Node | string} node\r\n   *     The expression to be simplified\r\n   * @param {Object} options\r\n   *     Simplification options, as per simplify()\r\n   * @return {Node} Returns expression with basic simplifications applied\r\n   */\r\n\r\n  function _simplifyCore(nodeToSimplify) {\r\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    var context = options ? options.context : undefined;\r\n\r\n    if (hasProperty(nodeToSimplify, 'trivial', context)) {\r\n      // This node does nothing if it has only one argument, so if so,\r\n      // return that argument simplified\r\n      if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {\r\n        return _simplifyCore(nodeToSimplify.args[0], options);\r\n      } // For other node types, we try the generic methods\r\n\r\n\r\n      var simpChild = false;\r\n      var childCount = 0;\r\n      nodeToSimplify.forEach(c => {\r\n        ++childCount;\r\n\r\n        if (childCount === 1) {\r\n          simpChild = _simplifyCore(c, options);\r\n        }\r\n      });\r\n\r\n      if (childCount === 1) {\r\n        return simpChild;\r\n      }\r\n    }\r\n\r\n    var node = nodeToSimplify;\r\n\r\n    if (isFunctionNode(node)) {\r\n      var op = getOperator(node.name);\r\n\r\n      if (op) {\r\n        // Replace FunctionNode with a new OperatorNode\r\n        if (node.args.length > 2 && hasProperty(node, 'associative', context)) {\r\n          // unflatten into binary operations since that's what simplifyCore handles\r\n          while (node.args.length > 2) {\r\n            var last = node.args.pop();\r\n            var seclast = node.args.pop();\r\n            node.args.push(new OperatorNode(op, node.name, [last, seclast]));\r\n          }\r\n        }\r\n\r\n        node = new OperatorNode(op, node.name, node.args);\r\n      } else {\r\n        return new FunctionNode(_simplifyCore(node.fn), node.args.map(n => _simplifyCore(n, options)));\r\n      }\r\n    }\r\n\r\n    if (isOperatorNode(node) && node.isUnary()) {\r\n      var a0 = _simplifyCore(node.args[0], options);\r\n\r\n      if (node.op === '~') {\r\n        // bitwise not\r\n        if (isOperatorNode(a0) && a0.isUnary() && a0.op === '~') {\r\n          return a0.args[0];\r\n        }\r\n      }\r\n\r\n      if (node.op === 'not') {\r\n        // logical not\r\n        if (isOperatorNode(a0) && a0.isUnary() && a0.op === 'not') {\r\n          // Has the effect of turning the argument into a boolean\r\n          // So can only eliminate the double negation if\r\n          // the inside is already boolean\r\n          if (isAlwaysBoolean(a0.args[0])) {\r\n            return a0.args[0];\r\n          }\r\n        }\r\n      }\r\n\r\n      var finish = true;\r\n\r\n      if (node.op === '-') {\r\n        // unary minus\r\n        if (isOperatorNode(a0)) {\r\n          if (a0.isBinary() && a0.fn === 'subtract') {\r\n            node = new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\r\n            finish = false; // continue to process the new binary node\r\n          }\r\n\r\n          if (a0.isUnary() && a0.op === '-') {\r\n            return a0.args[0];\r\n          }\r\n        }\r\n      }\r\n\r\n      if (finish) return new OperatorNode(node.op, node.fn, [a0]);\r\n    }\r\n\r\n    if (isOperatorNode(node) && node.isBinary()) {\r\n      var _a = _simplifyCore(node.args[0], options);\r\n\r\n      var a1 = _simplifyCore(node.args[1], options);\r\n\r\n      if (node.op === '+') {\r\n        if (isConstantNode(_a) && isZero(_a.value)) {\r\n          return a1;\r\n        }\r\n\r\n        if (isConstantNode(a1) && isZero(a1.value)) {\r\n          return _a;\r\n        }\r\n\r\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\r\n          a1 = a1.args[0];\r\n          node = new OperatorNode('-', 'subtract', [_a, a1]);\r\n        }\r\n      }\r\n\r\n      if (node.op === '-') {\r\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\r\n          return _simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\r\n        }\r\n\r\n        if (isConstantNode(_a) && isZero(_a.value)) {\r\n          return _simplifyCore(new OperatorNode('-', 'unaryMinus', [a1]));\r\n        }\r\n\r\n        if (isConstantNode(a1) && isZero(a1.value)) {\r\n          return _a;\r\n        }\r\n\r\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\r\n      }\r\n\r\n      if (node.op === '*') {\r\n        if (isConstantNode(_a)) {\r\n          if (isZero(_a.value)) {\r\n            return node0;\r\n          } else if (equal(_a.value, 1)) {\r\n            return a1;\r\n          }\r\n        }\r\n\r\n        if (isConstantNode(a1)) {\r\n          if (isZero(a1.value)) {\r\n            return node0;\r\n          } else if (equal(a1.value, 1)) {\r\n            return _a;\r\n          }\r\n\r\n          if (isCommutative(node, context)) {\r\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\r\n          }\r\n        }\r\n\r\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\r\n      }\r\n\r\n      if (node.op === '/') {\r\n        if (isConstantNode(_a) && isZero(_a.value)) {\r\n          return node0;\r\n        }\r\n\r\n        if (isConstantNode(a1) && equal(a1.value, 1)) {\r\n          return _a;\r\n        }\r\n\r\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\r\n      }\r\n\r\n      if (node.op === '^') {\r\n        if (isConstantNode(a1)) {\r\n          if (isZero(a1.value)) {\r\n            return node1;\r\n          } else if (equal(a1.value, 1)) {\r\n            return _a;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (node.op === 'and') {\r\n        if (isConstantNode(_a)) {\r\n          if (_a.value) {\r\n            if (isAlwaysBoolean(a1)) return a1;\r\n          } else {\r\n            return nodeF;\r\n          }\r\n        }\r\n\r\n        if (isConstantNode(a1)) {\r\n          if (a1.value) {\r\n            if (isAlwaysBoolean(_a)) return _a;\r\n          } else {\r\n            return nodeF;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (node.op === 'or') {\r\n        if (isConstantNode(_a)) {\r\n          if (_a.value) {\r\n            return nodeT;\r\n          } else {\r\n            if (isAlwaysBoolean(a1)) return a1;\r\n          }\r\n        }\r\n\r\n        if (isConstantNode(a1)) {\r\n          if (a1.value) {\r\n            return nodeT;\r\n          } else {\r\n            if (isAlwaysBoolean(_a)) return _a;\r\n          }\r\n        }\r\n      }\r\n\r\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\r\n    }\r\n\r\n    if (isOperatorNode(node)) {\r\n      return new OperatorNode(node.op, node.fn, node.args.map(a => _simplifyCore(a, options)));\r\n    }\r\n\r\n    if (isArrayNode(node)) {\r\n      return new ArrayNode(node.items.map(n => _simplifyCore(n, options)));\r\n    }\r\n\r\n    if (isAccessorNode(node)) {\r\n      return new AccessorNode(_simplifyCore(node.object, options), _simplifyCore(node.index, options));\r\n    }\r\n\r\n    if (isIndexNode(node)) {\r\n      return new IndexNode(node.dimensions.map(n => _simplifyCore(n, options)));\r\n    }\r\n\r\n    if (isObjectNode(node)) {\r\n      var newProps = {};\r\n\r\n      for (var prop in node.properties) {\r\n        newProps[prop] = _simplifyCore(node.properties[prop], options);\r\n      }\r\n\r\n      return new ObjectNode(newProps);\r\n    } // cannot simplify\r\n\r\n\r\n    return node;\r\n  }\r\n\r\n  return typed(name, {\r\n    Node: _simplifyCore,\r\n    'Node,Object': _simplifyCore\r\n  });\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}