{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\daniz\\\\TFG\\\\Aplicacion\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var Node = _ref.Node;\n  /**\r\n   * Test whether a condition is met\r\n   * @param {*} condition\r\n   * @returns {boolean} true if condition is true or non-zero, else false\r\n   */\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n\n  var ConditionalNode = /*#__PURE__*/function (_Node) {\n    _inherits(ConditionalNode, _Node);\n\n    var _super = _createSuper(ConditionalNode);\n\n    /**\r\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\r\n     *\r\n     * @param {Node} condition   Condition, must result in a boolean\r\n     * @param {Node} trueExpr    Expression evaluated when condition is true\r\n     * @param {Node} falseExpr   Expression evaluated when condition is true\r\n     *\r\n     * @constructor ConditionalNode\r\n     * @extends {Node}\r\n     */\n    function ConditionalNode(condition, trueExpr, falseExpr) {\n      var _this;\n\n      _classCallCheck(this, ConditionalNode);\n\n      _this = _super.call(this);\n\n      if (!isNode(condition)) {\n        throw new TypeError('Parameter condition must be a Node');\n      }\n\n      if (!isNode(trueExpr)) {\n        throw new TypeError('Parameter trueExpr must be a Node');\n      }\n\n      if (!isNode(falseExpr)) {\n        throw new TypeError('Parameter falseExpr must be a Node');\n      }\n\n      _this.condition = condition;\n      _this.trueExpr = trueExpr;\n      _this.falseExpr = falseExpr;\n      return _this;\n    }\n\n    _createClass(ConditionalNode, [{\n      key: \"type\",\n      get: function get() {\n        return name;\n      }\n    }, {\n      key: \"isConditionalNode\",\n      get: function get() {\n        return true;\n      }\n      /**\r\n       * Compile a node into a JavaScript function.\r\n       * This basically pre-calculates as much as possible and only leaves open\r\n       * calculations which depend on a dynamic scope with variables.\r\n       * @param {Object} math     Math.js namespace with functions and constants.\r\n       * @param {Object} argNames An object with argument names as key and `true`\r\n       *                          as value. Used in the SymbolNode to optimize\r\n       *                          for arguments from user assigned functions\r\n       *                          (see FunctionAssignmentNode) or special symbols\r\n       *                          like `end` (see IndexNode).\r\n       * @return {function} Returns a function which can be called like:\r\n       *                        evalNode(scope: Object, args: Object, context: *)\r\n       */\n\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var evalCondition = this.condition._compile(math, argNames);\n\n        var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n        var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n        return function evalConditionalNode(scope, args, context) {\n          return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n        };\n      }\n      /**\r\n       * Execute a callback for each of the child nodes of this node\r\n       * @param {function(child: Node, path: string, parent: Node)} callback\r\n       */\n\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        callback(this.condition, 'condition', this);\n        callback(this.trueExpr, 'trueExpr', this);\n        callback(this.falseExpr, 'falseExpr', this);\n      }\n      /**\r\n       * Create a new ConditionalNode whose children are the results of calling\r\n       * the provided callback function for each child of the original node.\r\n       * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n       * @returns {ConditionalNode} Returns a transformed copy of the node\r\n       */\n\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n      }\n      /**\r\n       * Create a clone of this node, a shallow copy\r\n       * @return {ConditionalNode}\r\n       */\n\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n      }\n      /**\r\n       * Get string representation\r\n       * @param {Object} options\r\n       * @return {string} str\r\n       */\n\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\n        // or have lower or equal precedence\n        // NOTE: enclosing all OperatorNodes in parentheses is a decision\n        // purely based on aesthetics and readability\n\n        var condition = this.condition.toString(options);\n        var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n\n        if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n          condition = '(' + condition + ')';\n        }\n\n        var trueExpr = this.trueExpr.toString(options);\n        var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n\n        if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n          trueExpr = '(' + trueExpr + ')';\n        }\n\n        var falseExpr = this.falseExpr.toString(options);\n        var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n\n        if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n          falseExpr = '(' + falseExpr + ')';\n        }\n\n        return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n      }\n      /**\r\n       * Get a JSON representation of the node\r\n       * @returns {Object}\r\n       */\n\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: name,\n          condition: this.condition,\n          trueExpr: this.trueExpr,\n          falseExpr: this.falseExpr\n        };\n      }\n      /**\r\n       * Instantiate an ConditionalNode from its JSON representation\r\n       * @param {Object} json\r\n       *     An object structured like\r\n       *     ```\r\n       *     {\"mathjs\": \"ConditionalNode\",\r\n       *      \"condition\": ...,\r\n       *      \"trueExpr\": ...,\r\n       *      \"falseExpr\": ...}\r\n       *     ```\r\n       *     where mathjs is optional\r\n       * @returns {ConditionalNode}\r\n       */\n\n    }, {\n      key: \"toHTML\",\n      value:\n      /**\r\n       * Get HTML representation\r\n       * @param {Object} options\r\n       * @return {string} str\r\n       */\n      function toHTML(options) {\n        var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n        var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\n        // or have lower or equal precedence\n        // NOTE: enclosing all OperatorNodes in parentheses is a decision\n        // purely based on aesthetics and readability\n\n        var condition = this.condition.toHTML(options);\n        var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n\n        if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n          condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        var trueExpr = this.trueExpr.toHTML(options);\n        var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n\n        if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n          trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        var falseExpr = this.falseExpr.toHTML(options);\n        var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n\n        if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n          falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n      }\n      /**\r\n       * Get LaTeX representation\r\n       * @param {Object} options\r\n       * @return {string} str\r\n       */\n\n    }, {\n      key: \"_toTex\",\n      value: function _toTex(options) {\n        return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n      }\n    }], [{\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n      }\n    }]);\n\n    return ConditionalNode;\n  }(Node);\n\n  _defineProperty(ConditionalNode, \"name\", name);\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isBigNumber","isComplex","isNode","isUnit","typeOf","factory","getPrecedence","name","dependencies","createConditionalNode","_ref","Node","testCondition","condition","isZero","re","im","value","undefined","TypeError","ConditionalNode","trueExpr","falseExpr","math","argNames","evalCondition","_compile","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","callback","_ifNode","options","parenthesis","precedence","implicit","toString","conditionPrecedence","type","truePrecedence","falsePrecedence","mathjs","toHTML","toTex","json","isClass"],"sources":["C:/Users/daniz/TFG/Aplicacion/node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { getPrecedence } from '../operators.js';\r\nvar name = 'ConditionalNode';\r\nvar dependencies = ['Node'];\r\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n\r\n  /**\r\n   * Test whether a condition is met\r\n   * @param {*} condition\r\n   * @returns {boolean} true if condition is true or non-zero, else false\r\n   */\r\n  function testCondition(condition) {\r\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\r\n      return !!condition;\r\n    }\r\n\r\n    if (condition) {\r\n      if (isBigNumber(condition)) {\r\n        return !condition.isZero();\r\n      }\r\n\r\n      if (isComplex(condition)) {\r\n        return !!(condition.re || condition.im);\r\n      }\r\n\r\n      if (isUnit(condition)) {\r\n        return !!condition.value;\r\n      }\r\n    }\r\n\r\n    if (condition === null || condition === undefined) {\r\n      return false;\r\n    }\r\n\r\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\r\n  }\r\n\r\n  class ConditionalNode extends Node {\r\n    /**\r\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\r\n     *\r\n     * @param {Node} condition   Condition, must result in a boolean\r\n     * @param {Node} trueExpr    Expression evaluated when condition is true\r\n     * @param {Node} falseExpr   Expression evaluated when condition is true\r\n     *\r\n     * @constructor ConditionalNode\r\n     * @extends {Node}\r\n     */\r\n    constructor(condition, trueExpr, falseExpr) {\r\n      super();\r\n\r\n      if (!isNode(condition)) {\r\n        throw new TypeError('Parameter condition must be a Node');\r\n      }\r\n\r\n      if (!isNode(trueExpr)) {\r\n        throw new TypeError('Parameter trueExpr must be a Node');\r\n      }\r\n\r\n      if (!isNode(falseExpr)) {\r\n        throw new TypeError('Parameter falseExpr must be a Node');\r\n      }\r\n\r\n      this.condition = condition;\r\n      this.trueExpr = trueExpr;\r\n      this.falseExpr = falseExpr;\r\n    }\r\n\r\n    get type() {\r\n      return name;\r\n    }\r\n\r\n    get isConditionalNode() {\r\n      return true;\r\n    }\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n\r\n\r\n    _compile(math, argNames) {\r\n      var evalCondition = this.condition._compile(math, argNames);\r\n\r\n      var evalTrueExpr = this.trueExpr._compile(math, argNames);\r\n\r\n      var evalFalseExpr = this.falseExpr._compile(math, argNames);\r\n\r\n      return function evalConditionalNode(scope, args, context) {\r\n        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\r\n      };\r\n    }\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n\r\n\r\n    forEach(callback) {\r\n      callback(this.condition, 'condition', this);\r\n      callback(this.trueExpr, 'trueExpr', this);\r\n      callback(this.falseExpr, 'falseExpr', this);\r\n    }\r\n    /**\r\n     * Create a new ConditionalNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ConditionalNode} Returns a transformed copy of the node\r\n     */\r\n\r\n\r\n    map(callback) {\r\n      return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\r\n    }\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ConditionalNode}\r\n     */\r\n\r\n\r\n    clone() {\r\n      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\r\n    }\r\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n\r\n\r\n    _toString(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\r\n      // or have lower or equal precedence\r\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\r\n      // purely based on aesthetics and readability\r\n\r\n      var condition = this.condition.toString(options);\r\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\r\n\r\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\r\n        condition = '(' + condition + ')';\r\n      }\r\n\r\n      var trueExpr = this.trueExpr.toString(options);\r\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\r\n\r\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\r\n        trueExpr = '(' + trueExpr + ')';\r\n      }\r\n\r\n      var falseExpr = this.falseExpr.toString(options);\r\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\r\n\r\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\r\n        falseExpr = '(' + falseExpr + ')';\r\n      }\r\n\r\n      return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\r\n    }\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n\r\n\r\n    toJSON() {\r\n      return {\r\n        mathjs: name,\r\n        condition: this.condition,\r\n        trueExpr: this.trueExpr,\r\n        falseExpr: this.falseExpr\r\n      };\r\n    }\r\n    /**\r\n     * Instantiate an ConditionalNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     ```\r\n     *     {\"mathjs\": \"ConditionalNode\",\r\n     *      \"condition\": ...,\r\n     *      \"trueExpr\": ...,\r\n     *      \"falseExpr\": ...}\r\n     *     ```\r\n     *     where mathjs is optional\r\n     * @returns {ConditionalNode}\r\n     */\r\n\r\n\r\n    static fromJSON(json) {\r\n      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\r\n    }\r\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n\r\n\r\n    toHTML(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\r\n      // or have lower or equal precedence\r\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\r\n      // purely based on aesthetics and readability\r\n\r\n      var condition = this.condition.toHTML(options);\r\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\r\n\r\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\r\n        condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n\r\n      var trueExpr = this.trueExpr.toHTML(options);\r\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\r\n\r\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\r\n        trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n\r\n      var falseExpr = this.falseExpr.toHTML(options);\r\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\r\n\r\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\r\n        falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n\r\n      return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\r\n    }\r\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n\r\n\r\n    _toTex(options) {\r\n      return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\r\n    }\r\n\r\n  }\r\n\r\n  _defineProperty(ConditionalNode, \"name\", name);\r\n\r\n  return ConditionalNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"],"mappings":";;;;AAAA,OAAOA,eAAP,MAA4B,uCAA5B;AACA,SAASC,WAAT,EAAsBC,SAAtB,EAAiCC,MAAjC,EAAyCC,MAAzC,EAAiDC,MAAjD,QAA+D,mBAA/D;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,IAAIC,IAAI,GAAG,iBAAX;AACA,IAAIC,YAAY,GAAG,CAAC,MAAD,CAAnB;AACA,OAAO,IAAIC,qBAAqB,GAAG,eAAeJ,OAAO,CAACE,IAAD,EAAOC,YAAP,EAAqB,UAAAE,IAAI,EAAI;EACpF,IACEC,IADF,GAEID,IAFJ,CACEC,IADF;EAIA;AACF;AACA;AACA;AACA;;EACE,SAASC,aAAT,CAAuBC,SAAvB,EAAkC;IAChC,IAAI,OAAOA,SAAP,KAAqB,QAArB,IAAiC,OAAOA,SAAP,KAAqB,SAAtD,IAAmE,OAAOA,SAAP,KAAqB,QAA5F,EAAsG;MACpG,OAAO,CAAC,CAACA,SAAT;IACD;;IAED,IAAIA,SAAJ,EAAe;MACb,IAAIb,WAAW,CAACa,SAAD,CAAf,EAA4B;QAC1B,OAAO,CAACA,SAAS,CAACC,MAAV,EAAR;MACD;;MAED,IAAIb,SAAS,CAACY,SAAD,CAAb,EAA0B;QACxB,OAAO,CAAC,EAAEA,SAAS,CAACE,EAAV,IAAgBF,SAAS,CAACG,EAA5B,CAAR;MACD;;MAED,IAAIb,MAAM,CAACU,SAAD,CAAV,EAAuB;QACrB,OAAO,CAAC,CAACA,SAAS,CAACI,KAAnB;MACD;IACF;;IAED,IAAIJ,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKK,SAAxC,EAAmD;MACjD,OAAO,KAAP;IACD;;IAED,MAAM,IAAIC,SAAJ,CAAc,oCAAoCf,MAAM,CAACS,SAAD,CAA1C,GAAwD,GAAtE,CAAN;EACD;;EAlCmF,IAoC9EO,eApC8E;IAAA;;IAAA;;IAqClF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,yBAAYP,SAAZ,EAAuBQ,QAAvB,EAAiCC,SAAjC,EAA4C;MAAA;;MAAA;;MAC1C;;MAEA,IAAI,CAACpB,MAAM,CAACW,SAAD,CAAX,EAAwB;QACtB,MAAM,IAAIM,SAAJ,CAAc,oCAAd,CAAN;MACD;;MAED,IAAI,CAACjB,MAAM,CAACmB,QAAD,CAAX,EAAuB;QACrB,MAAM,IAAIF,SAAJ,CAAc,mCAAd,CAAN;MACD;;MAED,IAAI,CAACjB,MAAM,CAACoB,SAAD,CAAX,EAAwB;QACtB,MAAM,IAAIH,SAAJ,CAAc,oCAAd,CAAN;MACD;;MAED,MAAKN,SAAL,GAAiBA,SAAjB;MACA,MAAKQ,QAAL,GAAgBA,QAAhB;MACA,MAAKC,SAAL,GAAiBA,SAAjB;MAjB0C;IAkB3C;;IAjEiF;MAAA;MAAA,KAmElF,eAAW;QACT,OAAOf,IAAP;MACD;IArEiF;MAAA;MAAA,KAuElF,eAAwB;QACtB,OAAO,IAAP;MACD;MACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAtFsF;MAAA;MAAA,OAyFlF,kBAASgB,IAAT,EAAeC,QAAf,EAAyB;QACvB,IAAIC,aAAa,GAAG,KAAKZ,SAAL,CAAea,QAAf,CAAwBH,IAAxB,EAA8BC,QAA9B,CAApB;;QAEA,IAAIG,YAAY,GAAG,KAAKN,QAAL,CAAcK,QAAd,CAAuBH,IAAvB,EAA6BC,QAA7B,CAAnB;;QAEA,IAAII,aAAa,GAAG,KAAKN,SAAL,CAAeI,QAAf,CAAwBH,IAAxB,EAA8BC,QAA9B,CAApB;;QAEA,OAAO,SAASK,mBAAT,CAA6BC,KAA7B,EAAoCC,IAApC,EAA0CC,OAA1C,EAAmD;UACxD,OAAOpB,aAAa,CAACa,aAAa,CAACK,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAAd,CAAb,GAAqDL,YAAY,CAACG,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAAjE,GAA0FJ,aAAa,CAACE,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAA9G;QACD,CAFD;MAGD;MACD;AACJ;AACA;AACA;;IAvGsF;MAAA;MAAA,OA0GlF,iBAAQC,QAAR,EAAkB;QAChBA,QAAQ,CAAC,KAAKpB,SAAN,EAAiB,WAAjB,EAA8B,IAA9B,CAAR;QACAoB,QAAQ,CAAC,KAAKZ,QAAN,EAAgB,UAAhB,EAA4B,IAA5B,CAAR;QACAY,QAAQ,CAAC,KAAKX,SAAN,EAAiB,WAAjB,EAA8B,IAA9B,CAAR;MACD;MACD;AACJ;AACA;AACA;AACA;AACA;;IApHsF;MAAA;MAAA,OAuHlF,aAAIW,QAAJ,EAAc;QACZ,OAAO,IAAIb,eAAJ,CAAoB,KAAKc,OAAL,CAAaD,QAAQ,CAAC,KAAKpB,SAAN,EAAiB,WAAjB,EAA8B,IAA9B,CAArB,CAApB,EAA+E,KAAKqB,OAAL,CAAaD,QAAQ,CAAC,KAAKZ,QAAN,EAAgB,UAAhB,EAA4B,IAA5B,CAArB,CAA/E,EAAwI,KAAKa,OAAL,CAAaD,QAAQ,CAAC,KAAKX,SAAN,EAAiB,WAAjB,EAA8B,IAA9B,CAArB,CAAxI,CAAP;MACD;MACD;AACJ;AACA;AACA;;IA7HsF;MAAA;MAAA,OAgIlF,iBAAQ;QACN,OAAO,IAAIF,eAAJ,CAAoB,KAAKP,SAAzB,EAAoC,KAAKQ,QAAzC,EAAmD,KAAKC,SAAxD,CAAP;MACD;MACD;AACJ;AACA;AACA;AACA;;IAvIsF;MAAA;MAAA,OA0IlF,mBAAUa,OAAV,EAAmB;QACjB,IAAIC,WAAW,GAAGD,OAAO,IAAIA,OAAO,CAACC,WAAnB,GAAiCD,OAAO,CAACC,WAAzC,GAAuD,MAAzE;QACA,IAAIC,UAAU,GAAG/B,aAAa,CAAC,IAAD,EAAO8B,WAAP,EAAoBD,OAAO,IAAIA,OAAO,CAACG,QAAvC,CAA9B,CAFiB,CAE+D;QAChF;QACA;QACA;;QAEA,IAAIzB,SAAS,GAAG,KAAKA,SAAL,CAAe0B,QAAf,CAAwBJ,OAAxB,CAAhB;QACA,IAAIK,mBAAmB,GAAGlC,aAAa,CAAC,KAAKO,SAAN,EAAiBuB,WAAjB,EAA8BD,OAAO,IAAIA,OAAO,CAACG,QAAjD,CAAvC;;QAEA,IAAIF,WAAW,KAAK,KAAhB,IAAyB,KAAKvB,SAAL,CAAe4B,IAAf,KAAwB,cAAjD,IAAmED,mBAAmB,KAAK,IAAxB,IAAgCA,mBAAmB,IAAIH,UAA9H,EAA0I;UACxIxB,SAAS,GAAG,MAAMA,SAAN,GAAkB,GAA9B;QACD;;QAED,IAAIQ,QAAQ,GAAG,KAAKA,QAAL,CAAckB,QAAd,CAAuBJ,OAAvB,CAAf;QACA,IAAIO,cAAc,GAAGpC,aAAa,CAAC,KAAKe,QAAN,EAAgBe,WAAhB,EAA6BD,OAAO,IAAIA,OAAO,CAACG,QAAhD,CAAlC;;QAEA,IAAIF,WAAW,KAAK,KAAhB,IAAyB,KAAKf,QAAL,CAAcoB,IAAd,KAAuB,cAAhD,IAAkEC,cAAc,KAAK,IAAnB,IAA2BA,cAAc,IAAIL,UAAnH,EAA+H;UAC7HhB,QAAQ,GAAG,MAAMA,QAAN,GAAiB,GAA5B;QACD;;QAED,IAAIC,SAAS,GAAG,KAAKA,SAAL,CAAeiB,QAAf,CAAwBJ,OAAxB,CAAhB;QACA,IAAIQ,eAAe,GAAGrC,aAAa,CAAC,KAAKgB,SAAN,EAAiBc,WAAjB,EAA8BD,OAAO,IAAIA,OAAO,CAACG,QAAjD,CAAnC;;QAEA,IAAIF,WAAW,KAAK,KAAhB,IAAyB,KAAKd,SAAL,CAAemB,IAAf,KAAwB,cAAjD,IAAmEE,eAAe,KAAK,IAApB,IAA4BA,eAAe,IAAIN,UAAtH,EAAkI;UAChIf,SAAS,GAAG,MAAMA,SAAN,GAAkB,GAA9B;QACD;;QAED,OAAOT,SAAS,GAAG,KAAZ,GAAoBQ,QAApB,GAA+B,KAA/B,GAAuCC,SAA9C;MACD;MACD;AACJ;AACA;AACA;;IA3KsF;MAAA;MAAA,OA8KlF,kBAAS;QACP,OAAO;UACLsB,MAAM,EAAErC,IADH;UAELM,SAAS,EAAE,KAAKA,SAFX;UAGLQ,QAAQ,EAAE,KAAKA,QAHV;UAILC,SAAS,EAAE,KAAKA;QAJX,CAAP;MAMD;MACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAlMsF;MAAA;MAAA;MAwMlF;AACJ;AACA;AACA;AACA;MAGI,gBAAOa,OAAP,EAAgB;QACd,IAAIC,WAAW,GAAGD,OAAO,IAAIA,OAAO,CAACC,WAAnB,GAAiCD,OAAO,CAACC,WAAzC,GAAuD,MAAzE;QACA,IAAIC,UAAU,GAAG/B,aAAa,CAAC,IAAD,EAAO8B,WAAP,EAAoBD,OAAO,IAAIA,OAAO,CAACG,QAAvC,CAA9B,CAFc,CAEkE;QAChF;QACA;QACA;;QAEA,IAAIzB,SAAS,GAAG,KAAKA,SAAL,CAAegC,MAAf,CAAsBV,OAAtB,CAAhB;QACA,IAAIK,mBAAmB,GAAGlC,aAAa,CAAC,KAAKO,SAAN,EAAiBuB,WAAjB,EAA8BD,OAAO,IAAIA,OAAO,CAACG,QAAjD,CAAvC;;QAEA,IAAIF,WAAW,KAAK,KAAhB,IAAyB,KAAKvB,SAAL,CAAe4B,IAAf,KAAwB,cAAjD,IAAmED,mBAAmB,KAAK,IAAxB,IAAgCA,mBAAmB,IAAIH,UAA9H,EAA0I;UACxIxB,SAAS,GAAG,mEAAmEA,SAAnE,GAA+E,gEAA3F;QACD;;QAED,IAAIQ,QAAQ,GAAG,KAAKA,QAAL,CAAcwB,MAAd,CAAqBV,OAArB,CAAf;QACA,IAAIO,cAAc,GAAGpC,aAAa,CAAC,KAAKe,QAAN,EAAgBe,WAAhB,EAA6BD,OAAO,IAAIA,OAAO,CAACG,QAAhD,CAAlC;;QAEA,IAAIF,WAAW,KAAK,KAAhB,IAAyB,KAAKf,QAAL,CAAcoB,IAAd,KAAuB,cAAhD,IAAkEC,cAAc,KAAK,IAAnB,IAA2BA,cAAc,IAAIL,UAAnH,EAA+H;UAC7HhB,QAAQ,GAAG,mEAAmEA,QAAnE,GAA8E,gEAAzF;QACD;;QAED,IAAIC,SAAS,GAAG,KAAKA,SAAL,CAAeuB,MAAf,CAAsBV,OAAtB,CAAhB;QACA,IAAIQ,eAAe,GAAGrC,aAAa,CAAC,KAAKgB,SAAN,EAAiBc,WAAjB,EAA8BD,OAAO,IAAIA,OAAO,CAACG,QAAjD,CAAnC;;QAEA,IAAIF,WAAW,KAAK,KAAhB,IAAyB,KAAKd,SAAL,CAAemB,IAAf,KAAwB,cAAjD,IAAmEE,eAAe,KAAK,IAApB,IAA4BA,eAAe,IAAIN,UAAtH,EAAkI;UAChIf,SAAS,GAAG,mEAAmEA,SAAnE,GAA+E,gEAA3F;QACD;;QAED,OAAOT,SAAS,GAAG,gEAAZ,GAA+EQ,QAA/E,GAA0F,gEAA1F,GAA6JC,SAApK;MACD;MACD;AACJ;AACA;AACA;AACA;;IAjPsF;MAAA;MAAA,OAoPlF,gBAAOa,OAAP,EAAgB;QACd,OAAO,qBAAqB,KAAKd,QAAL,CAAcyB,KAAd,CAAoBX,OAApB,CAArB,GAAoD,2BAApD,GAAkF,KAAKtB,SAAL,CAAeiC,KAAf,CAAqBX,OAArB,CAAlF,GAAkH,QAAlH,GAA6H,KAAKb,SAAL,CAAewB,KAAf,CAAqBX,OAArB,CAA7H,GAA6J,2CAApK;MACD;IAtPiF;MAAA;MAAA,OAqMlF,kBAAgBY,IAAhB,EAAsB;QACpB,OAAO,IAAI3B,eAAJ,CAAoB2B,IAAI,CAAClC,SAAzB,EAAoCkC,IAAI,CAAC1B,QAAzC,EAAmD0B,IAAI,CAACzB,SAAxD,CAAP;MACD;IAvMiF;;IAAA;EAAA,EAoCtDX,IApCsD;;EA0PpFZ,eAAe,CAACqB,eAAD,EAAkB,MAAlB,EAA0Bb,IAA1B,CAAf;;EAEA,OAAOa,eAAP;AACD,CA7PwD,EA6PtD;EACD4B,OAAO,EAAE,IADR;EAED9C,MAAM,EAAE;AAFP,CA7PsD,CAAlD"},"metadata":{},"sourceType":"module"}