{"map":{"version":3,"sources":["static/js/main.1fc98915.chunk.js"],"names":["this","push","126","module","exports","__webpack_require__","178","337","__webpack_exports__","r","react","react_default","n","react_dom","react_dom_default","Placeholder","Navbar","Nav","Icon","Header","Content","Footer","Panel","objectSpread2","slicedToArray","index_de9ac4b8","esm","Button","lib","lib_default","shadertoy_react_min","shadertoy_react_min_default","Shader","props","Object","shader","uniforms","a","createElement","style","ratio","fs","key","InputHandle","type","position","id","className","isConnectable","onConnect","params","console","log","OutputHandle","initialNodes","x","y","data","value","initialEdges","source","target","markerEnd","ArrowClosed","animated","nodeTypes","shaderNode","_ref","_useState","_useState2","color","setColor","evt","onClick","Math","random","appearance","margin","Graph","nodes","setNodes","_useState3","_useState4","edges","setEdges","onNodesChange","changes","nds","onEdgesChange","eds","connection","Fragment","fitView","Paragraph","App_NavBarExample","Body","Item","eventKey","pullRight","icon","App_MainContent","width","layoutStyles","display","flexDirection","height","App","flexGrow","bordered","rootElement","document","getElementById","render","StrictMode"],"mappings":"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"},"code":"(this[\"webpackJsonp3d-visualizer\"]=this[\"webpackJsonp3d-visualizer\"]||[]).push([[0],{126:function(e,n,t){},178:function(e,n,t){e.exports=t(337)},337:function(e,n,t){\"use strict\";t.r(n);var a=t(0),o=t.n(a),c=t(32),r=t.n(c),i=t(343),l=t(341),s=t(342),m=t(165),d=t(345),p=t(346),v=t(347),u=t(344),f=t(98),g=t(45),h=t(2),y=t(27);var E=t(164),b=t(154),w=t.n(b),_=t(155),x=t.n(_);function I(e){return Object(a.useEffect)((function(){}),[e.shader,e.uniforms]),o.a.createElement(\"div\",{style:e.style},o.a.createElement(w.a,{ratio:1},o.a.createElement(x.a,{fs:e.shader,key:e.shader,uniforms:e.uniforms})))}function z(){return o.a.createElement(y.a,{type:\"target\",position:\"left\",id:\"a\",className:\"custom-handle\",isConnectable:!0,onConnect:function(e){return console.log(\"handle onConnect\",e)}})}function N(){return o.a.createElement(y.a,{type:\"source\",position:\"right\",id:\"a\",className:\"custom-handle\",isConnectable:!0})}t(126);var C=[{id:\"node-1\",type:\"shaderNode\",position:{x:0,y:0},data:{value:123}},{id:\"node-2\",type:\"shaderNode\",position:{x:250,y:0},data:{value:1}},{id:\"node-3\",type:\"shaderNode\",position:{x:250,y:-300},data:{value:1}}],L=[{id:\"e1-2\",type:\"arrowEdge\",source:\"node-1\",target:\"node-2\",markerEnd:{type:h.g.ArrowClosed},animated:!0}],S={shaderNode:function(e){e.data;var n=Object(a.useState)([1,0,0]),t=Object(g.a)(n,2),c=t[0],r=t[1];return Object(a.useCallback)((function(e){console.log(e.target.value)}),[]),o.a.createElement(\"div\",{className:\"custom-node\"},o.a.createElement(\"div\",{className:\"custom-node-header\"},\"Ejemplo:\"),o.a.createElement(\"div\",null,o.a.createElement(z,null)),o.a.createElement(\"div\",null,o.a.createElement(N,null)),o.a.createElement(E.a,{onClick:function(){return r([Math.random(),Math.random(),Math.random()])},appearance:\"primary\"},\"Change Color\"),o.a.createElement(I,{shader:\"\\n  // https://thebookofshaders.com/03/?lan=es\\n// https://thebookofshaders.com/03/\\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\\n// https://www.shadertoy.com/view/llt3R4\\n\\n// camera\\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\\n// http://www.codinglabs.net/article_world_view_projection_matrix.aspx\\n// https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\\n// https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\\n\\n#ifdef GL_ES\\nprecision mediump float;\\n#endif\\n\\nconst int AA = 3;\\nconst int MAX_MARCHING_STEPS = 255;\\nconst float EPSILON = 0.0001;\\nconst float MIN_DIST = 0.0;\\nconst float MAX_DIST = 100.0;\\n\\n\\nstruct Material\\n{\\n    vec3 specular;\\n    vec3 diffuse;\\n    vec3 ambient;\\n    float smoothness;\\n};\\n\\nfloat sdfCube(vec3 p, vec3 dim){\\n    vec3 d = abs(p) - dim;\\n\\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\\n    float outsideDistance = length(max(d, 0.0));\\n    \\n    return insideDistance + outsideDistance;\\n}\\n\\nfloat map( in vec3 pos )\\n{\\n    return  sdfCube(pos, vec3(1.0));\\n}\\n\\n\\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\\n    const float fov = 45.0;\\n\\n    vec2 xy = fragCoord - size / 2.0;\\n    float z = size.y / tan(radians(fov) / 2.0);\\n\\n    return normalize(vec3(xy, -z));\\n}\\n\\nvec3 normal(vec3 p) {\\n    return normalize(vec3(\\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\\n    ));\\n}\\n\\nvec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\\n    vec3 ambient = vec3(0.5);\\n\\n    vec3 lights_pos[2];\\n    lights_pos[0] = vec3(4.0, 2.0, 2.0);\\n    lights_pos[1] = vec3(-4.0, -2.0, -2.0);\\n\\n    vec3 lights_color[2];\\n    lights_color[0] = vec3(1.0, 1.0, 1.0);\\n    lights_color[1] = vec3(1.0, 1.0, 1.0);\\n\\n    vec3 Ip = mat.ambient * ambient;\\n\\n    for(int i=0; i<2; i++){\\n        vec3 Lm = normalize(lights_pos[i] - p);\\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\\n        vec3 V  = normalize(eye - p);\\n\\n        float LN = dot(Lm, n);\\n        float RV = dot(Rm, V);\\n\\n        if (LN < 0.0)   // Light not visible\\n            Ip += vec3(0.0, 0.0, 0.0);\\n        else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\\n            Ip += lights_color[i] * (mat.diffuse * LN);\\n        else\\n            Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\\n    }\\n\\n    return Ip;\\n}\\n\\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\\n    // Based on gluLookAt man page\\n    vec3 f = normalize(center - eye);\\n    vec3 s = normalize(cross(f, up));\\n    vec3 u = cross(s, f);\\n    return mat4(\\n        vec4(s, 0.0),\\n        vec4(u, 0.0),\\n        vec4(-f, 0.0),\\n        vec4(0.0, 0.0, 0.0, 1)\\n    );\\n}\\n\\nvoid main() {\\n    Material mat_red = Material(\\n        vec3(1.0, 1.0, 1.0),    // specular\\n        vec3(color.xyz),        // diffuse\\n        vec3(0.2),              // ambient\\n        10.0                    // shiness\\n    );\\n    vec3 eye                    = vec3(10.0*cos(iTime), 1.0, 10.0*sin(iTime));\\n    const vec3 backGroundColor  = vec3(0.7);\\n\\n    for( int m=0; m<AA; m++ ){\\n        for( int n=0; n<AA; n++ ){\\n            float depth = MIN_DIST;\\n\\n            // create view ray\\n            vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\\n            mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\\n            vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\\n\\n            // raytracing\\n            for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\\n                float dist = map(eye + depth * worldDir);\\n                if (dist < EPSILON) {\\n                    vec3 p = eye + depth * worldDir;\\n                    vec3 n = normal(p);\\n\\n                    gl_FragColor = vec4(lighting(p, n, eye, mat_red), 1.0);\\n                    return;\\n                }\\n\\n                depth += dist;\\n\\n                if (depth >= MAX_DIST) {\\n                    gl_FragColor = vec4(backGroundColor.xyz, 1.0);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n\",uniforms:{color:{type:\"3fv\",value:c}},style:{margin:\"10px\"}}))}};function M(){var e=Object(a.useState)(C),n=Object(g.a)(e,2),t=n[0],c=n[1],r=Object(a.useState)(L),i=Object(g.a)(r,2),l=i[0],s=i[1],m=Object(a.useCallback)((function(e){return c((function(n){return Object(h.G)(e,n)}))}),[c]),d=Object(a.useCallback)((function(e){return s((function(n){return Object(h.H)(e,n)}))}),[s]),p=Object(a.useCallback)((function(e){console.log(e),s((function(n){return Object(h.l)(Object(f.a)(Object(f.a)({},e),{},{animated:!0,markerEnd:{type:h.g.ArrowClosed}}),n)}))}),[s]);return o.a.createElement(o.a.Fragment,null,o.a.createElement(y.b,{nodes:t,edges:l,onNodesChange:m,onEdgesChange:d,onConnect:p,nodeTypes:S,fitView:!0}))}t(221),i.a.Paragraph;var O=function(){return o.a.createElement(l.a,{appearance:\"inverse\"},o.a.createElement(l.a.Header,null,o.a.createElement(\"a\",{className:\"navbar-brand logo\"},\"3D Visualizer\")),o.a.createElement(l.a.Body,null,o.a.createElement(s.a,null,o.a.createElement(s.a.Item,{eventKey:\"1\"},\"Home\"),o.a.createElement(s.a.Item,{eventKey:\"2\"},\"News\"),o.a.createElement(s.a.Item,{eventKey:\"3\"},\"Products\")),o.a.createElement(s.a,{pullRight:!0},o.a.createElement(s.a.Item,{icon:o.a.createElement(m.a,{icon:\"cog\"})},\"Settings\"))))},P=function(){return o.a.createElement(o.a.Fragment,null,o.a.createElement(I,{style:{width:\"100px\"},shader:\"\\n    \\n    // https://thebookofshaders.com/03/?lan=es\\n  // https://thebookofshaders.com/03/\\n  // http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\\n  // https://www.shadertoy.com/view/llt3R4\\n  \\n  // camera\\n  // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\\n  // http://www.codinglabs.net/article_world_view_projection_matrix.aspx\\n  // https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\\n  // https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\\n  \\n  #ifdef GL_ES\\n  precision mediump float;\\n  #endif\\n  \\n  const int AA = 3;\\n  const int MAX_MARCHING_STEPS = 255;\\n  const float EPSILON = 0.0001;\\n  const float MIN_DIST = 0.0;\\n  const float MAX_DIST = 100.0;\\n\\n  uniform bool leftClick;\\n\\n  struct Material\\n  {\\n      vec3 specular;\\n      vec3 diffuse;\\n      vec3 ambient;\\n      float smoothness;\\n  };\\n  \\n  float sdfCube(vec3 p, vec3 dim){\\n      vec3 d = abs(p) - dim;\\n  \\n      float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\\n      float outsideDistance = length(max(d, 0.0));\\n      \\n      return insideDistance + outsideDistance;\\n  }\\n  \\n  float map( in vec3 pos )\\n  {\\n      return  sdfCube(pos, vec3(1.0));\\n  }\\n  \\n  \\n  vec3 rayDirection(vec2 size, vec2 fragCoord) {\\n      const float fov = 45.0;\\n  \\n      vec2 xy = fragCoord - size / 2.0;\\n      float z = size.y / tan(radians(fov) / 2.0);\\n  \\n      return normalize(vec3(xy, -z));\\n  }\\n  \\n  vec3 normal(vec3 p) {\\n      return normalize(vec3(\\n          map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\\n          map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\\n          map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\\n      ));\\n  }\\n  \\n  vec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\\n      vec3 ambient = vec3(0.5);\\n  \\n      vec3 lights_pos[2];\\n      lights_pos[0] = vec3(4.0, 2.0, 2.0);\\n      lights_pos[1] = vec3(-4.0, -2.0, -2.0);\\n  \\n      vec3 lights_color[2];\\n      lights_color[0] = vec3(1.0, 1.0, 1.0);\\n      lights_color[1] = vec3(1.0, 1.0, 1.0);\\n  \\n      vec3 Ip = mat.ambient * ambient;\\n  \\n      for(int i=0; i<2; i++){\\n          vec3 Lm = normalize(lights_pos[i] - p);\\n          vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\\n          vec3 V  = normalize(eye - p);\\n  \\n          float LN = dot(Lm, n);\\n          float RV = dot(Rm, V);\\n  \\n          if (LN < 0.0)   // Light not visible\\n              Ip += vec3(0.0, 0.0, 0.0);\\n          else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\\n              Ip += lights_color[i] * (mat.diffuse * LN);\\n          else\\n              Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\\n      }\\n  \\n      return Ip;\\n  }\\n  \\n  mat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\\n      // Based on gluLookAt man page\\n      vec3 f = normalize(center - eye);\\n      vec3 s = normalize(cross(f, up));\\n      vec3 u = cross(s, f);\\n      return mat4(\\n          vec4(s, 0.0),\\n          vec4(u, 0.0),\\n          vec4(-f, 0.0),\\n          vec4(0.0, 0.0, 0.0, 1)\\n      );\\n  }\\n  \\n  void main() {\\n      Material mat_red = Material(\\n          vec3(1.0, 1.0, 1.0),    // specular\\n          vec3(1.0, 1.0,0.0),        // diffuse\\n          vec3(0.2),              // ambient\\n          10.0                    // shiness\\n      );\\n      vec3 cameraPos                    = vec3(10.0, 1.0, 10.0);\\n      const vec3 backGroundColor  = vec3(0.7);\\n      vec2 mouseStartPos, mouseCurrPos;\\n      vec2 mouse = iMouse.xy / iResolution.xy;\\n\\n      if(iMouse.z > 0.0){\\n        \\n        vec3 cameraAt \\t= vec3(0.0);\\n\\n        float angleX = 6.28 * mouse.x;\\n        float angleY =  mouse.y * 6.28 ;\\n        cameraPos\\t= 12.0 * (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY)));\\n      }\\n\\n      for( int m=0; m<AA; m++ ){\\n          for( int n=0; n<AA; n++ ){\\n              float depth = MIN_DIST;\\n  \\n              // create view ray\\n              vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\\n              mat4 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\\n              vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\\n  \\n              // raytracing\\n              for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\\n                  float dist = map(cameraPos + depth * worldDir);\\n                  if (dist < EPSILON) {\\n                      vec3 p = cameraPos + depth * worldDir;\\n                      vec3 n = normal(p);\\n  \\n                      gl_FragColor = vec4(lighting(p, n, cameraPos, mat_red), 1.0);\\n                      return;\\n                  }\\n  \\n                  depth += dist;\\n  \\n                  if (depth >= MAX_DIST) {\\n                      gl_FragColor = vec4(backGroundColor.xyz, 1.0);\\n                      return;\\n                  }\\n              }\\n          }\\n      }\\n  }\\n\\n  \\n  \",uniforms:{color:{type:\"3fv\",value:[1,1,0]}}}),o.a.createElement(M,null))},A={display:\"flex\",flexDirection:\"column\",height:\"100vh\"};function D(){return o.a.createElement(\"div\",{style:A},o.a.createElement(d.a,null,o.a.createElement(O,null)),o.a.createElement(p.a,{style:{flexGrow:1}},o.a.createElement(P,null)),o.a.createElement(v.a,null,o.a.createElement(u.a,{bordered:!0},o.a.createElement(\"p\",null,\"Daniel Zufr\\xed Quesada\"))))}var k=document.getElementById(\"root\");r.a.render(o.a.createElement(o.a.StrictMode,null,o.a.createElement(D,null)),k)}},[[178,1,2]]]);","extractedComments":[]}