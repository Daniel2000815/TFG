(this["webpackJsonp3d-visualizer"]=this["webpackJsonp3d-visualizer"]||[]).push([[0],{127:function(e,n,t){},178:function(e,n,t){e.exports=t(337)},337:function(e,n,t){"use strict";t.r(n);var a=t(0),o=t.n(a),c=t(33),r=t.n(c),i=t(344),l=t(341),s=t(343),m=t(165),d=t(346),v=t(347),p=t(348),u=t(349),f=t(350),h=t(351),g=t(345),y=t(99),E=t(46),b=t(2),w=t(28);var _=t(164),x=t(155),I=t.n(x),z=t(156),N=t.n(z);function C(e){return Object(a.useEffect)((function(){}),[e.shader,e.uniforms]),o.a.createElement("div",{style:e.style},o.a.createElement(I.a,{ratio:1},o.a.createElement(N.a,{fs:e.shader,key:e.shader,uniforms:e.uniforms})))}function L(){return o.a.createElement(w.a,{type:"target",position:"left",id:"a",className:"custom-handle",isConnectable:!0,onConnect:function(e){return console.log("handle onConnect",e)}})}function S(){return o.a.createElement(w.a,{type:"source",position:"right",id:"a",className:"custom-handle",isConnectable:!0})}t(127);var M=[{id:"node-1",type:"shaderNode",position:{x:0,y:0},data:{value:123}},{id:"node-2",type:"shaderNode",position:{x:250,y:0},data:{value:1}},{id:"node-3",type:"shaderNode",position:{x:250,y:-300},data:{value:1}}],O=[{id:"e1-2",type:"arrowEdge",source:"node-1",target:"node-2",markerEnd:{type:b.g.ArrowClosed},animated:!0}],P={shaderNode:function(e){e.data;var n=Object(a.useState)([1,0,0]),t=Object(E.a)(n,2),c=t[0],r=t[1];return Object(a.useCallback)((function(e){console.log(e.target.value)}),[]),o.a.createElement("div",{className:"custom-node"},o.a.createElement("div",{className:"custom-node-header"},"Ejemplo:"),o.a.createElement("div",null,o.a.createElement(L,null)),o.a.createElement("div",null,o.a.createElement(S,null)),o.a.createElement(_.a,{onClick:function(){return r([Math.random(),Math.random(),Math.random()])},appearance:"primary"},"Change Color"),o.a.createElement(C,{shader:"\n  // https://thebookofshaders.com/03/?lan=es\n// https://thebookofshaders.com/03/\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\n// https://www.shadertoy.com/view/llt3R4\n\n// camera\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\n// http://www.codinglabs.net/article_world_view_projection_matrix.aspx\n// https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\n// https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst int AA = 3;\nconst int MAX_MARCHING_STEPS = 255;\nconst float EPSILON = 0.0001;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\n\n\nstruct Material\n{\n    vec3 specular;\n    vec3 diffuse;\n    vec3 ambient;\n    float smoothness;\n};\n\nfloat sdfCube(vec3 p, vec3 dim){\n    vec3 d = abs(p) - dim;\n\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat map( in vec3 pos )\n{\n    return  sdfCube(pos, vec3(1.0));\n}\n\n\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\n    const float fov = 45.0;\n\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n\n    return normalize(vec3(xy, -z));\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\n    vec3 ambient = vec3(0.5);\n\n    vec3 lights_pos[2];\n    lights_pos[0] = vec3(4.0, 2.0, 2.0);\n    lights_pos[1] = vec3(-4.0, -2.0, -2.0);\n\n    vec3 lights_color[2];\n    lights_color[0] = vec3(1.0, 1.0, 1.0);\n    lights_color[1] = vec3(1.0, 1.0, 1.0);\n\n    vec3 Ip = mat.ambient * ambient;\n\n    for(int i=0; i<2; i++){\n        vec3 Lm = normalize(lights_pos[i] - p);\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\n        vec3 V  = normalize(eye - p);\n\n        float LN = dot(Lm, n);\n        float RV = dot(Rm, V);\n\n        if (LN < 0.0)   // Light not visible\n            Ip += vec3(0.0, 0.0, 0.0);\n        else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\n            Ip += lights_color[i] * (mat.diffuse * LN);\n        else\n            Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\n    }\n\n    return Ip;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid main() {\n    Material mat_red = Material(\n        vec3(1.0, 1.0, 1.0),    // specular\n        vec3(color.xyz),        // diffuse\n        vec3(0.2),              // ambient\n        10.0                    // shiness\n    );\n    vec3 eye                    = vec3(10.0*cos(iTime), 1.0, 10.0*sin(iTime));\n    const vec3 backGroundColor  = vec3(0.7);\n\n    for( int m=0; m<AA; m++ ){\n        for( int n=0; n<AA; n++ ){\n            float depth = MIN_DIST;\n\n            // create view ray\n            vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\n            mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n            vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\n\n            // raytracing\n            for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n                float dist = map(eye + depth * worldDir);\n                if (dist < EPSILON) {\n                    vec3 p = eye + depth * worldDir;\n                    vec3 n = normal(p);\n\n                    gl_FragColor = vec4(lighting(p, n, eye, mat_red), 1.0);\n                    return;\n                }\n\n                depth += dist;\n\n                if (depth >= MAX_DIST) {\n                    gl_FragColor = vec4(backGroundColor.xyz, 1.0);\n                    return;\n                }\n            }\n        }\n    }\n}\n\n",uniforms:{color:{type:"3fv",value:c}},style:{margin:"10px"}}))}};function A(){var e=Object(a.useState)(M),n=Object(E.a)(e,2),t=n[0],c=n[1],r=Object(a.useState)(O),i=Object(E.a)(r,2),l=i[0],s=i[1],m=Object(a.useCallback)((function(e){return c((function(n){return Object(b.G)(e,n)}))}),[c]),d=Object(a.useCallback)((function(e){return s((function(n){return Object(b.H)(e,n)}))}),[s]),v=Object(a.useCallback)((function(e){console.log(e),s((function(n){return Object(b.l)(Object(y.a)(Object(y.a)({},e),{},{animated:!0,markerEnd:{type:b.g.ArrowClosed}}),n)}))}),[s]);return o.a.createElement("div",{style:{height:"100vh"}},o.a.createElement(w.b,{nodes:t,edges:l,onNodesChange:m,onEdgesChange:d,onConnect:v,nodeTypes:P,fitView:!0}))}t(221),i.a.Paragraph;var D=function(){return o.a.createElement(l.a,{appearance:"inverse"},o.a.createElement(l.a.Header,null,o.a.createElement("a",{className:"navbar-brand logo"},"3D Visualizer")),o.a.createElement(l.a.Body,null,o.a.createElement(s.a,null,o.a.createElement(s.a.Item,{eventKey:"1"},"Tab 1"),o.a.createElement(s.a.Item,{eventKey:"2"},"Tab 2"),o.a.createElement(s.a.Item,{eventKey:"3"},"Tab 3")),o.a.createElement(s.a,{pullRight:!0},o.a.createElement(s.a.Item,{icon:o.a.createElement(m.a,{icon:"cog"})},"Settings"))))};function k(){return o.a.createElement(o.a.Fragment,null,o.a.createElement(d.a,{fluid:!0},o.a.createElement(v.a,null,o.a.createElement(p.a,{xs:6},o.a.createElement(C,{style:{height:"100vh"},shader:"\n    \n    // https://thebookofshaders.com/03/?lan=es\n  // https://thebookofshaders.com/03/\n  // http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\n  // https://www.shadertoy.com/view/llt3R4\n  \n  // camera\n  // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\n  // http://www.codinglabs.net/article_world_view_projection_matrix.aspx\n  // https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\n  // https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\n  \n  #ifdef GL_ES\n  precision mediump float;\n  #endif\n  \n  const int AA = 3;\n  const int MAX_MARCHING_STEPS = 255;\n  const float EPSILON = 0.0001;\n  const float MIN_DIST = 0.0;\n  const float MAX_DIST = 100.0;\n\n  uniform bool leftClick;\n\n  struct Material\n  {\n      vec3 specular;\n      vec3 diffuse;\n      vec3 ambient;\n      float smoothness;\n  };\n  \n  float sdfCube(vec3 p, vec3 dim){\n      vec3 d = abs(p) - dim;\n  \n      float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n      float outsideDistance = length(max(d, 0.0));\n      \n      return insideDistance + outsideDistance;\n  }\n  \n  float map( in vec3 pos )\n  {\n      return  sdfCube(pos, vec3(1.0));\n  }\n  \n  \n  vec3 rayDirection(vec2 size, vec2 fragCoord) {\n      const float fov = 45.0;\n  \n      vec2 xy = fragCoord - size / 2.0;\n      float z = size.y / tan(radians(fov) / 2.0);\n  \n      return normalize(vec3(xy, -z));\n  }\n  \n  vec3 normal(vec3 p) {\n      return normalize(vec3(\n          map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n          map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n          map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n      ));\n  }\n  \n  vec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\n      vec3 ambient = vec3(0.5);\n  \n      vec3 lights_pos[2];\n      lights_pos[0] = vec3(4.0, 2.0, 2.0);\n      lights_pos[1] = vec3(-4.0, -2.0, -2.0);\n  \n      vec3 lights_color[2];\n      lights_color[0] = vec3(1.0, 1.0, 1.0);\n      lights_color[1] = vec3(1.0, 1.0, 1.0);\n  \n      vec3 Ip = mat.ambient * ambient;\n  \n      for(int i=0; i<2; i++){\n          vec3 Lm = normalize(lights_pos[i] - p);\n          vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\n          vec3 V  = normalize(eye - p);\n  \n          float LN = dot(Lm, n);\n          float RV = dot(Rm, V);\n  \n          if (LN < 0.0)   // Light not visible\n              Ip += vec3(0.0, 0.0, 0.0);\n          else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\n              Ip += lights_color[i] * (mat.diffuse * LN);\n          else\n              Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\n      }\n  \n      return Ip;\n  }\n  \n  mat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n      // Based on gluLookAt man page\n      vec3 f = normalize(center - eye);\n      vec3 s = normalize(cross(f, up));\n      vec3 u = cross(s, f);\n      return mat4(\n          vec4(s, 0.0),\n          vec4(u, 0.0),\n          vec4(-f, 0.0),\n          vec4(0.0, 0.0, 0.0, 1)\n      );\n  }\n  \n  void main() {\n      Material mat_red = Material(\n          vec3(1.0, 1.0, 1.0),    // specular\n          vec3(1.0, 1.0,0.0),        // diffuse\n          vec3(0.2),              // ambient\n          10.0                    // shiness\n      );\n      vec3 cameraPos                    = vec3(10.0, 1.0, 10.0);\n      const vec3 backGroundColor  = vec3(0.7);\n      vec2 mouseStartPos, mouseCurrPos;\n      vec2 mouse = iMouse.xy / iResolution.xy;\n\n      if(iMouse.z > 0.0){\n        \n        vec3 cameraAt \t= vec3(0.0);\n\n        float angleX = 6.28 * mouse.x;\n        float angleY =  mouse.y * 6.28 ;\n        cameraPos\t= 12.0 * (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY)));\n      }\n\n      for( int m=0; m<AA; m++ ){\n          for( int n=0; n<AA; n++ ){\n              float depth = MIN_DIST;\n  \n              // create view ray\n              vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\n              mat4 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n              vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\n  \n              // raytracing\n              for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n                  float dist = map(cameraPos + depth * worldDir);\n                  if (dist < EPSILON) {\n                      vec3 p = cameraPos + depth * worldDir;\n                      vec3 n = normal(p);\n  \n                      gl_FragColor = vec4(lighting(p, n, cameraPos, mat_red), 1.0);\n                      return;\n                  }\n  \n                  depth += dist;\n  \n                  if (depth >= MAX_DIST) {\n                      gl_FragColor = vec4(backGroundColor.xyz, 1.0);\n                      return;\n                  }\n              }\n          }\n      }\n  }\n\n  \n  ",uniforms:{color:{type:"3fv",value:[1,1,0]}}})),o.a.createElement(p.a,{xs:1},o.a.createElement("div",{style:{borderRight:"2px solid grey",height:"100vh"}})),o.a.createElement(p.a,{xs:17},o.a.createElement(A,null)))))}var T={display:"flex",flexDirection:"column",height:"100vh"};function j(){return o.a.createElement("div",{style:T},o.a.createElement(u.a,null,o.a.createElement(D,null)),o.a.createElement(f.a,{style:{flexGrow:1}},o.a.createElement(k,null)),o.a.createElement(h.a,null,o.a.createElement(g.a,{bordered:!0},o.a.createElement("p",null,"Daniel Zufr\xed Quesada"))))}var R=document.getElementById("root");r.a.render(o.a.createElement(o.a.StrictMode,null,o.a.createElement(j,null)),R)}},[[178,1,2]]]);
//# sourceMappingURL=main.6360d08c.chunk.js.map