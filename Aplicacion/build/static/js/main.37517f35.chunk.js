(this["webpackJsonp3d-visualizer"]=this["webpackJsonp3d-visualizer"]||[]).push([[0],{159:function(e,n,t){},242:function(e,n,t){e.exports=t(405)},405:function(e,n,t){"use strict";t.r(n);var a=t(0),o=t.n(a),c=t(31),r=t.n(c),i=t(452),l=t(456),s=t(220),d=t(464),m=t(465),u=t(466),p=t(467),v=t(468),f=t(469),h=t(461),g=t(26),y=t(12),b=t(53),E=t(3),x=t(160),O=t(205),w=t.n(O),I=t(206),S=t.n(I);function _(e){return Object(a.useEffect)((function(){}),[e.shader,e.uniforms]),o.a.createElement("div",{style:e.style},o.a.createElement(w.a,{ratio:1},o.a.createElement(S.a,{fs:e.shader,key:e.shader,uniforms:e.uniforms})))}var N=function(e){return"\n  // https://thebookofshaders.com/03/?lan=es\n// https://thebookofshaders.com/03/\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\n// https://www.shadertoy.com/view/llt3R4\n\n// camera\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\n// http://www.codinglabs.net/article_world_view_projection_matrix.aspx\n// https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\n// https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst int AA = 3;\nconst int MAX_MARCHING_STEPS = 255;\nconst float EPSILON = 0.0001;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\n\n".concat("\n    float sphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float box( vec3 p, vec3 b )\n    {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n","\n\nstruct Material\n{\n    vec3 specular;\n    vec3 diffuse;\n    vec3 ambient;\n    float smoothness;\n};\n\nfloat map( in vec3 p )\n{\n    return ").concat(e,";\n}\n\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\n    const float fov = 45.0;\n\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n\n    return normalize(vec3(xy, -z));\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\n    vec3 ambient = vec3(0.5);\n\n    vec3 lights_pos[2];\n    lights_pos[0] = vec3(4.0, 2.0, 2.0);\n    lights_pos[1] = vec3(-4.0, -2.0, -2.0);\n\n    vec3 lights_color[2];\n    lights_color[0] = vec3(1.0, 1.0, 1.0);\n    lights_color[1] = vec3(1.0, 1.0, 1.0);\n\n    vec3 Ip = mat.ambient * ambient;\n\n    for(int i=0; i<2; i++){\n        vec3 Lm = normalize(lights_pos[i] - p);\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\n        vec3 V  = normalize(eye - p);\n\n        float LN = dot(Lm, n);\n        float RV = dot(Rm, V);\n\n        if (LN < 0.0)   // Light not visible\n            Ip += vec3(0.0, 0.0, 0.0);\n        else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\n            Ip += lights_color[i] * (mat.diffuse * LN);\n        else\n            Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\n    }\n\n    return Ip;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nfloat clamp(float val){\n    if(val < 0.0)   return 0.0;\n    if(val >1.0)    return 1.0;\n\n    return val;\n}\n\nvoid main() {\n    Material mat_red = Material(\n        vec3(1.0, 1.0, 1.0),    // specular\n        vec3(color.xyz),        // diffuse\n        vec3(0.2),              // ambient\n        10.0                    // shiness\n    );\n    vec3 eye                    = vec3(10.0*cos(iTime), 1.0, 10.0*sin(iTime));\n    const vec3 backGroundColor  = vec3(0.7);\n\n    for( int m=0; m<AA; m++ ){\n        for( int n=0; n<AA; n++ ){\n            float depth = MIN_DIST;\n\n            // create view ray\n            vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\n            mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n            vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\n\n            // raytracing\n            for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n                float dist = map(eye + depth * worldDir);\n                if (dist < EPSILON) {\n                    vec3 p = eye + depth * worldDir;\n                    vec3 n = normal(p);\n\n                    gl_FragColor =  vec4(lighting(p, n, eye, mat_red), 1.0);\n                    \n                    return;\n                }\n\n                depth += dist;\n\n                if (depth >= MAX_DIST) {\n                    gl_FragColor = vec4(backGroundColor.xyz, 1.0);\n                    return;\n                }\n            }\n        }\n    }\n}\n\n")},C=t(462),z=t(211),A=t.n(z),L=t(210),j=t.n(L),D=t(471),P=t(459),M=t(463);function k(e){return o.a.createElement(D.a,{sx:{m:1},size:"small"},o.a.createElement(P.a,null,e.label),o.a.createElement(M.a,{value:e.val,type:"number",onChange:function(n){return e.handleChange(parseFloat(n.target.value))},label:e.label}))}var T=t(458),R=t(455);function F(e){var n=o.a.useState(!1),t=Object(y.a)(n,2),a=t[0],c=t[1];return o.a.createElement(D.a,{onClick:function(){return c(!a)},sx:{m:1,minWidth:80}},o.a.createElement(P.a,null,e.label),o.a.createElement(R.a,{value:e.value,onChange:function(n){return e.onChange(n.target.value)},autoWidth:!0,open:a,label:"Primitive"},e.items.map((function(e){return o.a.createElement(T.a,{value:e},e)}))))}var V=o.a.createContext({}),G=V.Provider,B=V;function H(e){return o.a.createElement(o.a.Fragment,null,"source"===e.type?o.a.createElement(b.a,{type:"source",id:e.id,style:Object(g.a)(Object(g.a)({},e.style),{},{width:"12px",height:"12px"}),position:"bottom",onConnect:function(n){return e.onConnect(n)}}):o.a.createElement(b.a,{type:"target",id:e.id?e.id:"0",style:Object(g.a)(Object(g.a)({},e.style),{},{width:"12px",height:"12px"}),position:"top",onConnect:function(n){return e.onConnect(n)}}))}var X="Sphere",U="Box";var W="Union",q="Difference",Y="Intersection";t(159);var J=[{id:"node-0",type:"primitiveNode",position:{x:-100,y:50},data:{sdf:"sphere(1.0)",children:[]}},{id:"node-1",type:"primitiveNode",position:{x:100,y:50},data:{sdf:"box(1.0, 1.0, 1.0)",children:[]}},{id:"node-2",type:"booleanNode",position:{x:0,y:550},data:{sdfs:{},children:[]}}],K={primitiveNode:function(e){var n=e.data,t=e.id,c=o.a.useState(X),r=Object(y.a)(c,2),i=r[0],l=r[1],s=o.a.useState(n.sdf),d=Object(y.a)(s,2),m=d[0],u=d[1],p=o.a.useState(!0),v=Object(y.a)(p,2),f=v[0],h=v[1],g=o.a.useState(1),b=Object(y.a)(g,2),E=b[0],x=b[1],O=o.a.useState(1),w=Object(y.a)(O,2),I=w[0],S=(w[1],o.a.useState(1)),z=Object(y.a)(S,2),L=z[0],D=(z[1],Object(a.useContext)(B));return Object(a.useEffect)((function(){}),[n]),Object(a.useEffect)((function(){D.updateNodeSdf(t,m)}),[m]),Object(a.useEffect)((function(){console.log("ACTUALIZADO SDF"),i==X?u("sphere(p, ".concat(E.toFixed(4),")")):i==U&&u("box(p, vec3(".concat(E.toFixed(4),", ").concat(I.toFixed(4),", ").concat(L.toFixed(4),"))"))}),[i,E,I,L]),o.a.createElement("div",{className:"custom-node"},o.a.createElement("div",{className:"custom-node-header"},"Primitive"),o.a.createElement(F,{value:i,onChange:l,items:[X,U],label:"Primitives"}),o.a.createElement(k,{val:E,handleChange:x,label:"Radius"}),E,t,n.sdf,"CHILDREN: ",n.children,o.a.createElement(H,{type:"source",onConnect:function(e){return D.connectSdf(e.source,e.target,e)}}),f?o.a.createElement(_,{shader:N(m),uniforms:{color:{type:"3fv",value:[1,1,0]}},style:{margin:"10px"}}):null,o.a.createElement(C.a,{onClick:function(){return h(!f)},variant:"contained",className:"custom-node-creater",size:"small",endIcon:f?o.a.createElement(j.a,null):o.a.createElement(A.a,null)},f?"Hide canvas":"Show canvas"))},booleanNode:function(e){var n=e.data,t=(e.id,o.a.useState(W)),c=Object(y.a)(t,2),r=c[0],i=c[1],l=o.a.useState(""),s=Object(y.a)(l,2),d=s[0],m=s[1];return Object(a.useEffect)((function(){console.log("SE HAN MODIFICADO LOS SDF EN NODO BOOLEANO. AHORA HAY ".concat(n.sdfs.length));var e="".concat(Object.keys(n.sdfs).map((function(e){return"".concat(n.sdfs[e])})).join(", "));r===W?m("min(".concat(e,")")):r===Y?m("max(".concat(e,")")):r===q&&m("max(-".concat(e,")"))}),[n,r]),o.a.createElement("div",{className:"custom-node"},o.a.createElement("div",{className:"custom-node-header"},"Boolean"),d,o.a.createElement(F,{value:r,onChange:i,items:[W,q,Y],label:"Operation"}),o.a.createElement(H,{id:"0",type:"target",onConnect:function(e){return console.log("handle ss",e)},style:{left:"30%"}}),o.a.createElement(H,{id:"1",type:"target",onConnect:function(e){return n.updateBooleanPrimitive(e.source,e.target)},style:{left:"60%"}}),o.a.createElement(H,{id:"2",type:"source",onConnect:function(e){return console.log("handle onsConnect",e)},style:{left:"50%"}}),o.a.createElement(_,{shader:N("".concat(d)),uniforms:{color:{type:"3fv",value:[1,1,0]}},style:{margin:"10px"}}))}},Z=function(e){return console.log("flow loaded:",e)};function Q(){var e=Object(b.d)(J),n=Object(y.a)(e,3),t=n[0],c=n[1],r=n[2],i=Object(b.c)([]),l=Object(y.a)(i,3),s=l[0],d=l[1],m=l[2],u=o.a.useState(3),p=Object(y.a)(u,2),v=p[0],f=p[1],h={updateNodeSdf:function(e,n){console.log("ACTUALIZADO SDF"),c((function(t){return t.map((function(a){return a.id===e&&(a.data=Object(g.a)(Object(g.a)({},a.data),{},{sdf:n}),a.data.children.forEach((function(a){t.map((function(t){if(t.id===a){console.log(t);var o=t.data.sdfs;o["".concat(e)]=n,console.log("HIJO: "+a),t.data=Object(g.a)(Object(g.a)({},t.data),{},{sdfs:o})}}))}))),a}))}))},connectSdf:function(e,n,a){var o=t.find((function(n){return n.id===e})),i=t.find((function(e){return e.id===n})).data.sdfs;i["".concat(e)]=o.data.sdf,console.log(i),c((function(e){return e.map((function(e){return e.id===n&&(console.log("FOUND"),e.data=Object(g.a)(Object(g.a)({},e.data),{},{sdfs:i})),r([e]),e}))}))}},O=Object(a.useCallback)((function(e){t.find((function(n){return n.id===e.source}));d((function(n){return Object(E.m)(Object(g.a)(Object(g.a)({},e),{},{animated:!0,markerEnd:{type:E.h.Arrow,color:"#000"},data:{}}),n)}));var n=t.find((function(n){return n.id===e.target})).data.children;n.push(e.target),c((function(t){return t.map((function(t){return t.id===e.source&&(console.log("A\xd1ADIDO HIJO ".concat(e.target," A ").concat(e.source)),t.data=Object(g.a)(Object(g.a)({},t.data),{},{children:n})),r([t]),t}))}))}),[]);Object(a.useEffect)((function(){console.log("NODOS ACTUALIZADOS"),console.log(t)}),[t]),Object(a.useEffect)((function(){console.log("NUEVO EDGE:"),console.log(s)}),[s]);return o.a.createElement("div",{style:{height:"100vh"},tabIndex:"0",onKeyDown:function(e){if("p"===e.key){var n=(f(v+1),{id:"node-".concat(v),type:"primitiveNode",position:{x:0,y:0},data:{sdf:"sphere(1.0)",children:[]}});t.push(n),r([n])}else if("b"===e.key){var a=(f(v+1),{id:"node-".concat(v),type:"booleanNode",position:{x:0,y:0},data:{sdfs:{},children:[]}});t.push(a),r([a])}}},o.a.createElement(G,{value:h},o.a.createElement(b.b,{nodes:t,edges:s,onNodesChange:r,onEdgesChange:m,onConnect:O,nodeTypes:K,onInit:Z,onEdgeClick:function(e,n){return d(s.filter((function(e){return e.id!=n.id})))},snapToGrid:!0,fitView:!0},o.a.createElement(x.a,{color:"#aaa",gap:10}))))}t(254);var $=function(){return o.a.createElement(i.a,{appearance:"inverse"},o.a.createElement(i.a.Header,null,o.a.createElement("a",{className:"navbar-brand logo"},"3D Visualizer")),o.a.createElement(i.a.Body,null,o.a.createElement(l.a,null,o.a.createElement(l.a.Item,{eventKey:"1"},"Tab 1"),o.a.createElement(l.a.Item,{eventKey:"2"},"Tab 2"),o.a.createElement(l.a.Item,{eventKey:"3"},"Tab 3")),o.a.createElement(l.a,{pullRight:!0},o.a.createElement(l.a.Item,{icon:o.a.createElement(s.a,{icon:"cog"})},"Settings"))))};function ee(){return o.a.createElement(o.a.Fragment,null,o.a.createElement(d.a,{fluid:!0},o.a.createElement(m.a,null,o.a.createElement(u.a,{xs:6},o.a.createElement(_,{style:{height:"100vh"},shader:"\n    \n    // https://thebookofshaders.com/03/?lan=es\n  // https://thebookofshaders.com/03/\n  // http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\n  // https://www.shadertoy.com/view/llt3R4\n  \n  // camera\n  // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\n  // http://www.codinglabs.net/article_world_view_projection_matrix.aspx\n  // https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\n  // https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\n  \n  #ifdef GL_ES\n  precision mediump float;\n  #endif\n  \n  const int AA = 3;\n  const int MAX_MARCHING_STEPS = 255;\n  const float EPSILON = 0.0001;\n  const float MIN_DIST = 0.0;\n  const float MAX_DIST = 100.0;\n\n  uniform bool leftClick;\n\n  struct Material\n  {\n      vec3 specular;\n      vec3 diffuse;\n      vec3 ambient;\n      float smoothness;\n  };\n  \n  float sdfCube(vec3 p, vec3 dim){\n      vec3 d = abs(p) - dim;\n  \n      float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n      float outsideDistance = length(max(d, 0.0));\n      \n      return insideDistance + outsideDistance;\n  }\n  \n  float map( in vec3 pos )\n  {\n      return  sdfCube(pos, vec3(1.0));\n  }\n  \n  \n  vec3 rayDirection(vec2 size, vec2 fragCoord) {\n      const float fov = 45.0;\n  \n      vec2 xy = fragCoord - size / 2.0;\n      float z = size.y / tan(radians(fov) / 2.0);\n  \n      return normalize(vec3(xy, -z));\n  }\n  \n  vec3 normal(vec3 p) {\n      return normalize(vec3(\n          map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n          map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n          map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n      ));\n  }\n  \n  vec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\n      vec3 ambient = vec3(0.5);\n  \n      vec3 lights_pos[2];\n      lights_pos[0] = vec3(4.0, 2.0, 2.0);\n      lights_pos[1] = vec3(-4.0, -2.0, -2.0);\n  \n      vec3 lights_color[2];\n      lights_color[0] = vec3(1.0, 1.0, 1.0);\n      lights_color[1] = vec3(1.0, 1.0, 1.0);\n  \n      vec3 Ip = mat.ambient * ambient;\n  \n      for(int i=0; i<2; i++){\n          vec3 Lm = normalize(lights_pos[i] - p);\n          vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\n          vec3 V  = normalize(eye - p);\n  \n          float LN = dot(Lm, n);\n          float RV = dot(Rm, V);\n  \n          if (LN < 0.0)   // Light not visible\n              Ip += vec3(0.0, 0.0, 0.0);\n          else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\n              Ip += lights_color[i] * (mat.diffuse * LN);\n          else\n              Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\n      }\n  \n      return Ip;\n  }\n  \n  mat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n      // Based on gluLookAt man page\n      vec3 f = normalize(center - eye);\n      vec3 s = normalize(cross(f, up));\n      vec3 u = cross(s, f);\n      return mat4(\n          vec4(s, 0.0),\n          vec4(u, 0.0),\n          vec4(-f, 0.0),\n          vec4(0.0, 0.0, 0.0, 1)\n      );\n  }\n  \n  void main() {\n      Material mat_red = Material(\n          vec3(1.0, 1.0, 1.0),    // specular\n          vec3(1.0, 1.0,0.0),        // diffuse\n          vec3(0.2),              // ambient\n          10.0                    // shiness\n      );\n      vec3 cameraPos                    = vec3(10.0, 1.0, 10.0);\n      const vec3 backGroundColor  = vec3(0.7);\n      vec2 mouseStartPos, mouseCurrPos;\n      vec2 mouse = iMouse.xy / iResolution.xy;\n\n      if(iMouse.z > 0.0){\n        \n        vec3 cameraAt \t= vec3(0.0);\n\n        float angleX = 6.28 * mouse.x;\n        float angleY =  mouse.y * 6.28 ;\n        cameraPos\t= 12.0 * (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY)));\n      }\n\n      for( int m=0; m<AA; m++ ){\n          for( int n=0; n<AA; n++ ){\n              float depth = MIN_DIST;\n  \n              // create view ray\n              vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\n              mat4 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n              vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\n  \n              // raytracing\n              for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n                  float dist = map(cameraPos + depth * worldDir);\n                  if (dist < EPSILON) {\n                      vec3 p = cameraPos + depth * worldDir;\n                      vec3 n = normal(p);\n  \n                      gl_FragColor = vec4(lighting(p, n, cameraPos, mat_red), 1.0);\n                      return;\n                  }\n  \n                  depth += dist;\n  \n                  if (depth >= MAX_DIST) {\n                      gl_FragColor = vec4(backGroundColor.xyz, 1.0);\n                      return;\n                  }\n              }\n          }\n      }\n  }\n\n  \n  ",uniforms:{color:{type:"3fv",value:[1,1,0]}}})),o.a.createElement(u.a,{xs:1},o.a.createElement("div",{style:{borderRight:"2px solid grey",height:"100vh"}})),o.a.createElement(u.a,{xs:17},o.a.createElement(Q,null)))))}var ne={display:"flex",flexDirection:"column",height:"100vh"};function te(){return o.a.createElement("div",{style:ne},o.a.createElement(p.a,null,o.a.createElement($,null)),o.a.createElement(v.a,{style:{flexGrow:1}},o.a.createElement(ee,null)),o.a.createElement(f.a,null,o.a.createElement(h.a,{bordered:!0},o.a.createElement("p",null,"Daniel Zufr\xed Quesada"))))}var ae=document.getElementById("root");r.a.render(o.a.createElement(o.a.StrictMode,null,o.a.createElement(te,null)),ae)}},[[242,1,2]]]);
//# sourceMappingURL=main.37517f35.chunk.js.map