(this["webpackJsonp3d-visualizer"]=this["webpackJsonp3d-visualizer"]||[]).push([[0],{124:function(e,n,t){},257:function(e,n,t){e.exports=t(427)},427:function(e,n,t){"use strict";t.r(n);var a=t(0),o=t.n(a),c=t(32),r=t.n(c),i=t(472),l=t(474),s=t(90),m=t(484),v=t(485),u=t(486),d=t(487),p=t(488),f=t(489),h=t(480),g=t(91),E=t(11),y=t(38),b=t(3),x=t(175);t(124);var w=t(221),_=t.n(w),S=t(222),I=t.n(S);function N(e){return Object(a.useEffect)((function(){}),[e.shader,e.uniforms]),o.a.createElement("div",{style:e.style},o.a.createElement(_.a,{ratio:1},o.a.createElement(I.a,{fs:e.shader,key:e.shader,uniforms:e.uniforms})))}var z=t(477),C=t(491),O=t(473),L=t(478),A=function(e){return"\n  // https://thebookofshaders.com/03/?lan=es\n// https://thebookofshaders.com/03/\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\n// https://www.shadertoy.com/view/llt3R4\n\n// camera\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\n// http://www.codinglabs.net/article_world_view_projection_matrix.aspx\n// https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\n// https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst int AA = 3;\nconst int MAX_MARCHING_STEPS = 255;\nconst float EPSILON = 0.0001;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\n\n".concat("\n    float sphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float box( vec3 p, vec3 b )\n    {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n","\n\nstruct Material\n{\n    vec3 specular;\n    vec3 diffuse;\n    vec3 ambient;\n    float smoothness;\n};\n\nfloat map( in vec3 p )\n{\n    return ").concat(e,";\n}\n\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\n    const float fov = 45.0;\n\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n\n    return normalize(vec3(xy, -z));\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\n    vec3 ambient = vec3(0.5);\n\n    vec3 lights_pos[2];\n    lights_pos[0] = vec3(4.0, 2.0, 2.0);\n    lights_pos[1] = vec3(-4.0, -2.0, -2.0);\n\n    vec3 lights_color[2];\n    lights_color[0] = vec3(1.0, 1.0, 1.0);\n    lights_color[1] = vec3(1.0, 1.0, 1.0);\n\n    vec3 Ip = mat.ambient * ambient;\n\n    for(int i=0; i<2; i++){\n        vec3 Lm = normalize(lights_pos[i] - p);\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\n        vec3 V  = normalize(eye - p);\n\n        float LN = dot(Lm, n);\n        float RV = dot(Rm, V);\n\n        if (LN < 0.0)   // Light not visible\n            Ip += vec3(0.0, 0.0, 0.0);\n        else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\n            Ip += lights_color[i] * (mat.diffuse * LN);\n        else\n            Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\n    }\n\n    return Ip;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nfloat clamp(float val){\n    if(val < 0.0)   return 0.0;\n    if(val >1.0)    return 1.0;\n\n    return val;\n}\n\nvoid main() {\n    Material mat_red = Material(\n        vec3(1.0, 1.0, 1.0),    // specular\n        vec3(color.xyz),        // diffuse\n        vec3(0.2),              // ambient\n        10.0                    // shiness\n    );\n    vec3 eye                    = vec3(10.0*cos(iTime), 1.0, 10.0*sin(iTime));\n    const vec3 backGroundColor  = vec3(0.7);\n\n    for( int m=0; m<AA; m++ ){\n        for( int n=0; n<AA; n++ ){\n            float depth = MIN_DIST;\n\n            // create view ray\n            vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\n            mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n            vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\n\n            // raytracing\n            for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n                float dist = map(eye + depth * worldDir);\n                if (dist < EPSILON) {\n                    vec3 p = eye + depth * worldDir;\n                    vec3 n = normal(p);\n\n                    gl_FragColor =  vec4(lighting(p, n, eye, mat_red), 1.0);\n                    \n                    return;\n                }\n\n                depth += dist;\n\n                if (depth >= MAX_DIST) {\n                    gl_FragColor = vec4(backGroundColor.xyz, 1.0);\n                    return;\n                }\n            }\n        }\n    }\n}\n\n")},P=t(482),M=t(225),D=t.n(M),j=t(224),k=t.n(j),T=t(481);function R(e){return o.a.createElement(C.a,{sx:{m:1},size:"small"},o.a.createElement(L.a,null,e.label),o.a.createElement(T.a,{value:e.val,type:"number",onChange:function(n){return e.handleChange(parseFloat(n.target.value))},label:e.label}))}var G="Sphere",V="Box";function F(e){var n=o.a.useState(!1),t=Object(E.a)(n,2),a=t[0],c=t[1];return o.a.createElement(C.a,{onClick:function(){return c(!a)},sx:{m:1,minWidth:80}},o.a.createElement(L.a,{id:"demo-simple-select-autowidth-label"},"Primitive"),o.a.createElement(O.a,{value:e.primitive,onChange:function(n){return e.onChange(n.target.value)},autoWidth:!0,open:a,label:"Primitive"},o.a.createElement(z.a,{value:G},"Sphere"),o.a.createElement(z.a,{value:V},"Box")))}function X(e){var n=o.a.useState(!1),t=Object(E.a)(n,2),a=t[0],c=t[1];return o.a.createElement(C.a,{onClick:function(){return c(!a)},sx:{m:1,minWidth:80}},o.a.createElement(L.a,null,e.label),o.a.createElement(O.a,{value:e.value,onChange:function(n){return e.onChange(n.target.value)},autoWidth:!0,open:a,label:"Primitive"},e.items.map((function(e){return o.a.createElement(z.a,{value:e},e)}))))}var B="Union",W="Difference",H="Intersection";var q=[],K={primitiveNode:function(e){var n=e.data,t=e.id,c=o.a.useState(G),r=Object(E.a)(c,2),i=r[0],l=r[1],s=o.a.useState(n.sdf),m=Object(E.a)(s,2),v=m[0],u=m[1],d=o.a.useState(!0),p=Object(E.a)(d,2),f=p[0],h=p[1],g=o.a.useState(1),b=Object(E.a)(g,2),x=b[0],w=b[1],_=o.a.useState(1),S=Object(E.a)(_,2),I=S[0],z=(S[1],o.a.useState(1)),C=Object(E.a)(z,2),O=C[0];return C[1],Object(a.useEffect)((function(){l(V)}),[]),Object(a.useEffect)((function(){console.log("EFE"),n.onChangeSdf(t,v)}),[v]),Object(a.useEffect)((function(){console.log("ASASAS1212"),i==G?u("sphere(p, ".concat(x.toFixed(4),")")):i==V&&u("box(p, vec3(".concat(x.toFixed(4),", ").concat(I.toFixed(4),", ").concat(O.toFixed(4),"))"))}),[i,x,I,O]),o.a.createElement("div",{className:"custom-node"},o.a.createElement("div",{className:"custom-node-header"},"Primitive"),o.a.createElement(F,{value:i,onChange:l,items:["sphere","box"],label:"Primitives"}),o.a.createElement(R,{val:x,handleChange:w,label:"Radius"}),x,t,n.sdf,o.a.createElement("div",{className:"custom-node-subheader custom-node-subheader__inputs"},o.a.createElement("div",{className:"custom-node-port-in"},"Inputs"),o.a.createElement("div",{className:"custom-node-port custom-node-port-in"},"label",o.a.createElement(y.a,{className:"circle-port circle-port-left",type:"target",target:"0",id:0,position:"left",onConnect:function(e){return console.log("handle onConnect",e)}}))),o.a.createElement("div",{style:{display:"flex"}},o.a.createElement("div",{style:{textAlign:"left",flexGrow:"1"}},o.a.createElement("div",{style:{display:"flex",flexDirection:"column"}},o.a.createElement("div",{style:{flexGrow:"1"}},"inputs"),o.a.createElement("div",{style:{flexGrow:"1"}},"i1"),o.a.createElement("div",{style:{flexGrow:"1"}},"i2"),o.a.createElement("div",{style:{flexGrow:"1"}},"i3"))),o.a.createElement("div",{style:{textAlign:"right",flexGrow:"1"}},o.a.createElement("div",{style:{display:"flex",flexDirection:"column"}},o.a.createElement("div",{style:{flexGrow:"1"}},"out"),o.a.createElement("div",{style:{flexGrow:"1"}},o.a.createElement(y.a,{className:"circle-port",type:"source",id:0,position:"right"}))))),o.a.createElement("div",{className:"custom-node-subheader custom-node-subheader__output"},o.a.createElement("div",{className:"custom-node-port-out"},"Outputs"),o.a.createElement("div",{className:"custom-node-port custom-node-port-out"},"label",o.a.createElement(y.a,{className:"circle-port circle-port-right",type:"source",id:0,position:"right"}))),f?o.a.createElement(N,{shader:A(v),uniforms:{color:{type:"3fv",value:[1,1,0]}},style:{margin:"10px"}}):null,o.a.createElement(P.a,{onClick:function(){return h(!f)},variant:"contained",className:"custom-node-creater",size:"small",endIcon:f?o.a.createElement(k.a,null):o.a.createElement(D.a,null)},f?"Hide canvas":"Show canvas"))},booleanNode:function(e){e.data,e.id;var n=o.a.useState(B),t=Object(E.a)(n,2),a=t[0],c=t[1];return o.a.createElement("div",{className:"custom-node"},o.a.createElement("div",{className:"custom-node-header"},"Primitive"),o.a.createElement(X,{value:a,onChange:c,items:[B,W,H],label:"Primitives"}))}},Y=function(e){return console.log("flow loaded:",e)};function J(){var e=Object(y.f)([]),n=Object(E.a)(e,3),t=n[0],c=n[1],r=n[2],i=Object(y.e)(q),l=Object(E.a)(i,3),s=l[0],m=l[1],v=l[2],u=function(e,n){console.log("ALO"),c((function(t){return t.map((function(t){return t.id===e&&(t.data=Object(g.a)(Object(g.a)({},t.data),{},{sdf:n})),t}))}))},d=Object(a.useCallback)((function(e){return m((function(n){return Object(b.m)(Object(g.a)(Object(g.a)({},e),{},{animated:!0,markerEnd:{type:b.h.Arrow,color:"#000"},data:{}}),n)}))}),[]);Object(a.useEffect)((function(){console.log("ASASA"),console.log(s)}),[s]);return o.a.createElement("div",{style:{height:"100vh"},tabIndex:"0",onKeyDown:function(e){if(" "===e.key){var n={id:"node-".concat(t.length),type:"primitiveNode",position:{x:0,y:0},data:{sdf:"sphere(p, 1.0)",onChangeSdf:u}};t.push(n),r([n])}}},o.a.createElement(y.b,{nodes:t,edges:s,onNodesChange:r,onEdgesChange:v,onConnect:d,nodeTypes:K,onInit:Y,onEdgeClick:function(e,n){return m(s.filter((function(e){return e.id!=n.id})))},snapToGrid:!0,fitView:!0},o.a.createElement(x.a,{color:"#aaa",gap:10})))}t(269),t(483),t(475);var Q=function(){return o.a.createElement(i.a,{appearance:"inverse"},o.a.createElement(i.a.Header,null,o.a.createElement("a",{className:"navbar-brand logo"},"3D Visualizer")),o.a.createElement(i.a.Body,null,o.a.createElement(l.a,null,o.a.createElement(l.a.Item,{eventKey:"1"},"Tab 1"),o.a.createElement(l.a.Item,{eventKey:"2"},"Tab 2"),o.a.createElement(l.a.Item,{eventKey:"3"},"Tab 3")),o.a.createElement(l.a,{pullRight:!0},o.a.createElement(l.a.Item,{icon:o.a.createElement(s.a,{icon:"cog"})},"Settings"))))};function U(){return o.a.createElement(o.a.Fragment,null,o.a.createElement(m.a,{fluid:!0},o.a.createElement(v.a,null,o.a.createElement(u.a,{xs:6},o.a.createElement(N,{style:{height:"100vh"},shader:"\n    \n    // https://thebookofshaders.com/03/?lan=es\n  // https://thebookofshaders.com/03/\n  // http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\n  // https://www.shadertoy.com/view/llt3R4\n  \n  // camera\n  // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\n  // http://www.codinglabs.net/article_world_view_projection_matrix.aspx\n  // https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\n  // https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\n  \n  #ifdef GL_ES\n  precision mediump float;\n  #endif\n  \n  const int AA = 3;\n  const int MAX_MARCHING_STEPS = 255;\n  const float EPSILON = 0.0001;\n  const float MIN_DIST = 0.0;\n  const float MAX_DIST = 100.0;\n\n  uniform bool leftClick;\n\n  struct Material\n  {\n      vec3 specular;\n      vec3 diffuse;\n      vec3 ambient;\n      float smoothness;\n  };\n  \n  float sdfCube(vec3 p, vec3 dim){\n      vec3 d = abs(p) - dim;\n  \n      float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n      float outsideDistance = length(max(d, 0.0));\n      \n      return insideDistance + outsideDistance;\n  }\n  \n  float map( in vec3 pos )\n  {\n      return  sdfCube(pos, vec3(1.0));\n  }\n  \n  \n  vec3 rayDirection(vec2 size, vec2 fragCoord) {\n      const float fov = 45.0;\n  \n      vec2 xy = fragCoord - size / 2.0;\n      float z = size.y / tan(radians(fov) / 2.0);\n  \n      return normalize(vec3(xy, -z));\n  }\n  \n  vec3 normal(vec3 p) {\n      return normalize(vec3(\n          map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n          map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n          map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n      ));\n  }\n  \n  vec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\n      vec3 ambient = vec3(0.5);\n  \n      vec3 lights_pos[2];\n      lights_pos[0] = vec3(4.0, 2.0, 2.0);\n      lights_pos[1] = vec3(-4.0, -2.0, -2.0);\n  \n      vec3 lights_color[2];\n      lights_color[0] = vec3(1.0, 1.0, 1.0);\n      lights_color[1] = vec3(1.0, 1.0, 1.0);\n  \n      vec3 Ip = mat.ambient * ambient;\n  \n      for(int i=0; i<2; i++){\n          vec3 Lm = normalize(lights_pos[i] - p);\n          vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\n          vec3 V  = normalize(eye - p);\n  \n          float LN = dot(Lm, n);\n          float RV = dot(Rm, V);\n  \n          if (LN < 0.0)   // Light not visible\n              Ip += vec3(0.0, 0.0, 0.0);\n          else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\n              Ip += lights_color[i] * (mat.diffuse * LN);\n          else\n              Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\n      }\n  \n      return Ip;\n  }\n  \n  mat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n      // Based on gluLookAt man page\n      vec3 f = normalize(center - eye);\n      vec3 s = normalize(cross(f, up));\n      vec3 u = cross(s, f);\n      return mat4(\n          vec4(s, 0.0),\n          vec4(u, 0.0),\n          vec4(-f, 0.0),\n          vec4(0.0, 0.0, 0.0, 1)\n      );\n  }\n  \n  void main() {\n      Material mat_red = Material(\n          vec3(1.0, 1.0, 1.0),    // specular\n          vec3(1.0, 1.0,0.0),        // diffuse\n          vec3(0.2),              // ambient\n          10.0                    // shiness\n      );\n      vec3 cameraPos                    = vec3(10.0, 1.0, 10.0);\n      const vec3 backGroundColor  = vec3(0.7);\n      vec2 mouseStartPos, mouseCurrPos;\n      vec2 mouse = iMouse.xy / iResolution.xy;\n\n      if(iMouse.z > 0.0){\n        \n        vec3 cameraAt \t= vec3(0.0);\n\n        float angleX = 6.28 * mouse.x;\n        float angleY =  mouse.y * 6.28 ;\n        cameraPos\t= 12.0 * (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY)));\n      }\n\n      for( int m=0; m<AA; m++ ){\n          for( int n=0; n<AA; n++ ){\n              float depth = MIN_DIST;\n  \n              // create view ray\n              vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\n              mat4 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n              vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\n  \n              // raytracing\n              for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n                  float dist = map(cameraPos + depth * worldDir);\n                  if (dist < EPSILON) {\n                      vec3 p = cameraPos + depth * worldDir;\n                      vec3 n = normal(p);\n  \n                      gl_FragColor = vec4(lighting(p, n, cameraPos, mat_red), 1.0);\n                      return;\n                  }\n  \n                  depth += dist;\n  \n                  if (depth >= MAX_DIST) {\n                      gl_FragColor = vec4(backGroundColor.xyz, 1.0);\n                      return;\n                  }\n              }\n          }\n      }\n  }\n\n  \n  ",uniforms:{color:{type:"3fv",value:[1,1,0]}}})),o.a.createElement(u.a,{xs:1},o.a.createElement("div",{style:{borderRight:"2px solid grey",height:"100vh"}})),o.a.createElement(u.a,{xs:17},o.a.createElement(J,null)))))}var Z={display:"flex",flexDirection:"column",height:"100vh"};function $(){return o.a.createElement("div",{style:Z},o.a.createElement(d.a,null,o.a.createElement(Q,null)),o.a.createElement(p.a,{style:{flexGrow:1}},o.a.createElement(U,null)),o.a.createElement(f.a,null,o.a.createElement(h.a,{bordered:!0},o.a.createElement("p",null,"Daniel Zufr\xed Quesada"))))}var ee=document.getElementById("root");r.a.render(o.a.createElement(o.a.StrictMode,null,o.a.createElement($,null)),ee)}},[[257,1,2]]]);
//# sourceMappingURL=main.79da8e8f.chunk.js.map