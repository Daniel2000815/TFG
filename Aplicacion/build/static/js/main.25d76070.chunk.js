(this["webpackJsonp3d-visualizer"]=this["webpackJsonp3d-visualizer"]||[]).push([[0],{159:function(e,n,t){},242:function(e,n,t){e.exports=t(405)},405:function(e,n,t){"use strict";t.r(n);var a=t(0),o=t.n(a),c=t(30),r=t.n(c),i=t(452),l=t(456),s=t(220),m=t(464),d=t(465),u=t(466),v=t(467),p=t(468),f=t(469),g=t(461),h=t(59),y=t(12),E=t(44),b=t(3),x=t(160),w=t(205),O=t.n(w),S=t(206),_=t.n(S);function I(e){return Object(a.useEffect)((function(){}),[e.shader,e.uniforms]),o.a.createElement("div",{style:e.style},o.a.createElement(O.a,{ratio:1},o.a.createElement(_.a,{fs:e.shader,key:e.shader,uniforms:e.uniforms})))}var N=function(e){return"\n  // https://thebookofshaders.com/03/?lan=es\n// https://thebookofshaders.com/03/\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\n// https://www.shadertoy.com/view/llt3R4\n\n// camera\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\n// http://www.codinglabs.net/article_world_view_projection_matrix.aspx\n// https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\n// https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst int AA = 3;\nconst int MAX_MARCHING_STEPS = 255;\nconst float EPSILON = 0.0001;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\n\n".concat("\n    float sphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float box( vec3 p, vec3 b )\n    {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n","\n\nstruct Material\n{\n    vec3 specular;\n    vec3 diffuse;\n    vec3 ambient;\n    float smoothness;\n};\n\nfloat map( in vec3 p )\n{\n    return ").concat(e,";\n}\n\nvec3 rayDirection(vec2 size, vec2 fragCoord) {\n    const float fov = 45.0;\n\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n\n    return normalize(vec3(xy, -z));\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\n    vec3 ambient = vec3(0.5);\n\n    vec3 lights_pos[2];\n    lights_pos[0] = vec3(4.0, 2.0, 2.0);\n    lights_pos[1] = vec3(-4.0, -2.0, -2.0);\n\n    vec3 lights_color[2];\n    lights_color[0] = vec3(1.0, 1.0, 1.0);\n    lights_color[1] = vec3(1.0, 1.0, 1.0);\n\n    vec3 Ip = mat.ambient * ambient;\n\n    for(int i=0; i<2; i++){\n        vec3 Lm = normalize(lights_pos[i] - p);\n        vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\n        vec3 V  = normalize(eye - p);\n\n        float LN = dot(Lm, n);\n        float RV = dot(Rm, V);\n\n        if (LN < 0.0)   // Light not visible\n            Ip += vec3(0.0, 0.0, 0.0);\n        else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\n            Ip += lights_color[i] * (mat.diffuse * LN);\n        else\n            Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\n    }\n\n    return Ip;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nfloat clamp(float val){\n    if(val < 0.0)   return 0.0;\n    if(val >1.0)    return 1.0;\n\n    return val;\n}\n\nvoid main() {\n    Material mat_red = Material(\n        vec3(1.0, 1.0, 1.0),    // specular\n        vec3(color.xyz),        // diffuse\n        vec3(0.2),              // ambient\n        10.0                    // shiness\n    );\n    vec3 eye                    = vec3(10.0*cos(iTime), 1.0, 10.0*sin(iTime));\n    const vec3 backGroundColor  = vec3(0.7);\n\n    for( int m=0; m<AA; m++ ){\n        for( int n=0; n<AA; n++ ){\n            float depth = MIN_DIST;\n\n            // create view ray\n            vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\n            mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n            vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\n\n            // raytracing\n            for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n                float dist = map(eye + depth * worldDir);\n                if (dist < EPSILON) {\n                    vec3 p = eye + depth * worldDir;\n                    vec3 n = normal(p);\n\n                    gl_FragColor =  vec4(lighting(p, n, eye, mat_red), 1.0);\n                    \n                    return;\n                }\n\n                depth += dist;\n\n                if (depth >= MAX_DIST) {\n                    gl_FragColor = vec4(backGroundColor.xyz, 1.0);\n                    return;\n                }\n            }\n        }\n    }\n}\n\n")},z=t(462),C=t(211),L=t.n(C),A=t(210),D=t.n(A),P=t(471),j=t(459),M=t(463);function k(e){return o.a.createElement(P.a,{sx:{m:1},size:"small"},o.a.createElement(j.a,null,e.label),o.a.createElement(M.a,{value:e.val,type:"number",onChange:function(n){return e.handleChange(parseFloat(n.target.value))},label:e.label}))}var T=t(458),R=t(455);function F(e){var n=o.a.useState(!1),t=Object(y.a)(n,2),a=t[0],c=t[1];return o.a.createElement(P.a,{onClick:function(){return c(!a)},sx:{m:1,minWidth:80}},o.a.createElement(j.a,null,e.label),o.a.createElement(R.a,{value:e.value,onChange:function(n){return e.onChange(n.target.value)},autoWidth:!0,open:a,label:"Primitive"},e.items.map((function(e){return o.a.createElement(T.a,{value:e},e)}))))}var V=o.a.createContext({}),G=V.Provider,B=V,H="Sphere",X="Box";var U="Union",W="Difference",q="Intersection";t(159);var Y={primitiveNode:function(e){var n=e.data,t=e.id,c=o.a.useState(H),r=Object(y.a)(c,2),i=r[0],l=r[1],s=o.a.useState(n.sdf),m=Object(y.a)(s,2),d=m[0],u=m[1],v=o.a.useState(!0),p=Object(y.a)(v,2),f=p[0],g=p[1],h=o.a.useState(1),b=Object(y.a)(h,2),x=b[0],w=b[1],O=o.a.useState(1),S=Object(y.a)(O,2),_=S[0],C=(S[1],o.a.useState(1)),A=Object(y.a)(C,2),P=A[0],j=(A[1],Object(a.useContext)(B));return Object(a.useEffect)((function(){j.updateNodeSdf(t,d)}),[d]),Object(a.useEffect)((function(){console.log("ACTUALIZADO SDF"),i==H?u("sphere(p, ".concat(x.toFixed(4),")")):i==X&&u("box(p, vec3(".concat(x.toFixed(4),", ").concat(_.toFixed(4),", ").concat(P.toFixed(4),"))"))}),[i,x,_,P]),o.a.createElement("div",{className:"custom-node"},o.a.createElement("div",{className:"custom-node-header"},"Primitive"),o.a.createElement(F,{value:i,onChange:l,items:[H,X],label:"Primitives"}),o.a.createElement(k,{val:x,handleChange:w,label:"Radius"}),x,t,n.sdf,o.a.createElement(E.a,{type:"source",id:"0",style:{left:"50%"},position:"bottom",onConnect:function(e){return j.connectSdf(e.source,e.target,e)}}),f?o.a.createElement(I,{shader:N(d),uniforms:{color:{type:"3fv",value:[1,1,0]}},style:{margin:"10px"}}):null,o.a.createElement(z.a,{onClick:function(){return g(!f)},variant:"contained",className:"custom-node-creater",size:"small",endIcon:f?o.a.createElement(D.a,null):o.a.createElement(L.a,null)},f?"Hide canvas":"Show canvas"))},booleanNode:function(e){var n=e.data,t=(e.id,o.a.useState(U)),c=Object(y.a)(t,2),r=c[0],i=c[1],l=o.a.useState(""),s=Object(y.a)(l,2),m=s[0],d=s[1];return Object(a.useEffect)((function(){console.log("SE HAN MODIFICADO LOS SDF EN NODO BOOLEANO. AHORA HAY ".concat(n.sdfs.length)),r===U&&d("min(".concat(n.sdfs[0],",").concat(n.sdfs[1],")"))}),[n]),o.a.createElement("div",{className:"custom-node"},o.a.createElement("div",{className:"custom-node-header"},"Boolean"),m,o.a.createElement(F,{value:r,onChange:i,items:[U,W,q],label:"Operation"}),o.a.createElement(E.a,{type:"target",id:"0",style:{left:"30%"},position:"top",onConnect:function(e){return console.log("handle ss",e)}}),o.a.createElement(E.a,{type:"target",id:"1",style:{left:"60%"},position:"top",onConnect:function(e){return n.updateBooleanPrimitive(e.source,e.target)}}),o.a.createElement(E.a,{type:"source",id:2,style:{left:"50%"},position:"bottom",onConnect:function(e){return console.log("handle onsConnect",e)}}),o.a.createElement(I,{shader:N("".concat(m)),uniforms:{color:{type:"3fv",value:[1,1,0]}},style:{margin:"10px"}}))}},K=function(e){return console.log("flow loaded:",e)};function Z(){var e=Object(E.d)([]),n=Object(y.a)(e,3),t=n[0],c=n[1],r=n[2],i=Object(E.c)([]),l=Object(y.a)(i,3),s=l[0],m=l[1],d=l[2],u=o.a.useState(0),v=Object(y.a)(u,2),p=v[0],f=v[1],g=function(e,n){console.log("ACTUALIZADO SDF"),c((function(t){return t.map((function(t){return t.id===e&&(t.data=Object(h.a)(Object(h.a)({},t.data),{},{sdf:n})),t}))}))},w=function(e,n,a){var o=t.find((function(n){return n.id===e})),i=t.find((function(e){return e.id===n})).data.sdfs,l=parseInt(a.targetHandle,10);console.log(l),i[l]=o.data.sdf,console.log(i),c((function(e){return e.map((function(e){return e.id===n&&(console.log("FOUND"),e.data=Object(h.a)(Object(h.a)({},e.data),{},{sdfs:i})),r([e]),e}))}))},O={updateNodeSdf:g,connectSdf:w},S=Object(a.useCallback)((function(e){t.find((function(n){return n.id===e.source}));m((function(n){return Object(b.m)(Object(h.a)(Object(h.a)({},e),{},{animated:!0,markerEnd:{type:b.h.Arrow,color:"#000"},data:{}}),n)}))}),[]);Object(a.useEffect)((function(){console.log("NODOS ACTUALIZADOS"),console.log(t)}),[t]),Object(a.useEffect)((function(){console.log("NUEVO EDGE:"),console.log(s)}),[s]);return o.a.createElement("div",{style:{height:"100vh"},tabIndex:"0",onKeyDown:function(e){if("p"===e.key){var n=(f(p+1),{id:"node-".concat(p),type:"primitiveNode",position:{x:0,y:0},data:{sdf:"sphere(p, 1.0)",onChangeSdf:g,onConnectHandle:w}});t.push(n),r([n])}else if("b"===e.key){var a=(f(p+1),{id:"node-".concat(p),type:"booleanNode",position:{x:0,y:0},data:{sdfs:["0","0"]}});t.push(a),r([a])}}},o.a.createElement(G,{value:O},o.a.createElement(E.b,{nodes:t,edges:s,onNodesChange:r,onEdgesChange:d,onConnect:S,nodeTypes:Y,onInit:K,onEdgeClick:function(e,n){return m(s.filter((function(e){return e.id!=n.id})))},snapToGrid:!0,fitView:!0},o.a.createElement(x.a,{color:"#aaa",gap:10}))))}t(254);var J=function(){return o.a.createElement(i.a,{appearance:"inverse"},o.a.createElement(i.a.Header,null,o.a.createElement("a",{className:"navbar-brand logo"},"3D Visualizer")),o.a.createElement(i.a.Body,null,o.a.createElement(l.a,null,o.a.createElement(l.a.Item,{eventKey:"1"},"Tab 1"),o.a.createElement(l.a.Item,{eventKey:"2"},"Tab 2"),o.a.createElement(l.a.Item,{eventKey:"3"},"Tab 3")),o.a.createElement(l.a,{pullRight:!0},o.a.createElement(l.a.Item,{icon:o.a.createElement(s.a,{icon:"cog"})},"Settings"))))};function Q(){return o.a.createElement(o.a.Fragment,null,o.a.createElement(m.a,{fluid:!0},o.a.createElement(d.a,null,o.a.createElement(u.a,{xs:6},o.a.createElement(I,{style:{height:"100vh"},shader:"\n    \n    // https://thebookofshaders.com/03/?lan=es\n  // https://thebookofshaders.com/03/\n  // http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#putting-it-all-together\n  // https://www.shadertoy.com/view/llt3R4\n  \n  // camera\n  // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work\n  // http://www.codinglabs.net/article_world_view_projection_matrix.aspx\n  // https://iopscience.iop.org/article/10.1088/0031-9155/52/12/006/meta\n  // https://www.ingebook.com/ib/NPcd/IB_BooksVis?cod_primaria=1000187&codigo_libro=6575\n  \n  #ifdef GL_ES\n  precision mediump float;\n  #endif\n  \n  const int AA = 3;\n  const int MAX_MARCHING_STEPS = 255;\n  const float EPSILON = 0.0001;\n  const float MIN_DIST = 0.0;\n  const float MAX_DIST = 100.0;\n\n  uniform bool leftClick;\n\n  struct Material\n  {\n      vec3 specular;\n      vec3 diffuse;\n      vec3 ambient;\n      float smoothness;\n  };\n  \n  float sdfCube(vec3 p, vec3 dim){\n      vec3 d = abs(p) - dim;\n  \n      float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n      float outsideDistance = length(max(d, 0.0));\n      \n      return insideDistance + outsideDistance;\n  }\n  \n  float map( in vec3 pos )\n  {\n      return  sdfCube(pos, vec3(1.0));\n  }\n  \n  \n  vec3 rayDirection(vec2 size, vec2 fragCoord) {\n      const float fov = 45.0;\n  \n      vec2 xy = fragCoord - size / 2.0;\n      float z = size.y / tan(radians(fov) / 2.0);\n  \n      return normalize(vec3(xy, -z));\n  }\n  \n  vec3 normal(vec3 p) {\n      return normalize(vec3(\n          map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n          map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n          map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n      ));\n  }\n  \n  vec3 lighting(vec3 p, vec3 n, vec3 eye, Material mat){\n      vec3 ambient = vec3(0.5);\n  \n      vec3 lights_pos[2];\n      lights_pos[0] = vec3(4.0, 2.0, 2.0);\n      lights_pos[1] = vec3(-4.0, -2.0, -2.0);\n  \n      vec3 lights_color[2];\n      lights_color[0] = vec3(1.0, 1.0, 1.0);\n      lights_color[1] = vec3(1.0, 1.0, 1.0);\n  \n      vec3 Ip = mat.ambient * ambient;\n  \n      for(int i=0; i<2; i++){\n          vec3 Lm = normalize(lights_pos[i] - p);\n          vec3 Rm = normalize(2.0*(dot(Lm,n))*n - Lm);    // reflect(-Lm, n)\n          vec3 V  = normalize(eye - p);\n  \n          float LN = dot(Lm, n);\n          float RV = dot(Rm, V);\n  \n          if (LN < 0.0)   // Light not visible\n              Ip += vec3(0.0, 0.0, 0.0);\n          else if (RV < 0.0)  // opposite direction as viewer, apply only diffuse\n              Ip += lights_color[i] * (mat.diffuse * LN);\n          else\n              Ip += lights_color[i] * (mat.diffuse*LN + mat.specular*pow(RV, mat.smoothness));\n      }\n  \n      return Ip;\n  }\n  \n  mat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n      // Based on gluLookAt man page\n      vec3 f = normalize(center - eye);\n      vec3 s = normalize(cross(f, up));\n      vec3 u = cross(s, f);\n      return mat4(\n          vec4(s, 0.0),\n          vec4(u, 0.0),\n          vec4(-f, 0.0),\n          vec4(0.0, 0.0, 0.0, 1)\n      );\n  }\n  \n  void main() {\n      Material mat_red = Material(\n          vec3(1.0, 1.0, 1.0),    // specular\n          vec3(1.0, 1.0,0.0),        // diffuse\n          vec3(0.2),              // ambient\n          10.0                    // shiness\n      );\n      vec3 cameraPos                    = vec3(10.0, 1.0, 10.0);\n      const vec3 backGroundColor  = vec3(0.7);\n      vec2 mouseStartPos, mouseCurrPos;\n      vec2 mouse = iMouse.xy / iResolution.xy;\n\n      if(iMouse.z > 0.0){\n        \n        vec3 cameraAt \t= vec3(0.0);\n\n        float angleX = 6.28 * mouse.x;\n        float angleY =  mouse.y * 6.28 ;\n        cameraPos\t= 12.0 * (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY)));\n      }\n\n      for( int m=0; m<AA; m++ ){\n          for( int n=0; n<AA; n++ ){\n              float depth = MIN_DIST;\n  \n              // create view ray\n              vec3 ray = rayDirection(iResolution.xy, gl_FragCoord.xy);\n              mat4 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n              vec3 worldDir = (viewToWorld * vec4(ray, 0.0)).xyz;\n  \n              // raytracing\n              for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n                  float dist = map(cameraPos + depth * worldDir);\n                  if (dist < EPSILON) {\n                      vec3 p = cameraPos + depth * worldDir;\n                      vec3 n = normal(p);\n  \n                      gl_FragColor = vec4(lighting(p, n, cameraPos, mat_red), 1.0);\n                      return;\n                  }\n  \n                  depth += dist;\n  \n                  if (depth >= MAX_DIST) {\n                      gl_FragColor = vec4(backGroundColor.xyz, 1.0);\n                      return;\n                  }\n              }\n          }\n      }\n  }\n\n  \n  ",uniforms:{color:{type:"3fv",value:[1,1,0]}}})),o.a.createElement(u.a,{xs:1},o.a.createElement("div",{style:{borderRight:"2px solid grey",height:"100vh"}})),o.a.createElement(u.a,{xs:17},o.a.createElement(Z,null)))))}var $={display:"flex",flexDirection:"column",height:"100vh"};function ee(){return o.a.createElement("div",{style:$},o.a.createElement(v.a,null,o.a.createElement(J,null)),o.a.createElement(p.a,{style:{flexGrow:1}},o.a.createElement(Q,null)),o.a.createElement(f.a,null,o.a.createElement(g.a,{bordered:!0},o.a.createElement("p",null,"Daniel Zufr\xed Quesada"))))}var ne=document.getElementById("root");r.a.render(o.a.createElement(o.a.StrictMode,null,o.a.createElement(ee,null)),ne)}},[[242,1,2]]]);
//# sourceMappingURL=main.25d76070.chunk.js.map