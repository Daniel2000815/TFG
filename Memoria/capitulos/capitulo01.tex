% !TeX root = ../libro.tex
% !TeX encoding = utf8

\chapter{Función Distancia con Signo}
Tenemos como objetivo representar superficies en $\R^3$. En general, estas pueden estar definidas de multitud de formas, siendo una de las más usuales a través de una función implícita. Nosotros nos centraremos en un tipo especial de funciones implícitas, que introducimos a continuación.

\begin{definicion}
  Sea $\Omega \subseteq \R^3$. Una \textbf{función distancia} es aquella que a cada punto de $\R^3$ le asigna su menor distancia a la frontera de $\Omega$:
    \begin{align*}
          d_{\Omega} \colon \R^3 &\to \R_0^+\\
          x &\mapsto \inf\{\Vert x-y\Vert) \colon y \in \delta\Omega\}
    \end{align*}

    Cuando $\Omega$ sea cerrado, podremos usar el mínimo en lugar del ínfimo.
\end{definicion}
 
\begin{definicion}[SDF]\label{d:sdf}
  Sea $\Omega \subseteq \R^3$. Una \textbf{función distancia con signo} es una función implícita de la forma:
  \begin{align*}
          \phi_{\Omega} \colon \R^3 &\to \R\\
          x &\mapsto \begin{cases}
      d_{\Omega}(x),  &x\in \R^3\setminus \mathring{\Omega} \\
      -d_{\Omega}(x), &x\in \mathring{\Omega}
    \end{cases}
    \end{align*}

  En general, nos referiremos a esta función por sus siglas en inglés SDF (\textit{Signed Distance Function}), y la denotaremos simplemente $\phi$ siempre que no haya confusión.
\end{definicion}

\begin{definicion}
  Dada una función $\phi\colon \R^3 \to \R$ y $k\in\R$, llamamos \textbf{isosuperficie} al conjunto:
  \begin{equation*}
      S_{\phi,k} = \{(x,y,z) :  \phi(x,y,z)=k\}
  \end{equation*}
  Sin pérdida de generalidad podemos suponer $k=0$, pues de no ser el caso, tomamos la función $\phi'(x,y,z)=\phi(x,y,z)-k$ y tenemos que $S_{\phi',0} = S_{\phi,k}$. Por tanto, la denotaremos como $S_\phi$.
\end{definicion}

Nuestra intención será entonces construir una escena definida como la isosuperficie generada por un SDF.

\begin{ejemplo}
    Ejemplos simples de SDF $\phi$ para un punto $p=(x,y,z)$ en diferentes conjuntos $\Omega$ son:
    \begin{itemize}
        \item \textbf{Esfera de radio $\boldsymbol{r}$ centrada en el origen.}
        \begin{equation*}
            \Omega=\{x\in \R^3 : \Vert x\Vert = r\},\quad \phi(p) = \Vert p\Vert - r
        \end{equation*}
        \item \textbf{Plano con vector normal $\boldsymbol{n=(a,b,c)}$ pasando por el origen}.
        \begin{equation*}
            \Omega=\{p\in\R^3 : ax+by+cz = 0\},\quad \phi(p) = p\cdot n
        \end{equation*}
        \item \textbf{Toro de radios $\boldsymbol{R>r}$}:
        \begin{equation*}
            \Omega=\left\{p\in \R^3 : \left(R-\sqrt{x^2+y^2}\right)^2 + z^2 = r^2\right\},\quad \phi(p)= \bigg\Vert (\Vert(x,0,z)\Vert - R, y) \bigg\Vert - r
        \end{equation*}
    \end{itemize}
\end{ejemplo}

\section{Operaciones sobre SDF}
Si bien estas primitivas son fáciles de generar, también son muy simples y nos serán insuficientes si queremos construir escenas más complejas. Una de las ventajas de los SDF es que se pueden generar nuevas formas a partir de primitivas de forma muy sencilla.

\begin{proposicion}[Operaciones Booleanas]
    Sean $A$,$B$ isosupercies generadas por $\phi,\gamma$ respectivamente. Entonces:
    \begin{itemize}
        \item $\sdf_{A\cup B} = \min(\phi, \gamma)$,
        \item $\sdf_{A\cap B} = \max(\phi, \gamma)$,
        \item $\sdf_{A\setminus B} = \max(\phi, -\gamma)$.
    \end{itemize}
\end{proposicion}

\begin{observacion}
    Solo en el caso de la unión se obtiene un SDF según lo establecido en \autoref{d:sdf}, ya que en el interior (donde $\phi < 0$), estas transformaciones producen valores inesperados. En nuestro caso solo estamos interesados en visualizar la frontera de las superficies, así que podemos obviar este problema.
\end{observacion}

Un problema de usar estas transformaciones es que produce discontinuidades en la derivada del SDF resultante, lo cual preferimos evitar, además de por motivos analíticos, por motivos visuales, ya que el resultado de estas operaciones produce bordes muy acusados en la intersección de ambas superficies. Existen muchas formas de combinar SDF de forma más natural. Una de las más sencillas es la interpolación lineal.

\begin{proposicion}[Operaciones Booleanas Suavizadas]
    Sean $A$,$B$ isosupercies generadas por $\phi,\gamma$ respectivamente y $k\in \R$ un coeficiente de suavizado. Entonces:
    \begin{itemize}
        \item $\sdf(A\cup B) = li(\gamma, \phi, h_1) - k\cdot h_1 \cdot (1-h_1)$.
        \item $\sdf(A\cap B) = li(\gamma, \phi, h_2) + k\cdot h_2 \cdot (1-h_2)$.
        \item $\sdf(A\setminus B) = li(\phi, -\gamma, h_3) + k\cdot h_3 \cdot (1-h_3)$.
    \end{itemize}

    donde:
    \begin{itemize}
        \item $li(x,y,a) = (1-a)\cdot x + a\cdot y$ interpola linealmente $x$ e $y$ según el parámetro $a\in\R$.
        \item $c(x) = \min(\max(x, 0), 1)$ acota $x$ en $[0,1]$.
        \item $h_1 = c\left(\frac{1}{2} + \frac{\gamma - \phi}{2k}\right)$.
        \item $h_2 = c\left( \frac{1}{2} - \frac{\gamma - \phi}{2k} \right)$.
        \item $h_3 = c\left( \frac{1}{2} - \frac{\gamma + \phi}{2k}\right)$.
    \end{itemize}
\end{proposicion}

Introducimos por último otro tipo de operaciones que nos resultarán útiles para generar nuevas formas a partir de un único SDF.

TODO


\section{Raymarching y Spheretracing}
Una vez definida la escena necesitamos un método para visualizarla. Utilizaremos la técnica de \textit{raymarcing}. Para ello deberemos elegir un punto donde estará el observador. A partir de él se trazarán rayos hacia cada uno de los puntos de un plano imaginario que llamaremos plano de visión, de forma que cada punto de este plano corresponde a un pixel de la imagen resultante. Si el rayo interseca con $S_\phi$ significa que ese pixel corresponde a un punto de $S_\phi$ y será coloreado como tal.\newline

Para comprobar esta intersección utilizamos un método iterativo: a partir de la posición del observador, en cada iteración avanzamos en la dirección del rayo una distancia fija $\delta$. Evaluamos entonces nuestro SDF en la posición actual. Si este valor es muy cercano a 0 significará que estamos en la isosuperficie. De lo contrario, repetiremos el proceso hasta encontrar la intersección o superar el número máximo de iteraciones, en cuyo caso concluiremos que no hay intersección.\newline

TODO: diagrama

Sin embargo podemos mejorar esta técnica, ya que cuanto más alejados estén los puntos de $S_\phi$ del observador, mayor es el número de iteraciones necesarias para encontrar la intersección. Esto es debido a que si no queremos perder ninguna intersección, el valor de incremento $\delta$ deberá de ser pequeño. La solución a este problema es el uso de \textit{spheretracing}. Su funcionamiento es similar al \textit{raymarching}, con la diferencia de que el incremento en la posición del rayo no es fija, sino que es la máxima que podemos tomar asegurándonos de no perder información en cada iteración. Esta distancia será entonces la distancia mínima del punto actual del rayo a $S_\phi$, que no es más que evaluar $\phi$ en dicho punto.\newline

TODO: diagrama de pérdida de intersección

El algoritmo sería por tanto el descrito en \autoref{a:spheretracing}. 
\SetKwComment{Comment}{/* }{ */}
\begin{algorithm}[hbt!]\label{a:spheretracing}
    \caption{Spheretracing}\label{alg:spheretracing}
    \KwData{origen $p$, dirección $v$}
    $\text{incremento} \gets 0$\;
    $\text{distanciaTotal} \gets 0$\;
    
    \For{i \in MAX\_ITERACIONES} {
        rayo \gets p + \text{distanciaTotal}\cdot v\;
        
        distanciaActual \gets \phi(\text{rayo})\;
        
        \If{distanciaActual < \varepsilon}{
           \Return{DibujarSuperficie(rayo)};
        }

        distanciaTotal \mathrel{{+}{=}} distanciaActual\;

        \If{distanciaTotal > MAX\_DISTANCIA}{
            \Return{DibujarFondo()};
        }
    }
\end{algorithm}

\section{Aproximación de implícitas}
Empezábamos el capítulo diciendo que una de las representaciones más comunes de superficies es a través de implícitas, pero hasta ahora nos hemos centrado en estudiar un tipo particular de este tipo de ecuaciones. Si intentásemos aplicar los algoritmos anteriores a una función implícita cualquiera, observaríamos que el resultado tiene ciertos defectos, tales como deformaciones. Vamos a introducir una técnica que dada una función implícita $\phi$, nos permitirá obtener un SDF aproximado de $S_\phi$. Esto nos será útil cuando no conozcamos o no podamos calcular explícitamente el SDF de una superficie pero sí su representación implícita.

TODO

\section{Iluminación}
Ya sabemos qué píxeles pertenecen a la superficie, pero no de qué color deben dibujarse. Para ello utilizaremos el modelo de reflexión de Phong. En él trabajaremos con los siguientes parámetros:
\begin{itemize}
  \item Luz ambiente $i_a$: vector RGB suma de las contribuciones de todas las fuentes de luz de la escena. Contiene un valor por defecto que será el color del fondo.
  \item Lista de fuentes de luz $(l_1, \dots, l_m, \dots, l_n)$.
  \item Materiales asignados a cada objeto definidos por las constantes:
      \begin{itemize}
          \item Reflexión especular $k_s$: modela cómo se refleja la luz en objetos brillantes. Depende tanto de la posición de las fuentes de luz como de la del observador.
          \item Reflexión difusa $k_d$: modela cómo se refleja la luz en objetos mates. Depende de la posición de las fuentes de luz, pero no de la posición del observador.
          \item Reflexión ambiental $k_a$: representa la proporción de luz del ambiente que refleja el objeto.
          \item Coeficiente de brillo $\alpha$: valor real positivo que permite variar el tamaño de las zonas brillantes (a mayor valor, menor tamaño y más pulida o especular).
      \end{itemize}
  
  \item Los vectores normalizados definidos para cada punto de la superficie $p$:
        \begin{itemize}
          \item $L_m$: vector director desde $p$ a cada fuente de luz $l_m$.
          \item $N$ vector normal a la superficie en $p$.
          \item $R_m$ dirección del rayo de luz reflejado especularmente desde la fuente $l_m$ en el punto $p$.
          \item $V$: dirección de $p$ a la posición del observador.
        \end{itemize}
\end{itemize}

TODO: diagrama vectores

Con estas variables, el color en $p$ vendrá dado por la fórmula:
\begin{equation*}
  I_p = k_a i_a + \sum_{m=0}^{n} \left(k_d\left(L_m\cdot N\right) + k_s\left(R_m\cdot V\right)^{\alpha} \right)
\end{equation*}

De los vectores anteriores, $L_m$ y $V$ se calculan trivialmente, y $R_m$ se puede obtener como
\begin{equation*}
  R_m = 2(L_m\cdot N)N - L_m
\end{equation*}

Veamos como obtener $N$.

\subsection{Cálculo del vector normal}
\begin{definicion}
  El \textbf{gradiente} de una función implícita $\phi\colon \R^3\to\R$ es $\nabla\phi = \left(\frac{\partial \phi}{\partial x}, \frac{\partial \phi}{\partial y}, \frac{\partial \phi}{\partial z}\right)$.
\end{definicion}

\begin{proposicion}\label{p:gradient_perp}
  $\nabla\phi$ es perpendicular a $S_\phi$.
\end{proposicion}

\begin{proof}
  Sea $s\in S_\phi$ arbitrario. Tomamos una curva parametrizada:
  \begin{align*}
    \alpha \colon [0,1] & \to S_\phi                             \\
    t                   & \mapsto \left(x(t), y(t), z(t) \right)
  \end{align*}

  cumpliendo $\alpha(t_0)=s$. Veamos que $\nabla\phi(s) \perp \alpha$:

  \begin{align*}
    \alpha(t)\subset S_\phi & \implies \phi(\alpha(t))=0\\
                            & \implies \nabla\phi(\alpha(t)) = \frac{\partial{F}}{\partial{x}}\frac{dx}{dt} + \frac{\partial{F}}{\partial{y}}\frac{dy}{dt} + \frac{\partial{F}}{\partial{z}}\frac{dz}{dt} = 0 \\
                            & \implies \langle \nabla\phi(x,y,z), \alpha'(t)\rangle = 0 \implies \langle \nabla\phi(x,y,z), \alpha'(t_0)\rangle = 0
  \end{align*}

    Por tanto, $\nabla\phi(s)$ es perpendicular al vector tangente de $\alpha$ en $s$, que a su vez está contenida en el plano tangente de $S_\phi$ en $s$. Por tanto $\nabla\phi(s) \perp S_\phi$.
\end{proof}

Hemos visto que calcular $N$ equivale a calcular $\nabla\phi$. Sin embargo, dado que la superficie viene dada por un SDF que podría ser no derivable, no podemos hacerlo de forma analítica. De ser derivable, podría ser una buena opción calcular el gradiente una única vez al momento de definir la $\phi$, tras lo cual para obtener $N$ solo habría que realizar evaluaciones de dicho gradiente. Sin embargo, por su sencillez y popularidad, nos decantaremos por un método numérico que únicamente hará uso de evaluaciones de $\phi$.

\begin{definicion}
  Dada $\phi:\R^3\to \R$ diferenciable, $p = (x,y,z)$, $v\in \R^3$, definimos la \textbf{derivada direccional} en $p$ con dirección $v$ a:
  \begin{equation*}
    \nabla_v f(p) = \nabla f(p) \cdot v = \frac{\partial{f}(p)}{\partial{x}}v_x + \frac{\partial{f}(p)}{\partial{y}}v_y + \frac{\partial{f}(p)}{\partial{z}}v_z
  \end{equation*}
\end{definicion}

Para el cálculo de cada parcial de $f$ podemos utilizar la definición de derivada. Por ejemplo, para la primera componente:
\begin{equation*}
  \frac{\partial{f}(p)}{\partial{x}} v_x = \lim_{h\to 0}\frac{f(p + (h,0,0)) - f(p)}{h} v_x
\end{equation*}

Procedemos a calcular $N$ aplicaremos el \textbf{método del tetraedro}, el cual se basa en evaluar $\phi$ en la dirección de los vértices de un tetraedro:

\begin{equation*}
    k_0 = (1,-1,-1)\quad k_1 = (-1,-1,1)\quad k_2=(-1,1,-1)\quad k_3=(1,1,1)
\end{equation*}

\begin{proposicion}[Método del tetraedro]
  Dado $p\in S_\phi$, su vector normal $N$ se obtiene normalizando el vector
  \begin{equation*}
    \hat{N} = \sum_{i=0}^3 k_i\cdot f(p + hk_i)
  \end{equation*}
\end{proposicion}

\begin{proof}
  Por la proposición \autoref{p:gradient_perp}, basta comprobar que $\hat{N}$ es colineal a $\nabla \phi(p)$.

  \begin{align*}
    \hat{N} & = \sum_{i=0}^3 k_i\cdot f(p + hk_i) = \sum_{i=0}^3 k_i\cdot f(p + hk_i) + k_i\cdot f(p) = \sum_{i=0}^3 k_i\cdot f(p+hk_i - f(p)) = \sum_{i=0}^3 k_i \nabla_{k_i}f(x)\\
    &= \sum_{i=0}^3 k_i \cdot \left( k_i \cdot \nabla f(p)\right) = \sum_{i=0}^3 (k_i\cdot k_i) \nabla f(p) = \sum_{i=0}^3 \nabla f(p) = 4\nabla f(p)
  \end{align*}

  donde hemos usado que $\sum_{i=0}^3 k_i = (0,0,0)$, $\sum_{i=0}^3 k_i\cdot k_i = (1,1,1)$, y que el producto escalar es un operador lineal.
\end{proof}



